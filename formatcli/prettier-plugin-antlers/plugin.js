"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// server/src/projects/projectManager.ts
var ProjectManager, projectManager_default;
var init_projectManager = __esm({
  "server/src/projects/projectManager.ts"() {
    "use strict";
    ProjectManager = class {
      constructor() {
        this.currentStructure = null;
        this.isReloading = false;
        this.isDirtyState = true;
        this.structuredProject = null;
      }
      setStructuredProject(fields) {
        this.structuredProject = fields;
      }
      hasStructuredBlueprints() {
        return this.structuredProject != null;
      }
      getAllStructuredBlueprints() {
        if (this.structuredProject == null) {
          return [];
        }
        return this.structuredProject.assets.concat(this.structuredProject.collections).concat(this.structuredProject.forms).concat(this.structuredProject.general).concat(this.structuredProject.navigations).concat(this.structuredProject.taxonomies);
      }
      getStructuredProject() {
        return this.structuredProject;
      }
      setActiveProject(project) {
        this.currentStructure = project;
      }
      getStructure() {
        return this.currentStructure;
      }
      hasStructure() {
        return this.currentStructure != null;
      }
      setDirtyState(isDirty) {
        this.isDirtyState = isDirty;
      }
      reloadDetails() {
        if (this.isReloading) {
          return;
        }
        if (this.isDirtyState == false) {
          return;
        }
        if (this.currentStructure != null) {
          this.isReloading = true;
          this.currentStructure = this.currentStructure.reloadDetails();
          this.isReloading = false;
          this.isDirtyState = false;
        }
      }
    };
    ProjectManager.instance = null;
    if (typeof ProjectManager.instance == "undefined" || ProjectManager.instance == null) {
      ProjectManager.instance = new ProjectManager();
    }
    projectManager_default = ProjectManager;
  }
});

// server/src/idehelper/documentDetailsManager.ts
var DocumentDetailsManager;
var init_documentDetailsManager = __esm({
  "server/src/idehelper/documentDetailsManager.ts"() {
    "use strict";
    DocumentDetailsManager = class {
      static registerDetails(documentUri, details) {
        this.documentDetails.set(documentUri, details);
      }
      static hasDetails(documentUri) {
        return this.documentDetails.has(documentUri);
      }
    };
    DocumentDetailsManager.documentDetails = /* @__PURE__ */ new Map();
  }
});

// server/src/idehelper/parser.ts
function parseIdeHelper(documentUri, symbol) {
  if (symbol == null || symbol.isComment == false) {
    return EmptyEnvironmentHelper;
  }
  const commentLines = symbol.content.replace(/(\r\n|\n|\r)/gm, "\n").split("\n").map((r) => r.trim()), injectsParameters = [], varReferenceNames = /* @__PURE__ */ new Map();
  let documentName = "", documentDescription = "", collectionNames = [], blueprintNames = [], varReference = "", variableHelper = null, isParsingDescription = false, formatterEnabled = true;
  for (let i = 0; i < commentLines.length; i++) {
    const thisLine = commentLines[i];
    if (thisLine.startsWith(EntryPrefix)) {
      collectionNames = collectionNames.concat(
        thisLine.slice(EntryPrefix.length).split(",").map((f) => f.trim())
      );
      isParsingDescription = false;
    } else if (thisLine.startsWith(CollectionPrefix)) {
      collectionNames = collectionNames.concat(
        thisLine.slice(CollectionPrefix.length).split(",").map((f) => f.trim())
      );
      isParsingDescription = false;
    } else if (thisLine.startsWith(BlueprintPrefix)) {
      blueprintNames = blueprintNames.concat(
        thisLine.slice(BlueprintPrefix.length).split(",").map((f) => f.trim())
      );
      isParsingDescription = false;
    } else if (thisLine.startsWith(DocumentName)) {
      documentName = thisLine.slice(DocumentName.length).trim();
      isParsingDescription = false;
    } else if (thisLine.startsWith(DocumentDescription)) {
      documentDescription = thisLine.slice(DocumentDescription.length).trim();
      isParsingDescription = true;
    } else if (thisLine.startsWith(DocDescriptionShort)) {
      documentDescription = thisLine.slice(DocDescriptionShort.length).trim();
      isParsingDescription = true;
    } else if (thisLine.startsWith(VariablePrefix)) {
      varReference = thisLine.slice(VariablePrefix.length).trim();
      isParsingDescription = false;
    } else if (thisLine.startsWith(SetPrefix)) {
      varReference = "@page " + thisLine.slice(SetPrefix.length).trim();
      isParsingDescription = false;
    } else if (thisLine.startsWith(ParamPrefix)) {
      let sliceLen = ParamPrefix.length, paramRequired = false;
      if (thisLine.startsWith(RequiredParamPrefix)) {
        sliceLen = RequiredParamPrefix.length;
        paramRequired = true;
      }
      const directiveDetails = thisLine.slice(sliceLen).trim();
      const directiveParts = directiveDetails.split(" ");
      if (directiveParts.length > 0) {
        if (directiveParts[0] == ParamFromViewDataDirective && directiveParts.length >= 4) {
          directiveParts.shift();
          const varName = directiveParts.shift(), paramName = directiveParts.shift(), paramDesc = directiveParts.join(" ");
          injectsParameters.push({
            acceptsVariableInterpolation: true,
            aliases: [],
            allowsVariableReference: true,
            description: paramDesc,
            expectsTypes: ["*"],
            isDynamic: true,
            isRequired: paramRequired,
            name: paramName
          });
          varReferenceNames.set(paramName, varName);
        } else {
          const paramName = directiveParts.shift(), paramDesc = directiveParts.join(" ");
          injectsParameters.push({
            acceptsVariableInterpolation: true,
            aliases: [],
            allowsVariableReference: true,
            description: paramDesc,
            expectsTypes: ["*"],
            isDynamic: true,
            isRequired: paramRequired,
            name: paramName
          });
        }
      }
    } else if (thisLine.startsWith(FormatterPrefix)) {
      const formatterDetails = thisLine.slice(FormatterPrefix.length).trim().toLowerCase();
      if (formatterDetails == "true") {
        formatterEnabled = true;
      } else {
        formatterEnabled = false;
      }
    } else {
      if (isParsingDescription) {
        documentDescription += "\n" + thisLine.trim();
      }
    }
  }
  if (varReference.length > 0) {
    const varNameParts = varReference.split(" ");
    if (varNameParts.length == 2) {
      const varName = varNameParts[0], fieldPath = varNameParts[1];
      if (fieldPath.includes(".")) {
        const refParts = fieldPath.split(".");
        if (refParts.length == 2) {
          const collectionName = refParts[0], fieldHandle = refParts[1];
          variableHelper = {
            variableName: varName,
            collectionName,
            fieldHandle,
            setHandle: ""
          };
        } else if (refParts.length == 3) {
          const collectionName = refParts[0], fieldHandle = refParts[1], setHandle = refParts[2];
          variableHelper = {
            variableName: varName,
            collectionName,
            fieldHandle,
            setHandle
          };
        }
      } else {
        variableHelper = {
          variableName: varName,
          setHandle: "",
          collectionName: "",
          fieldHandle: fieldPath
        };
      }
    }
  }
  if (documentUri.trim().length > 0 && projectManager_default.instance != null && projectManager_default.instance.hasStructure()) {
    const projectView = projectManager_default.instance.getStructure().findView(documentUri);
    if (projectView != null) {
      projectView.injectsParameters = injectsParameters;
      projectView.varReferenceNames = varReferenceNames;
    }
  }
  const ideHelper = {
    documentName,
    documentDescription,
    collectionInjections: collectionNames,
    blueprints: blueprintNames,
    variableHelper,
    injectsParameters,
    varReferenceNames,
    formatterEnabled
  };
  if (documentUri.trim().length > 0 && symbol.startPosition != null) {
    if (symbol.startPosition.line <= 1 || symbol.index <= 1) {
      DocumentDetailsManager.registerDetails(documentUri, ideHelper);
    }
  }
  return ideHelper;
}
var EmptyEnvironmentHelper, DocumentName, DocumentDescription, DocDescriptionShort, EntryPrefix, CollectionPrefix, BlueprintPrefix, VariablePrefix, SetPrefix, ParamPrefix, RequiredParamPrefix, ParamFromViewDataDirective, FormatterPrefix;
var init_parser = __esm({
  "server/src/idehelper/parser.ts"() {
    "use strict";
    init_projectManager();
    init_documentDetailsManager();
    EmptyEnvironmentHelper = {
      documentDescription: "",
      documentName: "",
      collectionInjections: [],
      blueprints: [],
      variableHelper: null,
      injectsParameters: [],
      varReferenceNames: /* @__PURE__ */ new Map(),
      formatterEnabled: true
    };
    DocumentName = "@name";
    DocumentDescription = "@description";
    DocDescriptionShort = "@desc";
    EntryPrefix = "@entry";
    CollectionPrefix = "@collection";
    BlueprintPrefix = "@blueprint";
    VariablePrefix = "@var";
    SetPrefix = "@set";
    ParamPrefix = "@param";
    RequiredParamPrefix = "@param*";
    ParamFromViewDataDirective = "@front";
    FormatterPrefix = "@format";
  }
});

// server/src/projects/blueprints/blueprintTypes.ts
function getFieldRuntimeType(fieldType) {
  if (stringTypes.includes(fieldType)) {
    return "string";
  }
  if (arrayTypes.includes(fieldType)) {
    return "array";
  }
  if (numberTypes.includes(fieldType)) {
    return "number";
  }
  if (booleanTypes.includes(fieldType)) {
    return "boolean";
  }
  return fieldType;
}
var stringTypes, arrayTypes, numberTypes, booleanTypes;
var init_blueprintTypes = __esm({
  "server/src/projects/blueprints/blueprintTypes.ts"() {
    "use strict";
    stringTypes = [
      "markdown",
      "text",
      "textarea",
      "slug",
      "button_group",
      "code",
      "color",
      "date",
      "form",
      "link",
      "structures",
      "select",
      "taxonomies",
      "terms",
      "template",
      "time",
      "video",
      "users",
      "user_groups",
      "user_roles"
    ];
    arrayTypes = [
      "array",
      "assets",
      "bard",
      "blueprints",
      "collections",
      "entries",
      "list",
      "grid",
      "replicator",
      "structures_multiple",
      "sites",
      "select_multiple",
      "form_multiple",
      "table",
      "tags",
      "terms_multiple",
      "taxonomies_multiple",
      "users_multiple",
      "checkboxes",
      "select_multiple",
      "yaml",
      "user_groups_multiple",
      "user_roles_multiple"
    ];
    numberTypes = ["integer", "range"];
    booleanTypes = ["toggle"];
  }
});

// server/src/references/referenceManager.ts
var ReferenceManager, referenceManager_default;
var init_referenceManager = __esm({
  "server/src/references/referenceManager.ts"() {
    "use strict";
    ReferenceManager = class {
      constructor() {
        this.partialReferences = /* @__PURE__ */ new Map();
        this.cacheReferences = /* @__PURE__ */ new Map();
        this.removesPageScope = /* @__PURE__ */ new Map();
      }
      clearAllReferences(documentUri) {
        this.clearPartialReferences(documentUri);
        this.clearCacheReferences(documentUri);
      }
      registerPartialReferences(documentUri, nodes) {
        if (this.partialReferences.has(documentUri) == false) {
          this.partialReferences.set(documentUri, []);
        }
        this.partialReferences.set(documentUri, nodes);
      }
      registerCacheReferences(documentUri, nodes) {
        if (this.cacheReferences.has(documentUri) == false) {
          this.cacheReferences.set(documentUri, []);
        }
        this.cacheReferences.set(documentUri, nodes);
      }
      clearPartialReferences(documentUri) {
        if (this.partialReferences.has(documentUri)) {
          this.partialReferences.set(documentUri, []);
        }
      }
      clearRemovesPageScope(documentUri) {
        if (this.removesPageScope.has(documentUri)) {
          this.removesPageScope.delete(documentUri);
        }
      }
      pageScopeDisabled(documentUri) {
        return this.removesPageScope.has(documentUri);
      }
      clearCacheReferences(documentUri) {
        if (this.cacheReferences.has(documentUri)) {
          this.cacheReferences.set(documentUri, []);
        }
      }
      setRemovesPageScope(documentUri, node) {
        this.removesPageScope.set(documentUri, node);
      }
      getPartialReferences(documentUri) {
        if (this.partialReferences.has(documentUri) == false) {
          return [];
        }
        return this.partialReferences.get(documentUri);
      }
      getCacheReferencnes(documentUri) {
        if (this.cacheReferences.has(documentUri) == false) {
          return [];
        }
        return this.cacheReferences.get(documentUri);
      }
      hasPartialReferences(documentPath) {
        return this.partialReferences.has(documentPath);
      }
      hasCacheReferences(documentPath) {
        return this.cacheReferences.has(documentPath);
      }
    };
    ReferenceManager.instance = null;
    if (typeof ReferenceManager.instance == "undefined" || ReferenceManager.instance == null) {
      ReferenceManager.instance = new ReferenceManager();
    }
    referenceManager_default = ReferenceManager;
  }
});

// server/src/runtime/nodes/position.ts
var Position;
var init_position = __esm({
  "server/src/runtime/nodes/position.ts"() {
    "use strict";
    Position = class {
      constructor() {
        this.index = -1;
        this.offset = 0;
        this.line = 0;
        this.char = 0;
      }
      shiftRight(shiftOffset) {
        const position = new Position();
        position.offset = this.offset + shiftOffset;
        position.index = this.index + shiftOffset;
        position.line = this.line;
        position.char = this.char + shiftOffset;
        return position;
      }
      isBefore(position) {
        if (position == null) {
          return false;
        }
        if (position.line > this.line) {
          return true;
        }
        if (position.line == this.line && this.offset < position.offset) {
          return true;
        }
        return false;
      }
      isWithin(start, end, shiftEnd = 0) {
        if (start == null || end == null) {
          return false;
        }
        if (this.index >= start.index && this.index <= end.index + shiftEnd) {
          return true;
        }
        return false;
      }
      isWithinRange(range) {
        if (range == null) {
          return false;
        }
        if (range.start != null && range.end != null) {
          return this.isWithin(range.start, range.end);
        }
        return false;
      }
    };
  }
});

// server/src/runtime/document/documentRange.ts
var _DocumentRange, DocumentRange;
var init_documentRange = __esm({
  "server/src/runtime/document/documentRange.ts"() {
    "use strict";
    _DocumentRange = class {
      constructor() {
        this.start = null;
        this.end = null;
      }
    };
    DocumentRange = _DocumentRange;
    DocumentRange.Empty = new _DocumentRange();
  }
});

// server/src/antlers/modifiers/scopeAugmentation/augmentGroupByScope.ts
function augmentGroupByScope(node, scope) {
  const iterableItems = scope.copy(), groupScope = scope.copy();
  groupScope.addVariable({ sourceName: "*internal.group_by", sourceField: null, dataType: "string", name: "group", introducedBy: node });
  groupScope.addVariable({ sourceName: "*internal.group_by", sourceField: null, dataType: "string", name: "key", introducedBy: node });
  groupScope.addScopeList("items", iterableItems);
  scope.addScopeList("groups", groupScope);
  return scope;
}
var init_augmentGroupByScope = __esm({
  "server/src/antlers/modifiers/scopeAugmentation/augmentGroupByScope.ts"() {
    "use strict";
  }
});

// server/src/antlers/modifiers/scopeAugmentation/augmentSplitScope.ts
function augmentSplitScope(node, scope) {
  const itemsScope = scope.copy();
  scope.addScopeList("items", itemsScope);
  return scope;
}
var init_augmentSplitScope = __esm({
  "server/src/antlers/modifiers/scopeAugmentation/augmentSplitScope.ts"() {
    "use strict";
  }
});

// server/src/antlers/modifiers/arrayModifiers.ts
var arrayModifiers;
var init_arrayModifiers = __esm({
  "server/src/antlers/modifiers/arrayModifiers.ts"() {
    "use strict";
    init_augmentGroupByScope();
    init_augmentSplitScope();
    arrayModifiers = [
      {
        name: "key_by",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Re-keys the array or collection using the provided field name.",
        docLink: null,
        parameters: [
          {
            name: "field",
            description: "The field to re-key the array or collection by."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "as",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Alias the array variable with a key.",
        docLink: "https://statamic.dev/modifiers/as",
        parameters: [
          {
            name: "alias",
            description: "The alias name."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "ampersand_list",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts the array into a comma delimited string, with an ampersand before the last item.",
        docLink: "https://statamic.dev/modifiers/ampersand_list",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "collapse",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Collapses an array of arrays into a single, flat, array.",
        docLink: "https://statamic.dev/modifiers/collapse",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "contains",
        acceptsType: ["array", "string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the value contains another value.",
        docLink: "https://statamic.dev/modifiers/contains",
        parameters: [
          {
            name: "needle",
            description: "The value to check for."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "count",
        acceptsType: ["array"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Returns the number of items in the array.",
        docLink: "https://statamic.dev/modifiers/count",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "dl",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turns an associative array into an HTML definition list.",
        docLink: "https://statamic.dev/modifiers/dl",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "explode",
        acceptsType: ["string"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Breaks a string into an array on a given delimiter.",
        docLink: "https://statamic.dev/modifiers/explode",
        parameters: [
          {
            name: "delimiter",
            description: "The delimiter to break the string apart on."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "flatten",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Flattens a multi-dimensional array.",
        docLink: "https://statamic.dev/modifiers/flatten",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "flip",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Swaps the array keys with their values.",
        docLink: "https://statamic.dev/modifiers/flip",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "group_by",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Groups the array items by the given key.",
        docLink: "https://statamic.dev/modifiers/group_by",
        parameters: [
          {
            name: "key",
            description: "The key to group by."
          }
        ],
        canBeParameter: true,
        augmentScope: augmentGroupByScope,
        isDeprecated: false
      },
      {
        name: "in_array",
        acceptsType: ["array"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if an array contains a specific value.",
        docLink: "https://statamic.dev/modifiers/in_array",
        parameters: [
          {
            name: "needle",
            description: "The value to check for."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_empty",
        acceptsType: ["array"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the array is empty.",
        docLink: "https://statamic.dev/modifiers/is_empty",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "join",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turn an array into a string by gluing together all the data.",
        docLink: "https://statamic.dev/modifiers/join",
        parameters: [
          {
            name: "glue",
            description: "The string to combine the parts by."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "joinplode",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turn an array into a string by gluing together all the data.",
        docLink: null,
        parameters: [
          {
            name: "glue",
            description: "The string to combine the parts by."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "limit",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Limits the number of items returned in the array",
        docLink: "https://statamic.dev/modifiers/limit",
        parameters: [
          {
            name: "count",
            description: "The maximum number of items to return."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "list",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts the array into a comma-separated string.",
        docLink: "https://statamic.dev/modifiers/list",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "offset",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Offsets the items returned in the array.",
        docLink: "https://statamic.dev/modifiers/offset",
        parameters: [
          {
            name: "offset",
            description: "The one-based index to start retrieving items."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "ol",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turns the array into an HTML ordered list.",
        docLink: "https://statamic.dev/modifiers/ol",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "option_list",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turns an array into a pipe-delimited string.",
        docLink: "https://statamic.dev/modifiers/option_list",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "pluck",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Plucks a value from a collection of items.",
        parameters: [
          {
            name: "value",
            description: "The value to pluck from the array or collection."
          }
        ],
        canBeParameter: true,
        docLink: null,
        isDeprecated: false
      },
      {
        name: "pad",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Pads the array to a specified length with the given value.",
        docLink: "https://statamic.dev/modifiers/pad",
        parameters: [
          {
            name: "length",
            description: "The desired length of the array."
          },
          {
            name: "value",
            description: "The value to pad the array with."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "piped",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turns an array into a pipe-delimited string.",
        docLink: "https://statamic.dev/modifiers/piped",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "sentence_list",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: 'Turns the array into a comma-delimited list, with the word "and" before the last item.',
        docLink: "https://statamic.dev/modifiers/sentence_list",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "shuffle",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Randomizes the order of array elements.",
        docLink: "https://statamic.dev/modifiers/shuffle",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "sort",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Sorts the array by a key in ascending or descending order.",
        docLink: "https://statamic.dev/modifiers/sort",
        parameters: [
          {
            name: "key",
            description: "The key to sort by."
          },
          {
            name: "order",
            description: "The sort direction. `asc` or `desc`."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "sum",
        acceptsType: ["array"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Returns the sum of all items in the array.",
        docLink: "https://statamic.dev/modifiers/sum",
        parameters: [
          {
            name: "key",
            description: "The value to sum."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "ul",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Turns the array into an HTML unordered list.",
        docLink: "https://statamic.dev/modifiers/ul",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "unique",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Returns all unique items in the array.",
        docLink: "https://statamic.dev/modifiers/unique",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "where",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Filters the array by a given key and value.",
        docLink: "https://statamic.dev/modifiers/where",
        parameters: [
          {
            name: "key",
            description: "The property to filter by."
          },
          {
            name: "value",
            description: "The value to compare to."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "split",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Splits an array into smaller arrays with the provided size.",
        canBeParameter: true,
        docLink: "",
        parameters: [
          {
            name: "size",
            description: "The size of each new array"
          }
        ],
        augmentScope: augmentSplitScope,
        isDeprecated: false
      },
      {
        name: "compact",
        acceptsType: ["string"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Accepts a comma-delimited list of variable names and return an array with their values.",
        canBeParameter: true,
        docLink: "",
        parameters: [
          {
            name: "variables",
            description: "A comma-delimited list of variable names."
          }
        ],
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/assetModifiers.ts
var assetModifiers;
var init_assetModifiers = __esm({
  "server/src/antlers/modifiers/assetModifiers.ts"() {
    "use strict";
    assetModifiers = [
      {
        name: "background_position",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: ["assets"],
        description: "Converts an asset focal point into a background-position CSS property.",
        docLink: "https://statamic.dev/modifiers/background_position",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "image",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: ["assets"],
        description: "Generates an HTML image element with the variable's value as the src.",
        docLink: "https://statamic.dev/modifiers/image",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "output",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: ["assets"],
        description: "Returns the string output of an Asset file's contents.",
        docLink: "https://statamic.dev/modifiers/output",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/conditionalModifiers.ts
var conditionalModifiers;
var init_conditionalModifiers = __esm({
  "server/src/antlers/modifiers/conditionalModifiers.ts"() {
    "use strict";
    conditionalModifiers = [
      {
        name: "contains_all",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if a string contains all of the provided needles.",
        docLink: "https://statamic.dev/modifiers/contains_all",
        parameters: [
          {
            name: "needle",
            description: "The string(s) to search for."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "contains_any",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if a string contains all of the provided needles.",
        docLink: "https://statamic.dev/modifiers/contains_any",
        parameters: [
          {
            name: "needle",
            description: "The string(s) to search for."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "ends_with",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if a string ends with another string.",
        docLink: "https://statamic.dev/modifiers/ends_with",
        parameters: [
          {
            name: "value",
            description: "The value to check against."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "has_lower_case",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string contains any lowercase characters.",
        docLink: "https://statamic.dev/modifiers/has_lower_case",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "has_upper_case",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string contains any uppercase characters.",
        docLink: "https://statamic.dev/modifiers/has_upper_case",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "in_array",
        acceptsType: ["array"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if an array contains a specific value.",
        docLink: "https://statamic.dev/modifiers/in_array",
        parameters: [
          {
            name: "needle",
            description: "The value(s) to search for."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_after",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is after another date.",
        docLink: "https://statamic.dev/modifiers/is_after",
        parameters: [
          {
            name: "date",
            description: "The date to compare to."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_alphanumeric",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string contains only alphanumeric characters.",
        docLink: "https://statamic.dev/modifiers/is_alphanumeric",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_before",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if a date is before another date.",
        docLink: "https://statamic.dev/modifiers/is_before",
        parameters: [
          {
            name: "date",
            description: "The date to compare to."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_between",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if a date is between two other dates.",
        docLink: "https://statamic.dev/modifiers/is_between",
        parameters: [
          {
            name: "start_date",
            description: "The start date to compare."
          },
          {
            name: "end_date",
            description: "The end date to compare."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_blank",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string contains only whitespace characters.",
        docLink: "https://statamic.dev/modifiers/is_blank",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_email",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: ["text", "textarea"],
        description: "Tests if the string is a valid email address.",
        docLink: "https://statamic.dev/modifiers/is_email",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_future",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is in the future.",
        docLink: "https://statamic.dev/modifiers/is_future",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_json",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string is valid JSON.",
        docLink: "https://statamic.dev/modifiers/is_json",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_leap_year",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is a leap year.",
        docLink: "https://statamic.dev/modifiers/is_leap_year",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_numeric",
        acceptsType: ["string", "number"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the value is a number or numeric string.",
        docLink: "https://statamic.dev/modifiers/is_numeric",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_past",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is in the past.",
        docLink: "https://statamic.dev/modifiers/is_past",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_today",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is today.",
        docLink: "https://statamic.dev/modifiers/is_today",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_uppercase",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string contains only uppercase characters.",
        docLink: "https://statamic.dev/modifiers/is_uppercase",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_url",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if the string is a valid URL.",
        docLink: "https://statamic.dev/modifiers/is_url",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_weekday",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is a week day.",
        docLink: "https://statamic.dev/modifiers/is_weekday",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_weekend",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is a weekend day.",
        docLink: "https://statamic.dev/modifiers/is_weekend",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_yesterday",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is yesterday.",
        docLink: "https://statamic.dev/modifiers/is_yesterday",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_tomorrow",
        acceptsType: ["string", "date"],
        returnsType: ["boolean"],
        forFieldType: ["date"],
        description: "Tests if the date is tomorrow.",
        docLink: null,
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "starts_with",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Tests if a value starts with the provided value.",
        docLink: "https://statamic.dev/modifiers/starts_with",
        parameters: [
          {
            name: "value",
            description: "The value to test for."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/dateModifiers.ts
var dateModifiers;
var init_dateModifiers = __esm({
  "server/src/antlers/modifiers/dateModifiers.ts"() {
    "use strict";
    dateModifiers = [
      {
        name: "days_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of days since a given date.",
        docLink: "https://statamic.dev/modifiers/days_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "format_translated",
        acceptsType: ["string", "date"],
        returnsType: ["string", "date"],
        forFieldType: ["date"],
        description: "Returns a formatted Carbon datetime/string.",
        docLink: "https://statamic.dev/modifiers/format",
        parameters: [
          {
            name: "format",
            description: "The format to use."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "format",
        acceptsType: ["string", "date"],
        returnsType: ["string", "date"],
        forFieldType: ["date"],
        description: "Formats the date using the provided format using PHP's [date variables](https://www.php.net/date).",
        hoverDescription: `Formats the date using the provided format using PHP's [date variables](https://www.php.net/date).

## Formatting Options

See [PHP: DateTimeInterface::format](https://www.php.net/manual/en/datetime.format.php) for all available options.

| Format Character | Description | Example |
|:----|----|---|
| Day | --- | --- |
| d | Day of the month, 2 digits with leading zeros | 01 to 31 |
| D |A textual representation of a day | Mon - Sun |
| j | Day of the month, without leading zeros | 1 - 31 |
| l | The day of the week | Sunday - Saturday |
| N | ISO 8601 representation of the day of the week | 1 (Monday) - 7 (Sunday) |
| S | English ordinal suffix for the day | st, nd, rt, or th |
| w | Numeric day of the week | 0 (Sunday) - 6 (Saturday) |
| z | Day of the year, starting at 0 | 0 - 365 |
| Week | --- | --- |
| W | ISO 8601 week number of the year, starting on Monday | 42 |
| Month | --- | --- |
| F | Text representation of the month | January - December |
| m | Numeric representation of the month, with leading zeros | 01 - 12 |
| M | A short text representation of the month | Jan - Dec |
| n | Numeric representation of the month | 1 - 12 |
| t | Number of days in the month | 28 - 31 |
| Year | --- | --- |
| L | Indicates if it's a leap year | 1 if true, 0 otherwise |
| Y | Four digit representation of the year | 2022 |
| y | Two digit representation of the year | 22 |
| Time | --- | --- |
| a | Lowercase Anti meridiem and Post meridiem | am or pm |
| A | Uppercase Anti meridiem and Post meridiem | AM or PM |
| g | 12-hour hour format without leading zeros | 1 - 12 |
| G | 24-hour hour format without leading zeros | 0 - 23 |
| h | 12-hour hour format with leading zeros | 01 - 12 |
| H | 24-hour hour format with leading zeros | 00 - 23 |
| i | Minutes with leading zeros | 00 - 59 |
| s | Seconds with leading zeros | 00 - 59 |
| Timezone | --- | --- |
| e | Timezone identifier | UTC, GMT |
| I | Indicates if date is in daylight saving time | 1 if true, 0 otherwise |
| T | Timezone appreviation | EST, MDT, +05 |
`,
        docLink: "https://statamic.dev/modifiers/format",
        parameters: [
          {
            name: "format",
            description: "The format to use."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "format_localized",
        acceptsType: ["string", "date"],
        returnsType: ["string", "date"],
        forFieldType: ["date"],
        description: "Formats the date using server's locale, using PHP's [strftime format variables](https://www.php.net/strftime).",
        docLink: "https://statamic.dev/modifiers/format_localized",
        parameters: [
          {
            name: "format",
            description: "The format to use."
          }
        ],
        canBeParameter: true,
        isDeprecated: true,
        getDeprecatedMessage() {
          return "The format_localized modifier is deprecated. Alternatives, such as the iso_format modifier, should be used instead.";
        }
      },
      {
        name: "hours_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of hours since the date.",
        docLink: "https://statamic.dev/modifiers/hours_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "iso_format",
        acceptsType: ["string", "date"],
        returnsType: ["string", "date"],
        forFieldType: ["date"],
        description: "Formats the date using an ISO format.",
        docLink: "https://statamic.dev/modifiers/iso_format",
        parameters: [
          {
            name: "format",
            description: "The format to use."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "minutes_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of minutes since the date.",
        docLink: "https://statamic.dev/modifiers/minutes_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "modify_date",
        acceptsType: ["string", "date"],
        returnsType: ["string", "date"],
        forFieldType: ["date"],
        description: "Alters the date by incrementing or decrementing it in a format accepted by PHP's [strtotime](https://www.php.net/strtotime) function.",
        docLink: "https://statamic.dev/modifiers/modify_date",
        parameters: [],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "months_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of months since the date.",
        docLink: "https://statamic.dev/modifiers/months_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "relative",
        acceptsType: ["string", "date"],
        returnsType: ["string"],
        forFieldType: ["date"],
        description: "Returns a human readable date difference.",
        docLink: "https://statamic.dev/modifiers/relative",
        parameters: [
          {
            name: "add_ago",
            description: "Whether to add the relative suffix words at the end of the string."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "seconds_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of seconds since the date.",
        docLink: "https://statamic.dev/modifiers/seconds_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "timezone",
        acceptsType: ["string", "date"],
        returnsType: ["string", "date"],
        forFieldType: ["date"],
        description: "Applies a timezone to the date.",
        docLink: "https://statamic.dev/modifiers/timezone",
        parameters: [
          {
            name: "timezone",
            description: "The timezone to apply."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "weeks_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of weeks since the date.",
        docLink: "https://statamic.dev/modifiers/weeks_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "years_ago",
        acceptsType: ["string", "date"],
        returnsType: ["number"],
        forFieldType: ["date"],
        description: "Returns the number of years since the date.",
        docLink: "https://statamic.dev/modifiers/years_ago",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/markupModifiers.ts
var markupModifiers;
var init_markupModifiers = __esm({
  "server/src/antlers/modifiers/markupModifiers.ts"() {
    "use strict";
    markupModifiers = [
      {
        name: "chunk",
        acceptsType: ["array"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Breaks the array or collection into smaller arrays of a given size.",
        docLink: "https://statamic.dev/modifiers/chunk",
        parameters: [
          {
            name: "chunk_size",
            description: "The maximum length of each new chunk."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "favicon",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Generates a favicon HTML meta tag for the given value.",
        docLink: "https://statamic.dev/modifiers/favicon",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "first",
        acceptsType: ["string", "array"],
        returnsType: ["*"],
        forFieldType: [],
        description: "Returns the specified number of characters/items from the beginning of the string/array.",
        docLink: "https://statamic.dev/modifiers/first",
        parameters: [
          {
            name: "count",
            description: "The number of characters to return."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "last",
        acceptsType: ["string", "array"],
        returnsType: ["*"],
        forFieldType: [],
        description: "Returns the specified number of characters/items from the end of the string/array.",
        docLink: "https://statamic.dev/modifiers/last",
        parameters: [
          {
            name: "count",
            description: "The number of characters to return."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "link",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Generates an HTML link for the provided value.",
        docLink: "https://statamic.dev/modifiers/link",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "mailto",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Generates a mailto HTML link for the provided value.",
        docLink: "https://statamic.dev/modifiers/mailto",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "markdown",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Parses the value as Markdown and returns the HTML.",
        docLink: "https://statamic.dev/modifiers/markdown",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "nl2br",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Replaces line breaks with HTML `<br>` tags.",
        docLink: "https://statamic.dev/modifiers/nl2br",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "obfuscate",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Modifies the input string by replacing it with special characters, making it harder for bots but remains readable to site visitors.",
        docLink: "https://statamic.dev/modifiers/obfuscate",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "obfuscate_email",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Obfuscates an email address with special HTML characters.",
        docLink: "https://statamic.dev/modifiers/obfuscate_email",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "strip_tags",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Removes HTML tags from the string.",
        docLink: "https://statamic.dev/modifiers/strip_tags",
        parameters: [
          {
            name: "tags",
            description: "The HTML tag(s) to remove from the string."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "table",
        acceptsType: ["array"],
        returnsType: ["string"],
        forFieldType: ["table"],
        description: "Turns a [Table FieldType](https://statamic.dev/fieldtypes/table) array into an HTML table.",
        docLink: "https://statamic.dev/modifiers/table",
        parameters: [
          {
            name: "content_markdown",
            description: "Whether to parse cell contents as Markdown."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "textile",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Parses a string with [Textile](http://demo.textilewiki.com/theme-default/) and returns the HTML.",
        docLink: "https://statamic.dev/modifiers/textile",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "wrap",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Wraps a string with a given HTML tag.",
        docLink: "https://statamic.dev/modifiers/wrap",
        parameters: [
          {
            name: "expression",
            description: "The HTML tag or Emmet-style expression to wrap the value in."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/mathModifiers.ts
var mathModifiers;
var init_mathModifiers = __esm({
  "server/src/antlers/modifiers/mathModifiers.ts"() {
    "use strict";
    mathModifiers = [
      {
        name: "add",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Adds two values together.",
        docLink: "https://statamic.dev/modifiers/add",
        parameters: [
          {
            name: "value",
            description: "The value to add."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "+",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Adds two values together.",
        docLink: "https://statamic.dev/modifiers/add",
        parameters: [
          {
            name: "value",
            description: "The value to add."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "ceil",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Rounds the value to the next whole number.",
        docLink: "https://statamic.dev/modifiers/ceil",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "divide",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Divides two values.",
        docLink: "https://statamic.dev/modifiers/divide",
        parameters: [
          {
            name: "value",
            description: "The value to divide."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "floor",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Rounds a number down to the next whole number.",
        docLink: "https://statamic.dev/modifiers/floor",
        parameters: [],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "format_number",
        acceptsType: ["number"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Formats a number.",
        docLink: "https://statamic.dev/modifiers/format_number",
        parameters: [
          {
            name: "precision",
            description: "Number of decimal places before rounding."
          },
          {
            name: "decimal_separator",
            description: "The decimal separator (defaults to `.`)."
          },
          {
            name: "thousands_separator",
            description: "The thousands separator (default `,`)."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "mode",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "",
        docLink: "",
        parameters: [],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "multiply",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Multiplies two values.",
        docLink: "https://statamic.dev/modifiers/multiply",
        parameters: [
          {
            name: "value",
            description: "The value to multiply."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "*",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Multiplies two values.",
        docLink: "https://statamic.dev/modifiers/multiply",
        parameters: [
          {
            name: "value",
            description: "The value to multiply."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "round",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Rounds a number to a specified precision.",
        docLink: "https://statamic.dev/modifiers/round",
        parameters: [
          {
            name: "precision",
            description: "The number of digits after the decimal point."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "subtract",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Subtracts two values.",
        docLink: "https://statamic.dev/modifiers/subtract",
        parameters: [
          {
            name: "value",
            description: "The value to subtract."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "-",
        acceptsType: ["number"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Subtracts two values.",
        docLink: "https://statamic.dev/modifiers/subtract",
        parameters: [
          {
            name: "value",
            description: "The value to subtract."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/specialModifiers.ts
var specialModifiers;
var init_specialModifiers = __esm({
  "server/src/antlers/modifiers/specialModifiers.ts"() {
    "use strict";
    specialModifiers = [
      {
        name: "partial",
        acceptsType: ["*"],
        returnsType: ["*view*"],
        forFieldType: [],
        description: "Injects data into a partial and renders it.",
        docLink: "https://statamic.dev/modifiers/partial",
        parameters: [
          {
            name: "partial",
            description: "The name of the partial."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "macro",
        acceptsType: ["*"],
        returnsType: ["*"],
        forFieldType: [],
        description: "Runs a pre-configured macro on the data.",
        docLink: "https://statamic.dev/modifiers/macro",
        parameters: [
          {
            name: "macro",
            description: "The macro name."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "url",
        acceptsType: ["string", "*"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Locates the URL of an asset, page, entry, or taxonomy term based on the variable contents.",
        docLink: "https://statamic.dev/modifiers/url",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "bool_string",
        acceptsType: ["boolean", "*"],
        returnsType: ["string"],
        canBeParameter: false,
        description: 'Converts the provided value to a "true" or "false" string',
        docLink: null,
        forFieldType: ["toggle"],
        isDeprecated: false,
        parameters: [
          {
            name: "value",
            description: "The truthy value to convert to a string."
          }
        ]
      }
    ];
  }
});

// server/src/antlers/modifiers/stringModifiers.ts
var stringModifiers;
var init_stringModifiers = __esm({
  "server/src/antlers/modifiers/stringModifiers.ts"() {
    "use strict";
    stringModifiers = [
      {
        name: "ascii",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Replaces all non-ASCII characters with their closest ASCII counterparts.",
        docLink: "https://statamic.dev/modifiers/ascii",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "at",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns the character at a given zero-based position.",
        docLink: "https://statamic.dev/modifiers/at",
        parameters: [
          {
            name: "position",
            description: "The zero-based position to retrieve a character from."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "backspace",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Removes a specified number of characters from the end of a string.",
        docLink: "https://statamic.dev/modifiers/backspace",
        parameters: [
          {
            name: "character_count",
            description: "The number of characters to remove from the end of the string."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "camelize",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts the string into camelCase.",
        docLink: "https://statamic.dev/modifiers/camelize",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "cdata",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Wraps the string in CDATA XML tags.",
        docLink: "https://statamic.dev/modifiers/cdata",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "collapse_whitespace",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Trims a string and replaces consecutive whitespace characters with a single space.",
        docLink: "https://statamic.dev/modifiers/collapse_whitespace",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "count_substring",
        acceptsType: ["string"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Counts the number of occurrences of a term within the string.",
        docLink: "https://statamic.dev/modifiers/count_substring",
        parameters: [
          {
            name: "term",
            description: "The sub-string to search for."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "dashify",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a lower-cased and trimmed string, separated by dashes.",
        docLink: "https://statamic.dev/modifiers/dashify",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "deslugify",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Replaces all hyphens and underscores with spaces.",
        docLink: "https://statamic.dev/modifiers/deslugify",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "embed_url",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: ["video"],
        description: "Converts a YouTube or Viemo link into their embed URLs.",
        docLink: "https://statamic.dev/modifiers/embed_url",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "trackable_embed_url",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Get the embed URL when given a YouTube or Vimeo link that's direct to the page.",
        docLink: null,
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "ensure_left",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Ensures that the string begins with the specified string.",
        docLink: "https://statamic.dev/modifiers/ensure_left",
        parameters: [
          {
            name: "start_string",
            description: "The value that should be at the start of the string."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "ensure_right",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Ensures that the string ends with the specified string.",
        docLink: "https://statamic.dev/modifiers/ensure_right",
        parameters: [
          {
            name: "end_string",
            description: "The value that should be at the end of the string."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "entities",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Encode a string with HTML entities.",
        docLink: "https://statamic.dev/modifiers/entities",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "excerpt",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Breaks a string at a given marker.",
        docLink: "https://statamic.dev/modifiers/excerpt",
        parameters: [
          {
            name: "marker",
            description: "The substring to break on."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "explode",
        acceptsType: ["string"],
        returnsType: ["array"],
        forFieldType: [],
        description: "Breaks a string into an array of strings.",
        docLink: "https://statamic.dev/modifiers/explode",
        parameters: [
          {
            name: "delimiter",
            description: "The string to split the larger string by."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "gravatar",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts an email string to a Gravatar image URL.",
        docLink: "https://statamic.dev/modifiers/gravatar",
        parameters: [
          {
            name: "image size",
            description: "The desired image size."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "insert",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Inserts a string at the position provided.",
        docLink: "https://statamic.dev/modifiers/insert",
        parameters: [
          {
            name: "value",
            description: "The value to insert."
          },
          {
            name: "position",
            description: "The zero based position to insert the text at."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "is_email",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Returns true if the string is a valid email address.",
        docLink: "https://statamic.dev/modifiers/is_email",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_embeddable",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: ["video"],
        description: "Checks to see if a video URL is embeddable.",
        docLink: "https://statamic.dev/modifiers/is_embeddable",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_lowercase",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Returns true if the string contains only lowercase characters.",
        docLink: "https://statamic.dev/modifiers/is_lowercase",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "is_url",
        acceptsType: ["string"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Returns true if a string is a valid URL.",
        docLink: "https://statamic.dev/modifiers/is_url",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "lcfirst",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts the first character of the value to lower case.",
        docLink: "https://statamic.dev/modifiers/lcfirst",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "length",
        acceptsType: ["string"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Returns the number of items in an array or number of characters in a string.",
        docLink: "https://statamic.dev/modifiers/length",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "lower",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts all characters to lowercase.",
        docLink: "https://statamic.dev/modifiers/lower",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "md5",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Creates an MD5 hash of the variable.",
        docLink: "https://statamic.dev/modifiers/md5",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "rawurlencode",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "URL-encode a variable according to RFC-3986.",
        docLink: "https://statamic.dev/modifiers/rawurlencode",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "read_time",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns an estimated read time, in minutes.",
        docLink: "https://statamic.dev/modifiers/read_time",
        parameters: [
          {
            name: "words per minute",
            description: "The words per minute to use as an estimate."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "regex_replace",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Replaces all regex matches within a string.",
        docLink: "https://statamic.dev/modifiers/regex_replace",
        parameters: [
          {
            name: "pattern",
            description: "The regex pattern."
          },
          {
            name: "replace",
            description: "The replacement value."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "remove_left",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Ensures that the string never begins with a specified string.",
        docLink: "https://statamic.dev/modifiers/remove_left/",
        parameters: [
          {
            name: "value",
            description: "The value to remove."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "remove_right",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Ensures that a string never ends with a specified string.",
        docLink: "https://statamic.dev/modifiers/remove_right",
        parameters: [
          {
            name: "value",
            description: "The value to remove."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "replace",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Replaces all occurrences of a string with a different value.",
        docLink: "https://statamic.dev/modifiers/replace",
        parameters: [
          {
            name: "needle",
            description: "The string to search for."
          },
          {
            name: "value",
            description: "The value to replace all occurrences with."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "reverse",
        acceptsType: ["string", "array"],
        returnsType: ["string", "array"],
        forFieldType: [],
        description: "Reverses all characters in a string, or all items in an array.",
        docLink: "https://statamic.dev/modifiers/reverse",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "safe_truncate",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Truncates a string to a given length.",
        docLink: "https://statamic.dev/modifiers/safe_truncate",
        parameters: [
          {
            name: "length",
            description: "The desired string length."
          },
          {
            name: "suffix",
            description: "An optional suffix to append to the string if truncation occurs."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "sanitize",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts special characters to HTML entities.",
        docLink: "https://statamic.dev/modifiers/sanitize",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "segment",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a segment by number from any valid URL or URI.",
        docLink: "https://statamic.dev/modifiers/segment",
        parameters: [
          {
            name: "segment",
            description: "The one-based segment to return."
          }
        ],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "singular",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns the singular form of an English word.",
        docLink: "https://statamic.dev/modifiers/singular",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "slugify",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts the string into an URL slug.",
        docLink: "https://statamic.dev/modifiers/slugify",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "smartypants",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Translates plain ASCII punctuation characters into typographic punctuation HTML entities.",
        docLink: "https://statamic.dev/modifiers/smartypants",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "spaceless",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Removes excess whitespace and line breaks from a string.",
        docLink: "https://statamic.dev/modifiers/spaceless",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "substr",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a portion of a string based on provided a start index, and optional length.",
        docLink: "https://statamic.dev/modifiers/substr",
        parameters: [
          {
            name: "start",
            description: "The 0-based index to start searching."
          },
          {
            name: "length",
            description: "An optional length for the string to find."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "surround",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Surrounds a string with another string.",
        docLink: "https://statamic.dev/modifiers/surround",
        parameters: [
          {
            name: "value",
            description: "The value to surround the string with."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "swap_case",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a case swapped version of the string.",
        docLink: "https://statamic.dev/modifiers/swap_case",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "tidy",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a string with smart quotes, ellipsis characters, and dashes from Windows-1252 replaced by ASCII equivalents.",
        docLink: "https://statamic.dev/modifiers/tidy",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "title",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a Title Cased version of the string.",
        docLink: "https://statamic.dev/modifiers/title",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "trim",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Removes whitespace from the start and end of the string.",
        docLink: "https://statamic.dev/modifiers/trim",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "truncate",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Truncates a string to a given length.",
        docLink: "https://statamic.dev/modifiers/truncate",
        parameters: [
          {
            name: "length",
            description: "The maximum string length."
          },
          {
            name: "suffix",
            description: "An optional suffix to append to the string if truncation occurs."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "ucfirst",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Upper cases the first character in the string.",
        docLink: "https://statamic.dev/modifiers/ucfirst",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "underscored",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Returns a lower-cased and trimmed version of the string, separated by underscores.",
        docLink: "https://statamic.dev/modifiers/underscored",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "upper",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Transforms the string to uppercase.",
        docLink: "https://statamic.dev/modifiers/upper",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "urldecode",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "URL-decodes the string.",
        docLink: "https://statamic.dev/modifiers/urldecode",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "urlencode",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "URL-encodes the string.",
        docLink: "https://statamic.dev/modifiers/urlencode",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "widont",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Attempts to prevent lines with single words.",
        docLink: "https://statamic.dev/modifiers/widont",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "word_count",
        acceptsType: ["string"],
        returnsType: ["number"],
        forFieldType: [],
        description: "Returns the number of words in the string.",
        docLink: "https://statamic.dev/modifiers/word_count",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "add_slashes",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Adds slashes before characters that need to be escaped.",
        docLink: "https://statamic.dev/modifiers/add_slashes",
        canBeParameter: false,
        parameters: [],
        isDeprecated: false
      },
      {
        name: "antlers",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Parses the provided value as Antlers, and returns the result.",
        docLink: null,
        canBeParameter: false,
        parameters: [],
        isDeprecated: false
      },
      {
        name: "bard_items",
        acceptsType: ["string"],
        returnsType: ["array"],
        forFieldType: ["bard"],
        description: "Converts a Bard value to a flat array of nodes and marks.",
        docLink: null,
        canBeParameter: false,
        parameters: [],
        isDeprecated: false
      },
      {
        name: "bard_text",
        acceptsType: ["array", "string"],
        returnsType: ["string"],
        forFieldType: ["bard"],
        description: "Converts a Bard value to plain text (excluding sets).",
        docLink: null,
        canBeParameter: false,
        parameters: [],
        isDeprecated: false
      },
      {
        name: "bard_html",
        acceptsType: ["array", "string"],
        returnsType: ["string"],
        forFieldType: ["bard"],
        description: "Converts a Bard value to HTML (excluding sets).",
        docLink: null,
        canBeParameter: false,
        parameters: [],
        isDeprecated: false
      },
      {
        name: "mark",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Wraps matched words and phrases in <mark> tags.",
        docLink: null,
        canBeParameter: false,
        parameters: [
          {
            name: "search",
            description: "The search word or phrase to wrap in <mark> tags."
          }
        ],
        isDeprecated: false
      },
      {
        name: "regex_mark",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Wraps matched words and phrases in <mark> tags using regular expressions.",
        docLink: null,
        canBeParameter: false,
        parameters: [
          {
            name: "pattern",
            description: "The search pattern used to wrap content in <mark> tags."
          }
        ],
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifiers/utilityModifiers.ts
var utilityModifiers;
var init_utilityModifiers = __esm({
  "server/src/antlers/modifiers/utilityModifiers.ts"() {
    "use strict";
    utilityModifiers = [
      {
        name: "console_log",
        acceptsType: ["*"],
        returnsType: ["null"],
        forFieldType: [],
        description: "Displays variable data in the browser's JavaScript console.",
        docLink: "https://statamic.dev/modifiers/console_log",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "decode",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts all HTML entities to their character codes.",
        docLink: "https://statamic.dev/modifiers/decode",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "dump",
        acceptsType: ["*"],
        returnsType: ["null"],
        forFieldType: [],
        description: "Displays variable data in the browser.",
        docLink: "https://statamic.dev/modifiers/dump",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "full_urls",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Replaces root-relative URLs with absolute URLs.",
        docLink: "https://statamic.dev/modifiers/full_urls",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "repeat",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Repeats a value a given number of times.",
        docLink: "https://statamic.dev/modifiers/repeat",
        parameters: [{
          name: "times",
          description: "The number of times to repeat the value."
        }],
        canBeParameter: true,
        isDeprecated: false
      },
      {
        name: "to_spaces",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts all tabs to spaces.",
        docLink: "https://statamic.dev/modifiers/to_spaces",
        parameters: [
          {
            name: "space_count",
            description: "The number of spaces to replace tabs with."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "to_tabs",
        acceptsType: ["string"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts spaces to tabs.",
        docLink: "https://statamic.dev/modifiers/to_tabs",
        parameters: [
          {
            name: "space_count",
            description: "The number of spaces to convert to tabs."
          }
        ],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "to_json",
        acceptsType: ["*"],
        returnsType: ["string"],
        forFieldType: [],
        description: "Converts the data to JSON",
        docLink: "https://statamic.dev/modifiers/to_json",
        parameters: [],
        canBeParameter: false,
        isDeprecated: false
      },
      {
        name: "to_bool",
        acceptsType: ["*"],
        returnsType: ["boolean"],
        forFieldType: [],
        description: "Converts the data to a boolean/truthy value.",
        parameters: [],
        canBeParameter: false,
        docLink: null,
        isDeprecated: false
      }
    ];
  }
});

// server/src/antlers/modifierManager.ts
var ModifierManager, modifierManager_default;
var init_modifierManager = __esm({
  "server/src/antlers/modifierManager.ts"() {
    "use strict";
    init_blueprintTypes();
    init_arrayModifiers();
    init_assetModifiers();
    init_conditionalModifiers();
    init_dateModifiers();
    init_markupModifiers();
    init_mathModifiers();
    init_specialModifiers();
    init_stringModifiers();
    init_utilityModifiers();
    ModifierManager = class {
      constructor() {
        this.registeredModifiers = /* @__PURE__ */ new Map();
        this.acceptTypedModifierReference = /* @__PURE__ */ new Map();
        this.returnTypeModifierReference = /* @__PURE__ */ new Map();
        this.macros = /* @__PURE__ */ new Map();
        this.modifierNameCache = [];
      }
      reset() {
        this.modifierNameCache = [];
        this.registeredModifiers.clear();
        this.acceptTypedModifierReference.clear();
        this.returnTypeModifierReference.clear();
      }
      getRegisteredModifiers() {
        return this.registeredModifiers;
      }
      resetMacros() {
        this.macros.clear();
      }
      loadCoreModifiers() {
        this.registerModifiers(arrayModifiers);
        this.registerModifiers(assetModifiers);
        this.registerModifiers(conditionalModifiers);
        this.registerModifiers(dateModifiers);
        this.registerModifiers(markupModifiers);
        this.registerModifiers(mathModifiers);
        this.registerModifiers(utilityModifiers);
        this.registerModifiers(stringModifiers);
        this.registerModifiers(specialModifiers);
      }
      getModifierNames() {
        return this.modifierNameCache;
      }
      registerMacro(macro) {
        this.macros.set(macro.name, macro);
      }
      registerMacros(macros) {
        for (let i = 0; i < macros.length; i++) {
          this.registerMacro(macros[i]);
        }
      }
      hasMacro(name) {
        if (this.macros.has(name)) {
          const macro = this.macros.get(name);
          if (typeof macro === "undefined" || macro === null) {
            return false;
          }
          return true;
        }
        return false;
      }
      getMacro(name) {
        if (this.macros.has(name)) {
          const macro = this.macros.get(name);
          if (typeof macro === "undefined" || macro === null) {
            return null;
          }
          return macro;
        }
        return null;
      }
      getMacroManifestingType(name) {
        const macro = this.getMacro(name);
        if (macro == null) {
          return "";
        }
        return macro.manifestsType;
      }
      getRegisteredModifier(name) {
        if (this.registeredModifiers.has(name)) {
          return this.registeredModifiers.get(name);
        }
        return null;
      }
      getModifiersForType(type2) {
        const lookupType = getFieldRuntimeType(type2);
        if (this.acceptTypedModifierReference.has(lookupType)) {
          return this.acceptTypedModifierReference.get(lookupType);
        }
        return [];
      }
      getProbableReturnType(modifier, isTagPair) {
        if (modifier == null) {
          return "";
        }
        if (modifier.returnsType.length == 0) {
          return "";
        }
        if (isTagPair && modifier.returnsType.includes("array")) {
          return "array";
        }
        return modifier.returnsType[0];
      }
      registerModifiers(modifiers) {
        var _a, _b;
        for (let i = 0; i < modifiers.length; i++) {
          const curModifier = modifiers[i];
          this.modifierNameCache.push(curModifier.name);
          for (let j = 0; j < curModifier.acceptsType.length; j++) {
            const curAcceptType = curModifier.acceptsType[j];
            if (this.acceptTypedModifierReference.has(curAcceptType) == false) {
              this.acceptTypedModifierReference.set(curAcceptType, []);
            }
            (_a = this.acceptTypedModifierReference.get(curAcceptType)) == null ? void 0 : _a.push(curModifier);
          }
          for (let j = 0; j < curModifier.returnsType.length; j++) {
            const curReturnType = curModifier.returnsType[j];
            if (this.returnTypeModifierReference.has(curReturnType) == false) {
              this.returnTypeModifierReference.set(curReturnType, []);
            }
            (_b = this.returnTypeModifierReference.get(curReturnType)) == null ? void 0 : _b.push(curModifier);
          }
          this.registeredModifiers.set(modifiers[i].name, modifiers[i]);
        }
      }
      registerModifier(modifier) {
        const modifiers = [];
        modifiers.push(modifier);
        this.registerModifiers(modifiers);
      }
      getModifier(name) {
        if (this.registeredModifiers.has(name) == false) {
          return null;
        }
        const modifier = this.registeredModifiers.get(name);
        if (typeof modifier == "undefined" || modifier == null) {
          return null;
        }
        return modifier;
      }
      hasModifier(name) {
        if (!this.registeredModifiers.has(name)) {
          return false;
        }
        const modifier = this.registeredModifiers.get(name);
        if (typeof modifier == "undefined" || modifier == null) {
          return false;
        }
        return true;
      }
    };
    ModifierManager.instance = null;
    if (typeof ModifierManager.instance == "undefined" || ModifierManager.instance == null) {
      ModifierManager.instance = new ModifierManager();
      ModifierManager.instance.loadCoreModifiers();
    }
    modifierManager_default = ModifierManager;
  }
});

// server/src/runtime/nodes/antlersVirtualStructures/nodeVirtualModifiers.ts
var NodeVirtualModifiers;
var init_nodeVirtualModifiers = __esm({
  "server/src/runtime/nodes/antlersVirtualStructures/nodeVirtualModifiers.ts"() {
    "use strict";
    init_modifierManager();
    init_abstractNode();
    NodeVirtualModifiers = class {
      constructor(node) {
        this.parameterModifiers = [];
        this.hasMixedModifierStyles = false;
        this.modifierNames = [];
        this.node = node;
      }
      isPaired() {
        if (this.node instanceof AntlersNode) {
          return this.node.isPaired();
        }
        return false;
      }
      getModifierValue(modifierName) {
        var _a;
        if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0) {
          for (let i = 0; i < this.node.modifierChain.modifierChain.length; i++) {
            const thisModifier = this.node.modifierChain.modifierChain[i];
            if (((_a = thisModifier.nameNode) == null ? void 0 : _a.name) == modifierName) {
              if (thisModifier.valueNodes.length > 0) {
                return thisModifier.valueNodes[0].content;
              }
              return "";
            }
          }
        }
        if (this.hasParameterModifiers()) {
          for (let i = 0; i < this.parameterModifiers.length; i++) {
            const thisModifier = this.parameterModifiers[i];
            if (thisModifier.name == modifierName) {
              return thisModifier.value;
            }
          }
        }
        return null;
      }
      getModifierRange(modifierName) {
        var _a;
        if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0) {
          for (let i = 0; i < this.node.modifierChain.modifierChain.length; i++) {
            const thisModifier = this.node.modifierChain.modifierChain[i];
            if (((_a = thisModifier.nameNode) == null ? void 0 : _a.name) == modifierName) {
              if (thisModifier.valueNodes.length > 0) {
                return {
                  start: thisModifier.startPosition,
                  end: thisModifier.endPosition
                };
              }
              return null;
            }
          }
        }
        if (this.hasParameterModifiers()) {
          for (let i = 0; i < this.parameterModifiers.length; i++) {
            const thisModifier = this.parameterModifiers[i];
            if (thisModifier.name == modifierName) {
              if (thisModifier.namePosition != null && thisModifier.valuePosition != null) {
                return {
                  start: thisModifier.namePosition.start,
                  end: thisModifier.valuePosition.end
                };
              }
            }
          }
        }
        return null;
      }
      getLastManifestedModifierRuntimeType() {
        if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0 && this.node.modifierChain.lastManifestedModifier != null) {
          if (this.node.modifierChain.lastManifestedModifier.parameters.length > 0) {
            if (this.node.modifierChain.lastManifestedModifier.modifier != null && modifierManager_default.instance != null) {
              const tModifier = this.node.modifierChain.lastManifestedModifier.modifier;
              return modifierManager_default.instance.getProbableReturnType(tModifier, this.isPaired());
            }
          }
          return "*";
        }
        if (this.parameterModifiers.length > 0) {
          const pModifiers = this.parameterModifiers.reverse();
          for (let i = 0; i < pModifiers.length; i++) {
            if (pModifiers[i].modifier != null && modifierManager_default.instance != null) {
              const tModifier = pModifiers[i].modifier;
              return modifierManager_default.instance.getProbableReturnType(tModifier, this.isPaired());
            }
          }
        }
        return "*";
      }
      getLastManifestedModifierValue() {
        if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0 && this.node.modifierChain.lastManifestedModifier != null) {
          if (this.node.modifierChain.lastManifestedModifier.parameters.length > 0) {
            return this.node.modifierChain.lastManifestedModifier.parameters[0].value;
          }
          return "";
        }
        if (this.parameterModifiers.length > 0) {
          const pModifiers = this.parameterModifiers.reverse();
          for (let i = 0; i < pModifiers.length; i++) {
            if (pModifiers[i].modifier != null) {
              return pModifiers[i].value;
            }
          }
        }
        return "";
      }
      getLastManifestedModifier() {
        if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0 && this.node.modifierChain.lastModifier != null) {
          return this.node.modifierChain.lastModifier;
        }
        if (this.parameterModifiers.length > 0) {
          const pModifiers = this.parameterModifiers.reverse();
          for (let i = 0; i < pModifiers.length; i++) {
            if (pModifiers[i].modifier != null) {
              return pModifiers[i].modifier;
            }
          }
        }
        return null;
      }
      hasModifiers() {
        if (this.node.modifierChain == null || this.node.modifierChain.modifierChain.length == 0) {
          if (this.parameterModifiers.length > 0) {
            return true;
          }
          return false;
        }
        return true;
      }
      hasParameterModifiers() {
        return this.parameterModifiers.length > 0;
      }
      hasShorthandModifiers() {
        if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0) {
          return true;
        }
        return false;
      }
      hasModifier(modifierName) {
        return this.modifierNames.includes(modifierName);
      }
    };
  }
});

// server/src/runtime/document/scanners/nodeFilters.ts
function filterStructuralAntlersNodes(sourceNodes) {
  const nodes = [];
  sourceNodes.forEach((node) => {
    if (node instanceof AntlersNode) {
      nodes.push(node);
    } else if (node instanceof ConditionNode) {
      if (node.logicBranches.length > 0) {
        node.logicBranches.forEach((branch) => {
          if (branch.head != null) {
            const tBrancHead = branch.head;
            if (tBrancHead.originalNode != null) {
              nodes.push(tBrancHead.originalNode);
            } else {
              nodes.push(tBrancHead);
            }
          }
        });
      }
    }
  });
  return nodes;
}
var init_nodeFilters = __esm({
  "server/src/runtime/document/scanners/nodeFilters.ts"() {
    "use strict";
    init_abstractNode();
  }
});

// server/src/runtime/utilities/isNumeric.ts
function is_numeric(char) {
  return (typeof char === "number" || typeof char === "string" && whitespace.indexOf(char.slice(-1)) === -1) && char !== "" && !isNaN(char);
}
var whitespace;
var init_isNumeric = __esm({
  "server/src/runtime/utilities/isNumeric.ts"() {
    "use strict";
    whitespace = [
      " ",
      "\n",
      "\r",
      "	",
      "\f",
      "\v",
      "\xA0",
      "\u2000",
      "\u2001",
      "\u2002",
      "\u2003",
      "\u2004",
      "\u2005",
      "\u2006",
      "\u2007",
      "\u2008",
      "\u2009",
      "\u200A",
      "\u200B",
      "\u2028",
      "\u2029",
      "\u3000"
    ].join("");
  }
});

// server/src/runtime/utilities/stringUtilities.ts
var StringUtilities;
var init_stringUtilities = __esm({
  "server/src/runtime/utilities/stringUtilities.ts"() {
    "use strict";
    init_isNumeric();
    StringUtilities = class {
      static boolLabel(value) {
        return value ? "true" : "false";
      }
      static normalizeLineEndings(string, to = "\n") {
        return string.replace(/\r?\n/g, to);
      }
      static breakByNewLine(value) {
        return value.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
      }
      static split(text) {
        return text.split("");
      }
      static substring(text, start, length) {
        return text.substr(start, length);
      }
      static ctypeSpace(char) {
        return (char == null ? void 0 : char.search(/^[\f\n\r\t\v ]+$/g)) !== -1;
      }
      static ctypeAlpha(char) {
        return (char == null ? void 0 : char.search(/^[A-Za-z]+$/g)) !== -1;
      }
      static ctypeDigit(char) {
        return (char == null ? void 0 : char.search(/^[\d]+$/g)) !== -1;
      }
      static ctypePunct(char) {
        return (char == null ? void 0 : char.search(/^[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]+$/g)) !== -1;
      }
      static trimLeft(value, charList = "\\s") {
        return value.replace(new RegExp("^[" + charList + "]+"), "");
      }
      static trimRight(value, charList = "\\s") {
        return value.replace(new RegExp("[" + charList + "]+$"), "");
      }
      static isNumeric(string) {
        return is_numeric(string);
      }
      static substringCount(haystack, needle) {
        const subStr = needle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return (haystack.match(new RegExp(subStr, "gi")) || []).length;
      }
      static getLastLine(content) {
        const lines = StringUtilities.breakByNewLine(content);
        if (lines.length == 0) {
          return "";
        }
        return lines[lines.length - 1];
      }
      static getFirstLine(content) {
        const lines = StringUtilities.breakByNewLine(content);
        if (lines.length == 0) {
          return "";
        }
        return lines[0];
      }
      static snakeCase(string) {
        return string.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`).replace(/^_/, "");
      }
    };
  }
});

// server/src/runtime/nodes/antlersVirtualStructures/nodeVirtualHierarchy.ts
var NodeVirtualHierarchy;
var init_nodeVirtualHierarchy = __esm({
  "server/src/runtime/nodes/antlersVirtualStructures/nodeVirtualHierarchy.ts"() {
    "use strict";
    NodeVirtualHierarchy = class {
      constructor(node) {
        this.node = node;
      }
      findParentWithName(name) {
        const parser = this.node.getParser();
        if (parser == null) {
          return null;
        }
        return parser.structure.findParentWithName(name, this.node);
      }
    };
  }
});

// server/node_modules/ts-md5/dist/md5.js
var require_md5 = __commonJS({
  "server/node_modules/ts-md5/dist/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Md54 = function() {
      function Md55() {
        this._state = new Int32Array(4);
        this._buffer = new ArrayBuffer(68);
        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
        this.start();
      }
      Md55.hashStr = function(str2, raw) {
        if (raw === void 0) {
          raw = false;
        }
        return this.onePassHasher.start().appendStr(str2).end(raw);
      };
      Md55.hashAsciiStr = function(str2, raw) {
        if (raw === void 0) {
          raw = false;
        }
        return this.onePassHasher.start().appendAsciiStr(str2).end(raw);
      };
      Md55._hex = function(x) {
        var hc = Md55.hexChars;
        var ho = Md55.hexOut;
        var n;
        var offset;
        var j;
        var i;
        for (i = 0; i < 4; i += 1) {
          offset = i * 8;
          n = x[i];
          for (j = 0; j < 8; j += 2) {
            ho[offset + 1 + j] = hc.charAt(n & 15);
            n >>>= 4;
            ho[offset + 0 + j] = hc.charAt(n & 15);
            n >>>= 4;
          }
        }
        return ho.join("");
      };
      Md55._md5cycle = function(x, k) {
        var a = x[0];
        var b = x[1];
        var c = x[2];
        var d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      };
      Md55.prototype.start = function() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state.set(Md55.stateIdentity);
        return this;
      };
      Md55.prototype.appendStr = function(str2) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var code;
        var i;
        for (i = 0; i < str2.length; i += 1) {
          code = str2.charCodeAt(i);
          if (code < 128) {
            buf8[bufLen++] = code;
          } else if (code < 2048) {
            buf8[bufLen++] = (code >>> 6) + 192;
            buf8[bufLen++] = code & 63 | 128;
          } else if (code < 55296 || code > 56319) {
            buf8[bufLen++] = (code >>> 12) + 224;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          } else {
            code = (code - 55296) * 1024 + (str2.charCodeAt(++i) - 56320) + 65536;
            if (code > 1114111) {
              throw new Error("Unicode standard supports code points up to U+10FFFF");
            }
            buf8[bufLen++] = (code >>> 18) + 240;
            buf8[bufLen++] = code >>> 12 & 63 | 128;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          }
          if (bufLen >= 64) {
            this._dataLength += 64;
            Md55._md5cycle(this._state, buf32);
            bufLen -= 64;
            buf32[0] = buf32[16];
          }
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.appendAsciiStr = function(str2) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var i;
        var j = 0;
        for (; ; ) {
          i = Math.min(str2.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = str2.charCodeAt(j++);
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md55._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.appendByteArray = function(input) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var i;
        var j = 0;
        for (; ; ) {
          i = Math.min(input.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = input[j++];
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md55._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.getState = function() {
        var self2 = this;
        var s = self2._state;
        return {
          buffer: String.fromCharCode.apply(null, self2._buffer8),
          buflen: self2._bufferLength,
          length: self2._dataLength,
          state: [s[0], s[1], s[2], s[3]]
        };
      };
      Md55.prototype.setState = function(state) {
        var buf = state.buffer;
        var x = state.state;
        var s = this._state;
        var i;
        this._dataLength = state.length;
        this._bufferLength = state.buflen;
        s[0] = x[0];
        s[1] = x[1];
        s[2] = x[2];
        s[3] = x[3];
        for (i = 0; i < buf.length; i += 1) {
          this._buffer8[i] = buf.charCodeAt(i);
        }
      };
      Md55.prototype.end = function(raw) {
        if (raw === void 0) {
          raw = false;
        }
        var bufLen = this._bufferLength;
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var i = (bufLen >> 2) + 1;
        var dataBitsLen;
        this._dataLength += bufLen;
        buf8[bufLen] = 128;
        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
        buf32.set(Md55.buffer32Identity.subarray(i), i);
        if (bufLen > 55) {
          Md55._md5cycle(this._state, buf32);
          buf32.set(Md55.buffer32Identity);
        }
        dataBitsLen = this._dataLength * 8;
        if (dataBitsLen <= 4294967295) {
          buf32[14] = dataBitsLen;
        } else {
          var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
          if (matches === null) {
            return;
          }
          var lo = parseInt(matches[2], 16);
          var hi = parseInt(matches[1], 16) || 0;
          buf32[14] = lo;
          buf32[15] = hi;
        }
        Md55._md5cycle(this._state, buf32);
        return raw ? this._state : Md55._hex(this._state);
      };
      Md55.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
      Md55.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Md55.hexChars = "0123456789abcdef";
      Md55.hexOut = [];
      Md55.onePassHasher = new Md55();
      return Md55;
    }();
    exports.Md5 = Md54;
    if (Md54.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
      console.error("Md5 self test failed.");
    }
  }
});

// server/src/runtime/errors/antlersError.ts
var import_ts_md5, AntlersError;
var init_antlersError = __esm({
  "server/src/runtime/errors/antlersError.ts"() {
    "use strict";
    import_ts_md5 = __toESM(require_md5());
    AntlersError = class {
      constructor() {
        this.node = null;
        this.errorCode = "";
        this.message = "";
        this.level = 0 /* Error */;
        this.range = null;
        this.actions = [];
        this.lsRange = null;
        this.data = null;
      }
      hash() {
        var _a, _b, _c, _d;
        let positionSlug = "";
        if (this.node != null) {
          positionSlug = ((_b = (_a = this.node.endPosition) == null ? void 0 : _a.offset) != null ? _b : 0).toString() + "|" + ((_d = (_c = this.node.startPosition) == null ? void 0 : _c.offset) != null ? _d : 0).toString() + "|";
        }
        return import_ts_md5.Md5.hashStr(positionSlug + "|" + this.errorCode);
      }
      static makeSyntaxError(errorCode, node, message, level) {
        if (level == null) {
          level = 0 /* Error */;
        }
        const error = new AntlersError();
        error.errorCode = errorCode;
        error.node = node;
        error.message = message;
        error.level = level;
        return error;
      }
    };
  }
});

// server/src/runtime/errors/antlersErrorCodes.ts
var AntlersErrorCodes;
var init_antlersErrorCodes = __esm({
  "server/src/runtime/errors/antlersErrorCodes.ts"() {
    "use strict";
    AntlersErrorCodes = class {
    };
    AntlersErrorCodes.TYPE_EXPECTING_OPERAND = "ANTLR_001";
    AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT = "ANTLR_002";
    AntlersErrorCodes.TYPE_RUNTIME_TYPE_MISMATCH = "ANTLR_003";
    AntlersErrorCodes.TYPE_RUNTIME_DIVIDE_BY_ZERO = "ANTLR_004";
    AntlersErrorCodes.TYPE_RUNTIME_UNKNOWN_LANG_OPERATOR = "ANTLR_005";
    AntlersErrorCodes.TYPE_RUNTIME_UNEXPECTED_STACK_CONDITION = "ANTLR_006";
    AntlersErrorCodes.TYPE_RUNTIME_PARSE_VALUE_VIOLATION = "ANTLR_007";
    AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL = "ANTLR_008";
    AntlersErrorCodes.TYPE_PARSE_EMPTY_CONDITIONAL = "ANTLR_009";
    AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL = "ANTLR_008";
    AntlersErrorCodes.TYPE_ILLEGAL_STRING_ESCAPE_SEQUENCE = "ANTLR_009";
    AntlersErrorCodes.TYPE_INCOMPLETE_ANTLERS_REGION = "ANTLR_010";
    AntlersErrorCodes.TYPE_INCOMPLETE_ANTELRS_COMMENT_REGION = "ANTLR_011";
    AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_RIGHT = "ANTLR_012";
    AntlersErrorCodes.TYPE_ILLEGAL_DOTVARPATH_RIGHT = "ANTLR_013";
    AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SUBPATH_START = "ANTLR_014";
    AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SPACE_RIGHT = "ANTLR_015";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_VARPATH_ACCESSOR = "ANTLR_016";
    AntlersErrorCodes.TYPE_ILLEGAL_VARIABLE_NAME = "ANTLR_017";
    AntlersErrorCodes.TYPE_UNSET_MODIFIER_DETAILS = "ANTLR_018";
    AntlersErrorCodes.TYPE_MODIFIER_NAME_NOT_START_OF_DETAILS = "ANTLR_019";
    AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_VALUE = "ANTLR_020";
    AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_END_OF_VALUE_LIST = "ANTLR_021";
    AntlersErrorCodes.TYPE_TERNARY_EXPECTING_BRANCH_SEPARATOR = "ANTLR_022";
    AntlersErrorCodes.TYPE_TERNARY_UNEXPECTED_EXPRESSION_LENGTH = "ANTLR_023";
    AntlersErrorCodes.TYPE_RECURSIVE_UNPAIRED_NODE = "ANTLR_024";
    AntlersErrorCodes.TYPE_RECURSIVE_NODE_INVALID_POSITION = "ANTLR_025";
    AntlersErrorCodes.TYPE_NO_PARSE_UNASSOCIATED = "ANTLR_026";
    AntlersErrorCodes.TYPE_RECURSIVE_NODE_UNASSOCIATED_PARENT = "ANTLR_027";
    AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_END = "ANTLR_028";
    AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_START = "ANTLR_029";
    AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR = "ANTLR_030";
    AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR_FOR_VARCOMBINE = "ANTLR_031";
    AntlersErrorCodes.TYPE_UNEXPECTED_MODIFIER_SEPARATOR = "ANTLR_032";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_DETAILS = "ANTLR_033";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_VALUE = "ANTLR_034";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NODE_PARAMETER = "ANTLR_035";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_MANIFESTING_ANTLERS_NODE = "ANTLR_036";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_REDUCING_NEGATION_OPERATORS = "ANTLR_037";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_SEMANTIC_GROUP = "ANTLR_038";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NULL_COALESCENCE_GROUP = "ANTLR_039";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP = "ANTLR_040";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP_FALSE_BRANCH = "ANTLR_041";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_EXITING_TERNARY_GROUP = "ANTLR_042";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_NEGATION_OFFSET = "ANTLR_043";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END_DUE_TO_NEGATION = "ANTLR_044";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END = "ANTLR_045";
    AntlersErrorCodes.TYPE_RUNTIME_UNKNOWN_LIBRARY = "ANTLR_046";
    AntlersErrorCodes.TYPE_RUNTIME_LIBRARY_BAD_METHOD_CALL = "ANTLR_047";
    AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_WHILE_CREATING_GROUPS = "ANTLR_048";
    AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_OPERAND = "ANTLR_049";
    AntlersErrorCodes.TYPE_UNEXPECTED_LOGIC_NEGATION_OPERATOR = "ANTLR_050";
    AntlersErrorCodes.TYPE_FACTORIAL_MATERIALIZED_BOOL_DETECTED = "ANTLR_051";
    AntlersErrorCodes.TYPE_ARG_UNEXPECTED_NAMED_ARGUMENT = "ANTLR_052";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_BRANCH_GROUP = "ANTLR_053";
    AntlersErrorCodes.TYPE_UNEXPECTED_UNNAMED_METHOD_ARGUMENT = "ANTLR_054";
    AntlersErrorCodes.TYPE_LIBRARY_CALL_NO_ARGS_PROVIDED = "ANTLR_055";
    AntlersErrorCodes.TYPE_LIBRARY_CALL_MISSING_REQUIRED_FORMAL_ARG = "ANTLR_056";
    AntlersErrorCodes.TYPE_LIBRARY_CALL_RUNTIME_TYPE_MISMATCH = "ANTLR_057";
    AntlersErrorCodes.TYPE_LIBRARY_CALL_UNEXPECTED_ARG_RESOLVE_FAULT = "ANTLR_058";
    AntlersErrorCodes.TYPE_LIBRARY_CALL_TOO_MANY_ARGUMENTS = "ANTLR_059";
    AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_WHILE_PARSING_METHOD = "ANTLR_060";
    AntlersErrorCodes.TYPE_INVALID_NAMED_ARG_IDENTIFIER = "ANTLR_061";
    AntlersErrorCodes.TYPE_LIBRARY_CALL_INVALID_ARGUMENT_NAME = "ANTLR_062";
    AntlersErrorCodes.TYPE_RUNTIME_ATTEMPT_TO_OVERWRITE_LOADED_LIBRARY = "ANTLR_063";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_ARG_GROUP = "ANTLR_064";
    AntlersErrorCodes.TYPE_EXPECTING_ARGUMENT_GROUP = "ANTLR_065";
    AntlersErrorCodes.TYPE_RUNTIME_PROTECTED_LIBRARY_ACCESS_VIOLATION = "ANTLR_066";
    AntlersErrorCodes.TYPE_RUNTIME_FATAL_UNPAIRED_LOOP_END = "ANTLR_067";
    AntlersErrorCodes.TYPE_UNEXPECTED_OPERATOR = "ANTLR_068";
    AntlersErrorCodes.TYPE_OPERATOR_INVALID_ON_RIGHT = "ANTLR_069";
    AntlersErrorCodes.TYPE_INVALID_ASSIGNMENT_LOOP_PAIR = "ANTLR_070";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_ORDER_GROUP = "ANTLR_071";
    AntlersErrorCodes.TYPE_EXPECTING_ORDER_GROUP_FOR_ORDER_BY_OPERAND = "ANTLR_072";
    AntlersErrorCodes.TYPE_QUERY_UNSUPPORTED_VALUE_TYPE = "ANTLR_073";
    AntlersErrorCodes.TYPE_UNEXPECTED_RUNTIME_RESULT_FOR_ORDER_BY_CLAUSE = "ANTLR_074";
    AntlersErrorCodes.TYPE_UNEXPECTED_EMPTY_DIRECTION_GROUP = "ANTLR_075";
    AntlersErrorCodes.TYPE_INVALID_ORDER_BY_NAME_VALUE = "ANTLR_076";
    AntlersErrorCodes.TYPE_INVALID_ORDER_BY_SORT_VALUE = "ANTLR_077";
    AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_GROUP_BY = "ANTLR_78";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_GROUP_BY = "ANTLR_079";
    AntlersErrorCodes.TYPE_UNEXPECTED_GROUP_BY_AS_ALIAS_TYPE = "ANTLR_080";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_SWITCH_GROUP = "ANTLR_081";
    AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_SWITCH_GROUP = "ANTLR_082";
    AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE = "ANTLR_083";
    AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE = "ANTLR_084";
    AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_SEMANTIC_VALUE = "ANTLR_085";
    AntlersErrorCodes.TYPE_SWITCH_DEFAULT_MUST_BE_LAST = "ANTLR_086";
    AntlersErrorCodes.TYPE_PARSER_INVALID_SWITCH_TOKEN = "ANTLR_087";
    AntlersErrorCodes.TYPE_ORDER_BY_INVALID_RETURN_TYPE = "ANTLR_088";
    AntlersErrorCodes.TYPE_GROUP_BY_SCOPED_GROUP_MUST_BE_ENCLOSED = "ANTLR_089";
    AntlersErrorCodes.TYPE_PLUCK_INTO_MISSING_VARIABLE_TARGET = "ANTLR_090";
    AntlersErrorCodes.TYPE_PLUCK_INTO_INVALID_VARIABLE_TARGET = "ANTLR_091";
    AntlersErrorCodes.TYPE_PLUCK_INTO_NO_PREDICATE = "ANTLR_092";
    AntlersErrorCodes.TYPE_PLUCK_INTO_INVALID_PREDICATE_VALUE = "ANTLR_093";
    AntlersErrorCodes.TYPE_PLUCK_INTO_EMPTY_LOGIC_GROUP = "ANTLR_094";
    AntlersErrorCodes.TYPE_PLUCK_INTO_INVALID_NUMBER_OF_TUPLE_VARIABLES = "ANTLR_095";
    AntlersErrorCodes.TYPE_PLUCK_INTO_UNKNOWN_ALIAS_VARNAME = "ANTLR_096";
    AntlersErrorCodes.TYPE_PLUCK_INTO_UNEXPECTED_EMPTY_T_LOGIC_GROUP = "ANTLR_097";
    AntlersErrorCodes.TYPE_PLUCK_INTO_REFERENCE_TYPE_DYNAMIC = "ANTLR_098";
    AntlersErrorCodes.TYPE_PLUCK_INTO_REFERENCE_AMBIGUOUS = "ANTLR_099";
    AntlersErrorCodes.TYPE_RUNTIME_ASSIGNMENT_TO_NON_VAR = "ANTLR_100";
    AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_TARGET = "ANTLR_101";
    AntlersErrorCodes.TYPE_ARR_MAKE_UNEXPECTED_TYPE = "ANTLR_102";
    AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_ARR_KEY_PAIR_VALUE = "ANTLR_103";
    AntlersErrorCodes.TYPE_ARR_KEY_PAIR_INVALID_KEY_TYPE = "ANTLR_104";
    AntlersErrorCodes.TYPE_ARR_UNEXPECT_ARG_SEPARATOR = "ANTLR_105";
    AntlersErrorCodes.TYPE_ARR_KEY_PAIR_MISSING_KEY = "ANTLR_106";
    AntlersErrorCodes.RUNTIME_PROTECTED_VAR_ACCESS = "ANTLR_107";
    AntlersErrorCodes.RUNTIME_PROTECTED_TAG_ACCESS = "ANTLR_108";
    AntlersErrorCodes.RUNTIME_PROTECTED_MODIFIER_ACCESS = "ANTLR_109";
    AntlersErrorCodes.TYPE_INCOMPLETE_PHP_EVALUATION_REGION = "ANTLR_110";
    AntlersErrorCodes.RUNTIME_PHP_NODE_WHEN_PHP_DISABLED = "ANTLR_111";
    AntlersErrorCodes.RUNTIME_PHP_NODE_USER_CONTENT_TAG = "ANTLR_112";
    AntlersErrorCodes.TYPE_UNEXPECTED_TYPE_FOR_TUPLE_LIST = "ANTLR_113";
    AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_TUPLE_LIST = "ANTLR_114";
    AntlersErrorCodes.TYPE_MISSING_BODY_TUPLE_LIST = "ANTLR_115";
    AntlersErrorCodes.TYPE_MISSING_NAMES_TUPLE_LIST = "ANTLR_116";
    AntlersErrorCodes.TYPE_VALUE_NAME_LENGTH_MISMATCH_TUPLE_LIST = "ANTLR_117";
    AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_NAME_TYPE = "ANTLR_118";
    AntlersErrorCodes.TYPE_INVALID_MANIFESTED_NAME_GROUP = "ANTLR_119";
    AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE_GROUP = "ANTLR_120";
    AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE = "ANTLR_121";
    AntlersErrorCodes.TYPE_RUNTIME_BAD_METHOD_CALL = "ANTLR_122";
    AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_ARG_GROUP = "ANTLR_123";
    AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP = "ANTLR_124";
    AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_METHOD = "ANTLR_125";
    AntlersErrorCodes.TYPE_MODIFIER_NOT_FOUND = "ANTLR_126";
    AntlersErrorCodes.TYPE_RUNTIME_GENERAL_FAULT = "ANTLR_127";
    AntlersErrorCodes.TYPE_MODIFIER_INCORRECT_VALUE_POSITION = "ANTLR_128";
    AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_TOKEN_METHOD_SYNTAX = "ANTLR_129";
    AntlersErrorCodes.TYPE_RUNTIME_ATTEMPTING_TO_RENDER_OBJECT_AS_STRING = "ANTLR_130";
    AntlersErrorCodes.TYPE_UNPAIRED_CLOSING_TAG = "ANTLR_131";
    AntlersErrorCodes.PARSER_CANNOT_PARSE_PATH_RECURSIVE = "ANTLR_200";
    AntlersErrorCodes.PATH_STRING_NOT_INSIDE_ARRAY_ACCESSOR = "ANTLR_201";
    AntlersErrorCodes.LINT_UNKNOWN_PARAMETER = "ANTLR_500";
    AntlersErrorCodes.LINT_GENERAL_INVALID_PARAMETER_CONTENTS = "ANTLR_501";
    AntlersErrorCodes.LINT_PARAMETER_CONTENT_INVALID_INTEGER = "ANTLR_502";
    AntlersErrorCodes.LINT_PARAMETER_CONTENT_INVALID_BOOLEAN = "ANT LR_503";
    AntlersErrorCodes.LINT_PAGINATE_INVALID_VALUE = "ANTLR_504";
    AntlersErrorCodes.LINT_DEBUG_DATA_EXPOSED = "ANTLR_505";
    AntlersErrorCodes.LINT_DOUBLE_COLON_IN_TAG_IDENTIFIER = "ANTLR_506";
    AntlersErrorCodes.LINT_MIXED_MODIFIERS = "ANTLR_507";
    AntlersErrorCodes.LINT_MODIFIER_UNEXPECTED_TYPE = "ANTLR_508";
    AntlersErrorCodes.LINT_REMOVE_RELATE_TAG = "ANTLR_509";
    AntlersErrorCodes.LINT_SET_PRODUCES_RUNTIME_ERROR = "ANTLR_510";
    AntlersErrorCodes.LINT_FRONT_MATTER_EMPTY_DOCUMENT = "ANTLR_511";
    AntlersErrorCodes.LINT_SHORTHAND_MODIFIER_TAG_MUST_MATCH = "ANTLR_512";
    AntlersErrorCodes.LINT_INVALID_FRONT_MATTER = "ANTLR_513";
    AntlersErrorCodes.LINT_DUPLICATE_CODE = "ANTLR_514";
    AntlersErrorCodes.LINT_VERSION_NOT_COMPATIBLE = "ANTLR_515";
    AntlersErrorCodes.LINT_INTERLEAVED_TAG_PAIRS = "ANTLR_516";
    AntlersErrorCodes.LINT_MISSING_REQUIRED_PARAMETER = "ANTLR_517";
    AntlersErrorCodes.LINT_POSSIBLE_PARTIAL_RECURSION = "ANTLR_518";
    AntlersErrorCodes.LINT_URL_VARIABLE_WITHOUT_SANITIZE = "ANTLR_519";
    AntlersErrorCodes.LINT_DYNAMIC_CLASS_NAMES_POSSIBLE_PURGE = "ANTLER_520";
    AntlersErrorCodes.LINT_DEPRECATED_MODIFIER = "ANTLER_521";
    AntlersErrorCodes.LINT_INVALID_VARIABLE_ACCESS = "ANTLR_522";
    AntlersErrorCodes.LINT_SELECT_FIELD_JOIN_RAW = "ANTLR_523";
    AntlersErrorCodes.LINT_INVALID_PARAMETER_VALUE_DELIMITER = "ANTLR_524";
    AntlersErrorCodes.LINT_MODIFIERS_ON_QUERY_BUILDERS_REQUIRE_AS = "ANTLR_525";
  }
});

// server/src/runtime/utilities/nodeHelpers.ts
var NodeHelpers;
var init_nodeHelpers = __esm({
  "server/src/runtime/utilities/nodeHelpers.ts"() {
    "use strict";
    init_abstractNode();
    init_stringUtilities();
    NodeHelpers = class {
      static distance(left, right) {
        if (left.endPosition == null || right.startPosition == null) {
          return this.DistMax;
        }
        return right.startPosition.index - left.endPosition.index;
      }
      static getTrueName(node) {
        var _a, _b, _c, _d;
        if (node.originalNode != null) {
          return (_b = (_a = node.originalNode.name) == null ? void 0 : _a.name) != null ? _b : "";
        }
        return (_d = (_c = node.name) == null ? void 0 : _c.name) != null ? _d : "";
      }
      static getSimpleVarName(variableNode) {
        if (variableNode.variableReference != null && variableNode.variableReference.pathParts.length == 1) {
          if (variableNode.variableReference.pathParts[0] instanceof PathNode) {
            return variableNode.variableReference.pathParts[0].name;
          }
        }
        return "";
      }
      static isVariableMatching(node, path) {
        if (node instanceof VariableNode) {
          return node.name == path;
        }
        return false;
      }
      static mergeVarContentLeft(content, referenceNode, target) {
        target.mergeRefName = target.name;
        target.endPosition = referenceNode.endPosition;
        target.name = target.name + content;
        return target;
      }
      static mergeVarContentRight(content, referenceNode, target) {
        target.mergeRefName = target.name;
        target.startPosition = referenceNode.startPosition;
        target.name = content + target.name;
        return target;
      }
      static mergeVarRight(left, right) {
        right.mergeRefName = right.name;
        right.startPosition = left.startPosition;
        right.name = left.name + right.name;
        return right;
      }
      static getUnrefName(text) {
        return StringUtilities.trimLeft(text, ":.");
      }
    };
    NodeHelpers.DistMax = 65e3;
  }
});

// server/src/runtime/analyzers/conditionPairAnalyzer.ts
var _ConditionPairAnalyzer, ConditionPairAnalyzer;
var init_conditionPairAnalyzer = __esm({
  "server/src/runtime/analyzers/conditionPairAnalyzer.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_abstractNode();
    init_nodeHelpers();
    _ConditionPairAnalyzer = class {
      static isConditionalStructure(node) {
        var _a, _b;
        if (node.isComment) {
          return false;
        }
        const name = (_b = (_a = node.name) == null ? void 0 : _a.name) != null ? _b : "";
        if (name == "if" || name == "elseif" || name == "else") {
          return true;
        }
        return false;
      }
      static requiresClose(node) {
        var _a, _b;
        const name = (_b = (_a = node.name) == null ? void 0 : _a.name) != null ? _b : "";
        if (name == "elseif" || name == "else") {
          if (node.isClosedBy != null) {
            return false;
          }
          return true;
        }
        if (node.isClosingTag) {
          return false;
        }
        if (node.isClosedBy != null) {
          return false;
        }
        return true;
      }
      static getValidClosingPairs(current) {
        if (current == "if" || current == "elseif") {
          return _ConditionPairAnalyzer.conditionClosingPairs;
        }
        return [];
      }
      static findClosestStructurePair(nodes, node, index) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const stack = [], nodeLen = nodes.length, conditionCloseIndex = /* @__PURE__ */ new Map();
        let lastCloseIndex = null;
        stack.push({
          node,
          index
        });
        for (let i = 0; i < nodeLen; i += 1) {
          const node2 = nodes[i];
          if (node2 instanceof AntlersNode) {
            const name = (_b = (_a = node2.name) == null ? void 0 : _a.name) != null ? _b : "";
            if (node2.isClosingTag && name == "if") {
              conditionCloseIndex.set(i, i);
              continue;
            } else {
              if (name == "elseif" || name == "else") {
                conditionCloseIndex.set(i, i);
                continue;
              }
            }
          }
        }
        const conditionIndexLength = conditionCloseIndex.size;
        while (stack.length > 0) {
          const curItem = stack.pop();
          if (curItem == null) {
            continue;
          }
          if (curItem.node._conditionParserAbandonPairing) {
            break;
          }
          const curNode = curItem.node, thisValidPairs = _ConditionPairAnalyzer.getValidClosingPairs((_d = (_c = curNode.name) == null ? void 0 : _c.name) != null ? _d : "");
          let curIndex = curItem.index, doSkipValidation = false;
          if (conditionIndexLength > 50 && lastCloseIndex != null) {
            for (const [cIndex, n] of conditionCloseIndex) {
              if (cIndex > curIndex) {
                curIndex = cIndex;
                break;
              }
            }
          }
          for (let i = curIndex; i < nodeLen; i++) {
            const subNode = nodes[i];
            if (subNode instanceof AntlersNode) {
              if (_ConditionPairAnalyzer.isConditionalStructure(subNode)) {
                if (_ConditionPairAnalyzer.requiresClose(subNode)) {
                  stack.push(curItem);
                  stack.push({
                    node: subNode,
                    index: i + 1
                  });
                  doSkipValidation = true;
                  break;
                }
                if (curNode.isClosedBy != null) {
                  continue;
                }
                const subNodeName = (_f = (_e = subNode.name) == null ? void 0 : _e.name) != null ? _f : "";
                let canClose = false;
                if (subNode.ref == 0 && (subNode.isClosingTag && subNodeName == "if" || thisValidPairs.includes(subNodeName))) {
                  canClose = true;
                }
                if (subNode.refId == curNode.refId) {
                  canClose = false;
                }
                if (canClose) {
                  lastCloseIndex = i;
                  conditionCloseIndex.delete(i);
                  curNode.isClosedBy = subNode;
                  subNode.isOpenedBy = curNode;
                  subNode.ref += 1;
                  doSkipValidation = true;
                  break;
                }
              }
            }
          }
          if (!doSkipValidation) {
            if (curNode instanceof AntlersNode) {
              const nodeName = (_h = (_g = curNode.name) == null ? void 0 : _g.name) != null ? _h : "";
              if ((nodeName == "elseif" || nodeName == "else") && curNode.isOpenedBy == null) {
                let baseMessage = 'Unpaired "' + NodeHelpers.getTrueName(curNode) + '" control structure.';
                if (curNode.isInterpolationNode) {
                  baseMessage += " Tag pairs are not supported within Antlers tags.";
                }
                curNode.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL,
                  curNode,
                  baseMessage
                ));
                curNode._conditionParserAbandonPairing = true;
              }
              if (curNode.isClosedBy == null && _ConditionPairAnalyzer.requiresClose(curNode)) {
                let baseMessage = 'Unclosed "' + NodeHelpers.getTrueName(curNode) + '" control structure.';
                if (curNode.isInterpolationNode) {
                  baseMessage += " Tag pairs are not supported within Antlers tags.";
                }
                curNode.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL,
                  curNode,
                  baseMessage
                ));
                curNode._conditionParserAbandonPairing = true;
              }
            }
          }
        }
      }
      static pairConditionals(nodes) {
        for (let i = 0; i < nodes.length; i += 1) {
          const node = nodes[i];
          if (node instanceof AntlersNode && _ConditionPairAnalyzer.isConditionalStructure(node)) {
            if (_ConditionPairAnalyzer.requiresClose(node)) {
              _ConditionPairAnalyzer.findClosestStructurePair(nodes, node, i + 1);
            }
          }
        }
        nodes.forEach((node) => {
          var _a, _b;
          if (node instanceof AntlersNode && _ConditionPairAnalyzer.isConditionalStructure(node)) {
            const name = (_b = (_a = node.name) == null ? void 0 : _a.name) != null ? _b : "";
            if ((name == "elseif" || name == "else") && node.isOpenedBy == null) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL,
                node,
                'Unpaired "' + NodeHelpers.getTrueName(node) + '" control structure.'
              ));
              return;
            }
            if (node.isClosedBy == null && _ConditionPairAnalyzer.requiresClose(node)) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL,
                node,
                "Unclosed " + NodeHelpers.getTrueName(node) + " control structure."
              ));
              return;
            }
          }
        });
        return nodes;
      }
    };
    ConditionPairAnalyzer = _ConditionPairAnalyzer;
    ConditionPairAnalyzer.conditionClosingPairs = ["elseif", "else"];
  }
});

// server/src/utils/strings.ts
function trimLeft(value, charList) {
  if (charList == null) {
    charList = "s";
  }
  return value.replace(new RegExp("^[" + charList + "]+"), "");
}
function replaceAllInString(value, oldString, newString) {
  return value.replace(new RegExp(oldString, "g"), newString);
}
function trimRight(value, charList) {
  if (charList == null) {
    charList = "s";
  }
  return value.replace(new RegExp("[" + charList + "]+$"), "");
}
var init_strings = __esm({
  "server/src/utils/strings.ts"() {
    "use strict";
  }
});

// server/src/utils/simpleIds.ts
function getId() {
  return (Date.now().toString(32) + Math.random().toString(16)).replace(/\./g, "");
}
var init_simpleIds = __esm({
  "server/src/utils/simpleIds.ts"() {
    "use strict";
  }
});

// server/src/runtime/nodes/abstractNode.ts
function newRefId() {
  return replaceAllInString(getId(), "-", "_");
}
function cleanNodes(nodes) {
  const cleaned = [], ids = [];
  for (let i = 0; i < nodes.length; i++) {
    const child = nodes[i], refId = child.refId;
    if (ids.includes(refId)) {
      break;
    }
    cleaned.push(child);
    ids.push(refId);
  }
  return cleaned;
}
var FragmentNode, FragmentParameterNode, AbstractNode5, ExecutionBranch, ConditionNode, AntlersNode, ParserFailNode, AntlersParserFailNode, RecursiveNode, PhpExecutionNode, CommentParserFailNode, PhpParserFailNode, EscapedContentNode, ParameterNode2, ModifierChainNode, ModifierNode, ValueDirectionNode, ModifierParameterNode, FalseConstant, NullConstant, TrueConstant, AdditionOperator, DivisionOperator, ExponentiationOperator, FactorialOperator, ModulusOperator, MultiplicationOperator, SubtractionOperator, AdditionAssignmentOperator, DivisionAssignmentOperator, LeftAssignmentOperator, ModulusAssignmentOperator, MultiplicationAssignmentOperator, SubtractionAssignmentOperator, EqualCompOperator, GreaterThanCompOperator, GreaterThanEqualCompOperator, LessThanCompOperator, LessThanEqualCompOperator, NotEqualCompOperator, NotStrictEqualCompOperator, SpaceshipCompOperator, StrictEqualCompOperator, ConditionalVariableFallbackOperator, LanguageOperatorConstruct, StatementSeparatorNode, DirectionGroup, InlineBranchSeparator, ModifierSeparator, NullCoalescenceGroup, ModifierValueSeparator, InlineTernarySeparator, LogicalAndOperator, LogicalNegationOperator, LogicalOrOperator, LogicalXorOperator, NullCoalesceOperator, ScopeAssignmentOperator, StringConcatenationOperator, LogicGroupEnd, LogicGroupBegin, ListValueNode, LogicGroup, SwitchCase, SwitchGroup, ConditionalFallbackGroup, ArrayNode, TernaryCondition, ArgSeparator, SemanticGroup, ScopedLogicGroup, AliasedScopeLogicGroup, ArgumentGroup, TupleListStart, TupleList, LibraryInvocationConstruct, LiteralNode, MethodInvocationNode, ModifierNameNode, ModifierValueNode, NamedArgumentNode, NameValueNode, NumberNode, StringValueNode, VariableNode, AccessorNode, PathNode, VariableReference, StaticTracedAssignment;
var init_abstractNode = __esm({
  "server/src/runtime/nodes/abstractNode.ts"() {
    "use strict";
    init_position();
    init_documentRange();
    init_nodeVirtualModifiers();
    init_nodeFilters();
    init_stringUtilities();
    init_nodeVirtualHierarchy();
    init_conditionPairAnalyzer();
    init_strings();
    init_simpleIds();
    FragmentNode = class {
      constructor() {
        this.startPosition = null;
        this.endPosition = null;
        this.index = 0;
        this.embeddedIndex = 0;
        this.refId = null;
        this.parameters = [];
        this.isSelfClosing = false;
        this.isClosingFragment = false;
        this.name = "";
        this.containsStructures = false;
        this.refId = newRefId();
      }
    };
    FragmentParameterNode = class {
      constructor() {
        this.startPosition = null;
        this.endPosition = null;
        this.content = "";
        this.name = "";
      }
    };
    AbstractNode5 = class {
      constructor() {
        this.refId = null;
        this.index = 0;
        this.parent = null;
        this.content = "";
        this.rawLexContent = "";
        this.sourceContent = "";
        this.startPosition = null;
        this.endPosition = null;
        this.modifierChain = null;
        this.originalAbstractNode = null;
        this.positionContexts = [];
        this.addedContexts = /* @__PURE__ */ new Map();
        this.fragment = null;
        this.fragmentParameter = null;
        this.fragmentPosition = 3 /* Unresolved */;
        this.containsAnyFragments = false;
        this.containsChildStructures = false;
        this.isInScriptTag = false;
        this.isInStyleTag = false;
        this.isVirtual = true;
        this.isPartOfMethodChain = false;
        this.isVirtualGroupMember = false;
        this.isVirtualGroupOperatorResolve = false;
        this.isSwitchGroupMember = false;
        this.isListGroupMember = false;
        this.producesVirtualStatementTerminator = false;
        this.convertedToOperator = false;
        this.scopeVariable = null;
        this.currentScope = null;
        this.manifestType = "";
        this.scopeName = null;
        this.sourceType = "";
        this.runtimeType = null;
        this.modifiers = new NodeVirtualModifiers(this);
        this.prev = null;
        this.next = null;
        this.methodTarget = null;
        this.libraryTarget = null;
        this.antlersErrors = [];
        this.parser = null;
        this.refId = newRefId();
      }
      isEmbedded() {
        return this.isInScriptTag || this.isInStyleTag;
      }
      getContexts() {
        return this.positionContexts;
      }
      addContext(context) {
        if (this.addedContexts.has(context.refId) == false) {
          this.addedContexts.set(context.refId, true);
          this.positionContexts.push(context);
        }
      }
      getRange() {
        if (this.originalAbstractNode != null) {
          return this.originalAbstractNode.getRange();
        }
        if (this.startPosition == null || this.endPosition == null) {
          return DocumentRange.Empty;
        }
        const range = new DocumentRange();
        range.start = this.startPosition;
        range.end = this.endPosition;
        return range;
      }
      withParser(parser) {
        this.parser = parser;
      }
      getParser() {
        return this.parser;
      }
      pushError(error) {
        if (this.parent != null) {
          this.parent.pushError(error);
        }
        this.antlersErrors.push(error);
        if (this.parent == null) {
          if (this.parser != null) {
            this.parser.pushError(error);
          }
        }
      }
      mergeErrors(errors) {
        errors.forEach((error) => {
          if (error.node == null) {
            error.node = this;
          }
          this.antlersErrors.push(error);
        });
      }
      getErrors() {
        return this.antlersErrors;
      }
      innerContent() {
        return this.content;
      }
      rawContent() {
        return this.content;
      }
    };
    ExecutionBranch = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.head = null;
        this.tail = null;
        this.nodes = [];
        this.documentText = "";
        this.childDocument = null;
      }
      getImmediateChildren() {
        if (this.head == null) {
          return [];
        }
        return this.head.getImmediateChildren();
      }
    };
    ConditionNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.logicBranches = [];
        this.chain = [];
        this.nodeContent = "";
        this.fragment = null;
        this.fragmentParameter = null;
        this.fragmentPosition = 3 /* Unresolved */;
        this.containsAnyFragments = false;
        this.containsChildStructures = false;
      }
    };
    AntlersNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.isNodeAbanonded = false;
        this.isComment = false;
        this.isTagNode = false;
        this.isConditionNode = false;
        this.runtimeContent = "";
        this.name = null;
        this.pathReference = null;
        this.isClosingTag = false;
        this.isInterpolationNode = false;
        this.isOpenedBy = null;
        this.isClosedBy = null;
        this.isSelfClosing = false;
        this.children = [];
        this.runtimeNodes = [];
        this.parsedRuntimeNodes = [];
        this.hasParsedRuntimeNodes = false;
        this.parameters = [];
        this.hasParameters = false;
        this.contentOffset = null;
        this.cachedContent = null;
        this.cachedInnerContent = null;
        this.hasRecursiveNode = false;
        this.recursiveReference = null;
        this.rawStart = "";
        this.rawEnd = "";
        this.originalNode = null;
        this.interpolationRegions = /* @__PURE__ */ new Map();
        this.processedInterpolationRegions = /* @__PURE__ */ new Map();
        this.hasProcessedInterpolationRegions = false;
        this.ref = 0;
        this.contentStartRelativeIndex = null;
        this.antlersNodeIndex = 0;
        this.nameStartsOn = null;
        this.nameEndsOn = null;
        this.nameMethodPartStartsOn = null;
        this.documentText = "";
        this.nodeContent = "";
        this.childDocument = null;
        this.structure = new NodeVirtualHierarchy(this);
        this.isInlineAntlers = false;
        this.mustClose = false;
        this.reference = null;
        this._conditionParserAbandonPairing = false;
        this._isEndVirtual = false;
      }
      getOriginalContent() {
        if (this.startPosition == null || this.endPosition == null || this.parser == null) {
          return "";
        }
        if (this.isClosedBy != null) {
          if (this.isClosedBy.startPosition == null || this.isClosedBy.endPosition == null) {
            return "";
          }
          return this.parser.getText(
            this.startPosition.index,
            this.isClosedBy.endPosition.index + 1
          );
        }
        return this.parser.getText(
          this.startPosition.index,
          this.endPosition.index + 1
        );
      }
      getNodeDocumentText() {
        if (this.startPosition == null || this.endPosition == null || this.parser == null) {
          return "";
        }
        return this.parser.getText(this.startPosition.index, this.endPosition.index + 1);
      }
      getImmediateChildren() {
        const immediateChildren = [];
        for (let i = 0; i < this.children.length; i++) {
          const node = this.children[i];
          if (node.parent == this) {
            if (node == this.isClosedBy) {
              break;
            }
            immediateChildren.push(node);
          }
        }
        return cleanNodes(immediateChildren);
      }
      getChildren() {
        if (this.isClosedBy == null) {
          return [];
        }
        const newChildren = [];
        for (let i = 0; i < this.children.length; i++) {
          const child = this.children[i];
          if (child instanceof AntlersNode && child.refId == this.isClosedBy.refId) {
            break;
          }
          newChildren.push(child);
        }
        return newChildren;
      }
      getInnerDocumentText() {
        if (this.startPosition == null || this.endPosition == null || this.parser == null) {
          return "";
        }
        if (this.isClosedBy == null) {
          return this.getNodeDocumentText();
        }
        const closeStart = this.isClosedBy.startPosition;
        if (closeStart == null) {
          return "";
        }
        return this.parser.getText(this.endPosition.index + 1, closeStart.index);
      }
      nodeAtIndex(index) {
        if (this.runtimeNodes.length == 0) {
          return null;
        }
        for (let i = 0; i < this.runtimeNodes.length; i++) {
          if (this.runtimeNodes[i].index == index) {
            return this.runtimeNodes[i];
          }
        }
        return null;
      }
      getDepthCount() {
        if (this.parent == null) {
          return 1;
        }
        let parent = this.parent, depth = 1;
        while (parent != null) {
          depth += 1;
          if (parent.parent === parent) {
            parent = null;
            break;
          }
          parent = parent.parent;
        }
        return depth;
      }
      isEmpty() {
        return this.content.trim().length == 0;
      }
      nameMatches(content) {
        if (this.name == null) {
          return false;
        }
        return this.name.content == content;
      }
      copyBasicDetails() {
        return this.copyBasicDetailsTo(new AntlersNode());
      }
      copyBasicDetailsTo(instance) {
        instance.refId = this.refId;
        instance.isComment = this.isComment;
        instance.isTagNode = this.isTagNode;
        instance.children = this.children;
        instance.parent = this.parent;
        instance.parameters = this.parameters;
        instance.isClosingTag = this.isClosingTag;
        instance.rawStart = this.rawStart;
        instance.rawEnd = this.rawEnd;
        instance.startPosition = this.startPosition;
        instance.endPosition = this.endPosition;
        instance.originalAbstractNode = this;
        instance.containsAnyFragments = this.containsAnyFragments;
        instance.containsChildStructures = this.containsChildStructures;
        instance.isInScriptTag = this.isInScriptTag;
        instance.isInStyleTag = this.isInStyleTag;
        return instance;
      }
      id() {
        return this.refId;
      }
      innerContent() {
        if (this.cachedInnerContent == null) {
          this.cachedInnerContent = this.content.replace('"', '\\"');
        }
        return this.cachedInnerContent;
      }
      resetContentCache() {
        this.cachedContent = null;
        this.cachedInnerContent = null;
      }
      hasMethodPart() {
        if (this.name == null) {
          return false;
        }
        const methodPart = this.name.getMethodName();
        if (methodPart != null) {
          return true;
        }
        return false;
      }
      runtimeName() {
        if (this.name == null) {
          return "";
        }
        return this.name.getCompoundTagName();
      }
      getTagName() {
        if (this.name == null) {
          return "";
        }
        return this.name.name;
      }
      getNameContent() {
        if (this.name == null) {
          return "";
        }
        return this.name.content;
      }
      getMethodNameValue() {
        if (this.name == null) {
          return "";
        }
        const methodPart = this.name.getMethodName();
        if (methodPart != null) {
          return methodPart;
        }
        return "";
      }
      methodIsEmptyOrMatches(testValue) {
        return this.getMethodNameValue() == testValue;
      }
      hasParameter(name) {
        const paramMatch = this.findParameter(name);
        return paramMatch != null;
      }
      hasParameterWithValue(name, expectedValue) {
        const paramMatch = this.findParameter(name);
        if (paramMatch == null) {
          return false;
        }
        return paramMatch.value == expectedValue;
      }
      findParameterValue(name, defaultValue) {
        const paramMatch = this.findParameter(name);
        if (paramMatch == null) {
          return defaultValue;
        }
        return paramMatch.value;
      }
      findParameterValueOrNull(name) {
        const paramMatch = this.findParameter(name);
        if (paramMatch == null) {
          return null;
        }
        return paramMatch.value;
      }
      findParameter(name) {
        if (this.parameters.length == 0) {
          return null;
        }
        for (let i = 0; i < this.parameters.length; i++) {
          if (this.parameters[i].name == name) {
            return this.parameters[i];
          }
        }
        return null;
      }
      findAnyParameter(names) {
        for (let i = 0; i < names.length; i++) {
          const tempValue = this.findParameter(names[i]);
          if (tempValue != null) {
            return tempValue;
          }
        }
        return null;
      }
      getContentRelativeStartIndex() {
        if (this.contentStartRelativeIndex == null) {
          const chars = this.content.split("");
          for (let i = 0; i < chars.length; i++) {
            if (!StringUtilities.ctypeSpace(chars[i])) {
              this.contentStartRelativeIndex = i;
              break;
            }
          }
          if (this.contentStartRelativeIndex == null) {
            this.contentStartRelativeIndex = chars.length;
          }
          this.contentStartRelativeIndex += this.rawStart.length;
        }
        return this.contentStartRelativeIndex;
      }
      getContentAfterName() {
        let start = 0;
        if (this.nameEndsOn != null) {
          start = this.nameEndsOn.char - this.rawStart.length - 1;
        }
        return this.content.substring(start);
      }
      getContent() {
        if (this.cachedContent == null) {
          if (this.isComment) {
            this.cachedContent = this.content;
            this.contentOffset = this.startPosition;
          } else {
            if (this.isTagNode) {
              let contentToAnalyze = this.content;
              contentToAnalyze = StringUtilities.trimLeft(contentToAnalyze);
              let compoundNameLen = 0;
              if (this.name != null) {
                compoundNameLen = this.name.compound.length;
              }
              if (this.parameters.length > 0) {
                let startPosIndex = 0;
                const firstParam = this.parameters[0];
                if (firstParam.startPosition != null) {
                  startPosIndex = firstParam.startPosition.index - 1;
                }
                const leadContent = contentToAnalyze, contentWithoutSpace2 = leadContent.trimLeft(), leadingWsCount2 = leadContent.length - contentWithoutSpace2.length, leadNameLen = compoundNameLen;
                contentToAnalyze = contentToAnalyze.substr(0, startPosIndex);
              }
              const contentWithoutSpace = contentToAnalyze.trimLeft(), leadingWsCount = contentToAnalyze.length - contentWithoutSpace.length, leadOffset = compoundNameLen + leadingWsCount + 2;
              if (this.parser != null) {
                let startPosOffset = 0;
                if (this.startPosition != null) {
                  startPosOffset = this.startPosition.offset;
                }
                this.contentOffset == this.parser.positionFromOffset(startPosOffset + leadOffset, 0);
              }
              if (this.name != null) {
                if (this.name.name == "if" || this.name.name == "elseif" || this.name.name == "unless" || this.name.name == "elseunless") {
                  contentToAnalyze = " " + contentToAnalyze.trimLeft();
                  this.cachedContent = contentToAnalyze.substr(
                    this.name.compound.length + 1
                  );
                } else {
                  this.cachedContent = contentToAnalyze;
                }
              } else {
                this.cachedContent = contentToAnalyze;
              }
            } else {
              if (this.parameters.length > 0) {
                const firstParam = this.parameters[0];
                let startPosIndex = 0;
                if (firstParam.startPosition != null) {
                  startPosIndex = firstParam.startPosition.index - 1;
                }
                this.contentOffset = this.startPosition;
                this.cachedContent = this.content.substr(0, startPosIndex);
              } else {
                this.contentOffset = this.startPosition;
                this.cachedContent = this.content;
              }
            }
          }
        }
        return this.cachedContent;
      }
      relativePositionFromOffset(offset, index) {
        var _a, _b;
        if (this.parser == null) {
          return null;
        }
        return this.parser.positionFromOffset(
          ((_b = (_a = this.contentOffset) == null ? void 0 : _a.offset) != null ? _b : 0) + offset,
          index
        );
      }
      getInterpolationNode(varName) {
        if (this.processedInterpolationRegions.has(varName)) {
          const refRegion = this.processedInterpolationRegions.get(
            varName
          );
          if (refRegion.length > 0 && refRegion[0] instanceof AntlersNode) {
            return refRegion[0];
          }
        }
        return null;
      }
      _lexerRelativeOffset(offset, index = null) {
        var _a, _b, _c;
        let indexToUse = offset;
        if (index != null) {
          indexToUse = index;
        }
        if (this.parser == null) {
          const position = new Position();
          position.index = offset;
          position.offset = offset;
          return position;
        }
        let relativeIndex = offset + this.rawStart.length + ((_b = (_a = this.startPosition) == null ? void 0 : _a.index) != null ? _b : 0);
        if (this.isTagNode && this.nameStartsOn != null) {
          relativeIndex = this.nameStartsOn.index + offset;
          if (!ConditionPairAnalyzer.isConditionalStructure(this)) {
            relativeIndex -= this.rawStart.length;
          }
          if (((_c = this.name) == null ? void 0 : _c.name) == "unless") {
            relativeIndex += 6;
          }
        }
        const resolvedOffset = this.parser.positionFromOffset(
          relativeIndex,
          relativeIndex,
          true
        );
        return resolvedOffset;
      }
      relativeOffset(offset, index = null) {
        var _a, _b;
        let indexToUse = offset;
        if (index != null) {
          indexToUse = index;
        }
        if (this.parser == null) {
          const position = new Position();
          position.index = offset;
          position.offset = offset;
          return position;
        }
        const relativeIndex = offset + this.rawStart.length + ((_b = (_a = this.startPosition) == null ? void 0 : _a.index) != null ? _b : 0);
        const resolvedOffset = this.parser.positionFromOffset(
          relativeIndex,
          relativeIndex,
          true
        );
        return resolvedOffset;
      }
      isPaired() {
        if (this.isClosingTag && this.isSelfClosing == false && this.isOpenedBy != null) {
          return true;
        }
        if (this.isClosedBy == null) {
          return false;
        }
        if (this.isSelfClosing) {
          return false;
        }
        return true;
      }
      getFinalClosingTag() {
        if (this.isClosedBy == null) {
          return this;
        }
        return this.isClosedBy.getFinalClosingTag();
      }
      rawContent() {
        return this.rawStart + this.content + this.rawEnd;
      }
      getTrueRuntimeNodes() {
        if (this.originalNode != null && this.originalNode != this) {
          return this.originalNode.getTrueRuntimeNodes();
        }
        return this.runtimeNodes;
      }
      getTrueRawContent() {
        if (this.originalNode != null && this.originalNode != this) {
          return this.originalNode.getTrueRawContent();
        }
        return this.rawContent();
      }
      getTrueNode() {
        if (this.originalNode != null && this.originalNode != this) {
          return this.originalNode.getTrueNode();
        }
        return this;
      }
      getStructuralChildren() {
        if (this.isClosedBy != null) {
          return filterStructuralAntlersNodes(this.children.slice(0, -1));
        }
        return filterStructuralAntlersNodes(this.children);
      }
      findParentOfType(types2) {
        if (this.parent == null) {
          return null;
        }
        if (this.parent instanceof AntlersNode) {
          if (this.parent.name != null && types2.includes(this.parent.getTagName())) {
            return this.parent;
          }
          return this.parent.findParentOfType(types2);
        }
        return null;
      }
    };
    ParserFailNode = class extends AntlersNode {
      static makeWithStartPosition(startPosition) {
        const newNode = new ParserFailNode();
        newNode.startPosition = startPosition;
        newNode.endPosition = startPosition;
        return newNode;
      }
    };
    AntlersParserFailNode = class extends ParserFailNode {
    };
    RecursiveNode = class extends AntlersNode {
      constructor() {
        super(...arguments);
        this.recursiveParent = null;
        this.isNestedRecursive = false;
      }
    };
    PhpExecutionNode = class extends AntlersNode {
      constructor() {
        super(...arguments);
        this.isEchoNode = false;
      }
    };
    CommentParserFailNode = class extends ParserFailNode {
    };
    PhpParserFailNode = class extends ParserFailNode {
    };
    EscapedContentNode = class extends AntlersNode {
      constructor() {
        super(...arguments);
        this.isNoParseRegion = false;
      }
    };
    ParameterNode2 = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.modifier = null;
        this.isModifierParameter = false;
        this.nameDelimiter = '"';
        this.isVariableReference = false;
        this.name = "";
        this.value = "";
        this.interpolations = [];
        this.parent = null;
        this.blockPosition = null;
        this.namePosition = null;
        this.valuePosition = null;
        this.hasValidValueDelimiter = true;
      }
      containsSimpleValue() {
        return this.hasInterpolations() == false && this.isVariableReference == false;
      }
      hasInterpolations() {
        return this.interpolations.length > 0;
      }
      getArrayValue() {
        return this.value.split("|");
      }
      getValue() {
        return this.value;
      }
    };
    ModifierChainNode = class {
      constructor() {
        this.modifierTarget = null;
        this.modifierChain = [];
        this.startPosition = null;
        this.endPosition = null;
        this.lastManifestedModifier = null;
        this.lastModifier = null;
      }
      updateValues() {
        if (this.modifierChain.length == 0) {
          this.startPosition = null;
          this.endPosition = null;
        } else {
          const firstModifier = this.modifierChain[0], lastModifier = this.modifierChain[this.modifierChain.length - 1];
          this.startPosition = firstModifier.startPosition;
          this.endPosition = lastModifier.endPosition;
        }
      }
    };
    ModifierNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.modifier = null;
        this.methodStyleArguments = null;
        this.nameNode = null;
        this.name = "";
        this.valueNodes = [];
        this.parameters = [];
      }
      getParameterValues() {
        const values = [];
        this.parameters.forEach((param) => {
          values.push(param.value);
        });
        return values;
      }
    };
    ValueDirectionNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.order = 0;
        this.name = null;
        this.directionNode = null;
      }
    };
    ModifierParameterNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.value = "";
      }
    };
    FalseConstant = class extends AbstractNode5 {
    };
    NullConstant = class extends AbstractNode5 {
    };
    TrueConstant = class extends AbstractNode5 {
    };
    AdditionOperator = class extends AbstractNode5 {
    };
    DivisionOperator = class extends AbstractNode5 {
    };
    ExponentiationOperator = class extends AbstractNode5 {
    };
    FactorialOperator = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.repeat = 1;
      }
    };
    ModulusOperator = class extends AbstractNode5 {
    };
    MultiplicationOperator = class extends AbstractNode5 {
    };
    SubtractionOperator = class extends AbstractNode5 {
    };
    AdditionAssignmentOperator = class extends AbstractNode5 {
    };
    DivisionAssignmentOperator = class extends AbstractNode5 {
    };
    LeftAssignmentOperator = class extends AbstractNode5 {
    };
    ModulusAssignmentOperator = class extends AbstractNode5 {
    };
    MultiplicationAssignmentOperator = class extends AbstractNode5 {
    };
    SubtractionAssignmentOperator = class extends AbstractNode5 {
    };
    EqualCompOperator = class extends AbstractNode5 {
    };
    GreaterThanCompOperator = class extends AbstractNode5 {
    };
    GreaterThanEqualCompOperator = class extends AbstractNode5 {
    };
    LessThanCompOperator = class extends AbstractNode5 {
    };
    LessThanEqualCompOperator = class extends AbstractNode5 {
    };
    NotEqualCompOperator = class extends AbstractNode5 {
    };
    NotStrictEqualCompOperator = class extends AbstractNode5 {
    };
    SpaceshipCompOperator = class extends AbstractNode5 {
    };
    StrictEqualCompOperator = class extends AbstractNode5 {
    };
    ConditionalVariableFallbackOperator = class extends AbstractNode5 {
    };
    LanguageOperatorConstruct = class extends AbstractNode5 {
    };
    StatementSeparatorNode = class extends AbstractNode5 {
    };
    DirectionGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.orderClauses = [];
      }
    };
    InlineBranchSeparator = class extends AbstractNode5 {
    };
    ModifierSeparator = class extends AbstractNode5 {
    };
    NullCoalescenceGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.left = null;
        this.right = null;
      }
    };
    ModifierValueSeparator = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.isTenaryBranchSeparator = false;
      }
    };
    InlineTernarySeparator = class extends AbstractNode5 {
    };
    LogicalAndOperator = class extends AbstractNode5 {
    };
    LogicalNegationOperator = class extends AbstractNode5 {
    };
    LogicalOrOperator = class extends AbstractNode5 {
    };
    LogicalXorOperator = class extends AbstractNode5 {
    };
    NullCoalesceOperator = class extends AbstractNode5 {
    };
    ScopeAssignmentOperator = class extends AbstractNode5 {
    };
    StringConcatenationOperator = class extends AbstractNode5 {
    };
    LogicGroupEnd = class extends AbstractNode5 {
    };
    LogicGroupBegin = class extends AbstractNode5 {
    };
    ListValueNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.values = [];
        this.isNamedNode = false;
        this.parsedName = null;
      }
    };
    LogicGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.start = null;
        this.end = null;
        this.nodes = [];
        this.scopeOperator = null;
      }
    };
    SwitchCase = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.condition = null;
        this.expression = null;
      }
    };
    SwitchGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.cases = [];
      }
    };
    ConditionalFallbackGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.left = null;
        this.right = null;
      }
    };
    ArrayNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.nodes = [];
      }
    };
    TernaryCondition = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.head = null;
        this.truthBranch = null;
        this.falseBranch = null;
      }
    };
    ArgSeparator = class extends AbstractNode5 {
    };
    SemanticGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.nodes = [];
        this.separatorToken = null;
      }
    };
    ScopedLogicGroup = class extends LogicGroup {
      constructor() {
        super(...arguments);
        this.scope = null;
      }
      extract() {
        let scopeName = null;
        if (this.scope != null) {
          scopeName = this.scope.name;
        }
        const sematicWrapper = this.nodes[0];
        return [
          scopeName,
          sematicWrapper.nodes
        ];
      }
    };
    AliasedScopeLogicGroup = class extends ScopedLogicGroup {
      constructor() {
        super(...arguments);
        this.alias = null;
      }
    };
    ArgumentGroup = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.args = [];
        this.hasNamedArguments = false;
        this.numberOfNamedArguments = 0;
      }
    };
    TupleListStart = class extends AbstractNode5 {
    };
    TupleList = class extends AbstractNode5 {
    };
    LibraryInvocationConstruct = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.libraryName = "";
        this.methodName = "";
        this.arguments = null;
      }
    };
    LiteralNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.sourceContent = "";
      }
    };
    MethodInvocationNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.method = null;
        this.args = null;
      }
    };
    ModifierNameNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.name = "";
      }
    };
    ModifierValueNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.value = "";
        this.name = "";
      }
    };
    NamedArgumentNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.name = null;
        this.value = null;
      }
    };
    NameValueNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.name = null;
        this.value = null;
      }
    };
    NumberNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.value = null;
      }
    };
    StringValueNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.value = "";
        this.sourceTerminator = "";
        this.sourceContent = "";
      }
    };
    VariableNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.name = "";
        this.mergeRefName = "";
        this.variableReference = null;
        this.interpolationNodes = [];
        this.isInterpolationReference = false;
      }
    };
    AccessorNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.name = "";
      }
    };
    PathNode = class extends AbstractNode5 {
      constructor() {
        super(...arguments);
        this.delimiter = "";
        this.name = "";
        this.isStringVar = false;
        this.isFinal = false;
      }
    };
    VariableReference = class {
      constructor() {
        this.originalContent = "";
        this.normalizedReference = "";
        this.isStrictTagReference = false;
        this.isStrictVariableReference = false;
        this.isExplicitVariableReference = false;
        this.isVariableVariable = false;
        this.pathParts = [];
        this.isFinal = false;
        this._isFromEmptyFailState = false;
      }
      clone() {
        const reference = new VariableReference();
        reference.originalContent = this.originalContent;
        reference.normalizedReference = this.normalizedReference;
        reference.isStrictVariableReference = this.isStrictVariableReference;
        reference.isExplicitVariableReference = this.isExplicitVariableReference;
        reference.pathParts = this.pathParts;
        reference.isFinal = this.isFinal;
        return reference;
      }
      implodePaths() {
        const stringParts = [];
        this.pathParts.forEach((part) => {
          if (part instanceof PathNode) {
            stringParts.push(part.name);
          } else if (part instanceof VariableReference) {
            stringParts.push(part.implodePaths());
          }
        });
        return stringParts.join(".");
      }
    };
    StaticTracedAssignment = class {
      constructor(target, value, operator) {
        this.target = target;
        this.value = value;
        this.operator = operator;
      }
    };
  }
});

// server/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports.Disposable || (exports.Disposable = {}));
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// server/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
          clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
          return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
          clearImmediate(handle);
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
    })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      const candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports.isResponseMessage = isResponseMessage;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports.Event || (exports.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            ral_1.default().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        ral_1.default().timer.clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options !== null && options !== void 0 ? options : "utf-8";
        } else {
          charset = (_a = options.charset) !== null && _a !== void 0 ? _a : "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = ral_1.default().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          ral_1.default().timer.clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        var _a, _b;
        if (options === void 0 || typeof options === "string") {
          return { charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder };
        } else {
          return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[Symbol.toStringTag] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a;
        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
      }
      get last() {
        var _a;
        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Verbose"] = 2] = "Verbose";
    })(Trace = exports.Trace || (exports.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString2(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString2;
    })(Trace = exports.Trace || (exports.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ Object.create(null);
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            const key = createRequestQueueKey(message.params.id);
            const toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type2;
        let requestHandler;
        if (element) {
          type2 = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = String(requestMessage.id);
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type2 !== void 0 && type2.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type2.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = String(responseMessage.id);
          const responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type2 = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            const id = params.id;
            const source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          const element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type2 = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type2 !== void 0) {
                  if (type2.numberOfParams !== 0 && type2.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type2.numberOfParams} params but recevied none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                if (type2 !== void 0) {
                  if (type2.parameterStructures === messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                  }
                  if (type2.numberOfParams !== message.params.length) {
                    logger.error(`Notification ${message.method} defines ${type2.numberOfParams} params but received ${message.params.length} argumennts`);
                  }
                }
                notificationHandler(...message.params);
              } else {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = String(responseMessage.id);
          const responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type2, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type: type2,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
            break;
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Recevied parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type2, params) {
        let result;
        const numberOfParams = type2.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type2.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type2, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type2)) {
            method = type2;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type2.method;
            messageParams = computeMessageParams(type2, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type2, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type2)) {
            starNotificationHandler = type2;
          } else if (handler) {
            if (Is2.string(type2)) {
              method = type2;
              notificationHandlers[type2] = { type: void 0, handler };
            } else {
              method = type2.method;
              notificationHandlers[type2.method] = { type: type2, handler };
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                delete notificationHandlers[method];
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type2, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type2)) {
            method = type2;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type2.method;
            messageParams = computeMessageParams(type2, params);
            const numberOfParams = type2.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              cancellationStrategy.sender.sendCancellation(connection, id);
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          return result;
        },
        onRequest: (type2, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type2)) {
            method = void 0;
            starRequestHandler = type2;
          } else if (Is2.string(type2)) {
            method = null;
            if (handler !== void 0) {
              method = type2;
              requestHandlers[type2] = { handler, type: void 0 };
            }
          } else {
            if (handler !== void 0) {
              method = type2.method;
              requestHandlers[type2.method] = { type: type2, handler };
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                delete requestHandlers[method];
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is2.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          ral_1.default().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
    exports.CancellationStrategy = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// server/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return api_1.createMessageConnection(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// server/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "server/node_modules/vscode-jsonrpc/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// server/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "server/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocument = exports2.EOL = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = void 0;
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
      })(integer = exports2.integer || (exports2.integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
      })(uinteger = exports2.uinteger || (exports2.uinteger = {}));
      var Position3;
      (function(Position4) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.line) && Is2.uinteger(candidate.character);
        }
        Position4.is = is;
      })(Position3 = exports2.Position || (exports2.Position = {}));
      var Range3;
      (function(Range4) {
        function create(one, two, three, four) {
          if (Is2.uinteger(one) && Is2.uinteger(two) && Is2.uinteger(three) && Is2.uinteger(four)) {
            return { start: Position3.create(one, two), end: Position3.create(three, four) };
          } else if (Position3.is(one) && Position3.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
          }
        }
        Range4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Position3.is(candidate.start) && Position3.is(candidate.end);
        }
        Range4.is = is;
      })(Range3 = exports2.Range || (exports2.Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && (Is2.string(candidate.uri) || Is2.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports2.Location || (exports2.Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.targetRange) && Is2.string(candidate.targetUri) && (Range3.is(candidate.targetSelectionRange) || Is2.undefined(candidate.targetSelectionRange)) && (Range3.is(candidate.originSelectionRange) || Is2.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink = exports2.LocationLink || (exports2.LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.numberRange(candidate.red, 0, 1) && Is2.numberRange(candidate.green, 0, 1) && Is2.numberRange(candidate.blue, 0, 1) && Is2.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color = exports2.Color || (exports2.Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Range3.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation = exports2.ColorInformation || (exports2.ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.string(candidate.label) && (Is2.undefined(candidate.textEdit) || TextEdit7.is(candidate)) && (Is2.undefined(candidate.additionalTextEdits) || Is2.typedArray(candidate.additionalTextEdits, TextEdit7.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation = exports2.ColorPresentation || (exports2.ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2["Comment"] = "comment";
        FoldingRangeKind2["Imports"] = "imports";
        FoldingRangeKind2["Region"] = "region";
      })(FoldingRangeKind = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind) {
          var result = {
            startLine,
            endLine
          };
          if (Is2.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is2.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is2.defined(kind)) {
            result.kind = kind;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.uinteger(candidate.startLine) && Is2.uinteger(candidate.startLine) && (Is2.undefined(candidate.startCharacter) || Is2.uinteger(candidate.startCharacter)) && (Is2.undefined(candidate.endCharacter) || Is2.uinteger(candidate.endCharacter)) && (Is2.undefined(candidate.kind) || Is2.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange = exports2.FoldingRange || (exports2.FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Location.is(candidate.location) && Is2.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation = exports2.DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity2;
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag = exports2.DiagnosticTag || (exports2.DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Is2.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription = exports2.CodeDescription || (exports2.CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is2.defined(severity)) {
            result.severity = severity;
          }
          if (Is2.defined(code)) {
            result.code = code;
          }
          if (Is2.defined(source)) {
            result.source = source;
          }
          if (Is2.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && Is2.string(candidate.message) && (Is2.number(candidate.severity) || Is2.undefined(candidate.severity)) && (Is2.integer(candidate.code) || Is2.string(candidate.code) || Is2.undefined(candidate.code)) && (Is2.undefined(candidate.codeDescription) || Is2.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is2.string(candidate.source) || Is2.undefined(candidate.source)) && (Is2.undefined(candidate.relatedInformation) || Is2.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports2.Diagnostic || (exports2.Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is2.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.title) && Is2.string(candidate.command);
        }
        Command2.is = is;
      })(Command = exports2.Command || (exports2.Command = {}));
      var TextEdit7;
      (function(TextEdit8) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit8.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit8.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit8.del = del;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.newText) && Range3.is(candidate.range);
        }
        TextEdit8.is = is;
      })(TextEdit7 = exports2.TextEdit || (exports2.TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation = exports2.ChangeAnnotation || (exports2.ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return typeof candidate === "string";
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier = exports2.ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit7.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit = exports2.AnnotatedTextEdit || (exports2.AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile = exports2.CreateFile || (exports2.CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is2.string(candidate.oldUri) && Is2.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile = exports2.RenameFile || (exports2.RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is2.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is2.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile = exports2.DeleteFile || (exports2.DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is2.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit = exports2.WorkspaceEdit || (exports2.WorkspaceEdit = {}));
      var TextEditChangeImpl = function() {
        function TextEditChangeImpl2(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit7.insert(position, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit7.replace(range, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.delete = function(range, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit7.del(range);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.add = function(edit) {
          this.edits.push(edit);
        };
        TextEditChangeImpl2.prototype.all = function() {
          return this.edits;
        };
        TextEditChangeImpl2.prototype.clear = function() {
          this.edits.splice(0, this.edits.length);
        };
        TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
          if (value === void 0) {
            throw new Error("Text edit change is not configured to manage change annotations.");
          }
        };
        return TextEditChangeImpl2;
      }();
      var ChangeAnnotations = function() {
        function ChangeAnnotations2(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        ChangeAnnotations2.prototype.all = function() {
          return this._annotations;
        };
        Object.defineProperty(ChangeAnnotations2.prototype, "size", {
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
          var id;
          if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error("Id " + id + " is already in use.");
          }
          if (annotation === void 0) {
            throw new Error("No annotation provided for id " + id);
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        };
        ChangeAnnotations2.prototype.nextId = function() {
          this._counter++;
          return this._counter.toString();
        };
        return ChangeAnnotations2;
      }();
      var WorkspaceChange = function() {
        function WorkspaceChange2(workspaceEdit) {
          var _this = this;
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach(function(change) {
                if (TextDocumentEdit.is(change)) {
                  var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                  _this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach(function(key) {
                var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                _this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        Object.defineProperty(WorkspaceChange2.prototype, "edit", {
          get: function() {
            this.initDocumentChanges();
            if (this._changeAnnotations !== void 0) {
              if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = void 0;
              } else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            }
            return this._workspaceEdit;
          },
          enumerable: false,
          configurable: true
        });
        WorkspaceChange2.prototype.getTextEditChange = function(key) {
          if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
              var edits = [];
              var textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            var result = this._textEditChanges[key];
            if (!result) {
              var edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        };
        WorkspaceChange2.prototype.initDocumentChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        };
        WorkspaceChange2.prototype.initChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        };
        WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = CreateFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = RenameFile.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = DeleteFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        return WorkspaceChange2;
      }();
      exports2.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (candidate.version === null || Is2.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier = exports2.OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.string(candidate.languageId) && Is2.integer(candidate.version) && Is2.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
      var MarkupKind5;
      (function(MarkupKind6) {
        MarkupKind6.PlainText = "plaintext";
        MarkupKind6.Markdown = "markdown";
      })(MarkupKind5 = exports2.MarkupKind || (exports2.MarkupKind = {}));
      (function(MarkupKind6) {
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind6.PlainText || candidate === MarkupKind6.Markdown;
        }
        MarkupKind6.is = is;
      })(MarkupKind5 = exports2.MarkupKind || (exports2.MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(value) && MarkupKind5.is(candidate.kind) && Is2.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent = exports2.MarkupContent || (exports2.MarkupContent = {}));
      var CompletionItemKind32;
      (function(CompletionItemKind33) {
        CompletionItemKind33.Text = 1;
        CompletionItemKind33.Method = 2;
        CompletionItemKind33.Function = 3;
        CompletionItemKind33.Constructor = 4;
        CompletionItemKind33.Field = 5;
        CompletionItemKind33.Variable = 6;
        CompletionItemKind33.Class = 7;
        CompletionItemKind33.Interface = 8;
        CompletionItemKind33.Module = 9;
        CompletionItemKind33.Property = 10;
        CompletionItemKind33.Unit = 11;
        CompletionItemKind33.Value = 12;
        CompletionItemKind33.Enum = 13;
        CompletionItemKind33.Keyword = 14;
        CompletionItemKind33.Snippet = 15;
        CompletionItemKind33.Color = 16;
        CompletionItemKind33.File = 17;
        CompletionItemKind33.Reference = 18;
        CompletionItemKind33.Folder = 19;
        CompletionItemKind33.EnumMember = 20;
        CompletionItemKind33.Constant = 21;
        CompletionItemKind33.Struct = 22;
        CompletionItemKind33.Event = 23;
        CompletionItemKind33.Operator = 24;
        CompletionItemKind33.TypeParameter = 25;
      })(CompletionItemKind32 = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
      var InsertTextFormat7;
      (function(InsertTextFormat8) {
        InsertTextFormat8.PlainText = 1;
        InsertTextFormat8.Snippet = 2;
      })(InsertTextFormat7 = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag = exports2.CompletionItemTag || (exports2.CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.newText) && Range3.is(candidate.insert) && Range3.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit = exports2.InsertReplaceEdit || (exports2.InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode = exports2.InsertTextMode || (exports2.InsertTextMode = {}));
      var CompletionItem30;
      (function(CompletionItem31) {
        function create(label) {
          return { label };
        }
        CompletionItem31.create = create;
      })(CompletionItem30 = exports2.CompletionItem || (exports2.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList = exports2.CompletionList || (exports2.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is2.string(candidate) || Is2.objectLiteral(candidate) && Is2.string(candidate.language) && Is2.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString = exports2.MarkedString || (exports2.MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is2.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is2.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range3.is(value.range));
        }
        Hover2.is = is;
      })(Hover = exports2.Hover || (exports2.Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is2.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is2.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is2.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind = exports2.SymbolKind || (exports2.SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag = exports2.SymbolTag || (exports2.SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.name) && Is2.number(candidate.kind) && Range3.is(candidate.range) && Range3.is(candidate.selectionRange) && (candidate.detail === void 0 || Is2.string(candidate.detail)) && (candidate.deprecated === void 0 || Is2.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol = exports2.DocumentSymbol || (exports2.DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind = exports2.CodeActionKind || (exports2.CodeActionKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is2.typedArray(candidate.only, Is2.string));
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.title) && (candidate.diagnostics === void 0 || Is2.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is2.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is2.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction = exports2.CodeAction || (exports2.CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is2.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && (Is2.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports2.CodeLens || (exports2.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.uinteger(candidate.tabSize) && Is2.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && (Is2.undefined(candidate.target) || Is2.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports2.DocumentLink || (exports2.DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && Range3.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange = exports2.SelectionRange || (exports2.SelectionRange = {}));
      exports2.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (Is2.undefined(candidate.languageId) || Is2.string(candidate.languageId)) && Is2.uinteger(candidate.lineCount) && Is2.func(candidate.getText) && Is2.func(candidate.positionAt) && Is2.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
      var FullTextDocument = function() {
        function FullTextDocument2(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        Object.defineProperty(FullTextDocument2.prototype, "uri", {
          get: function() {
            return this._uri;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "languageId", {
          get: function() {
            return this._languageId;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "version", {
          get: function() {
            return this._version;
          },
          enumerable: false,
          configurable: true
        });
        FullTextDocument2.prototype.getText = function(range) {
          if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        };
        FullTextDocument2.prototype.update = function(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = void 0;
        };
        FullTextDocument2.prototype.getLineOffsets = function() {
          if (this._lineOffsets === void 0) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              var ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        };
        FullTextDocument2.prototype.positionAt = function(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          var lineOffsets = this.getLineOffsets();
          var low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position3.create(0, offset);
          }
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          var line = low - 1;
          return Position3.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument2.prototype.offsetAt = function(position) {
          var lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          var lineOffset = lineOffsets[position.line];
          var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
          get: function() {
            return this.getLineOffsets().length;
          },
          enumerable: false,
          configurable: true
        });
        return FullTextDocument2;
      }();
      var Is2;
      (function(Is3) {
        var toString2 = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is3.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is3.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is3.boolean = boolean;
        function string(value) {
          return toString2.call(value) === "[object String]";
        }
        Is3.string = string;
        function number(value) {
          return toString2.call(value) === "[object Number]";
        }
        Is3.number = number;
        function numberRange(value, min, max) {
          return toString2.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is3.numberRange = numberRange;
        function integer2(value) {
          return toString2.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is3.integer = integer2;
        function uinteger2(value) {
          return toString2.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is3.uinteger = uinteger2;
        function func(value) {
          return toString2.call(value) === "[object Function]";
        }
        Is3.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is3.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is3.typedArray = typedArray;
      })(Is2 || (Is2 = {}));
    });
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeKind;
    (function(FoldingRangeKind2) {
      FoldingRangeKind2["Comment"] = "comment";
      FoldingRangeKind2["Imports"] = "imports";
      FoldingRangeKind2["Region"] = "region";
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
    var messages_1 = require_messages2();
    var SemanticTokenTypes;
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
    })(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
    var SemanticTokenModifiers;
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
    var SemanticTokens;
    (function(SemanticTokens2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    })(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2["document"] = "document";
      UniquenessLevel2["project"] = "project";
      UniquenessLevel2["group"] = "group";
      UniquenessLevel2["scheme"] = "scheme";
      UniquenessLevel2["global"] = "global";
    })(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2["import"] = "import";
      MonikerKind2["export"] = "export";
      MonikerKind2["local"] = "local";
    })(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
    var Is2 = require_is3();
    var messages_1 = require_messages2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "SemanticTokenTypes", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenTypes;
    } });
    Object.defineProperty(exports, "SemanticTokenModifiers", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenModifiers;
    } });
    Object.defineProperty(exports, "SemanticTokens", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokens;
    } });
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !DocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
    var InitializeError;
    (function(InitializeError2) {
      InitializeError2.unknownProtocolVersion = 1;
    })(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar(require_main2(), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    __exportStar(require_api2(), exports);
    function createProtocolConnection(input, output, logger, options) {
      return node_1.createMessageConnection(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// server/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// server/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection, token);
    }
    exports.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          var _a;
          if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = uuid_1.generateUuid();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection, token);
    }
    exports.attachPartialResult = attachPartialResult;
  }
});

// server/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is2 = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is2.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            return Array.isArray(arg) ? result : result[0];
          });
        }
      };
    };
    exports.ConfigurationFeature = ConfigurationFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/workspaceFolders.js
var require_workspaceFolders = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/workspaceFolders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        initialize(capabilities) {
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type2 = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type2 = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensBuilder = exports.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onDelta: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onRange: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          const prevDataLength = this._prevData.length;
          const dataLength = this._data.length;
          let startIndex = 0;
          while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
            startIndex++;
          }
          if (startIndex < dataLength && startIndex < prevDataLength) {
            let endIndex = 0;
            while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
              endIndex++;
            }
            const newData = this._data.slice(startIndex, dataLength - endIndex);
            const result = {
              resultId: this.id,
              edits: [
                { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
              ]
            };
            return result;
          } else if (startIndex < dataLength) {
            return { resultId: this.id, edits: [
              { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
            ] };
          } else if (startIndex < prevDataLength) {
            return { resultId: this.id, edits: [
              { start: startIndex, deleteCount: prevDataLength - startIndex }
            ] };
          } else {
            return { resultId: this.id, edits: [] };
          }
        } else {
          return this.build();
        }
      }
    };
    exports.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// server/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports.FileOperationsFeature = FileOperationsFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.MonikerRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports.MonikerFeature = MonikerFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.combineFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = exports.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is2 = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolders_1 = require_workspaceFolders();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var TextDocuments = class {
      constructor(configuration) {
        this._documents = /* @__PURE__ */ Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onWillSave() {
        return this._onWillSave.event;
      }
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      get(uri) {
        return this._documents[uri];
      }
      all() {
        return Object.keys(this._documents).map((key) => this._documents[key]);
      }
      keys() {
        return Object.keys(this._documents);
      }
      listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
          let td = event.textDocument;
          let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._documents[td.uri] = document;
          let toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
          let td = event.textDocument;
          let changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          let document = this._documents[td.uri];
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          document = this._configuration.update(document, changes, version);
          this._documents[td.uri] = document;
          this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            delete this._documents[event.textDocument.uri];
            this._onDidClose.fire(Object.freeze({ document }));
          }
        });
        connection.onWillSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
          }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
          let document = this._documents[event.textDocument.uri];
          if (document && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
          } else {
            return [];
          }
        });
        connection.onDidSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onDidSave.fire(Object.freeze({ document }));
          }
        });
      }
    };
    exports.TextDocuments = TextDocuments;
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      sendErrors(connection) {
        Object.keys(this._messages).forEach((message) => {
          connection.window.showErrorMessage(message);
        });
      }
    };
    exports.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection) {
        this._rawConnection = connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type2, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type: type2, message });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = showDocument_1.ShowDocumentFeature(progress_1.ProgressFeature(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type2, registerOptions) {
        const method = Is2.string(type2) ? type2 : type2.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is2.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type2, registerOptions) {
        const method = Is2.string(type2) ? type2 : type2.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type2, registerOptions) {
        const method = Is2.string(type2) ? type2 : type2.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method);
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = fileOperations_1.FileOperationsFeature(workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
      }
    };
    exports._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = moniker_1.MonikerFeature(linkedEditingRange_1.LinkedEditingRangeFeature(semanticTokens_1.SemanticTokensFeature(callHierarchy_1.CallHierarchyFeature(_LanguagesImpl))));
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
      };
      return result;
    }
    exports.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection = connectionFactory(logger);
      logger.rawAttach(connection);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is2.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type2, ...params) => connection.sendRequest(Is2.string(type2) ? type2 : type2.method, ...params),
        onRequest: (type2, handler) => connection.onRequest(type2, handler),
        sendNotification: (type2, param) => {
          const method = Is2.string(type2) ? type2 : type2.method;
          if (arguments.length === 1) {
            connection.sendNotification(method);
          } else {
            connection.sendNotification(method, param);
          }
        },
        onNotification: (type2, handler) => connection.onNotification(type2, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        dispose: () => connection.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is2.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is2.number(capabilities.textDocumentSync) && !Is2.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports.createConnection = createConnection;
  }
});

// server/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "server/node_modules/vscode-languageserver/lib/node/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
    var url = require("url");
    var path = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path.normalize(segments.join("/"));
    }
    exports.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = child_process_1.fork("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = child_process_1.spawnSync(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path.join(prefix, "node_modules");
          } else {
            return path.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = child_process_1.spawnSync(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        } else {
          return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
          nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports.resolveModulePath = resolveModulePath;
  }
});

// server/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// server/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProposedFeatures = exports.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    __exportStar(require_main3(), exports);
    __exportStar(require_server(), exports);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features"
      };
    })(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
  }
});

// server/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.Files = void 0;
    var Is2 = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports);
    __exportStar(require_api3(), exports);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files = exports.Files || (exports.Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is2.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = node_1.createServerSocketTransport(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = node_1.createServerPipeTransport(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is2.func(input.read) && Is2.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = node_1.createProtocolConnection(input, output, logger, options);
        return result;
      };
      return server_1.createConnection(connectionFactory, watchDog, factories);
    }
  }
});

// server/src/suggestions/attributeSuggestions.ts
function makeTagParameterSuggestions(request, parameters) {
  const paramSuggestions = [];
  if (request.currentNode == null) {
    return paramSuggestions;
  }
  const range = {
    start: {
      line: request.position.line,
      character: request.position.character - 0
    },
    end: request.position
  };
  for (let i = 0; i < parameters.length; i++) {
    const curParam = parameters[i];
    if (!request.currentNode.hasParameter(curParam.name)) {
      let insertParamName = curParam.name;
      if (request.leftWord != null && insertParamName.startsWith(request.leftWord)) {
        insertParamName = insertParamName.substring(request.leftWord.length);
      }
      const paramSnippet = insertParamName + '="$1"';
      paramSuggestions.push({
        label: curParam.name,
        kind: import_vscode_languageserver_types.CompletionItemKind.Value,
        insertTextFormat: import_vscode_languageserver_types.InsertTextFormat.Snippet,
        textEdit: import_vscode_languageserver_types.TextEdit.replace(range, paramSnippet),
        command: {
          title: "Suggest",
          command: "editor.action.triggerSuggest"
        }
      });
    }
  }
  return paramSuggestions;
}
var import_vscode_languageserver_types;
var init_attributeSuggestions = __esm({
  "server/src/suggestions/attributeSuggestions.ts"() {
    "use strict";
    import_vscode_languageserver_types = __toESM(require_main2());
  }
});

// server/src/suggestions/fieldFormatter.ts
function makeFieldSuggest(name, description, valueType) {
  const item = {
    label: name,
    insertText: name,
    kind: import_vscode_languageserver_types2.CompletionItemKind.Field,
    detail: valueType + ": " + description
  };
  return item;
}
function formatSuggestionList(fields) {
  const items = [];
  for (let i = 0; i < fields.length; i++) {
    if (typeof fields[i].name === "undefined") {
      continue;
    }
    items.push(formatSuggestion(fields[i]));
  }
  return items;
}
function formatSuggestion(field) {
  let detail = "";
  let displayName = field.name;
  if (field.instructionText != null) {
    detail = field.instructionText;
  }
  if (field.displayName != null) {
    displayName = field.displayName + " (" + field.name + ")";
  }
  if (field.blueprintName != null) {
    if (detail.trim().length > 0) {
      detail += "\n";
    }
    detail += "Blueprint: " + field.blueprintName;
  }
  if (field.type != null) {
    displayName += ": " + field.type;
  }
  return {
    label: field.name,
    insertText: field.name,
    kind: import_vscode_languageserver_types2.CompletionItemKind.Field,
    documentation: detail,
    detail: displayName
  };
}
var import_vscode_languageserver_types2;
var init_fieldFormatter = __esm({
  "server/src/suggestions/fieldFormatter.ts"() {
    "use strict";
    import_vscode_languageserver_types2 = __toESM(require_main2());
  }
});

// server/src/documentation/utils.ts
function makeTagDocWithCodeSample(title, description, code, docLink) {
  let docs = "**" + title + "**  ";
  docs += "\n";
  docs += description + "  ";
  docs += "\n```antlers\n";
  docs += code;
  docs += "\n```";
  if (docLink != null) {
    docs += "\n\n";
    docs += "[Documentation Reference](" + docLink + ")";
  }
  return docs;
}
function makeTagDoc(title, description, docLink) {
  let docs = "**" + title + "**  ";
  docs += "\n";
  docs += description + "  ";
  if (docLink != null) {
    docs += "\n\n";
    docs += "[Documentation Reference](" + docLink + ")";
  }
  return docs;
}
var init_utils = __esm({
  "server/src/documentation/utils.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/collection/alternateParamSuggestions.ts
function suggestAlternativeCollectionParams(unknown) {
  const results = [];
  if (unknown == "order") {
    results.push("sort");
  }
  return results;
}
var init_alternateParamSuggestions = __esm({
  "server/src/antlers/tags/core/collection/alternateParamSuggestions.ts"() {
    "use strict";
  }
});

// server/src/projects/blueprints/fields.ts
function blueprintFieldFromScopeVariable(variable) {
  return {
    blueprintName: variable.sourceName,
    displayName: variable.name,
    instructionText: "",
    maxItems: -1,
    name: variable.name,
    refFieldSetField: null,
    type: variable.dataType,
    sets: null,
    import: null
  };
}
function variablesToBlueprintFields(variables) {
  const fields = [];
  for (let i = 0; i < variables.length; i++) {
    fields.push(blueprintFieldFromScopeVariable(variables[i]));
  }
  return fields;
}
var init_fields = __esm({
  "server/src/projects/blueprints/fields.ts"() {
    "use strict";
  }
});

// server/src/antlers/variables/loopVariables.ts
function makeLoopVariables(symbol) {
  return [
    { name: "first", dataType: "boolean", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "last", dataType: "boolean", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "count", dataType: "integer", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "index", dataType: "integer", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "order", dataType: "integer", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol }
  ];
}
var init_loopVariables = __esm({
  "server/src/antlers/variables/loopVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/scope/factories/listFactory.ts
function checkSymbolForScopeAndAlias(node, scope, fields) {
  if (typeof fields === "undefined" || fields === null) {
    return;
  }
  const aliasParam = node.findParameter("as"), scopeParam = node.findParameter("scope");
  fields = fields.concat(variablesToBlueprintFields(makeLoopVariables(node)));
  if (aliasParam != null && scopeParam != null) {
    scope.introduceScopedAliasScope(
      node,
      scopeParam.value,
      aliasParam.value,
      fields
    );
  } else if (aliasParam != null) {
    scope.introduceAliasScope(node, aliasParam.value, fields);
  } else if (scopeParam != null) {
    scope.introduceDynamicScopeList(node, scopeParam.value, fields);
  } else {
    scope.addBlueprintFields(node, fields);
  }
}
var init_listFactory = __esm({
  "server/src/antlers/scope/factories/listFactory.ts"() {
    "use strict";
    init_fields();
    init_loopVariables();
  }
});

// server/src/antlers/variables/collectionVariables.ts
function makeCollectionVariables(node) {
  return [
    { name: "no_results", dataType: "boolean", sourceField: null, sourceName: "*internal.collection.context", introducedBy: node },
    { name: "total_results", dataType: "integer", sourceField: null, sourceName: "*internal.collection.context", introducedBy: node }
  ];
}
var init_collectionVariables = __esm({
  "server/src/antlers/variables/collectionVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/collection/parameters.ts
var collectionParameters, CollectionSourceParams, CollectionRestrictionParams, EntryStatuses;
var init_parameters = __esm({
  "server/src/antlers/tags/core/collection/parameters.ts"() {
    "use strict";
    collectionParameters = [
      {
        isRequired: false,
        name: "from",
        description: "The collection name to retrieve entries from",
        aliases: ["folder", "use"],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["string", "array"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "not_from",
        aliases: ["not_folder", "dont_use"],
        description: "The collections to exclude when retrieving entries",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["string", "array"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "show_unpublished",
        aliases: null,
        description: "Controls whether unpbulished entries are returned",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "show_published",
        aliases: null,
        description: "Controls whether published entries are returned",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "show_past",
        aliases: null,
        description: "Controls whether to display entries with a past date",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "since",
        aliases: null,
        description: "Sets the minimum date an entry can have to be returned",
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "until",
        aliases: null,
        description: "Sets the maximum date an entry can have to be returned",
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "sort",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: null,
        description: "Specifies the entry sort order",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "limit",
        aliases: null,
        description: "Sets the maximum number of entries to return",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["integer"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "filter",
        aliases: ["query_scope"],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        description: "Specifies a custom query scope",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: null,
        description: "Sets the amount that entry results should be offset by",
        expectsTypes: ["integer"],
        isRequired: false,
        name: "offset",
        isDynamic: false
      },
      {
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: null,
        description: "Sets whether not to paginate entry results",
        expectsTypes: ["boolean", "number"],
        isRequired: false,
        name: "paginate",
        isDynamic: false
      },
      {
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: null,
        description: "Specifies a name to give to a new entries array variable",
        expectsTypes: ["string"],
        isRequired: false,
        name: "as",
        isDynamic: false
      },
      {
        name: "scope",
        aliases: null,
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        description: "Sets a prefix on all entry variables",
        expectsTypes: ["string"],
        isRequired: false,
        isDynamic: false
      },
      {
        name: "locale",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: null,
        description: "Specifies the locale in which to retrieve entry content",
        expectsTypes: ["string"],
        isRequired: false,
        isDynamic: false
      },
      {
        name: "redirects",
        aliases: ["links"],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        description: "Controls whether entries with redirects are returned",
        expectsTypes: ["boolean"],
        isRequired: false,
        isDynamic: false
      },
      {
        name: "page_name",
        aliases: [],
        acceptsVariableInterpolation: true,
        allowsVariableReference: true,
        description: "Allows you to customise the name of the URL query parameter used for pagination.",
        expectsTypes: ["string"],
        isRequired: false,
        isDynamic: false
      }
    ];
    CollectionSourceParams = ["from", "folder", "use"];
    CollectionRestrictionParams = ["not_from", "not_folder", "dont_use"];
    EntryStatuses = ["draft", "scheduled", "expired", "published"];
  }
});

// server/src/antlers/tags/core/collection/utils.ts
function getTaxonomyCompletionItems(request) {
  const items = [];
  if (request.project != null) {
    const range = {
      start: {
        line: request.position.line,
        character: request.position.character - request.originalLeftWord.length
      },
      end: request.position
    };
    const taxonomyNames = request.project.getUniqueTaxonomyNames();
    for (let i = 0; i < taxonomyNames.length; i++) {
      const taxonomyName = taxonomyNames[i];
      const snippet2 = request.originalLeftWord + taxonomyName + '="$1"';
      items.push({
        label: request.originalLeftWord + taxonomyName,
        insertTextFormat: import_vscode_languageserver_types3.InsertTextFormat.Snippet,
        kind: import_vscode_languageserver_types3.CompletionItemKind.Field,
        textEdit: import_vscode_languageserver_types3.TextEdit.replace(range, snippet2),
        command: {
          title: "Suggest",
          command: "editor.action.triggerSuggest"
        }
      });
    }
  }
  return items;
}
function getCollectionBlueprintFields(node, scope) {
  let fields = [];
  if (node.reference != null) {
    const collectionNode = node.reference, nodeFields = scope.statamicProject.getBlueprintFields(collectionNode.collectionNames);
    if (typeof nodeFields !== "undefined" && nodeFields != null) {
      fields = nodeFields;
    }
  }
  return fields;
}
function makeStatusSuggestions(existingValues) {
  const items = [], validStatuses = EntryStatuses.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < validStatuses.length; i++) {
    items.push({
      label: validStatuses[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeTaxonomySuggestions(existingValues, taxonomyName, project) {
  const items = [], taxonomyTerms = project.getTaxonomyTerms(taxonomyName), termsToReturn = taxonomyTerms.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < termsToReturn.length; i++) {
    items.push({
      label: termsToReturn[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeSingleCollectionNameSuggestions(project) {
  const items = [], collectionNames = project.getCollectionNames();
  for (let i = 0; i < collectionNames.length; i++) {
    items.push({
      label: collectionNames[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeCollectionNameSuggestions(existingValues, project) {
  const items = [], collectionNames = project.getCollectionNames().filter((e) => !existingValues.includes(e));
  for (let i = 0; i < collectionNames.length; i++) {
    items.push({
      label: collectionNames[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeQueryScopeSuggestions(project) {
  const items = [];
  const queryScopes = project.getCollectionQueryScopes();
  for (let i = 0; i < queryScopes.length; i++) {
    items.push({
      label: `${queryScopes[i].handle} (${queryScopes[i].name})`,
      detail: queryScopes[i].description,
      insertText: queryScopes[i].handle,
      kind: import_vscode_languageserver_types3.CompletionItemKind.EnumMember
    });
  }
  return items;
}
var import_vscode_languageserver_types3;
var init_utils2 = __esm({
  "server/src/antlers/tags/core/collection/utils.ts"() {
    "use strict";
    import_vscode_languageserver_types3 = __toESM(require_main2());
    init_parameters();
  }
});

// server/src/antlers/tags/core/collection/augmentCollectionScope.ts
function augmentCollectionScope(node, scope) {
  if (node.isClosingTag) {
    return scope;
  }
  if (node.hasMethodPart() && node.getMethodNameValue() != "count") {
    scope.addVariables(makeCollectionVariables(node));
  }
  if (node.reference != null) {
    const fields = getCollectionBlueprintFields(node, scope), collRef = node.reference;
    if (fields.length == 0 && collRef.collectionNames.length > 0) {
      fields.push({ blueprintName: collRef.collectionNames[0], displayName: "Title", import: null, instructionText: "", maxItems: null, name: "title", type: "string", refFieldSetField: null, sets: [] });
      fields.push({ blueprintName: collRef.collectionNames[0], displayName: "Slug", import: null, instructionText: "", maxItems: null, name: "slug", type: "string", refFieldSetField: null, sets: [] });
      fields.push({ blueprintName: collRef.collectionNames[0], displayName: "Date", import: null, instructionText: "", maxItems: null, name: "date", type: "string", refFieldSetField: null, sets: [] });
    }
    checkSymbolForScopeAndAlias(node, scope, fields);
  }
  return scope;
}
var init_augmentCollectionScope = __esm({
  "server/src/antlers/tags/core/collection/augmentCollectionScope.ts"() {
    "use strict";
    init_listFactory();
    init_collectionVariables();
    init_utils2();
  }
});

// server/src/suggestions/defaults/stringConditions.ts
var StringConditionItems;
var init_stringConditions = __esm({
  "server/src/suggestions/defaults/stringConditions.ts"() {
    "use strict";
    StringConditionItems = [
      { name: "is", description: "Tests if a field is equal to a value" },
      { name: "equals", description: "Tests if a field is equal to a value" },
      { name: "not", description: "Tests if a field is not equal to a value" },
      { name: "isnt", description: "Tests if a field is not equal to a value" },
      { name: "exists", description: "Tests if a field exists" },
      { name: "isset", description: "Tests if a field exists" },
      { name: "doesnt_exist", description: "Tests if a field does not exist" },
      { name: "is_empty", description: "Tests if a field does not exist" },
      { name: "null", description: "Tests if a field does not exist" },
      { name: "contains", description: "Tests if a field contains a value" },
      { name: "doesnt_contain", description: "Tests if a field does not contain a value" },
      { name: "in", description: "Tests if a value is in an array" },
      { name: "not_in", description: "Tests if an array does not contain a value" },
      { name: "starts_with", description: "Tests if a field starts with a value" },
      { name: "doesnt_start_with", description: "Tests if a field does not start with a value" },
      { name: "ends_with", description: "Tests if a field ends with a value" },
      { name: "doesnt_end_with", description: "Tests if a field does not end with a value" },
      { name: "gt", description: "Tests if a field is greater than a value" },
      { name: "lt", description: "Tests if a field is less than a value" },
      { name: "gte", description: "Tests if a field is greater than or equal to a value" },
      { name: "lte", description: "Tests if a field is less than or equal to a value" },
      { name: "matches", description: "Tests if a field matches a case insensitive regex" },
      { name: "regex", description: "Tests if a field matches a case insensitive regex" },
      { name: "doesnt_match", description: "Tests if a field does not match a case insensitive regex" },
      { name: "is_alpha", description: "Tests if a field contains only alphabetical characters" },
      { name: "is_numeric", description: "Tests if a field contains only numeric characters" },
      { name: "is_alpha_numeric", description: "Tests if a field contains only alpha-numeric characters" },
      { name: "is_url", description: "Tests if a field is a valid URL" },
      { name: "is_embeddable", description: "Tests if a field is an embeddable video URL" },
      { name: "is_email", description: "Tests if a field is a valid email address" },
      { name: "is_after", description: "Tests if a field is after a given date" },
      { name: "is_before", description: "Tests if a field is before a given date" }
    ];
  }
});

// server/src/suggestions/defaults/conditionItems.ts
function getConditionCompletionItems(request) {
  const items = [];
  const range = {
    start: {
      line: request.position.line,
      character: request.position.character - request.originalLeftWord.length
    },
    end: request.position
  };
  for (let i = 0; i < StringConditionItems.length; i++) {
    const thisCondition = StringConditionItems[i];
    const snippet2 = request.originalLeftWord + thisCondition.name + '="$1"';
    items.push({
      label: thisCondition.name,
      insertTextFormat: import_vscode_languageserver_types4.InsertTextFormat.PlainText,
      kind: import_vscode_languageserver_types4.CompletionItemKind.Field
    });
  }
  return items;
}
var import_vscode_languageserver_types4;
var init_conditionItems = __esm({
  "server/src/suggestions/defaults/conditionItems.ts"() {
    "use strict";
    import_vscode_languageserver_types4 = __toESM(require_main2());
    init_stringConditions();
  }
});

// server/src/antlers/unclosedTagManager.ts
var UnclosedTagManager;
var init_unclosedTagManager = __esm({
  "server/src/antlers/unclosedTagManager.ts"() {
    "use strict";
    UnclosedTagManager = class {
      static clear(documentUri) {
        this.unclosedNodes.delete(documentUri);
      }
      static registerNodes(documentUri, nodes) {
        this.unclosedNodes.set(documentUri, nodes);
      }
      static getUnclosedTags(documentUri, position) {
        var _a, _b, _c;
        const nodesToReturn = [];
        if (this.unclosedNodes.has(documentUri) == false) {
          return nodesToReturn;
        }
        const docNodes = this.unclosedNodes.get(documentUri);
        if (docNodes.length == 0) {
          return nodesToReturn;
        }
        const checkLine = position.line + 1;
        for (let i = 0; i < docNodes.length; i++) {
          const thisNode = docNodes[i];
          if (((_a = thisNode.endPosition) == null ? void 0 : _a.line) == checkLine && position.character > thisNode.endPosition.char) {
            nodesToReturn.push(thisNode);
          } else if (checkLine > ((_c = (_b = thisNode.endPosition) == null ? void 0 : _b.line) != null ? _c : 0)) {
            nodesToReturn.push(thisNode);
          }
        }
        return nodesToReturn;
      }
      static hasUnclosedTags(documentUri, position) {
        if (this.unclosedNodes.has(documentUri) == false) {
          return false;
        }
        const unclosedNodes = this.getUnclosedTags(documentUri, position);
        return unclosedNodes.length > 0;
      }
    };
    UnclosedTagManager.unclosedNodes = /* @__PURE__ */ new Map();
  }
});

// server/src/antlers/variables/contentVariables.ts
function makeContentVariables(symbol) {
  return [
    { name: "edit_url", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "id", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "last_modified", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "permalink", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "published", dataType: "boolean", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "slug", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "template", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "url", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol }
  ];
}
var init_contentVariables = __esm({
  "server/src/antlers/variables/contentVariables.ts"() {
    "use strict";
  }
});

// server/src/suggestions/comments/documentPropertySuggestions.ts
var import_vscode_languageserver, DocumentPropertySuggestions;
var init_documentPropertySuggestions = __esm({
  "server/src/suggestions/comments/documentPropertySuggestions.ts"() {
    "use strict";
    import_vscode_languageserver = __toESM(require_main4());
    DocumentPropertySuggestions = [
      { label: "name", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "description", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "desc", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "entry", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "collection", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "blueprint", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "var", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "set", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "param", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "param*", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "front", kind: import_vscode_languageserver.CompletionItemKind.Property },
      { label: "format", kind: import_vscode_languageserver.CompletionItemKind.Property }
    ];
  }
});

// server/src/suggestions/defaults/languageConstructs.ts
var import_vscode_languageserver_types5, LanguageConstructs;
var init_languageConstructs = __esm({
  "server/src/suggestions/defaults/languageConstructs.ts"() {
    "use strict";
    import_vscode_languageserver_types5 = __toESM(require_main2());
    LanguageConstructs = [
      { label: "if", kind: import_vscode_languageserver_types5.CompletionItemKind.Keyword },
      { label: "elseif", kind: import_vscode_languageserver_types5.CompletionItemKind.Keyword },
      { label: "else", kind: import_vscode_languageserver_types5.CompletionItemKind.Keyword }
    ];
  }
});

// server/src/suggestions/genericTypesSuggestions.ts
var import_vscode_languageserver2, import_vscode_languageserver_types6;
var init_genericTypesSuggestions = __esm({
  "server/src/suggestions/genericTypesSuggestions.ts"() {
    "use strict";
    import_vscode_languageserver2 = __toESM(require_main4());
    import_vscode_languageserver_types6 = __toESM(require_main2());
    init_modifierManager();
  }
});

// server/src/suggestions/defaults/booleanItems.ts
var import_vscode_languageserver_types7, BooleanCompletionItems;
var init_booleanItems = __esm({
  "server/src/suggestions/defaults/booleanItems.ts"() {
    "use strict";
    import_vscode_languageserver_types7 = __toESM(require_main2());
    BooleanCompletionItems = [];
    BooleanCompletionItems.push({ label: "true", kind: import_vscode_languageserver_types7.CompletionItemKind.Keyword });
    BooleanCompletionItems.push({ label: "false", kind: import_vscode_languageserver_types7.CompletionItemKind.Keyword });
  }
});

// server/src/suggestions/parameterSuggestionProvider.ts
var init_parameterSuggestionProvider = __esm({
  "server/src/suggestions/parameterSuggestionProvider.ts"() {
    "use strict";
    init_booleanItems();
  }
});

// server/src/antlers/variables/arrayVariables.ts
function makeArrayVariables(symbol) {
  return [
    { sourceName: "*internal.array", sourceField: null, dataType: "*", name: "value", introducedBy: symbol },
    { sourceName: "*internal.array", sourceField: null, dataType: "*", name: "key", introducedBy: symbol }
  ];
}
var init_arrayVariables = __esm({
  "server/src/antlers/variables/arrayVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/fieldtypes/core/arrayFieldType.ts
var ArrayFieldType, arrayFieldType_default;
var init_arrayFieldType = __esm({
  "server/src/antlers/fieldtypes/core/arrayFieldType.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    ArrayFieldType = {
      name: "array",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    arrayFieldType_default = ArrayFieldType;
  }
});

// server/src/antlers/variables/assetVariables.ts
function makeAssetVariables(symbol) {
  return [
    { name: "id", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "title", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "path", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "filename", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "basename", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "extension", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_asset", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_audio", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_previewable", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_image", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_video", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "edit_url", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "url", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "permalink", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_bytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_gigabytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_kilobytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_megabytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_b", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_kb", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_mb", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_gb", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "focus", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "focus_css", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "height", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "width", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "orientation", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "ratio", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "mime_type", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "duration", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "duration_seconds", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "duration_sec", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "playtime", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol }
  ];
}
var init_assetVariables = __esm({
  "server/src/antlers/variables/assetVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/fieldtypes/core/assetsFieldType.ts
var AssetsFieldType, assetsFieldType_default;
var init_assetsFieldType = __esm({
  "server/src/antlers/fieldtypes/core/assetsFieldType.ts"() {
    "use strict";
    init_arrayVariables();
    init_assetVariables();
    AssetsFieldType = {
      name: "assets",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeAssetVariables(symbol));
      }
    };
    assetsFieldType_default = AssetsFieldType;
  }
});

// server/src/antlers/fieldtypes/core/bardFieldType.ts
var BardFieldType, bardFieldType_default;
var init_bardFieldType = __esm({
  "server/src/antlers/fieldtypes/core/bardFieldType.ts"() {
    "use strict";
    BardFieldType = {
      name: "bard",
      augmentScope: (symbol, scope) => {
        scope.addVariable({ name: "type", dataType: "string", sourceField: null, sourceName: "*internal.bard", introducedBy: symbol });
      },
      injectCompletions: (params, blueprintField, symbol) => {
        const items = [];
        return items;
      }
    };
    bardFieldType_default = BardFieldType;
  }
});

// server/src/antlers/fieldtypes/core/formMultiple.ts
var FormMultipleFieldtype, formMultiple_default;
var init_formMultiple = __esm({
  "server/src/antlers/fieldtypes/core/formMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    FormMultipleFieldtype = {
      name: "form_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    formMultiple_default = FormMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/listFieldType.ts
var ListFieldtype, listFieldType_default;
var init_listFieldType = __esm({
  "server/src/antlers/fieldtypes/core/listFieldType.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    ListFieldtype = {
      name: "list",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    listFieldType_default = ListFieldtype;
  }
});

// server/src/antlers/variables/replicatorVariables.ts
function makeReplicatorVariables(symbol) {
  return [
    { name: "type", dataType: "string", sourceName: "*internal.replicator", sourceField: null, introducedBy: symbol }
  ];
}
var init_replicatorVariables = __esm({
  "server/src/antlers/variables/replicatorVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/fieldtypes/core/replicatorFieldType.ts
var ReplicatorFieldtype, replicatorFieldType_default;
var init_replicatorFieldType = __esm({
  "server/src/antlers/fieldtypes/core/replicatorFieldType.ts"() {
    "use strict";
    init_loopVariables();
    init_replicatorVariables();
    ReplicatorFieldtype = {
      name: "replicator",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeReplicatorVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      },
      injectCompletions: (params, blueprintField, symbol) => {
        const items = [];
        return items;
      }
    };
    replicatorFieldType_default = ReplicatorFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/selectMultiple.ts
var SelectMultipleFieldtype, selectMultiple_default;
var init_selectMultiple = __esm({
  "server/src/antlers/fieldtypes/core/selectMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    SelectMultipleFieldtype = {
      name: "select_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    selectMultiple_default = SelectMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/sitesMultiple.ts
var SitesMultiple, sitesMultiple_default;
var init_sitesMultiple = __esm({
  "server/src/antlers/fieldtypes/core/sitesMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    SitesMultiple = {
      name: "sites_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    sitesMultiple_default = SitesMultiple;
  }
});

// server/src/antlers/fieldtypes/core/structuresMultiple.ts
var StructuresMultipleFieldtype, structuresMultiple_default;
var init_structuresMultiple = __esm({
  "server/src/antlers/fieldtypes/core/structuresMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    StructuresMultipleFieldtype = {
      name: "structures_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    structuresMultiple_default = StructuresMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/table.ts
var TableFieldtype, table_default;
var init_table = __esm({
  "server/src/antlers/fieldtypes/core/table.ts"() {
    "use strict";
    TableFieldtype = {
      name: "table",
      augmentScope: (symbol, scope) => {
        scope.addVariable({ name: "cells", dataType: "array", sourceName: "*internal.fieldtype.table", sourceField: null, introducedBy: symbol });
      }
    };
    table_default = TableFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/tagsFieldType.ts
var TagsFieldtype, tagsFieldType_default;
var init_tagsFieldType = __esm({
  "server/src/antlers/fieldtypes/core/tagsFieldType.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    TagsFieldtype = {
      name: "tags",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    tagsFieldType_default = TagsFieldtype;
  }
});

// server/src/antlers/variables/termVariables.ts
function makeTermVariables(symbol) {
  return makeContentVariables(symbol).concat([
    { name: "entries_count", dataType: "number", sourceName: "*internal.term", sourceField: null, introducedBy: symbol },
    { name: "is_term", dataType: "boolean", sourceName: "*internal.term", sourceField: null, introducedBy: symbol },
    { name: "taxonomy", dataType: "string", sourceName: "*internal.term", sourceField: null, introducedBy: symbol }
  ]);
}
var init_termVariables = __esm({
  "server/src/antlers/variables/termVariables.ts"() {
    "use strict";
    init_contentVariables();
  }
});

// server/src/antlers/fieldtypes/core/taxonomiesMultiple.ts
var TaxonomiesMultipleFieldtype, taxonomiesMultiple_default;
var init_taxonomiesMultiple = __esm({
  "server/src/antlers/fieldtypes/core/taxonomiesMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    init_termVariables();
    TaxonomiesMultipleFieldtype = {
      name: "taxonomies_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
        scope.addVariables(makeTermVariables(symbol));
      }
    };
    taxonomiesMultiple_default = TaxonomiesMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/termsMultiple.ts
var TermsMultipleFieldtype, termsMultiple_default;
var init_termsMultiple = __esm({
  "server/src/antlers/fieldtypes/core/termsMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    init_termVariables();
    TermsMultipleFieldtype = {
      name: "terms_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
        scope.addVariables(makeTermVariables(symbol));
      }
    };
    termsMultiple_default = TermsMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/userGroupsMultiple.ts
var UserGroupsMultipleFieldtype, userGroupsMultiple_default;
var init_userGroupsMultiple = __esm({
  "server/src/antlers/fieldtypes/core/userGroupsMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    UserGroupsMultipleFieldtype = {
      name: "user_groups_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    userGroupsMultiple_default = UserGroupsMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/userRolesMultiple.ts
var UserRolesMultipleFieldtype, userRolesMultiple_default;
var init_userRolesMultiple = __esm({
  "server/src/antlers/fieldtypes/core/userRolesMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    UserRolesMultipleFieldtype = {
      name: "user_roles_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    userRolesMultiple_default = UserRolesMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/usersMultiple.ts
var UsersMultipleFieldtype, usersMultiple_default;
var init_usersMultiple = __esm({
  "server/src/antlers/fieldtypes/core/usersMultiple.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    UsersMultipleFieldtype = {
      name: "users_multiple",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
        scope.injectBlueprint(symbol, "user");
      }
    };
    usersMultiple_default = UsersMultipleFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/yamlFieldType.ts
var YamlFieldtype, yamlFieldType_default;
var init_yamlFieldType = __esm({
  "server/src/antlers/fieldtypes/core/yamlFieldType.ts"() {
    "use strict";
    init_arrayVariables();
    init_loopVariables();
    YamlFieldtype = {
      name: "yaml",
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeArrayVariables(symbol));
        scope.addVariables(makeLoopVariables(symbol));
      }
    };
    yamlFieldType_default = YamlFieldtype;
  }
});

// server/src/antlers/fieldtypes/core/coreFieldtypes.ts
var CoreFieldtypes, coreFieldtypes_default;
var init_coreFieldtypes = __esm({
  "server/src/antlers/fieldtypes/core/coreFieldtypes.ts"() {
    "use strict";
    init_arrayFieldType();
    init_assetsFieldType();
    init_bardFieldType();
    init_formMultiple();
    init_listFieldType();
    init_replicatorFieldType();
    init_selectMultiple();
    init_sitesMultiple();
    init_structuresMultiple();
    init_table();
    init_tagsFieldType();
    init_taxonomiesMultiple();
    init_termsMultiple();
    init_userGroupsMultiple();
    init_userRolesMultiple();
    init_usersMultiple();
    init_yamlFieldType();
    CoreFieldtypes = [
      arrayFieldType_default,
      assetsFieldType_default,
      bardFieldType_default,
      formMultiple_default,
      listFieldType_default,
      replicatorFieldType_default,
      selectMultiple_default,
      sitesMultiple_default,
      structuresMultiple_default,
      yamlFieldType_default,
      table_default,
      taxonomiesMultiple_default,
      tagsFieldType_default,
      termsMultiple_default,
      usersMultiple_default,
      userGroupsMultiple_default,
      userRolesMultiple_default
    ];
    coreFieldtypes_default = CoreFieldtypes;
  }
});

// server/src/antlers/fieldtypes/fieldtypeManager.ts
var FieldtypeManager, fieldtypeManager_default;
var init_fieldtypeManager = __esm({
  "server/src/antlers/fieldtypes/fieldtypeManager.ts"() {
    "use strict";
    init_coreFieldtypes();
    FieldtypeManager = class {
      constructor() {
        this.fieldTypes = /* @__PURE__ */ new Map();
      }
      getFieldTypes() {
        return this.fieldTypes;
      }
      getFieldType(name) {
        return this.fieldTypes.get(name);
      }
      registerFieldtypes(types2) {
        for (let i = 0; i < types2.length; i++) {
          this.fieldTypes.set(types2[i].name, types2[i]);
        }
      }
      loadCoreFieldtypes() {
        this.registerFieldtypes(coreFieldtypes_default);
      }
      hasFieldtype(name) {
        return this.fieldTypes.has(name);
      }
    };
    FieldtypeManager.instance = null;
    if (typeof FieldtypeManager.instance == "undefined" || FieldtypeManager.instance == null) {
      FieldtypeManager.instance = new FieldtypeManager();
      FieldtypeManager.instance.loadCoreFieldtypes();
    }
    fieldtypeManager_default = FieldtypeManager;
  }
});

// server/src/suggestions/scopeVariableSuggestionsManager.ts
var init_scopeVariableSuggestionsManager = __esm({
  "server/src/suggestions/scopeVariableSuggestionsManager.ts"() {
    "use strict";
    init_fieldtypeManager();
  }
});

// server/src/suggestions/suggestionManager.ts
function getCurrentSymbolMethodNameValue(params) {
  let valueToReturnn = "";
  if (params.currentNode != null) {
    valueToReturnn = params.currentNode.getMethodNameValue();
  }
  return valueToReturnn;
}
function getRoot(word) {
  if (word.includes(":") == false) {
    return word;
  }
  const parts = word.split(":");
  if (parts.length > 1) {
    return parts[parts.length - 1];
  }
  return parts[0].trim();
}
function getAbsoluteRoot(word) {
  if (word.includes(":") == false) {
    return word;
  }
  return word.split(":")[0];
}
function convertImmediateScopeToCompletionList(params) {
  var _a;
  if (params.nodesInScope.length == 0) {
    return [];
  }
  let lastScopeItem = params.nodesInScope[params.nodesInScope.length - 1];
  if (((_a = params.context) == null ? void 0 : _a.node) != null) {
    lastScopeItem = params.context.node;
  }
  if (lastScopeItem.currentScope == null) {
    return [];
  }
  return convertScopeToCompletionList(params, lastScopeItem.currentScope);
}
function convertScopeToCompletionList(params, scope) {
  const items = [];
  scope.values.forEach((val) => {
    var _a;
    if (val.sourceField != null) {
      items.push({
        label: val.name,
        detail: val.sourceField.blueprintName,
        documentation: (_a = val.sourceField.instructionText) != null ? _a : "",
        kind: import_vscode_languageserver_protocol.CompletionItemKind.Field
      });
    } else {
      items.push(makeFieldSuggest(val.name, "", ""));
    }
    if (val.dataType.trim().length > 0 && val.dataType == "array") {
      const arrayCompleteSnippet = val.name + " }}\n    $1\n{{ /" + val.name + " ", range = {
        start: {
          line: params.position.line,
          character: params.position.character - params.originalLeftWord.length
        },
        end: params.position
      };
      items.push({
        label: val.name + " loop",
        insertTextFormat: import_vscode_languageserver_protocol.InsertTextFormat.Snippet,
        kind: import_vscode_languageserver_protocol.CompletionItemKind.Snippet,
        textEdit: import_vscode_languageserver_protocol.TextEdit.replace(range, arrayCompleteSnippet),
        command: {
          title: "Suggest",
          command: "editor.action.triggerSuggest"
        }
      });
    }
  });
  scope.lists.forEach((val, key) => {
    items.push(makeFieldSuggest(key, "", ""));
  });
  return items;
}
var import_vscode_languageserver_protocol;
var init_suggestionManager = __esm({
  "server/src/suggestions/suggestionManager.ts"() {
    "use strict";
    import_vscode_languageserver_protocol = __toESM(require_main3());
    init_modifierManager();
    init_tagManagerInstance();
    init_unclosedTagManager();
    init_contentVariables();
    init_abstractNode();
    init_strings();
    init_documentPropertySuggestions();
    init_languageConstructs();
    init_fieldFormatter();
    init_genericTypesSuggestions();
    init_parameterSuggestionProvider();
    init_scopeVariableSuggestionsManager();
    init_projectManager();
  }
});

// server/src/antlers/documentedLabel.ts
function tagToCompletionItem(tag) {
  let docs = "";
  if (typeof tag !== "undefined" && typeof tag.resolveDocumentation !== "undefined" && tag.resolveDocumentation != null) {
    docs = tag.resolveDocumentation();
  }
  let completionLabel = tag.tagName;
  if (completionLabel.includes(":")) {
    const parts = completionLabel.split(":");
    completionLabel = parts[parts.length - 1];
  }
  return {
    label: completionLabel,
    kind: import_vscode_languageserver3.CompletionItemKind.Text,
    sortText: "1",
    documentation: {
      kind: "markdown",
      value: docs
    }
  };
}
var import_vscode_languageserver3;
var init_documentedLabel = __esm({
  "server/src/antlers/documentedLabel.ts"() {
    "use strict";
    import_vscode_languageserver3 = __toESM(require_main4());
  }
});

// server/src/antlers/htmlCompat/parameters.ts
function makeHtmlParam(name, description, mdnReference) {
  return {
    name,
    acceptsVariableInterpolation: true,
    aliases: [],
    allowsVariableReference: true,
    description,
    expectsTypes: ["string"],
    isDynamic: true,
    isRequired: false,
    documentationLink: mdnReference,
    docLinkName: "MDN Reference"
  };
}
var HtmlClassParameter, HtmlStyleParameter;
var init_parameters2 = __esm({
  "server/src/antlers/htmlCompat/parameters.ts"() {
    "use strict";
    HtmlClassParameter = makeHtmlParam(
      "class",
      "A space-separated list of the classes of the element.",
      "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class"
    );
    HtmlStyleParameter = makeHtmlParam(
      "style",
      "Contains CSS styling declarations to be applied to the element. Note that it is recommended for styles to be defined in a separate file or files.",
      "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/style"
    );
  }
});

// server/src/antlers/tagManager.ts
function dynamicParameter(name) {
  if (name == "class") {
    return HtmlClassParameter;
  } else if (name == "style") {
    return HtmlStyleParameter;
  }
  return {
    name,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    description: "",
    expectsTypes: ["string", "number", "array"],
    isRequired: false,
    isDynamic: true
  };
}
function resultList(items) {
  const completionItems = [];
  for (let i = 0; i < items.length; i++) {
    completionItems.push({
      label: items[i],
      kind: import_vscode_languageserver_types8.CompletionItemKind.Field
    });
  }
  return exclusiveResult(completionItems);
}
function exclusiveResultList(items) {
  const completionItems = [];
  for (let i = 0; i < items.length; i++) {
    completionItems.push({
      label: items[i],
      kind: import_vscode_languageserver_types8.CompletionItemKind.Field
    });
  }
  return exclusiveResult(completionItems);
}
function exclusiveResult(items) {
  return {
    items,
    isExclusiveResult: true,
    analyzeDefaults: false
  };
}
function nonExclusiveResult(items) {
  return {
    items,
    isExclusiveResult: false,
    analyzeDefaults: true
  };
}
var import_vscode_languageserver_types8, EmptyCompletionResult;
var init_tagManager = __esm({
  "server/src/antlers/tagManager.ts"() {
    "use strict";
    import_vscode_languageserver_types8 = __toESM(require_main2());
    init_parameters2();
    EmptyCompletionResult = {
      items: [],
      isExclusiveResult: false,
      analyzeDefaults: true
    };
  }
});

// server/src/antlers/tags/alias.ts
function createDefinitionAlias(tag, alias) {
  const tagCopy = copyTagDefinition(tag);
  tagCopy.tagName = alias;
  return tagCopy;
}
function copyTagDefinition(tag) {
  return {
    allowsArbitraryParameters: tag.allowsArbitraryParameters,
    allowsContentClose: tag.allowsContentClose,
    injectParentScope: tag.injectParentScope,
    parameters: tag.parameters,
    requiresClose: tag.requiresClose,
    tagName: tag.tagName,
    introducedIn: tag.introducedIn,
    hideFromCompletions: tag.hideFromCompletions,
    augmentScope: tag.augmentScope,
    requiresCloseResolver: tag.requiresCloseResolver,
    resolveCompletionItems: tag.resolveCompletionItems,
    resolveDynamicParameter: tag.resolveDynamicParameter,
    resolveSpecialType: tag.resolveSpecialType,
    resovleParameterCompletionItems: tag.resovleParameterCompletionItems,
    suggestAlternativeParams: tag.suggestAlternativeParams,
    resolveDocumentation: tag.resolveDocumentation
  };
}
var init_alias = __esm({
  "server/src/antlers/tags/alias.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags.ts
function getScopeName(node) {
  return node.findParameterValueOrNull("scope");
}
function resolveTypedTree(document) {
  const docNodes = document.getAllNodes();
  docNodes.forEach((node) => {
    if (node instanceof AntlersNode) {
      if (node.manifestType === "array") {
        node.mustClose = true;
      }
    }
  });
}
var init_tags = __esm({
  "server/src/antlers/tags.ts"() {
    "use strict";
    init_abstractNode();
  }
});

// server/src/antlers/tags/core/collection/resolvesCollectionScope.ts
function getAliasName(node) {
  return node.findParameterValueOrNull("as");
}
function getCollectionName(node, statamicProject) {
  let collectionNames = [];
  if (node.hasMethodPart()) {
    const methodNameValue = node.getMethodNameValue();
    if (BuiltInCollectionMethods.includes(methodNameValue) == false) {
      collectionNames.push(methodNameValue);
      return collectionNames;
    }
  }
  const fromParam = node.findAnyParameter(CollectionSourceParams), restrictParam = node.findAnyParameter(CollectionRestrictionParams);
  let fromList = [], notInList = [];
  if (typeof fromParam !== "undefined" && fromParam !== null) {
    if (fromParam.value.trim() === "*") {
      fromList = statamicProject.getUniqueCollectionNames();
      if (typeof restrictParam !== "undefined" && restrictParam !== null) {
        if (restrictParam.isVariableReference == false && restrictParam.hasInterpolations() == false) {
          notInList = restrictParam.getArrayValue();
        }
      }
    } else {
      if (fromParam.isVariableReference == false && fromParam.hasInterpolations() == false) {
        fromList = fromParam.getArrayValue();
      }
    }
  }
  if (notInList.length > 0) {
    collectionNames = fromList.filter(function(n) {
      return notInList.includes(n) == false;
    });
  } else {
    collectionNames = fromList;
  }
  return collectionNames;
}
function resolveCollectionScope(symbol, project) {
  var _a, _b, _c, _d, _e, _f;
  const collectionNames = getCollectionName(symbol, project);
  let isAliased = false, isPaginated = false, isScoped = false, scopeName = null, aliasName = "";
  if (symbol.isClosingTag == false) {
    const alias = getAliasName(symbol), scope = getScopeName(symbol);
    if (alias != null) {
      isAliased = true;
      aliasName = alias;
    }
    if (scope != null) {
      isScoped = true;
      scopeName = scope;
    }
    isPaginated = symbol.hasParameter("paginate");
  }
  const collectionScope = {
    collectionNames: collectionNames != null ? collectionNames : [],
    endPosition: (_b = (_a = symbol.endPosition) == null ? void 0 : _a.char) != null ? _b : 0,
    aliasName,
    isAliased,
    isScoped,
    scopeName,
    isStartOfScope: !symbol.isClosingTag,
    line: (_d = (_c = symbol.startPosition) == null ? void 0 : _c.line) != null ? _d : 0,
    startPosition: (_f = (_e = symbol.startPosition) == null ? void 0 : _e.char) != null ? _f : 0,
    isPaginated,
    excludeCollections: [],
    includeCollections: []
  };
  return {
    context: collectionScope,
    issues: []
  };
}
var BuiltInCollectionMethods;
var init_resolvesCollectionScope = __esm({
  "server/src/antlers/tags/core/collection/resolvesCollectionScope.ts"() {
    "use strict";
    init_tags();
    init_parameters();
    BuiltInCollectionMethods = ["count", "next", "previous"];
  }
});

// server/src/antlers/tags/core/collection/resolvesConditionalParameters.ts
function resolveConditionalParmaters(symbol, paramName) {
  if (symbol == null) {
    return null;
  }
  let checkName = trimLeft(paramName, ":");
  if (checkName.includes(":")) {
    checkName = checkName.split(":")[0];
  }
  if (checkName == "status" || checkName == "taxonomy" || symbol.currentScope != null && symbol.currentScope.containsReference(checkName)) {
    return dynamicParameter(paramName);
  }
  return null;
}
var init_resolvesConditionalParameters = __esm({
  "server/src/antlers/tags/core/collection/resolvesConditionalParameters.ts"() {
    "use strict";
    init_strings();
    init_tagManager();
  }
});

// server/src/antlers/tags/core/collection/resolvesParameterSuggestions.ts
function resolveCollectionParameterCompletiontems(parameter, params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  if (parameter.isDynamic) {
    const checkName = getAbsoluteRoot(parameter.name);
    if (params.nodesInScope.length > 0) {
      const lastSymbolInScope = params.nodesInScope[params.nodesInScope.length - 1];
      if (lastSymbolInScope != null && lastSymbolInScope.currentScope != null) {
        const blueprintFields = getCollectionBlueprintFields(lastSymbolInScope, lastSymbolInScope.currentScope), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
        if (fieldNames.includes(rootLeft)) {
          return exclusiveResult(getConditionCompletionItems(params));
        }
      }
    }
    if (checkName == "status") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeStatusSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : []));
      }
    }
    if (checkName == "taxonomy") {
      const taxonomyName = getRoot(parameter.name);
      if (params.project.hasTaxonomy(taxonomyName)) {
        if (((_d = params.context) == null ? void 0 : _d.parameterContext) != null) {
          return exclusiveResult(makeTaxonomySuggestions((_f = (_e = params.context.parameterContext.parameter) == null ? void 0 : _e.getArrayValue()) != null ? _f : [], taxonomyName, params.project));
        }
      }
    }
  }
  if (parameter.name == "filter" || parameter.name == "query_scope") {
    return exclusiveResult(makeQueryScopeSuggestions(params.project));
  }
  if (params.nodesInScope.length > 0) {
    const lastSymbolInScope = params.nodesInScope[params.nodesInScope.length - 1];
    if (lastSymbolInScope.hasMethodPart()) {
      if (singleCollectionTagActivators.includes(lastSymbolInScope.getMethodNameValue())) {
        if (singleCollectionParamNames.includes(parameter.name)) {
          return exclusiveResult(makeSingleCollectionNameSuggestions(params.project));
        }
      }
    }
  }
  if (collectionParamNames.includes(parameter.name)) {
    if (((_g = params.context) == null ? void 0 : _g.parameterContext) != null) {
      return exclusiveResult(makeCollectionNameSuggestions((_j = (_i = (_h = params.context) == null ? void 0 : _h.parameterContext.parameter) == null ? void 0 : _i.getArrayValue()) != null ? _j : [], params.project));
    }
  }
  return null;
}
var collectionParamNames, singleCollectionTagActivators, singleCollectionParamNames;
var init_resolvesParameterSuggestions = __esm({
  "server/src/antlers/tags/core/collection/resolvesParameterSuggestions.ts"() {
    "use strict";
    init_conditionItems();
    init_suggestionManager();
    init_tagManager();
    init_utils2();
    collectionParamNames = [
      "from",
      "folder",
      "use",
      "not_from",
      "not_folder"
    ];
    singleCollectionTagActivators = ["previous", "next"];
    singleCollectionParamNames = [
      "in",
      "collection"
    ];
  }
});

// server/src/antlers/tags/core/collection/previous.ts
var CollectionPrevious, previous_default;
var init_previous = __esm({
  "server/src/antlers/tags/core/collection/previous.ts"() {
    "use strict";
    init_utils();
    init_alternateParamSuggestions();
    init_augmentCollectionScope();
    init_parameters();
    init_resolveCollectionCompletions();
    init_resolvesCollectionScope();
    init_resolvesConditionalParameters();
    init_resolvesParameterSuggestions();
    CollectionPrevious = {
      tagName: "collection:previous",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [
        ...collectionParameters,
        {
          name: "in",
          aliases: ["collection"],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The collection to search in",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "current",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Sets the current entry by ID",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        }
      ],
      augmentScope: augmentCollectionScope,
      resolveDynamicParameter: resolveConditionalParmaters,
      resolveSpecialType: resolveCollectionScope,
      suggestAlternativeParams: suggestAlternativeCollectionParams,
      resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
      resolveCompletionItems: resolveCollectionCompletions,
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "collection:previous Tag",
          "The `collection:previous` tag is used to show the entries that appear before the current entry, based on some entry order (publish date, alphabetical, or manual).",
          `{{# Retrieve the previous two entries, based on dates in ascending order. #}}
{{ collection:previous in="articles" limit="2" sort="date:asc" }}

{{ /collection:previous }}`,
          "https://statamic.dev/tags/collection-previous"
        );
      }
    };
    previous_default = CollectionPrevious;
  }
});

// server/src/antlers/tags/core/collection/ageDirectional.ts
var CollectionOlder, CollectionNewer;
var init_ageDirectional = __esm({
  "server/src/antlers/tags/core/collection/ageDirectional.ts"() {
    "use strict";
    init_alias();
    init_previous();
    CollectionOlder = createDefinitionAlias(previous_default, "collection:older");
    CollectionNewer = createDefinitionAlias(previous_default, "collection:newer");
  }
});

// server/src/antlers/tags/core/collection/count.ts
var CollectionCount, count_default;
var init_count = __esm({
  "server/src/antlers/tags/core/collection/count.ts"() {
    "use strict";
    init_utils();
    init_parameters();
    init_resolvesCollectionScope();
    init_resolvesParameterSuggestions();
    CollectionCount = {
      tagName: "collection:count",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [
        ...collectionParameters,
        {
          isRequired: true,
          name: "in",
          aliases: ["from"],
          description: "The collection from which to count entries",
          acceptsVariableInterpolation: true,
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resolveSpecialType: resolveCollectionScope,
      resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "collection:count Tag",
          "The `collection:count` tag returns the total number of entries in the specified collection(s). The collection count tag accepts the same parameters as the collection tag, allowing developers to count entries that meet specific conditions.",
          `Total entry count: {{ collection:count in="collection-name" }}
Draft count: {{ collection:count in="collection-name" status:in="draft" }}`,
          "https://statamic.dev/tags/collection-count"
        );
      }
    };
    count_default = CollectionCount;
  }
});

// server/src/antlers/tags/core/collection/next.ts
var CollectionNext, next_default;
var init_next = __esm({
  "server/src/antlers/tags/core/collection/next.ts"() {
    "use strict";
    init_utils();
    init_alternateParamSuggestions();
    init_augmentCollectionScope();
    init_parameters();
    init_resolveCollectionCompletions();
    init_resolvesCollectionScope();
    init_resolvesConditionalParameters();
    init_resolvesParameterSuggestions();
    CollectionNext = {
      tagName: "collection:next",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [
        ...collectionParameters,
        {
          name: "in",
          aliases: ["collection"],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The collection to search in",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "current",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Sets the current entry by ID",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        }
      ],
      augmentScope: augmentCollectionScope,
      resolveDynamicParameter: resolveConditionalParmaters,
      resolveSpecialType: resolveCollectionScope,
      suggestAlternativeParams: suggestAlternativeCollectionParams,
      resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
      resolveCompletionItems: resolveCollectionCompletions,
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "collection:next Tag",
          "The `collection:next` tag is used to show the entries that will appear after the current entry, based on some entry order (publish date, alphabetical, or manual).",
          `{{# Retrieve the next two entries, based on dates in ascending order. #}}
{{ collection:next in="articles" limit="2" sort="date:asc" }}

{{ /collection:next }}`,
          "https://statamic.dev/tags/collection-next"
        );
      }
    };
    next_default = CollectionNext;
  }
});

// server/src/antlers/tags/core/collection/resolveCollectionCompletions.ts
function resolveCollectionCompletions(params) {
  var _a, _b;
  let items = [];
  if (params.isPastTagPart == false && (params.leftWord == "collection" || params.leftWord == "/collection") && params.leftChar == ":") {
    const collectionNames = params.project.getCollectionNames();
    for (let i = 0; i < collectionNames.length; i++) {
      items.push({
        label: collectionNames[i],
        kind: import_vscode_languageserver4.CompletionItemKind.Field,
        sortText: "0"
      });
    }
    items.push(tagToCompletionItem(count_default));
    items.push(tagToCompletionItem(next_default));
    items.push(tagToCompletionItem(previous_default));
    items.push(tagToCompletionItem(CollectionOlder));
    items.push(tagToCompletionItem(CollectionNewer));
    return {
      items,
      analyzeDefaults: false,
      isExclusiveResult: false
    };
  }
  if (params.currentNode != null && params.currentNode.currentScope != null) {
    const blueprintFields = getCollectionBlueprintFields(params.currentNode, params.currentNode.currentScope), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
    if (rootLeft === "taxonomy") {
      return exclusiveResult(getTaxonomyCompletionItems(params));
    }
    if (fieldNames.includes(rootLeft)) {
      items = getConditionCompletionItems(params);
      return exclusiveResult(items);
    }
    if (params.isCaretInTag && !((_a = params.context) == null ? void 0 : _a.isInParameter) && ["collection", "/collection"].includes(params.leftWord) == false && params.leftChar != " ") {
      const addedNames = [];
      for (let i = 0; i < blueprintFields.length; i++) {
        const thisField = blueprintFields[i];
        if (addedNames.includes(thisField.name) == false) {
          items.push({
            label: thisField.name,
            detail: thisField.blueprintName,
            documentation: (_b = thisField.instructionText) != null ? _b : "",
            kind: import_vscode_languageserver4.CompletionItemKind.Field
          });
          addedNames.push(thisField.name);
        }
      }
      items.push({
        label: "taxonomy",
        insertText: "taxonomy:",
        kind: import_vscode_languageserver4.CompletionItemKind.Field
      });
      items.push({
        label: "status",
        insertText: "status:",
        kind: import_vscode_languageserver4.CompletionItemKind.Field
      });
      if (items.length > 0) {
        return nonExclusiveResult(items);
      }
    }
  }
  return EmptyCompletionResult;
}
var import_vscode_languageserver4;
var init_resolveCollectionCompletions = __esm({
  "server/src/antlers/tags/core/collection/resolveCollectionCompletions.ts"() {
    "use strict";
    import_vscode_languageserver4 = __toESM(require_main4());
    init_conditionItems();
    init_suggestionManager();
    init_documentedLabel();
    init_tagManager();
    init_ageDirectional();
    init_count();
    init_next();
    init_previous();
    init_utils2();
  }
});

// server/src/antlers/tags/core/collection/collection.ts
var Collection, collection_default;
var init_collection = __esm({
  "server/src/antlers/tags/core/collection/collection.ts"() {
    "use strict";
    init_utils();
    init_alternateParamSuggestions();
    init_augmentCollectionScope();
    init_parameters();
    init_resolveCollectionCompletions();
    init_resolvesCollectionScope();
    init_resolvesConditionalParameters();
    init_resolvesParameterSuggestions();
    Collection = {
      tagName: "collection",
      hideFromCompletions: false,
      introducedIn: null,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      parameters: collectionParameters,
      augmentScope: augmentCollectionScope,
      resolveDynamicParameter: resolveConditionalParmaters,
      resolveSpecialType: resolveCollectionScope,
      suggestAlternativeParams: suggestAlternativeCollectionParams,
      resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
      resolveCompletionItems: resolveCollectionCompletions,
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "collection Tag",
          "The `collection` tag provides access to entry data such as blog posts, products, etc.",
          `{{ collection:articles as="posts" }}

	{{ posts }}
		{{ title }}
	{{ /posts }}

{{ /collection:articles }}`,
          "https://statamic.dev/tags/collection"
        );
      }
    };
    collection_default = Collection;
  }
});

// server/src/antlers/tags/core/cache.ts
var Cache, cache_default;
var init_cache = __esm({
  "server/src/antlers/tags/core/cache.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    Cache = {
      tagName: "cache",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      resovleParameterCompletionItems: (parameter, params) => {
        if (parameter.name == "scope") {
          return exclusiveResultList(["page", "site", "user"]);
        }
        return null;
      },
      parameters: [
        {
          isRequired: false,
          name: "for",
          description: "The duration the cache is valid for.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "key",
          description: "An arbitrary name the cache entry may be referenced by.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "scope",
          description: " The scope of the cached value. Either site or page.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resolveSpecialType: (node, project) => {
        const keyParameter = node.findParameter("key");
        let cacheContext = null;
        if (keyParameter != null) {
          const cacheKeyValue = keyParameter.value;
          if (cacheKeyValue.trim().length > 0) {
            cacheContext = {
              key: cacheKeyValue,
              reference: node
            };
          }
        }
        return {
          context: cacheContext,
          issues: []
        };
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "cache Tag",
          "The `cache` tag can be used to save the results of an expensive template operation. The duration of the cache can be configured.",
          `{{ cache for="10 minutes" }}
    {{# Template code that won't be re-rendered for at least 10 minutes. #}}
{{ /cache }}`,
          "https://statamic.dev/tags/cache"
        );
      }
    };
    cache_default = Cache;
  }
});

// server/src/antlers/tags/core/dump.ts
var Dump, dump_default;
var init_dump = __esm({
  "server/src/antlers/tags/core/dump.ts"() {
    "use strict";
    init_utils();
    init_suggestionManager();
    init_tagManager();
    Dump = {
      tagName: "dump",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [],
      resolveCompletionItems: (params) => {
        if (params.leftWord == "dump" && params.leftChar == ":") {
          return exclusiveResult(convertImmediateScopeToCompletionList(params));
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "dump Tag",
          "The `dump` tag is a useful tag for debugging, and will display the raw data available at the point the tag is rendered.",
          `{{ collection:articles }}
	{{# View all data available, for each entry. #}}
    {{ dump }}
{{ /collection:articles }}`,
          "https://statamic.dev/tags/dump"
        );
      }
    };
    dump_default = Dump;
  }
});

// server/src/antlers/tags/core/error404.ts
var Error404, error404_default;
var init_error404 = __esm({
  "server/src/antlers/tags/core/error404.ts"() {
    "use strict";
    init_utils();
    Error404 = {
      tagName: "404",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "404 (Not Found) Tag",
          "The `404` (Not Found) tag will trigger a 404 status code, and display the 404 template to the site visitor.",
          `{{ unless logged_in }}
	{{# Display the 404 Not Found page. #}}
	{{ 404 }}
{{ /unless }}`,
          "https://statamic.dev/tags/404"
        );
      }
    };
    error404_default = Error404;
  }
});

// server/src/antlers/tags/core/link.ts
var Link, link_default;
var init_link = __esm({
  "server/src/antlers/tags/core/link.ts"() {
    "use strict";
    init_utils();
    Link = {
      tagName: "link",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [
        {
          name: "to",
          description: "The relative path",
          expectsTypes: ["string"],
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          isRequired: true,
          isDynamic: false
        },
        {
          name: "absolute",
          description: "Whether to generate absolute URLs. Default false",
          expectsTypes: ["boolean"],
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          isRequired: false,
          isDynamic: false
        },
        {
          name: "id",
          description: "The ID of the entry to link to",
          expectsTypes: ["string"],
          allowsVariableReference: true,
          acceptsVariableInterpolation: true,
          aliases: [],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "in",
          description: "The handle of the site to link to.",
          expectsTypes: ["string"],
          allowsVariableReference: true,
          acceptsVariableInterpolation: true,
          aliases: [],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "link Tag",
          "The `link` tag accepts relative URLs or entry IDs and generates fully-qualified URLs to the desired content.",
          "https://statamic.dev/tags/link"
        );
      }
    };
    link_default = Link;
  }
});

// server/src/antlers/tags/core/loop.ts
var Loop, RangeTag;
var init_loop = __esm({
  "server/src/antlers/tags/core/loop.ts"() {
    "use strict";
    init_utils();
    Loop = {
      tagName: "loop",
      hideFromCompletions: false,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      introducedIn: null,
      augmentScope: (node, scope) => {
        scope.addVariable({
          name: "value",
          dataType: "*",
          sourceName: "*internal.loop.value",
          sourceField: null,
          introducedBy: node
        });
        return scope;
      },
      parameters: [
        {
          name: "times",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["number"],
          description: "The number of iterations",
          isRequired: false,
          isDynamic: false
        },
        {
          name: "from",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["number"],
          description: "The value to start iterating from. Default 1",
          isRequired: false,
          isDynamic: false
        },
        {
          name: "to",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["number"],
          description: "The value to stop iterating at",
          isRequired: false,
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "loop Tag",
          "The `loop` tag is used to create an array of items between two values, and then iterate the created array. Alternatively, a max value can be set using the `times` parameter to loop that number of times.",
          "https://statamic.dev/tags/loop"
        );
      }
    };
    RangeTag = {
      tagName: "range",
      hideFromCompletions: false,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      introducedIn: null,
      augmentScope: (node, scope) => {
        scope.addVariable({
          name: "value",
          dataType: "*",
          sourceName: "*internal.loop.value",
          sourceField: null,
          introducedBy: node
        });
        return scope;
      },
      parameters: [
        {
          name: "times",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["number"],
          description: "The number of iterations",
          isRequired: false,
          isDynamic: false
        },
        {
          name: "from",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["number"],
          description: "The value to start iterating from. Default 1",
          isRequired: false,
          isDynamic: false
        },
        {
          name: "to",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["number"],
          description: "The value to stop iterating at",
          isRequired: false,
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "range Tag",
          "The `range` tag is used to create an array of items between two values, and then iterate the created array. Alternatively, a max value can be set using the `times` parameter to loop that number of times.",
          "https://statamic.dev/tags/loop"
        );
      }
    };
  }
});

// server/src/runtime/document/documentManager.ts
var DocumentManager, documentManager_default;
var init_documentManager = __esm({
  "server/src/runtime/document/documentManager.ts"() {
    "use strict";
    init_projectManager();
    init_antlersDocument();
    DocumentManager = class {
      constructor() {
        this.loadedDocuments = /* @__PURE__ */ new Map();
        this.activeProject = null;
      }
      getDocuments() {
        const docs = [];
        this.loadedDocuments.forEach((doc) => {
          docs.push(doc);
        });
        return docs;
      }
      setProject(project) {
        this.activeProject = project;
        this.loadedDocuments.forEach((document) => {
          if (this.activeProject != null) {
            document.updateProject(this.activeProject);
          }
        });
      }
      refreshDocumentState() {
        if (this.activeProject != null) {
          this.setProject(this.activeProject);
        }
      }
      hasDocument(uri) {
        return this.loadedDocuments.has(uri);
      }
      createDocument(uri) {
        if (!this.loadedDocuments.has(uri)) {
          const doc = new AntlersDocument();
          doc.documentUri = uri;
          this.loadedDocuments.set(uri, doc);
        }
      }
      loadDocument(uri, text) {
        this.loadedDocuments.set(uri, AntlersDocument.fromText(text));
      }
      getDocument(uri) {
        return this.loadedDocuments.get(uri);
      }
      updateDocument(uri, text) {
        var _a, _b;
        if (this.loadedDocuments.has(uri)) {
          const document = this.loadedDocuments.get(uri);
          document.loadString(text);
          const viewRef = (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.findView(uri);
          if (viewRef != null) {
            viewRef.document = document;
          }
        }
      }
      createOrUpdate(uri, text) {
        this.createDocument(uri);
        this.updateDocument(uri, text);
      }
      getDocumentErrors(uri) {
        if (!this.loadedDocuments.has(uri)) {
          return [];
        }
        const doc = this.loadedDocuments.get(uri);
        return doc.errors.all();
      }
    };
    DocumentManager.instance = null;
    if (typeof DocumentManager.instance == "undefined" || DocumentManager.instance == null) {
      DocumentManager.instance = new DocumentManager();
    }
    documentManager_default = DocumentManager;
  }
});

// server/src/languageService/documents.ts
var sessionDocuments;
var init_documents = __esm({
  "server/src/languageService/documents.ts"() {
    "use strict";
    init_documentManager();
    sessionDocuments = new documentManager_default();
  }
});

// server/src/antlers/tags/dynamicParameterResolver.ts
function returnDynamicParameter(node, paramName) {
  if (paramName.trim().length > 0) {
    return dynamicParameter(paramName);
  }
  return null;
}
var init_dynamicParameterResolver = __esm({
  "server/src/antlers/tags/dynamicParameterResolver.ts"() {
    "use strict";
    init_tagManager();
  }
});

// server/src/antlers/tags/core/partials/partialParameters.ts
var PartialParameters;
var init_partialParameters = __esm({
  "server/src/antlers/tags/core/partials/partialParameters.ts"() {
    "use strict";
    PartialParameters = [
      {
        isRequired: false,
        name: "src",
        description: "The name of the partial view.",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: [],
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "when",
        description: "A condition to control whether the partial renders. The partial will not render unless it receives a truthy value.",
        allowsVariableReference: true,
        acceptsVariableInterpolation: false,
        aliases: [],
        expectsTypes: ["*"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "unless",
        description: "A condition to control whether the partial renders. The partial will not render unless it receives a falsey value.",
        allowsVariableReference: true,
        acceptsVariableInterpolation: false,
        aliases: [],
        expectsTypes: ["*"],
        isDynamic: false
      }
    ];
  }
});

// server/src/antlers/tags/core/partials/resolvePartialParameterCompletions.ts
function resolvePartialParameterCompletions(parameter, params) {
  var _a;
  if (parameter.isDynamic) {
    if (params.currentNode != null && params.currentNode.getTagName() == "partial" && params.currentNode.hasMethodPart()) {
      const nodeMethodName = params.currentNode.getMethodNameValue();
      if (nodeMethodName.trim().length > 0) {
        if ((_a = projectManager_default.instance) == null ? void 0 : _a.hasStructure()) {
          const projectView = projectManager_default.instance.getStructure().findRelativeView(nodeMethodName);
          if (projectView != null && projectView.varReferenceNames.has(parameter.name)) {
            const viewDataRef = projectView.varReferenceNames.get(
              parameter.name
            );
            if (projectView.document != null) {
              if (projectView.document.hasFrontMatter()) {
                const frontMatterScope = projectView.document.getFrontMatterScope();
                if (frontMatterScope != null) {
                  const scopeRef = frontMatterScope.getList(viewDataRef);
                  if (scopeRef != null) {
                    return resultList(scopeRef.getVariableNames());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (parameter.name == "src") {
    const partials = params.project.getViews(), completionItems = [];
    partials.forEach((view) => {
      if (DocumentDetailsManager.hasDetails(view.documentUri)) {
        const partialDetails = DocumentDetailsManager.documentDetails.get(
          view.documentUri
        );
        completionItems.push({
          label: partialDetails.documentName + "(" + view.relativeDisplayName + ")",
          insertText: view.relativeDisplayName,
          detail: partialDetails.documentName,
          documentation: {
            kind: import_vscode_languageserver5.MarkupKind.Markdown,
            value: partialDetails.documentDescription
          },
          kind: import_vscode_languageserver5.CompletionItemKind.File
        });
      } else {
        completionItems.push({
          label: view.relativeDisplayName,
          kind: import_vscode_languageserver5.CompletionItemKind.File
        });
      }
    });
    return exclusiveResult(completionItems);
  }
  return null;
}
var import_vscode_languageserver5;
var init_resolvePartialParameterCompletions = __esm({
  "server/src/antlers/tags/core/partials/resolvePartialParameterCompletions.ts"() {
    "use strict";
    import_vscode_languageserver5 = __toESM(require_main4());
    init_documentDetailsManager();
    init_projectManager();
    init_tagManager();
  }
});

// server/src/antlers/tags/core/partials/partialExists.ts
var PartialExists, partialExists_default;
var init_partialExists = __esm({
  "server/src/antlers/tags/core/partials/partialExists.ts"() {
    "use strict";
    init_utils();
    init_partialParameters();
    init_resolvePartialParameterCompletions();
    PartialExists = {
      tagName: "partial:exists",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      parameters: PartialParameters,
      introducedIn: "3.2.7",
      resovleParameterCompletionItems: resolvePartialParameterCompletions,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "partial:exists Tag",
          "The `partial:exists` can be used within conditional statements to test if a partial exists.",
          "https://statamic.dev/tags/partial-exists"
        );
      }
    };
    partialExists_default = PartialExists;
  }
});

// server/src/antlers/tags/core/partials/partialIfExists.ts
var PartialIfExists, partialIfExists_default;
var init_partialIfExists = __esm({
  "server/src/antlers/tags/core/partials/partialIfExists.ts"() {
    "use strict";
    init_utils();
    init_partialParameters();
    init_resolvePartialParameterCompletions();
    PartialIfExists = {
      tagName: "partial:if_exists",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      parameters: PartialParameters,
      introducedIn: "3.2.7",
      resovleParameterCompletionItems: resolvePartialParameterCompletions,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "partial:if_exists Tag",
          "The `partial:if_exists` can be used to output the contents of a partial if it exists.",
          "https://statamic.dev/tags/partial-if-exists"
        );
      }
    };
    partialIfExists_default = PartialIfExists;
  }
});

// server/src/antlers/tags/core/partials/partialUtilities.ts
function getViewName(node) {
  if (node.getTagName() != "partial") {
    return null;
  }
  let partialName = "";
  if (node.hasMethodPart()) {
    partialName = node.getMethodNameValue();
  } else {
    const srcParam = node.findParameter("src");
    if (srcParam != null) {
      partialName = srcParam.value;
    }
  }
  return partialName;
}
var init_partialUtilities = __esm({
  "server/src/antlers/tags/core/partials/partialUtilities.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/partials/partial.ts
function getVariableNames(symbols) {
  const namesToReturn = [];
  symbols.forEach((symbol) => {
    if (symbol.isTagNode || symbol.isClosingTag) {
      return;
    }
    if (symbol.isComment) {
      return;
    }
    if (symbol.hasMethodPart() && symbol.getMethodNameValue().length > 0) {
      return;
    }
    if (symbol.name != null && symbol.name.content.includes("[")) {
      return;
    }
    const nodeTagName = symbol.getTagName();
    if (!namesToReturn.includes(nodeTagName) && nodeTagName != "#" && nodeTagName != "slot") {
      namesToReturn.push(nodeTagName);
    }
  });
  return namesToReturn;
}
var import_vscode_languageserver6, PartialCompletionItems, Partial, partial_default;
var init_partial = __esm({
  "server/src/antlers/tags/core/partials/partial.ts"() {
    "use strict";
    import_vscode_languageserver6 = __toESM(require_main4());
    init_documentDetailsManager();
    init_documents();
    init_documentedLabel();
    init_tagManager();
    init_dynamicParameterResolver();
    init_partialExists();
    init_partialIfExists();
    init_partialParameters();
    init_partialUtilities();
    init_resolvePartialParameterCompletions();
    PartialCompletionItems = [
      tagToCompletionItem(partialExists_default),
      tagToCompletionItem(partialIfExists_default)
    ];
    Partial = {
      tagName: "partial",
      hideFromCompletions: false,
      injectParentScope: false,
      allowsArbitraryParameters: true,
      parameters: PartialParameters,
      requiresClose: false,
      allowsContentClose: true,
      introducedIn: null,
      resolveDocumentation: (params) => {
        return `**Partial Tag**  
Includes another view into the current template.  

[Documentation Reference](https://statamic.dev/tags/partial)
`;
      },
      resolveDynamicParameter: returnDynamicParameter,
      resovleParameterCompletionItems: resolvePartialParameterCompletions,
      resolveCompletionItems: (params) => {
        let items = [];
        if (params.leftChar == '"' && params.leftWord == ':src="') {
          return {
            items: [],
            analyzeDefaults: true,
            isExclusiveResult: false
          };
        }
        if ((params.leftWord == "partial" || params.leftWord == "/partial") && params.leftChar == ":" || params.leftWord == 'src="' && params.leftChar == '"') {
          const partials = params.project.getViews();
          partials.forEach((view) => {
            const decodedUri = decodeURIComponent(view.documentUri);
            if (DocumentDetailsManager.hasDetails(decodedUri)) {
              const partialDetails = DocumentDetailsManager.documentDetails.get(decodedUri);
              items.push({
                label: partialDetails.documentName + "(" + view.relativeDisplayName + ")",
                insertText: view.relativeDisplayName,
                detail: partialDetails.documentName,
                documentation: {
                  kind: import_vscode_languageserver6.MarkupKind.Markdown,
                  value: partialDetails.documentDescription
                },
                kind: import_vscode_languageserver6.CompletionItemKind.File
              });
            } else {
              items.push({
                label: view.relativeDisplayName,
                kind: import_vscode_languageserver6.CompletionItemKind.File
              });
            }
          });
          if (params.leftWord != 'src="') {
            items = items.concat(PartialCompletionItems);
          }
          return {
            analyzeDefaults: false,
            isExclusiveResult: true,
            items
          };
        }
        if (params.currentNode != null && params.project != null) {
          const viewName = getViewName(params.currentNode);
          if (viewName != null && viewName.trim().length > 0) {
            const viewRef = params.project.findRelativeView(viewName);
            if (viewRef != null) {
              if (sessionDocuments.hasDocument(viewRef.documentUri)) {
                const docInstance = sessionDocuments.getDocument(
                  viewRef.documentUri
                );
                if (docInstance != null) {
                  const symbols = docInstance.getAllAntlersNodes(), variableNames = getVariableNames(symbols), addedNames = [];
                  if (viewRef.varReferenceNames != null) {
                    viewRef.varReferenceNames.forEach((val, varName) => {
                      variableNames.push(varName);
                    });
                  }
                  const completionItems = [];
                  if (viewRef.injectsParameters.length > 0) {
                    const range = {
                      start: {
                        line: params.position.line,
                        character: params.position.character - 0
                      },
                      end: params.position
                    };
                    viewRef.injectsParameters.forEach((parameter) => {
                      const paramSnippet = parameter.name + '="$1"';
                      if (addedNames.includes(parameter.name)) {
                        return;
                      }
                      addedNames.push(parameter.name);
                      completionItems.push({
                        label: parameter.name,
                        kind: import_vscode_languageserver6.CompletionItemKind.Value,
                        insertTextFormat: import_vscode_languageserver6.InsertTextFormat.Snippet,
                        textEdit: import_vscode_languageserver6.TextEdit.replace(range, paramSnippet),
                        command: {
                          title: "Suggest",
                          command: "editor.action.triggerSuggest"
                        }
                      });
                    });
                  }
                  if (variableNames.length > 0) {
                    const range = {
                      start: {
                        line: params.position.line,
                        character: params.position.character - 0
                      },
                      end: params.position
                    };
                    variableNames.forEach((variableName) => {
                      const paramSnippet = variableName + '="$1"';
                      if (addedNames.includes(variableName)) {
                        return;
                      }
                      addedNames.push(variableName);
                      completionItems.push({
                        label: variableName,
                        kind: import_vscode_languageserver6.CompletionItemKind.Value,
                        insertTextFormat: import_vscode_languageserver6.InsertTextFormat.Snippet,
                        textEdit: import_vscode_languageserver6.TextEdit.replace(range, paramSnippet),
                        command: {
                          title: "Suggest",
                          command: "editor.action.triggerSuggest"
                        }
                      });
                    });
                  }
                  return nonExclusiveResult(completionItems);
                }
              }
            }
          }
        }
        return {
          analyzeDefaults: true,
          isExclusiveResult: false,
          items: []
        };
      }
    };
    partial_default = Partial;
  }
});

// server/src/antlers/tags/core/incrementReset.ts
var IncrementReset, incrementReset_default;
var init_incrementReset = __esm({
  "server/src/antlers/tags/core/incrementReset.ts"() {
    "use strict";
    init_utils();
    IncrementReset = {
      tagName: "increment:reset",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: "3.2.28",
      parameters: [
        {
          isRequired: true,
          name: "counter",
          aliases: [],
          description: "The incrementing counter to reset",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "to",
          aliases: [],
          description: "An optional value to reset the counter to before incrementing starts again",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["number"],
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "increment:reset Tag",
          "The `increment:reset` tag can be used to reset the value of an incrementing counter.",
          `{{ array_variable }}
    {{ increment:counter_name }}
{{ /array_variable }}

{{ increment:reset counter="counter_name" }}
`,
          null
        );
      }
    };
    incrementReset_default = IncrementReset;
  }
});

// server/src/antlers/tags/core/increment.ts
var IncrementCompletionItems, Increment, increment_default;
var init_increment = __esm({
  "server/src/antlers/tags/core/increment.ts"() {
    "use strict";
    init_utils();
    init_documentedLabel();
    init_tagManager();
    init_incrementReset();
    IncrementCompletionItems = [
      tagToCompletionItem(incrementReset_default)
    ];
    Increment = {
      tagName: "increment",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: false,
          name: "from",
          aliases: [],
          description: "The number to start incrementing by",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["number"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "by",
          aliases: [],
          description: "The number to increment by",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["number"],
          isDynamic: false
        }
      ],
      resolveCompletionItems: (params) => {
        if (params.leftWord == "increment" || params.leftWord == "/increment" && params.leftChar == ":") {
          return exclusiveResult(IncrementCompletionItems);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "increment Tag",
          "The `increment` tag can be used to increment a value each time the tag is encountered.",
          "https://statamic.dev/tags/increment"
        );
      }
    };
    increment_default = Increment;
  }
});

// server/src/antlers/tags/core/sections/yield.ts
var YieldContext, Yields, Yield;
var init_yield = __esm({
  "server/src/antlers/tags/core/sections/yield.ts"() {
    "use strict";
    init_utils();
    YieldContext = class {
      constructor(node) {
        this.node = node;
      }
    };
    Yields = {
      tagName: "yields",
      hideFromCompletions: false,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      parameters: [],
      introducedIn: null,
      requiresClose: false,
      resolveSpecialType: (node, project) => {
        const context = new YieldContext(node);
        return {
          context,
          issues: []
        };
      }
    };
    Yield = {
      tagName: "yield",
      hideFromCompletions: false,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      parameters: [],
      introducedIn: null,
      requiresClose: false,
      resolveSpecialType: (node, project) => {
        const context = new YieldContext(node);
        return {
          context,
          issues: []
        };
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "yield Tag",
          "The `yield` tag may be used to push rendered content to named regions within a template's structure.",
          "https://statamic.dev/tags/yield"
        );
      }
    };
  }
});

// server/src/antlers/permissions/nativePermissions.ts
var NativePermissions;
var init_nativePermissions = __esm({
  "server/src/antlers/permissions/nativePermissions.ts"() {
    "use strict";
    NativePermissions = [
      { handle: "access cp" },
      { handle: "configure collections" },
      { handle: "[view edit create delete publish reorder] {collection} entries" },
      { handle: "configure structures" },
      { handle: "[view edit] {structure} structure" },
      { handle: "edit {global} globals" },
      { handle: "[view upload edit move rename delete] {container} assets" },
      { handle: "[view perform] updates" },
      { handle: "[view edit create delete] users" },
      { handle: "change passwords" },
      { handle: "edit roles" },
      { handle: "configure forms" },
      { handle: "[view delete] {form} submissions" }
    ];
  }
});

// server/src/antlers/permissions/permissionManager.ts
var PermissionsManager, permissionManager_default;
var init_permissionManager = __esm({
  "server/src/antlers/permissions/permissionManager.ts"() {
    "use strict";
    init_nativePermissions();
    PermissionsManager = class {
      constructor() {
        this.contextItems = /* @__PURE__ */ new Map();
        this.triggerNames = [];
        this.collectionTriggers = [];
        this.collectionTriggerCaps = [];
        this.globalTriggers = [];
        this.globalTriggerCaps = [];
        this.formTriggers = [];
        this.formTriggerCaps = [];
        this.structureTriggers = [];
        this.structureTriggerCaps = [];
        this.assetTriggers = [];
        this.assetTriggerCaps = [];
      }
      getCollectionTriggerCaps() {
        return this.collectionTriggerCaps;
      }
      getGlobalTriggerCaps() {
        return this.globalTriggerCaps;
      }
      getFormTriggerCaps() {
        return this.formTriggerCaps;
      }
      getStructureTriggerCaps() {
        return this.structureTriggerCaps;
      }
      getAssetTriggerCaps() {
        return this.assetTriggerCaps;
      }
      loadCorePermissions() {
        this.registerPermissions(NativePermissions);
      }
      getTriggerNames() {
        return this.triggerNames;
      }
      isCollectionTrigger(trigger) {
        return this.collectionTriggers.includes(trigger);
      }
      isGlobalTrigger(trigger) {
        return this.globalTriggers.includes(trigger);
      }
      isFormTrigger(trigger) {
        return this.formTriggers.includes(trigger);
      }
      isStructureTrigger(trigger) {
        return this.structureTriggers.includes(trigger);
      }
      isAssetTrigger(trigger) {
        return this.assetTriggers.includes(trigger);
      }
      getTriggerContextItems(trigger) {
        if (this.contextItems.has(trigger)) {
          return this.contextItems.get(trigger);
        }
        return [];
      }
      registerSpecialTrigger(trigger, specialTrigger, context) {
        if (specialTrigger == "{collection}") {
          if (this.collectionTriggerCaps.includes(context) == false) {
            this.collectionTriggerCaps.push(context);
          }
          if (this.collectionTriggers.includes(trigger) == false) {
            this.collectionTriggers.push(trigger);
          }
        } else if (specialTrigger == "{structure}") {
          if (this.structureTriggerCaps.includes(context) == false) {
            this.structureTriggerCaps.push(context);
          }
          if (this.structureTriggers.includes(trigger) == false) {
            this.structureTriggers.push(trigger);
          }
        } else if (specialTrigger == "{container}") {
          if (this.assetTriggerCaps.includes(context) == false) {
            this.assetTriggerCaps.push(context);
          }
          if (this.assetTriggers.includes(trigger) == false) {
            this.assetTriggers.push(trigger);
          }
        } else if (specialTrigger == "{global}") {
          if (this.globalTriggerCaps.includes(context) == false) {
            this.globalTriggerCaps.push(context);
          }
          if (this.globalTriggers.includes(trigger) == false) {
            this.globalTriggers.push(trigger);
          }
        } else if (specialTrigger == "{form}") {
          if (this.formTriggerCaps.includes(context) == false) {
            this.formTriggerCaps.push(context);
          }
          if (this.formTriggers.includes(trigger) == false) {
            this.formTriggers.push(trigger);
          }
        }
      }
      addContextToTrigger(trigger, context) {
        var _a;
        if (this.triggerNames.includes(trigger) == false) {
          this.triggerNames.push(trigger);
        }
        if (this.contextItems.has(trigger) == false) {
          this.contextItems.set(trigger, [context]);
        } else {
          (_a = this.contextItems.get(trigger)) == null ? void 0 : _a.push(context);
        }
      }
      registerPermissions(permissions) {
        for (let i = 0; i < permissions.length; i++) {
          const thisPermission = permissions[i];
          let triggers = [], specialTrigger = "", contextItem = "";
          if (thisPermission.handle.includes("[") && thisPermission.handle.includes("]")) {
            const openBracket = thisPermission.handle.indexOf("["), closeBracket = thisPermission.handle.indexOf("]"), len = closeBracket - openBracket, nestedTriggers = thisPermission.handle.substr(openBracket + 1, len - 1).split(" ").filter((n) => n.trim().length > 0), additionalPieces = thisPermission.handle.substr(closeBracket + 1).split(" ").filter((n) => n.trim().length > 0);
            triggers = nestedTriggers;
            if (additionalPieces.length == 2) {
              specialTrigger = additionalPieces[0];
              contextItem = additionalPieces[1];
            } else if (additionalPieces.length == 1) {
              specialTrigger = "";
              contextItem = additionalPieces[0];
            }
          } else {
            const pieces = thisPermission.handle.split(" ").filter((n) => n.trim().length > 0);
            if (pieces.length == 2) {
              triggers = [pieces[0]];
              contextItem = pieces[1];
            }
          }
          for (let j = 0; j < triggers.length; j++) {
            const thisTrigger = triggers[j];
            if (specialTrigger.trim().length > 0) {
              this.registerSpecialTrigger(thisTrigger, specialTrigger, contextItem);
            } else {
              this.addContextToTrigger(thisTrigger, contextItem);
            }
          }
        }
      }
    };
    PermissionsManager.instance = null;
    if (typeof PermissionsManager.instance == "undefined" || PermissionsManager.instance == null) {
      PermissionsManager.instance = new PermissionsManager();
      PermissionsManager.instance.loadCorePermissions();
    }
    permissionManager_default = PermissionsManager;
  }
});

// server/src/suggestions/permissionSuggestions.ts
function getPermissionSuggestions(currentValue, params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
  const items = [];
  if (currentValue.trim().length == 0) {
    const baseTriggerNames = (_b = (_a = permissionManager_default.instance) == null ? void 0 : _a.getTriggerNames()) != null ? _b : [];
    for (let i = 0; i < baseTriggerNames.length; i++) {
      items.push({
        label: baseTriggerNames[i],
        kind: import_vscode_languageserver_types9.CompletionItemKind.Value
      });
    }
  } else {
    const currentParts = currentValue.split(" ").filter((n) => n.trim().length > 0), currentTrigger = currentParts[0], allContextualItems = (_d = (_c = permissionManager_default.instance) == null ? void 0 : _c.getTriggerContextItems(currentTrigger)) != null ? _d : [], isCollectionTrigger = (_e = permissionManager_default.instance) == null ? void 0 : _e.isCollectionTrigger(currentTrigger), isGlobalTrigger = (_f = permissionManager_default.instance) == null ? void 0 : _f.isGlobalTrigger(currentTrigger), isFormTrigger = (_g = permissionManager_default.instance) == null ? void 0 : _g.isFormTrigger(currentTrigger), isStructureTrigger = (_h = permissionManager_default.instance) == null ? void 0 : _h.isStructureTrigger(currentTrigger), isAssetTrigger = (_i = permissionManager_default.instance) == null ? void 0 : _i.isAssetTrigger(currentTrigger);
    let candidateItems = [];
    if (currentParts.length <= 2) {
      if (isCollectionTrigger) {
        candidateItems = candidateItems.concat(
          params.project.getUniqueCollectionNames()
        );
      } else if (isGlobalTrigger) {
        candidateItems = candidateItems.concat(
          params.project.getUniqueGlobalsNames()
        );
      } else if (isFormTrigger) {
        candidateItems = candidateItems.concat(
          params.project.getUniqueFormNames()
        );
      } else if (isStructureTrigger) {
        candidateItems = candidateItems.concat(
          params.project.getUniqueNavigationMenuNames()
        );
      } else if (isAssetTrigger) {
        candidateItems = candidateItems.concat(
          params.project.getUniqueAssetNames()
        );
      }
      if (allContextualItems.length > 0) {
        candidateItems = candidateItems.concat(allContextualItems);
      }
      candidateItems = [...new Set(candidateItems)];
      for (let i = 0; i < candidateItems.length; i++) {
        items.push({
          label: candidateItems[i],
          kind: import_vscode_languageserver_types9.CompletionItemKind.Value
        });
      }
    } else {
      let capCandidates = [];
      if (isCollectionTrigger) {
        capCandidates = capCandidates.concat(
          (_k = (_j = permissionManager_default.instance) == null ? void 0 : _j.getCollectionTriggerCaps()) != null ? _k : []
        );
      } else if (isGlobalTrigger) {
        capCandidates = capCandidates.concat(
          (_m = (_l = permissionManager_default.instance) == null ? void 0 : _l.getGlobalTriggerCaps()) != null ? _m : []
        );
      } else if (isFormTrigger) {
        capCandidates = capCandidates.concat(
          (_o = (_n = permissionManager_default.instance) == null ? void 0 : _n.getFormTriggerCaps()) != null ? _o : []
        );
      } else if (isStructureTrigger) {
        capCandidates = capCandidates.concat(
          (_q = (_p = permissionManager_default.instance) == null ? void 0 : _p.getStructureTriggerCaps()) != null ? _q : []
        );
      } else if (isAssetTrigger) {
        capCandidates = capCandidates.concat(
          (_s = (_r = permissionManager_default.instance) == null ? void 0 : _r.getAssetTriggerCaps()) != null ? _s : []
        );
      }
      capCandidates = [...new Set(capCandidates)];
      for (let i = 0; i < capCandidates.length; i++) {
        items.push({
          label: capCandidates[i],
          kind: import_vscode_languageserver_types9.CompletionItemKind.Value
        });
      }
    }
  }
  return items;
}
var import_vscode_languageserver_types9;
var init_permissionSuggestions = __esm({
  "server/src/suggestions/permissionSuggestions.ts"() {
    "use strict";
    import_vscode_languageserver_types9 = __toESM(require_main2());
    init_permissionManager();
  }
});

// server/src/antlers/tags/core/user/parameterCompletions.ts
function resolveUserParameterCompletionItems(parameter, params) {
  var _a, _b, _c, _d;
  const checkName = getAbsoluteRoot(parameter.name);
  if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null && ["do", "permission"].includes(checkName)) {
    return exclusiveResult(getPermissionSuggestions((_d = (_c = (_b = params.context) == null ? void 0 : _b.parameterContext.parameter) == null ? void 0 : _c.value) != null ? _d : "", params));
  }
  return null;
}
var init_parameterCompletions = __esm({
  "server/src/antlers/tags/core/user/parameterCompletions.ts"() {
    "use strict";
    init_permissionSuggestions();
    init_suggestionManager();
    init_tagManager();
  }
});

// server/src/antlers/tags/core/userCan.ts
var UserCan, userCan_default;
var init_userCan = __esm({
  "server/src/antlers/tags/core/userCan.ts"() {
    "use strict";
    init_utils();
    init_parameterCompletions();
    UserCan = {
      tagName: "user:can",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      introducedIn: null,
      resovleParameterCompletionItems: resolveUserParameterCompletionItems,
      parameters: [
        {
          name: "do",
          acceptsVariableInterpolation: false,
          aliases: ["permission"],
          allowsVariableReference: false,
          description: "The permissions to check against",
          expectsTypes: ["string"],
          isRequired: true,
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:can Tag",
          "The `user:can` tag is used to check if the currently authenticated user has a specific set of permissions. When used as a tag pair, the tag contents will only be rendered if the user has the specified permissions.",
          "https://statamic.dev/tags/user-can"
        );
      }
    };
    userCan_default = UserCan;
  }
});

// server/src/antlers/tags/core/userLogout.ts
var UserLogout, userLogout_default;
var init_userLogout = __esm({
  "server/src/antlers/tags/core/userLogout.ts"() {
    "use strict";
    init_utils();
    UserLogout = {
      tagName: "user:logout",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [{
        name: "redirect",
        description: "An optional URL to redirect the user after being logged out",
        aliases: [],
        isRequired: false,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string"]
      }],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:logout Tag",
          "The `user:logout` tag will sign out the currently authenticated user. An optional `redirect` parameter may be used to redirect the visitor to a different page after being logged out.",
          "https://statamic.dev/tags/user-logout"
        );
      }
    };
    userLogout_default = UserLogout;
  }
});

// server/src/antlers/tags/core/userLogoutUrl.ts
var UserLogoutUrl, userLogoutUrl_default;
var init_userLogoutUrl = __esm({
  "server/src/antlers/tags/core/userLogoutUrl.ts"() {
    "use strict";
    init_utils();
    UserLogoutUrl = {
      tagName: "user:logout_url",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [{
        name: "redirect",
        description: "An optional URL to redirect the user after being logged out",
        aliases: [],
        isRequired: false,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string"]
      }],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "user:logout_url",
          "The `user:logout_url` tag can be used to retrieve the URL that will sign the current user out.",
          `<a href="{{ user:logout_url }}">Log out</a>`,
          "https://statamic.dev/tags/user-logout_url"
        );
      }
    };
    userLogoutUrl_default = UserLogoutUrl;
  }
});

// server/src/antlers/tags/core/switch.ts
var Switch, Rotate;
var init_switch = __esm({
  "server/src/antlers/tags/core/switch.ts"() {
    "use strict";
    init_utils();
    Switch = {
      tagName: "switch",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [{
        name: "between",
        description: "A set of values to iterate over",
        aliases: [],
        isRequired: false,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string", "array"]
      }, {
        name: "for",
        description: "A unique name for the switch instance",
        aliases: [],
        isRequired: false,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string"]
      }],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "switch Tag",
          "The `switch` tag can be used to alternate between a set of values each time the tag is evaluated.",
          "https://statamic.dev/tags/switch"
        );
      }
    };
    Rotate = {
      tagName: "rotate",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      introducedIn: null,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      parameters: [{
        name: "between",
        description: "A set of values to iterate over",
        aliases: [],
        isRequired: false,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string", "array"]
      }, {
        name: "for",
        description: "A unique name for the switch instance",
        aliases: [],
        isRequired: false,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string"]
      }],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "rotate Tag",
          "The `rotate` tag can be used to alternate between a set of values each time the tag is evaluated.",
          "https://statamic.dev/tags/switch"
        );
      }
    };
  }
});

// server/src/antlers/tags/core/oauth.ts
var OAuth, oauth_default;
var init_oauth = __esm({
  "server/src/antlers/tags/core/oauth.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    OAuth = {
      tagName: "oauth",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [{
        name: "provider",
        description: "The OAuth provider to be used.",
        aliases: [],
        isRequired: true,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string"]
      }, {
        name: "redirect",
        description: "The URL to be redirected to after authenticating.",
        aliases: [],
        isRequired: true,
        acceptsVariableInterpolation: true,
        allowsVariableReference: false,
        isDynamic: false,
        expectsTypes: ["string"]
      }],
      resovleParameterCompletionItems: (parameter, params) => {
        if (parameter.name == "provider") {
          return exclusiveResultList(params.project.getOAuthProviders());
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "oauth Tag",
          "The `oauth` tag can be used to generate login URls for various third-party services.",
          `<a href="{{ oauth provider="github" }}">Sign In with Github</a>`,
          "https://statamic.dev/tags/oauth"
        );
      }
    };
    oauth_default = OAuth;
  }
});

// server/src/antlers/tags/core/sessionDump.ts
var SessionDump, sessionDump_default;
var init_sessionDump = __esm({
  "server/src/antlers/tags/core/sessionDump.ts"() {
    "use strict";
    init_utils();
    SessionDump = {
      tagName: "session:dump",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      parameters: [],
      introducedIn: null,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "session:dump Tag",
          "The `session:dump` tag will display the contents of the user's session to the browser. This tag behaves similarly to the `dd` helper functions, but returns just the session data.",
          "https://statamic.dev/tags/session-dump"
        );
      }
    };
    sessionDump_default = SessionDump;
  }
});

// server/src/antlers/tags/core/contexts/sessionContext.ts
var SessionVariableContext;
var init_sessionContext = __esm({
  "server/src/antlers/tags/core/contexts/sessionContext.ts"() {
    "use strict";
    SessionVariableContext = class {
      constructor(node) {
        this.node = node;
      }
    };
  }
});

// server/src/antlers/tags/core/sessionSet.ts
var SessionSet, sessionSet_default;
var init_sessionSet = __esm({
  "server/src/antlers/tags/core/sessionSet.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    init_sessionContext();
    SessionSet = {
      tagName: "session:set",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: true,
      allowsContentClose: true,
      parameters: [],
      introducedIn: null,
      resolveDynamicParameter: returnDynamicParameter,
      resolveSpecialType: (node, project) => {
        const context = new SessionVariableContext(node);
        return {
          context,
          issues: []
        };
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "session:set Tag",
          "The `session:set` tag is used to add new data to the user's session.",
          "https://statamic.dev/tags/session-set"
        );
      }
    };
    sessionSet_default = SessionSet;
  }
});

// server/src/references/sessionVariableManager.ts
var SessionVariableManager, sessionVariableManager_default;
var init_sessionVariableManager = __esm({
  "server/src/references/sessionVariableManager.ts"() {
    "use strict";
    SessionVariableManager = class {
      constructor() {
        this.knownVariables = /* @__PURE__ */ new Map();
      }
      registerDocumentSessionVariables(fileContext, contexts) {
        if (!this.knownVariables.has(fileContext)) {
          this.knownVariables.set(fileContext, /* @__PURE__ */ new Map());
        }
        const fileVars = this.knownVariables.get(fileContext);
        fileVars.clear();
        for (let i = 0; i < contexts.length; i++) {
          const node = contexts[i].node;
          if (node.hasParameters) {
            for (let j = 0; j < node.parameters.length; j++) {
              const thisParam = node.parameters[j];
              fileVars.set(thisParam.name, contexts[i]);
            }
          }
        }
      }
      getKnownSessionVariableNames() {
        const variableNames = [];
        this.knownVariables.forEach(
          (mapping) => {
            mapping.forEach((val, name) => {
              if (variableNames.includes(name) == false) {
                variableNames.push(name);
              }
            });
          }
        );
        return variableNames;
      }
    };
    SessionVariableManager.instance = null;
    if (typeof SessionVariableManager.instance == "undefined" || SessionVariableManager.instance == null) {
      SessionVariableManager.instance = new SessionVariableManager();
    }
    sessionVariableManager_default = SessionVariableManager;
  }
});

// server/src/suggestions/uniqueParameterArraySuggestions.ts
function getUniqueParameterArrayValuesSuggestions(paramAttribute, allValues) {
  const items = [], paramValues = paramAttribute.getArrayValue(), valuesToUse = allValues.filter((e) => !paramValues.includes(e));
  for (let i = 0; i < valuesToUse.length; i++) {
    items.push({
      label: valuesToUse[i],
      kind: import_vscode_languageserver_types10.CompletionItemKind.Variable
    });
  }
  return exclusiveResult(items);
}
var import_vscode_languageserver_types10;
var init_uniqueParameterArraySuggestions = __esm({
  "server/src/suggestions/uniqueParameterArraySuggestions.ts"() {
    "use strict";
    import_vscode_languageserver_types10 = __toESM(require_main2());
    init_tagManager();
  }
});

// server/src/antlers/tags/core/sessionForget.ts
var SessionForget, sessionForget_default;
var init_sessionForget = __esm({
  "server/src/antlers/tags/core/sessionForget.ts"() {
    "use strict";
    init_utils();
    init_sessionVariableManager();
    init_uniqueParameterArraySuggestions();
    SessionForget = {
      tagName: "session:forget",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [
        {
          name: "keys",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "The session keys to clear",
          expectsTypes: ["string"],
          isRequired: true,
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "keys" && ((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
          const existingVarNames = (_c = (_b = sessionVariableManager_default.instance) == null ? void 0 : _b.getKnownSessionVariableNames()) != null ? _c : [];
          if (params.context.parameterContext.parameter != null) {
            return getUniqueParameterArrayValuesSuggestions(params.context.parameterContext.parameter, existingVarNames);
          }
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "session:forget Tag",
          "The `session:forget` tag is used to remove variables from the user's session.",
          "https://statamic.dev/tags/session-forget"
        );
      }
    };
    sessionForget_default = SessionForget;
  }
});

// server/src/antlers/tags/core/sessionFlush.ts
var SessionFlush, sessionFlush_default;
var init_sessionFlush = __esm({
  "server/src/antlers/tags/core/sessionFlush.ts"() {
    "use strict";
    init_utils();
    SessionFlush = {
      tagName: "session:flush",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      parameters: [],
      introducedIn: null,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "session:flush Tag",
          "The `session:flush` tag will clear all values from the visitor's session. If the visitor is currently signed in they will also be signed out.",
          "https://statamic.dev/tags/session-flush"
        );
      }
    };
    sessionFlush_default = SessionFlush;
  }
});

// server/src/antlers/tags/core/sessionFlash.ts
var SessionFlash, sessionFlash_default;
var init_sessionFlash = __esm({
  "server/src/antlers/tags/core/sessionFlash.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    init_sessionContext();
    SessionFlash = {
      tagName: "session:flash",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      parameters: [],
      introducedIn: null,
      resolveDynamicParameter: returnDynamicParameter,
      resolveSpecialType: (node, project) => {
        const context = new SessionVariableContext(node);
        return {
          context,
          issues: []
        };
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "session:flash Tag",
          "The `session:flash` tag can be used to add a value to the user's session. Flashed values only persist for a single request, and are then removed.",
          "https://statamic.dev/tags/session-flash"
        );
      }
    };
    sessionFlash_default = SessionFlash;
  }
});

// server/src/antlers/tags/core/markdownIndent.ts
var MarkdownIndent, markdownIndent_default;
var init_markdownIndent = __esm({
  "server/src/antlers/tags/core/markdownIndent.ts"() {
    "use strict";
    init_utils();
    MarkdownIndent = {
      tagName: "markdown:indent",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "markdown:indent Tag",
          "The `markdown:indent` tag is similar to the markdown tag, but will ignore leading whitepsace while rendering the tag's content as markdown.",
          "https://statamic.dev/tags/markdown-indent"
        );
      }
    };
    markdownIndent_default = MarkdownIndent;
  }
});

// server/src/antlers/tags/core/markdown.ts
var MarkdownCompletionItems, Markdown, markdown_default;
var init_markdown = __esm({
  "server/src/antlers/tags/core/markdown.ts"() {
    "use strict";
    init_utils();
    init_documentedLabel();
    init_tagManager();
    init_markdownIndent();
    MarkdownCompletionItems = [
      tagToCompletionItem(markdownIndent_default)
    ];
    Markdown = {
      tagName: "markdown",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [],
      resolveCompletionItems: (params) => {
        if (params.isPastTagPart == false && (params.leftWord == "markdown" || params.leftWord == "/markdown") && params.leftChar == ":") {
          return exclusiveResult(MarkdownCompletionItems);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "markdown Tag",
          "The `markdown` tag can be used to render the tags contents as markdown.",
          "https://statamic.dev/tags/markdown"
        );
      }
    };
    markdown_default = Markdown;
  }
});

// server/src/suggestions/project/dotStringCompletions.ts
function createSuggestionsFromDotStrings(currentValue, values) {
  const items = [];
  let valuesToSuggest = values;
  if (currentValue.trim().length > 0) {
    if (currentValue.includes(".")) {
      if (currentValue.endsWith(".")) {
        const testValue = currentValue.substr(0, currentValue.length - 1);
        valuesToSuggest = valuesToSuggest.filter((e) => e.startsWith(testValue));
      }
    }
  }
  for (let i = 0; i < valuesToSuggest.length; i++) {
    let insertText = valuesToSuggest[i], doAdd = true;
    if (currentValue.includes(".")) {
      if (insertText.startsWith(currentValue) == false) {
        doAdd = false;
      } else {
        insertText = insertText.substr(currentValue.length);
      }
    }
    if (doAdd) {
      items.push({
        label: insertText,
        insertText,
        kind: import_vscode_languageserver7.CompletionItemKind.Text
      });
    }
  }
  return items;
}
var import_vscode_languageserver7;
var init_dotStringCompletions = __esm({
  "server/src/suggestions/project/dotStringCompletions.ts"() {
    "use strict";
    import_vscode_languageserver7 = __toESM(require_main4());
  }
});

// server/src/suggestions/project/routeCompletions.ts
function getRouteCompletions(currentValue, project) {
  return createSuggestionsFromDotStrings(currentValue, project.getRouteNames());
}
var init_routeCompletions = __esm({
  "server/src/suggestions/project/routeCompletions.ts"() {
    "use strict";
    init_dotStringCompletions();
  }
});

// server/src/antlers/tags/core/route.ts
var Route, route_default;
var init_route = __esm({
  "server/src/antlers/tags/core/route.ts"() {
    "use strict";
    init_utils();
    init_routeCompletions();
    init_suggestionManager();
    init_tagManager();
    init_dynamicParameterResolver();
    Route = {
      tagName: "route",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      parameters: [],
      introducedIn: null,
      resolveDynamicParameter: returnDynamicParameter,
      resolveCompletionItems: (params) => {
        if (params.leftMeaningfulWord == "route") {
          const existingRouteValue = getCurrentSymbolMethodNameValue(params);
          return exclusiveResult(getRouteCompletions(existingRouteValue, params.project));
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "route Tag",
          "The `route` tag can be used to generate a full URL [to a named route](https://laravel.com/docs/8.x/routing#named-routes), including any defined route parameters.",
          "https://statamic.dev/tags/route"
        );
      }
    };
    route_default = Route;
  }
});

// server/src/suggestions/defaults/httpStatusCodes.ts
var import_vscode_languageserver_types11, RedirectStatusCodes;
var init_httpStatusCodes = __esm({
  "server/src/suggestions/defaults/httpStatusCodes.ts"() {
    "use strict";
    import_vscode_languageserver_types11 = __toESM(require_main2());
    RedirectStatusCodes = [
      { label: "301 Permanent", insertText: "301", kind: import_vscode_languageserver_types11.CompletionItemKind.EnumMember },
      { label: "302 Temporary", insertText: "302", kind: import_vscode_languageserver_types11.CompletionItemKind.EnumMember },
      { label: "404 Not Found", insertText: "404", kind: import_vscode_languageserver_types11.CompletionItemKind.EnumMember }
    ];
  }
});

// server/src/antlers/tags/core/redirect.ts
var Redirect, redirect_default;
var init_redirect = __esm({
  "server/src/antlers/tags/core/redirect.ts"() {
    "use strict";
    init_utils();
    init_httpStatusCodes();
    init_tagManager();
    Redirect = {
      tagName: "redirect",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [{
        name: "to",
        description: "The destination URL.",
        aliases: ["url"],
        allowsVariableReference: false,
        acceptsVariableInterpolation: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: true
      }, {
        name: "response",
        description: "The HTTP response code to use.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false
      }],
      resovleParameterCompletionItems: (parameter) => {
        if (parameter.name == "response") {
          return exclusiveResult(RedirectStatusCodes);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "redirect Tag",
          "The `redirect` tag can be used to redirect the site visitor to a URL or named route. An optional HTTP status code can also be specified on the response using the `response` parameter.",
          "https://statamic.dev/tags/redirect"
        );
      }
    };
    redirect_default = Redirect;
  }
});

// server/src/references/sectionManager.ts
var SectionManager, sectionManager_default;
var init_sectionManager = __esm({
  "server/src/references/sectionManager.ts"() {
    "use strict";
    SectionManager = class {
      constructor() {
        this.knownSections = /* @__PURE__ */ new Map();
      }
      registerDocumentSections(fileContext, contexts) {
        if (!this.knownSections.has(fileContext)) {
          this.knownSections.set(fileContext, /* @__PURE__ */ new Map());
        }
        const fileSections = this.knownSections.get(fileContext);
        fileSections.clear();
        for (let i = 0; i < contexts.length; i++) {
          const contextRef = contexts[i];
          if (contextRef.node.hasMethodPart()) {
            fileSections.set(contextRef.node.getMethodNameValue(), contextRef);
          }
        }
      }
      getKnownSectionNames() {
        const sectionNames = [];
        this.knownSections.forEach((mapping) => {
          mapping.forEach((val, name) => {
            if (sectionNames.includes(name) == false) {
              sectionNames.push(name);
            }
          });
        });
        return sectionNames;
      }
    };
    SectionManager.instance = null;
    if (typeof SectionManager.instance == "undefined" || SectionManager.instance == null) {
      SectionManager.instance = new SectionManager();
    }
    sectionManager_default = SectionManager;
  }
});

// server/src/antlers/tags/core/sections/section.ts
var import_vscode_languageserver_types12, Section, section_default;
var init_section = __esm({
  "server/src/antlers/tags/core/sections/section.ts"() {
    "use strict";
    import_vscode_languageserver_types12 = __toESM(require_main2());
    init_utils();
    init_sectionManager();
    init_tagManager();
    Section = {
      tagName: "section",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [],
      resolveCompletionItems: (params) => {
        var _a, _b;
        if ((params.leftWord == "section" || params.leftWord == "/section") && params.leftChar == ":") {
          const items = [], knownSectionNames = (_b = (_a = sectionManager_default.instance) == null ? void 0 : _a.getKnownSectionNames()) != null ? _b : [];
          for (let i = 0; i < knownSectionNames.length; i++) {
            items.push({
              label: knownSectionNames[i],
              kind: import_vscode_languageserver_types12.CompletionItemKind.Field
            });
          }
          return nonExclusiveResult(items);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "section Tag",
          "The `section` tag is used to push content to a named region defined by the `yield` tag.",
          "https://statamic.dev/tags/section"
        );
      }
    };
    section_default = Section;
  }
});

// server/src/antlers/tags/core/obfuscate.ts
var Obfuscate, obfuscate_default;
var init_obfuscate = __esm({
  "server/src/antlers/tags/core/obfuscate.ts"() {
    "use strict";
    init_utils();
    Obfuscate = {
      tagName: "obfuscate",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "obfuscate Tag",
          "The `obfuscate` tag converts the tags's content into a format that is difficult for bots to read, but can easily be viewed by users within their browser.",
          "https://statamic.dev/tags/obfuscate"
        );
      }
    };
    obfuscate_default = Obfuscate;
  }
});

// server/src/antlers/tags/core/parent.ts
var Parent, parent_default;
var init_parent = __esm({
  "server/src/antlers/tags/core/parent.ts"() {
    "use strict";
    init_utils();
    Parent = {
      tagName: "parent",
      hideFromCompletions: false,
      requiresClose: false,
      allowsContentClose: true,
      allowsArbitraryParameters: false,
      injectParentScope: true,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "parent Tag",
          "The `parent` tag provides access to data from the current page's parent (the URL one level above the current page).",
          "https://statamic.dev/tags/parent"
        );
      }
    };
    parent_default = Parent;
  }
});

// server/src/suggestions/project/translationCompletions.ts
function getTranslationSuggestions(currentValue, project) {
  return createSuggestionsFromDotStrings(currentValue, project.getTranslationKeys());
}
var init_translationCompletions = __esm({
  "server/src/suggestions/project/translationCompletions.ts"() {
    "use strict";
    init_dotStringCompletions();
  }
});

// server/src/antlers/tags/core/translate.ts
var TranslateTriggerTagNames, Translate, TransTag, TransChoiceTag;
var init_translate = __esm({
  "server/src/antlers/tags/core/translate.ts"() {
    "use strict";
    init_utils();
    init_translationCompletions();
    init_suggestionManager();
    init_tagManager();
    init_alias();
    init_dynamicParameterResolver();
    TranslateTriggerTagNames = [
      "translate",
      "trans",
      "trans_choice"
    ];
    Translate = {
      tagName: "translate",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      introducedIn: null,
      allowsArbitraryParameters: true,
      parameters: [
        {
          isRequired: false,
          name: "key",
          description: "The key of the translation string to find.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "locale",
          description: "The locale to be used when translating.",
          acceptsVariableInterpolation: false,
          aliases: ["site"],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "count",
          description: "The number of items to use for pluralization.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["number"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a;
        if (parameter.name == "key") {
          let curValue = "";
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null && params.context.parameterContext.parameter != null) {
            curValue = params.context.parameterContext.parameter.value;
          }
          return exclusiveResult(getTranslationSuggestions(
            curValue,
            params.project
          ));
        }
        return EmptyCompletionResult;
      },
      resolveDynamicParameter: returnDynamicParameter,
      resolveCompletionItems: (params) => {
        if (params.leftMeaningfulWord != null && TranslateTriggerTagNames.includes(params.leftMeaningfulWord)) {
          const existingTranslateValue = getCurrentSymbolMethodNameValue(params);
          return exclusiveResult(getTranslationSuggestions(existingTranslateValue, params.project));
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "trans Tag",
          "The `trans` tag can be used to retrieve a string for the current locale's language file.",
          "https://statamic.dev/tags/trans"
        );
      }
    };
    TransTag = createDefinitionAlias(Translate, "trans");
    TransChoiceTag = createDefinitionAlias(Translate, "trans_choice");
    TransChoiceTag.resolveDocumentation = (params) => {
      return makeTagDoc(
        "trans_choice Tag",
        "The `trans_choice` tag can be used to retrieve a pluralized string for the current locale's language file.",
        "https://statamic.dev/tags/trans#pluralization"
      );
    };
  }
});

// server/src/antlers/tags/core/svg.ts
var SVGTag, svg_default;
var init_svg = __esm({
  "server/src/antlers/tags/core/svg.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    SVGTag = {
      tagName: "svg",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: false,
          name: "src",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "The SVG filename relative to the project root",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "title",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "desc",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "",
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resolveDynamicParameter: returnDynamicParameter,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "svg Tag",
          "The `svg` tag can be used to render inline SVGs, as well as set attributes on the rendered `<svg>` element.",
          "https://statamic.dev/tags/svg"
        );
      }
    };
    svg_default = SVGTag;
  }
});

// server/src/antlers/tags/core/asset.ts
var Asset, asset_default;
var init_asset = __esm({
  "server/src/antlers/tags/core/asset.ts"() {
    "use strict";
    init_utils();
    init_assetVariables();
    Asset = {
      tagName: "asset",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "The path to the file",
          expectsTypes: ["string"],
          isDynamic: false,
          name: "url"
        }
      ],
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeAssetVariables(symbol));
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "asset Tag",
          "The `asset` tag can be used to retrive Assets by supplying a URL.",
          `{{ asset url="/url/for/asset.png" }}
    <img src="{{ url }}" alt="{{ alt }}" />
{{ /asset }}`,
          "https://statamic.dev/tags/asset"
        );
      }
    };
    asset_default = Asset;
  }
});

// server/src/suggestions/project/assetCompletions.ts
function getAllAssetCompletions(project) {
  const items = [], containers = project.getUniqueAssetNames();
  for (let i = 0; i < containers.length; i++) {
    items.push({ label: containers[i], kind: import_vscode_languageserver_types13.CompletionItemKind.Field });
  }
  return items;
}
var import_vscode_languageserver_types13;
var init_assetCompletions = __esm({
  "server/src/suggestions/project/assetCompletions.ts"() {
    "use strict";
    import_vscode_languageserver_types13 = __toESM(require_main2());
  }
});

// server/src/antlers/tags/core/assets.ts
var AssetContainerParameters, Assets, assets_default;
var init_assets = __esm({
  "server/src/antlers/tags/core/assets.ts"() {
    "use strict";
    init_utils();
    init_assetCompletions();
    init_tagManager();
    init_assetVariables();
    AssetContainerParameters = ["container", "id", "handle"];
    Assets = {
      tagName: "assets",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: false,
          name: "container",
          aliases: ["id", "handle"],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The handle of the asset container.",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "folder",
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "Filters the resulting assets by specific folder.",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "recursive",
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "Returns all assets in all subdirectories.",
          expectsTypes: ["boolean"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "limit",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Limits the total results",
          expectsTypes: ["number"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "sort",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Sort entries by any asset variable.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        if (AssetContainerParameters.includes(parameter.name)) {
          return exclusiveResult(getAllAssetCompletions(params.project));
        }
        return EmptyCompletionResult;
      },
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeAssetVariables(symbol));
        let containerName = "";
        if (symbol.name != null && symbol.name.getMethodName() != null) {
          containerName = symbol.name.getMethodName();
        } else {
          const containerParam = symbol.findAnyParameter(AssetContainerParameters);
          if (containerParam != null && containerParam.containsSimpleValue()) {
            containerName = containerParam.value;
          }
        }
        if (containerName.length > 0) {
          scope.injectAssetContainer(symbol, containerName);
        }
        return scope;
      },
      resolveCompletionItems: (params) => {
        if ((params.leftWord == "assets" || params.leftWord == "/assets") && params.leftChar == ":") {
          return exclusiveResult(getAllAssetCompletions(params.project));
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "assets Tag",
          "The `assets` tag can be used to retrieve multiple Assets from an Asset container.",
          `{{ assets container="container-name" }}
    {{# Loop over all assets in the container. #}}
	<img src="{{ url }}" alt="{{ alt }}" />
{{ /assets }}`,
          "https://statamic.dev/tags/assets"
        );
      }
    };
    assets_default = Assets;
  }
});

// server/src/antlers/tags/core/getContent.ts
var GetContent, getContent_default;
var init_getContent = __esm({
  "server/src/antlers/tags/core/getContent.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    GetContent = {
      tagName: "get_content",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      introducedIn: null,
      allowsArbitraryParameters: false,
      parameters: [
        {
          isRequired: false,
          name: "from",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          description: "The ID to retrieve data for.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "locale",
          aliases: ["site"],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The locale to show the content in.",
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        if (parameter.name == "locale" || parameter.name == "site") {
          return exclusiveResultList(params.project.getSiteNames());
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "get_content Tag",
          "The `get_content` tag can be used to retrieve content from other entries. This tag accepts the ID of another entry, and will return access to all data for that entry.",
          `{{ get_content from="the-entry-id" }}
{{ /get_content }}`,
          "https://statamic.dev/tags/get_content"
        );
      }
    };
    getContent_default = GetContent;
  }
});

// server/src/antlers/variables/fileVariables.ts
function makeFileVariables(symbol) {
  return [
    { name: "basename", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "extension", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "filename", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "is_image", dataType: "boolean", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "file", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "file", dataType: "last_modified", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_bytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_b", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_gigabytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_gb", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_kilobytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_kb", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_megabytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_mb", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol }
  ];
}
var init_fileVariables = __esm({
  "server/src/antlers/variables/fileVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/getFiles.ts
var GetFiles, getFiles_default;
var init_getFiles = __esm({
  "server/src/antlers/tags/core/getFiles.ts"() {
    "use strict";
    init_utils();
    init_fileVariables();
    GetFiles = {
      tagName: "get_files",
      hideFromCompletions: false,
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: false,
          name: "in",
          aliases: ["from"],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The directory to find files in relative to the public directory",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "depth",
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The depth of the subdirectories",
          expectsTypes: ["number"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "not_in",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          description: "The subdirectories or pattern to exclude",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "file_size",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["string"],
          description: "The file size filter to use",
          isDynamic: false
        },
        {
          isRequired: false,
          name: "ext",
          aliases: ["extension"],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          description: "The extension(s) to filter by",
          expectsTypes: ["string", "array"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "include",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: ["match"],
          description: "Filter files by a regular expression",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "exclude",
          description: "Excludes files by a regular expression",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "file_date",
          description: "Filters files by last modified date",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "limit",
          description: "Limits the total number of results",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["number"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "offset",
          description: "The number of entries the results should be offset by",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["number"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "sort",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Sorts the listing by extension, size, last_modified, or random",
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeFileVariables(symbol));
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "get_files Tag",
          "The `get_files` tag can be used to display information about files on the site's local filesystem.",
          "https://statamic.dev/tags/get_files"
        );
      }
    };
    getFiles_default = GetFiles;
  }
});

// server/src/antlers/variables/glideVariables.ts
function makeGlideVariables(node) {
  return [
    { name: "width", dataType: "number", sourceName: "*internal.glide", sourceField: null, introducedBy: node },
    { name: "height", dataType: "number", sourceName: "*internal.glide", sourceField: null, introducedBy: node },
    { name: "url", dataType: "string", sourceName: "*internal.glide", sourceField: null, introducedBy: node }
  ];
}
var init_glideVariables = __esm({
  "server/src/antlers/variables/glideVariables.ts"() {
    "use strict";
  }
});

// server/src/diagnostics/utils.ts
function parameterError(message, symbol, parameter) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  return {
    endLine: (_c = (_b = (_a = parameter.valuePosition) == null ? void 0 : _a.end) == null ? void 0 : _b.line) != null ? _c : 0,
    startLine: (_f = (_e = (_d = parameter.namePosition) == null ? void 0 : _d.start) == null ? void 0 : _e.line) != null ? _f : 0,
    endPos: (_i = (_h = (_g = parameter.valuePosition) == null ? void 0 : _g.end) == null ? void 0 : _h.char) != null ? _i : 0,
    startPos: (_l = (_k = (_j = parameter.namePosition) == null ? void 0 : _j.start) == null ? void 0 : _k.char) != null ? _l : 0,
    message,
    severity: import_vscode_languageserver_types14.DiagnosticSeverity.Error
  };
}
var import_vscode_languageserver_types14;
var init_utils3 = __esm({
  "server/src/diagnostics/utils.ts"() {
    "use strict";
    import_vscode_languageserver_types14 = __toESM(require_main2());
  }
});

// server/src/antlers/tags/core/glideParameters.ts
function resolveGlideParameterCompletions(parameter, params) {
  if (parameter.name == "orient") {
    return exclusiveResultList(GlideOrients);
  } else if (parameter.name == "format") {
    return exclusiveResultList(GlideFormats);
  } else if (parameter.name == "filter") {
    return exclusiveResultList(GlideFilters);
  } else if (parameter.name == "preset") {
    return exclusiveResultList(params.project.getAssetPresets());
  }
  return EmptyCompletionResult;
}
var GlideFilters, GlideFormats, GlideOrients, GlideParameters;
var init_glideParameters = __esm({
  "server/src/antlers/tags/core/glideParameters.ts"() {
    "use strict";
    init_utils3();
    init_tagManager();
    GlideFilters = ["greyscale", "sepia"];
    GlideFormats = [
      "jpg",
      "pjpg",
      "png",
      "gif",
      "webp",
      "avif",
      "tif",
      "bmp",
      "psd"
    ];
    GlideOrients = ["auto", "0", "90", "180", "270"];
    GlideParameters = [
      {
        isRequired: false,
        name: "src",
        aliases: ["path", "id"],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        description: "The URL of the image when not using shorthand syntax.",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "tag",
        aliases: [],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        description: "Outputs an image tag when set to true.",
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "alt",
        description: "The alt attribute value to use when generating tags.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "absolute",
        description: "Whether to output full URLs.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        name: "width",
        expectsTypes: ["number"],
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "The width of the image, in pixels.",
        isDynamic: false
      },
      {
        name: "height",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: [],
        description: "The height of the image, in pixels.",
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "square",
        expectsTypes: ["number"],
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "Sets both then height and width of the image.",
        isDynamic: false,
        isRequired: false
      },
      {
        name: "fit",
        expectsTypes: ["string"],
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "How the image is fitted to its target dimensions.",
        isDynamic: false,
        isRequired: false
      },
      {
        name: "crop",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "Crops the image to the specific dimensions.",
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "orient",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "Rotates the image.",
        expectsTypes: ["*"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (parameter.value.trim().length > 0 && !GlideOrients.includes(parameter.value)) {
            issues.push(parameterError("Invalid orient value", node, parameter));
          }
          return issues;
        }
      },
      {
        name: "quality",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "Defines the quality of the image",
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "dpr",
        allowsVariableReference: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        description: "Defines the device pixel ratio.",
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const intVal = parseInt(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (intVal < 1 || intVal > 8) {
            issues.push(
              parameterError(
                "dpr must be an integer between 1 and 8.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "format",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        description: "Encodes the image to a specific format.",
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (parameter.value.trim().length > 0 && !GlideFormats.includes(parameter.value)) {
            issues.push(
              parameterError(
                "Format must be one of: " + GlideFormats.join(","),
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "bg",
        description: "Sets the background color for transparent images.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "blur",
        description: "Adds a blur effect to the image.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const intVal = parseInt(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (intVal < 0 || intVal > 100) {
            issues.push(
              parameterError(
                "blur must be a value between 0 and 100.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "brightness",
        description: "Adjusts the image brightness.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const intVal = parseInt(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (intVal < -100 || intVal > 100) {
            issues.push(
              parameterError(
                "brightness must be a value between -100 and 100.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "contrast",
        description: "Adjusts the image contrast.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const intVal = parseInt(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (intVal < -100 || intVal > 100) {
            issues.push(
              parameterError(
                "contrast must be a value between -100 and 100.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "gamma",
        description: "Adjusts the image gamma.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const floatVal = parseFloat(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (floatVal < 0.1 || floatVal > 9.99) {
            issues.push(
              parameterError(
                "gamma must be a value between 0.1 and 9.99.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "sharpen",
        description: "Sharpens the image.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const intVal = parseInt(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (intVal < 0 || intVal > 100) {
            issues.push(
              parameterError(
                "sharpen must be a value between 0 and 100.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "pixelate",
        description: "Applies a pixelation effect to the image.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const intVal = parseInt(parameter.value), issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (intVal < 0 || intVal > 100) {
            issues.push(
              parameterError(
                "pixelate must be a value between 0 and 100.",
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "filter",
        description: "Applies a filter effect to the image.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false,
        validate: (node, parameter) => {
          const issues = [];
          if (!parameter.containsSimpleValue()) {
            return issues;
          }
          if (parameter.value.trim().length > 0 && !GlideFilters.includes(parameter.value)) {
            issues.push(
              parameterError(
                "Filter must be one of: " + GlideFilters.join(","),
                node,
                parameter
              )
            );
          }
          return issues;
        }
      },
      {
        name: "preset",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: true,
        expectsTypes: ["string"],
        description: "A collection of pre-configured image manipulation parameters.",
        isDynamic: false,
        isRequired: false
      }
    ];
  }
});

// server/src/antlers/tags/core/glideBatch.ts
var GlideBatch, glideBatch_default;
var init_glideBatch = __esm({
  "server/src/antlers/tags/core/glideBatch.ts"() {
    "use strict";
    init_utils();
    init_glideVariables();
    init_glideParameters();
    GlideBatch = {
      tagName: "glide:batch",
      hideFromCompletions: false,
      requiresClose: true,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      injectParentScope: false,
      parameters: GlideParameters,
      introducedIn: null,
      augmentScope: (node, scope) => {
        scope.addVariables(makeGlideVariables(node));
        return scope;
      },
      resovleParameterCompletionItems: resolveGlideParameterCompletions,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "glide:batch Tag",
          "The `glide:batch` tag is similar to the glide tag, but can be used to apply image manipulations to multiple images within a piece of content.",
          "https://statamic.dev/tags/glide-batch"
        );
      }
    };
    glideBatch_default = GlideBatch;
  }
});

// server/src/antlers/tags/core/glideDataUrl.ts
var GlideDataUrl, glideDataUrl_default;
var init_glideDataUrl = __esm({
  "server/src/antlers/tags/core/glideDataUrl.ts"() {
    "use strict";
    init_utils();
    init_glideParameters();
    GlideDataUrl = {
      tagName: "glide:data_url",
      hideFromCompletions: false,
      requiresClose: true,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      injectParentScope: false,
      parameters: GlideParameters,
      introducedIn: null,
      resovleParameterCompletionItems: resolveGlideParameterCompletions,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "glide:data_url Tag",
          "The `glide:data_url` tag returns manipulated image datas as a data URI.",
          null
        );
      }
    };
    glideDataUrl_default = GlideDataUrl;
  }
});

// server/src/antlers/tags/core/glide.ts
var GlideCompletionItems, Glide, glide_default;
var init_glide = __esm({
  "server/src/antlers/tags/core/glide.ts"() {
    "use strict";
    init_utils();
    init_documentedLabel();
    init_tagManager();
    init_glideVariables();
    init_glideBatch();
    init_glideDataUrl();
    init_glideParameters();
    GlideCompletionItems = [
      tagToCompletionItem(glideBatch_default),
      tagToCompletionItem(glideDataUrl_default)
    ];
    Glide = {
      tagName: "glide",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      injectParentScope: false,
      requiresClose: false,
      parameters: GlideParameters,
      introducedIn: null,
      augmentScope: (node, scope) => {
        scope.addVariables(makeGlideVariables(node));
        return scope;
      },
      resovleParameterCompletionItems: resolveGlideParameterCompletions,
      resolveCompletionItems: (params) => {
        if (params.isPastTagPart == false && (params.leftWord == "glide" || params.leftWord == "/glide") && params.leftChar == ":") {
          return exclusiveResult(GlideCompletionItems);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "glide Tag",
          "The `glide` tag is used to manipulate images on the fly. Image manipulations may include resizing, cropping, or adjusting sharpness and constrast, amongst many others.",
          "https://statamic.dev/tags/glide"
        );
      }
    };
    glide_default = Glide;
  }
});

// server/src/antlers/tags/core/iterate.ts
var IterateTag, ForeachTag;
var init_iterate = __esm({
  "server/src/antlers/tags/core/iterate.ts"() {
    "use strict";
    init_utils();
    IterateTag = {
      tagName: "iterate",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "as",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Optionally rename the key/value variables",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "array",
          acceptsVariableInterpolation: true,
          aliases: [],
          allowsVariableReference: true,
          description: "The array to iterate",
          expectsTypes: ["array"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "iterate Tag",
          "The `iterate` tag can be used to iterate over arbitrary arrays.",
          "https://statamic.dev/tags/foreach"
        );
      }
    };
    ForeachTag = {
      tagName: "foreach",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "as",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "Optionally rename the key/value variables",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "array",
          acceptsVariableInterpolation: true,
          aliases: [],
          allowsVariableReference: true,
          description: "The array to iterate",
          expectsTypes: ["array"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "foreach Tag",
          "The `foreach` tag can be used to iterate over arbitrary arrays.",
          "https://statamic.dev/tags/foreach"
        );
      }
    };
  }
});

// server/src/antlers/variables/localeVariables.ts
function makeLocaleVariables(node) {
  return [
    { name: "url", dataType: "string", sourceField: null, sourceName: "*internal.locale", introducedBy: node },
    { name: "name", dataType: "string", sourceField: null, sourceName: "*internal.locale", introducedBy: node }
  ];
}
var init_localeVariables = __esm({
  "server/src/antlers/variables/localeVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/localeParameters.ts
var LocaleParameters;
var init_localeParameters = __esm({
  "server/src/antlers/tags/core/localeParameters.ts"() {
    "use strict";
    LocaleParameters = [
      {
        isRequired: false,
        name: "id",
        description: "The ID of the content to localize.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        name: "sort",
        description: "Sort by a site's key.",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "current_first",
        description: "When true, ensures that the current locale is first.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "all",
        description: "When true, all locale data will be returned.",
        acceptsVariableInterpolation: true,
        aliases: [],
        allowsVariableReference: true,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: true,
        name: "self",
        description: "When true, the current locale will be included.",
        acceptsVariableInterpolation: true,
        aliases: [],
        allowsVariableReference: true,
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        name: "collection_term_workaround",
        description: "Disables the behavior introduced in https://github.com/statamic/cms/pull/6466.",
        acceptsVariableInterpolation: true,
        aliases: [],
        allowsVariableReference: true,
        expectsTypes: ["boolean"],
        isDynamic: false
      }
    ];
  }
});

// server/src/antlers/tags/core/localeCount.ts
var LocalesCount, localeCount_default;
var init_localeCount = __esm({
  "server/src/antlers/tags/core/localeCount.ts"() {
    "use strict";
    init_utils();
    init_localeParameters();
    LocalesCount = {
      tagName: "locales:count",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      injectParentScope: false,
      requiresClose: true,
      parameters: LocaleParameters,
      introducedIn: "3.0.36",
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "locales:count Tag",
          "The `locales:count` tag can be used to count the number of locales the current content is available in.",
          "https://statamic.dev/tags/locales-count"
        );
      }
    };
    localeCount_default = LocalesCount;
  }
});

// server/src/antlers/tags/core/locales.ts
var LocalesCompletionItems, Locales, locales_default;
var init_locales = __esm({
  "server/src/antlers/tags/core/locales.ts"() {
    "use strict";
    init_utils();
    init_documentedLabel();
    init_tagManager();
    init_localeVariables();
    init_localeCount();
    init_localeParameters();
    LocalesCompletionItems = [
      tagToCompletionItem(localeCount_default)
    ];
    Locales = {
      tagName: "locales",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      injectParentScope: false,
      requiresClose: true,
      parameters: LocaleParameters,
      introducedIn: null,
      augmentScope: (node, scope) => {
        scope.addVariableArray("locale", makeLocaleVariables(node));
        scope.addVariable({
          name: "current",
          dataType: "string",
          sourceField: null,
          sourceName: "*internal.locale",
          introducedBy: node
        });
        scope.addVariable({
          name: "is_current",
          dataType: "boolean",
          sourceField: null,
          sourceName: "*internal.locale",
          introducedBy: node
        });
        scope.addVariable({
          name: "exists",
          dataType: "boolean",
          sourceField: null,
          sourceName: "*internal.locale",
          introducedBy: node
        });
        scope.addVariable({
          name: "permalink",
          dataType: "string",
          sourceField: null,
          sourceName: "*internal.locale",
          introducedBy: node
        });
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "locales Tag",
          "The `locales` tag can be used to access all the locales the current content is available in.",
          "https://statamic.dev/tags/locales"
        );
      },
      resolveCompletionItems: (params) => {
        if (params.isPastTagPart == false && (params.leftWord == "locale" || params.leftWord == "/locale") && params.leftChar == ":") {
          return exclusiveResult(LocalesCompletionItems);
        }
        return EmptyCompletionResult;
      }
    };
    locales_default = Locales;
  }
});

// server/src/antlers/tags/core/mix.ts
var Mix, mix_default;
var init_mix = __esm({
  "server/src/antlers/tags/core/mix.ts"() {
    "use strict";
    init_utils();
    Mix = {
      tagName: "mix",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: false,
          name: "src",
          description: "The path to the versioned file, relative to the public directory",
          acceptsVariableInterpolation: false,
          aliases: ["path"],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          name: "in",
          description: "The location of the mix manifest file",
          acceptsVariableInterpolation: false,
          aliases: ["from"],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "mix Tag",
          "The `mix` tag is used to return the path of CSS and JavaScript files versioned with [Laravel Mix](https://laravel.com/docs/8.x/mix).",
          "https://statamic.dev/tags/mix"
        );
      }
    };
    mix_default = Mix;
  }
});

// server/src/antlers/tags/core/user/permissionUtils.ts
function getAllGroupSuggestionsn(project) {
  const items = [], userGroups = project.getUniqueUserGroupNames();
  for (let i = 0; i < userGroups.length; i++) {
    items.push({
      label: userGroups[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
function getAllRolesSuggestions(project) {
  const items = [], userRoles = project.getUniqueUserRoleNames();
  for (let i = 0; i < userRoles.length; i++) {
    items.push({
      label: userRoles[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
function makeUserGroupSuggestions(existingValues, project) {
  const items = [], userGroups = project.getUniqueUserGroupNames(), groupsToReturn = userGroups.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < groupsToReturn.length; i++) {
    items.push({
      label: groupsToReturn[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
function makeUserRolesSuggestions(existingValues, project) {
  const items = [], userRoles = project.getUniqueUserRoleNames(), rolesToReturn = userRoles.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < rolesToReturn.length; i++) {
    items.push({
      label: rolesToReturn[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
var import_vscode_languageserver_types15;
var init_permissionUtils = __esm({
  "server/src/antlers/tags/core/user/permissionUtils.ts"() {
    "use strict";
    import_vscode_languageserver_types15 = __toESM(require_main2());
  }
});

// server/src/antlers/tags/core/userIn.ts
var UserIn, userIn_default;
var init_userIn = __esm({
  "server/src/antlers/tags/core/userIn.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_permissionUtils();
    UserIn = {
      tagName: "user:in",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: ["groups"],
          allowsVariableReference: false,
          name: "group",
          description: "The groups to check against.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "groups" || parameter.name == "group") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeUserGroupSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
          }
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:in Tag",
          "The `user:in` tag can be used to check if the currently authenticated user belongs to one or more user groups. When used as a tag pair, the tag contents will only be rendered if the user belongs to the specified groups.",
          "https://statamic.dev/tags/user-in"
        );
      }
    };
    userIn_default = UserIn;
  }
});

// server/src/antlers/tags/core/userNotIn.ts
var UserNotIn, userNotIn_default;
var init_userNotIn = __esm({
  "server/src/antlers/tags/core/userNotIn.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_permissionUtils();
    UserNotIn = {
      tagName: "user:not_in",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: ["groups"],
          allowsVariableReference: false,
          name: "group",
          description: "The groups to check against.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "groups" || parameter.name == "group") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeUserGroupSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
          }
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:not_in Tag",
          "The `user:not_in` tag can be used to check if the currently authenticated user does not belong to one or more user groups. When used as a tag pair, the tag contents will be rendered if the user does not belong to the specified groups.",
          "https://statamic.dev/tags/user-in#not-in"
        );
      }
    };
    userNotIn_default = UserNotIn;
  }
});

// server/src/antlers/tags/core/userIs.ts
var UserIs, userIs_default;
var init_userIs = __esm({
  "server/src/antlers/tags/core/userIs.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_permissionUtils();
    UserIs = {
      tagName: "user:is",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: ["roles"],
          allowsVariableReference: false,
          name: "role",
          description: "The roles to check against.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "roles" || parameter.name == "role") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeUserRolesSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
          }
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:is Tag",
          "The `user:is` tag can be used to check whether the currently authenticated user has one or more roles.",
          "https://statamic.dev/tags/user-is"
        );
      }
    };
    userIs_default = UserIs;
  }
});

// server/src/antlers/tags/core/userIsnt.ts
var UserIsnt, userIsnt_default;
var init_userIsnt = __esm({
  "server/src/antlers/tags/core/userIsnt.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_permissionUtils();
    UserIsnt = {
      tagName: "user:isnt",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: ["roles"],
          allowsVariableReference: false,
          name: "role",
          description: "The roles to check against.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "roles" || parameter.name == "role") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeUserRolesSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
          }
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:isnt Tag",
          "The `user:isnt` tag can be used to check whether the currently authenticated user does not have one or more roles.",
          "https://statamic.dev/tags/user-is#isnt"
        );
      }
    };
    userIsnt_default = UserIsnt;
  }
});

// server/src/antlers/tags/core/in.ts
var In, in_default;
var init_in = __esm({
  "server/src/antlers/tags/core/in.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_permissionUtils();
    In = {
      tagName: "in",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: ["groups"],
          allowsVariableReference: false,
          name: "group",
          description: "The groups to check against",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "groups" || parameter.name == "group") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeUserGroupSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
          }
        }
        return null;
      },
      resolveCompletionItems: (params) => {
        if ((params.leftWord == "in" || params.leftWord == "/in") && params.leftChar == ":") {
          return exclusiveResult(getAllGroupSuggestionsn(params.project));
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "in Tag",
          "The `in` tag can be used to check if the authenticated user belongs to one or more groups. This tag operates similarly to the `user:in` tag.",
          "https://statamic.dev/tags/user-in"
        );
      }
    };
    in_default = In;
  }
});

// server/src/antlers/tags/core/notFound.ts
var NotFound, notFound_default;
var init_notFound = __esm({
  "server/src/antlers/tags/core/notFound.ts"() {
    "use strict";
    init_utils();
    NotFound = {
      tagName: "not_found",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      parameters: [],
      introducedIn: null,
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "404 (Not Found) Tag",
          "The `not_found` tag will trigger a 404 status code, and display the 404 template to the site visitor.",
          `{{ unless logged_in }}
	{{# Display the 404 Not Found page. #}}
	{{ not_found }}
{{ /unless }}`,
          "https://statamic.dev/tags/404"
        );
      }
    };
    notFound_default = NotFound;
  }
});

// server/src/antlers/tags/core/is.ts
var Is, is_default;
var init_is = __esm({
  "server/src/antlers/tags/core/is.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_permissionUtils();
    Is = {
      tagName: "is",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: ["roles"],
          allowsVariableReference: false,
          name: "role",
          description: "The roles to check against.",
          expectsTypes: ["string", "array"],
          isDynamic: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c;
        if (parameter.name == "roles" || parameter.name == "role") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeUserRolesSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
          }
        }
        return null;
      },
      resolveCompletionItems: (params) => {
        if ((params.leftWord == "is" || params.leftWord == "/is") && params.leftChar == ":") {
          return exclusiveResult(getAllRolesSuggestions(params.project));
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "is Tag",
          "The `is` tag can be used to check whether the currently authenticated user has one or more roles. This tag behaves the same as the `user:is` tag.",
          "https://statamic.dev/tags/user-is"
        );
      }
    };
    is_default = Is;
  }
});

// server/src/antlers/tags/core/widont.ts
var Widont, widont_default;
var init_widont = __esm({
  "server/src/antlers/tags/core/widont.ts"() {
    "use strict";
    init_utils();
    Widont = {
      tagName: "widont",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "widont Tag",
          "The `widont` tag is similar to the [widont modifier](https://statamic.dev/modifiers/widont), and will attempt to prevent lines with a single word from appearing within the tags rendered output.",
          `{{ widont }}
    {{ content }}
{{ /widont }}`,
          null
        );
      }
    };
    widont_default = Widont;
  }
});

// server/src/antlers/tags/core/userProfileParameters.ts
var UserProfileParameters;
var init_userProfileParameters = __esm({
  "server/src/antlers/tags/core/userProfileParameters.ts"() {
    "use strict";
    UserProfileParameters = [
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        allowsVariableReference: true,
        aliases: [],
        name: "id",
        description: "The user ID to fetch.",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        allowsVariableReference: true,
        aliases: [],
        name: "email",
        description: "The email address to find the user by.",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        allowsVariableReference: true,
        aliases: [],
        name: "field",
        description: "The field to fetch the user by",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        allowsVariableReference: true,
        aliases: [],
        name: "value",
        description: "The value to search for.",
        expectsTypes: ["string"],
        isDynamic: false
      }
    ];
  }
});

// server/src/antlers/tags/core/userProfile.ts
var UserProfile, userProfile_default;
var init_userProfile = __esm({
  "server/src/antlers/tags/core/userProfile.ts"() {
    "use strict";
    init_utils();
    init_fieldFormatter();
    init_tagManager();
    init_userProfileParameters();
    UserProfile = {
      tagName: "user:profile",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      parameters: UserProfileParameters,
      introducedIn: null,
      augmentScope: (node, scope) => {
        scope.injectBlueprint(node, "user");
        return scope;
      },
      resovleParameterCompletionItems: (parameter, params) => {
        if (parameter.name == "field") {
          return exclusiveResult(
            formatSuggestionList(params.project.getUserFields())
          );
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:profile Tag",
          "The `user:profile` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter.",
          null
        );
      }
    };
    userProfile_default = UserProfile;
  }
});

// server/src/antlers/tags/core/dd.ts
var DdTag, DddTag;
var init_dd = __esm({
  "server/src/antlers/tags/core/dd.ts"() {
    "use strict";
    init_utils();
    DdTag = {
      tagName: "dd",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "dd Tag",
          "The `dd` tag is a useful tag for debugging, and will display the raw data available at the point the tag is rendered. This tag will stop the template from rendering after it is encountered.  If Ignition is available, this tag will use the [ddd](https://flareapp.io/blog/1-introducing-ddd-a-new-global-helper-for-laravel) method.",
          `{{ collection:articles }}
	{{#
		View all data available, for the first
		entry that renders the dd tag.
	#}}
    {{ dd }}
{{ /collection:articles }}`,
          null
        );
      }
    };
    DddTag = {
      tagName: "ddd",
      hideFromCompletions: false,
      requiresClose: false,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "ddd Tag",
          "The `ddd` tag is a useful tag for debugging, and will display the raw data available at the point the tag is rendered. This tag will stop the template from rendering after it is encountered.  If Ignition is available, this tag will use the [ddd](https://flareapp.io/blog/1-introducing-ddd-a-new-global-helper-for-laravel) method.",
          `{{ collection:articles }}
	{{#
		View all data available, for the first
		entry that renders the ddd tag.
	#}}
    {{ ddd }}
{{ /collection:articles }}`,
          null
        );
      }
    };
  }
});

// server/src/antlers/tags/core/path.ts
var PathTag, path_default;
var init_path = __esm({
  "server/src/antlers/tags/core/path.ts"() {
    "use strict";
    init_utils();
    PathTag = {
      tagName: "path",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: false,
          acceptsVariableInterpolation: false,
          aliases: ["src"],
          allowsVariableReference: true,
          description: "The path source",
          name: "to",
          isDynamic: false,
          expectsTypes: ["string"]
        },
        {
          isRequired: false,
          allowsVariableReference: true,
          acceptsVariableInterpolation: false,
          aliases: [],
          description: "Whether to generate absolute paths",
          expectsTypes: ["boolean"],
          isDynamic: false,
          name: "absolute"
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "path Tag",
          "The `path` tag can be used to generate URLs from relative URLs, or an entry ID.",
          null
        );
      }
    };
    path_default = PathTag;
  }
});

// server/src/antlers/tags/core/userCant.ts
var UserCant, userCant_default;
var init_userCant = __esm({
  "server/src/antlers/tags/core/userCant.ts"() {
    "use strict";
    init_utils();
    init_parameterCompletions();
    UserCant = {
      tagName: "user:cant",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      introducedIn: null,
      resovleParameterCompletionItems: resolveUserParameterCompletionItems,
      parameters: [
        {
          name: "do",
          acceptsVariableInterpolation: false,
          aliases: ["permission"],
          allowsVariableReference: false,
          description: "The permissions to check against",
          expectsTypes: ["string"],
          isRequired: true,
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:cant Tag",
          "The `user:cant` tag is used to check if the currently authenticated user does not have a specific set of permissions. When used as a tag pair, the tag contents will only be rendered if the user does not have the specified permissions.",
          "https://statamic.dev/tags/user-can#cant"
        );
      }
    };
    userCant_default = UserCant;
  }
});

// server/src/antlers/tags/core/queryTag.ts
var QueryTag, queryTag_default;
var init_queryTag = __esm({
  "server/src/antlers/tags/core/queryTag.ts"() {
    "use strict";
    QueryTag = {
      tagName: "query",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      introducedIn: null,
      parameters: [
        {
          name: "builder",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          description: "The query to evaluate",
          expectsTypes: ["string"],
          isRequired: true,
          isDynamic: false
        }
      ]
    };
    queryTag_default = QueryTag;
  }
});

// server/src/antlers/tags/core/theme/themeParameters.ts
var ThemePathParameters;
var init_themeParameters = __esm({
  "server/src/antlers/tags/core/theme/themeParameters.ts"() {
    "use strict";
    ThemePathParameters = [
      {
        isRequired: true,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: true,
        name: "src",
        description: "The relative path to the file.",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: true,
        name: "cache_bust",
        description: "Whether to output the last modified date.",
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: true,
        name: "version",
        description: "Whether to check a versioning manifest to produce the final URL.",
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: true,
        name: "absolute",
        description: "Generate absolute URLs or not.",
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: true,
        name: "locale",
        description: "The locale the path should be generated in.",
        expectsTypes: ["string"],
        isDynamic: false
      }
    ];
  }
});

// server/src/antlers/tags/core/theme/theme.ts
var import_vscode_languageserver_types16, ThemeTagCompletionItems, Theme, theme_default;
var init_theme = __esm({
  "server/src/antlers/tags/core/theme/theme.ts"() {
    "use strict";
    import_vscode_languageserver_types16 = __toESM(require_main2());
    init_tagManager();
    init_themeParameters();
    ThemeTagCompletionItems = [
      { label: "asset", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
      { label: "css", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
      { label: "img", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
      { label: "js", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
      { label: "output", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
      { label: "path", kind: import_vscode_languageserver_types16.CompletionItemKind.Text }
    ];
    Theme = {
      tagName: "theme",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      introducedIn: null,
      injectParentScope: false,
      parameters: ThemePathParameters,
      resolveCompletionItems: (params) => {
        if (params.isPastTagPart == false && (params.leftWord == "theme" || params.leftWord == "/theme") && params.leftChar == ":") {
          return exclusiveResult(ThemeTagCompletionItems);
        }
        return EmptyCompletionResult;
      }
    };
    theme_default = Theme;
  }
});

// server/src/antlers/tags/core/theme/themePath.ts
var ThemePath, ThemeAsset;
var init_themePath = __esm({
  "server/src/antlers/tags/core/theme/themePath.ts"() {
    "use strict";
    init_utils();
    init_alias();
    init_themeParameters();
    ThemePath = {
      tagName: "theme:path",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: ThemePathParameters,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "theme:path Tag",
          "The `theme:path` tag may be used to generate URLs for public assets. This tag may also optionally add the current locale, generate relative URLs, or add cache busting URL parameters to the end of the generated URL.",
          null
        );
      }
    };
    ThemeAsset = createDefinitionAlias(ThemePath, "theme:asset");
  }
});

// server/src/antlers/tags/core/theme/themeCss.ts
var ThemeCss, themeCss_default;
var init_themeCss = __esm({
  "server/src/antlers/tags/core/theme/themeCss.ts"() {
    "use strict";
    init_utils();
    init_themeParameters();
    ThemeCss = {
      tagName: "theme:css",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        ...ThemePathParameters,
        {
          isRequired: false,
          isDynamic: false,
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: true,
          name: "tag",
          description: "Whether to generate an HTML tag",
          expectsTypes: ["boolean"]
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "theme:css Tag",
          "The `theme:css` tag may be used to generate a CSS path relative to a public `css/` directory for any arbitrary file path. This tag may also optionally create the HTML `link` tag.",
          null
        );
      }
    };
    themeCss_default = ThemeCss;
  }
});

// server/src/antlers/tags/core/theme/themeImg.ts
var ThemeImg, themeImg_default;
var init_themeImg = __esm({
  "server/src/antlers/tags/core/theme/themeImg.ts"() {
    "use strict";
    init_utils();
    init_themeParameters();
    ThemeImg = {
      tagName: "theme:img",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        ...ThemePathParameters,
        {
          isRequired: false,
          isDynamic: false,
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: true,
          name: "tag",
          description: "Whether to generate an HTML tag",
          expectsTypes: ["boolean"]
        },
        {
          isRequired: false,
          isDynamic: false,
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: true,
          name: "alt",
          description: "The alt text to use when generating the HTML tag",
          expectsTypes: ["string"]
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "theme:img Tag",
          "The `theme:img` tag may be used to generate an image path relative to a public `img/` directory for any arbitrary file path. This tag may also optionally create the HTML `img` tag.",
          null
        );
      }
    };
    themeImg_default = ThemeImg;
  }
});

// server/src/antlers/tags/core/theme/themeJs.ts
var ThemeJavaScript, themeJs_default;
var init_themeJs = __esm({
  "server/src/antlers/tags/core/theme/themeJs.ts"() {
    "use strict";
    init_utils();
    init_themeParameters();
    ThemeJavaScript = {
      tagName: "theme:js",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        ...ThemePathParameters,
        {
          isRequired: false,
          isDynamic: false,
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: true,
          name: "tag",
          description: "Whether to generate an HTML tag",
          expectsTypes: ["boolean"]
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "theme:js Tag",
          "The `theme:js` tag may be used to generate a JavaScript path relative to a public `js/` directory for any arbitrary file path. This tag may also optionally create the HTML `script` tag.",
          null
        );
      }
    };
    themeJs_default = ThemeJavaScript;
  }
});

// server/src/antlers/tags/core/theme/themeOutput.ts
var ThemeOutput, themeOutput_default;
var init_themeOutput = __esm({
  "server/src/antlers/tags/core/theme/themeOutput.ts"() {
    "use strict";
    init_utils();
    ThemeOutput = {
      tagName: "theme:output",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          allowsVariableReference: true,
          acceptsVariableInterpolation: false,
          aliases: [],
          name: "src",
          description: "The path to the file",
          expectsTypes: ["string"],
          isDynamic: false
        },
        {
          isRequired: false,
          allowsVariableReference: true,
          acceptsVariableInterpolation: false,
          aliases: [],
          name: "as",
          description: "An optional alias for the contents variable",
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      augmentScope: (node, scope) => {
        if (node.isClosedBy != null) {
          const param = node.findParameter("as");
          if (param != null) {
            scope.addVariable({
              name: param.value,
              dataType: "string",
              sourceField: null,
              sourceName: "*internal.theme.context",
              introducedBy: node
            });
          } else {
            scope.addVariable({
              name: "output_contents",
              dataType: "string",
              sourceField: null,
              sourceName: "*internal.theme.context",
              introducedBy: node
            });
          }
        }
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "theme:output Tag",
          "The `theme:output` tag may be used to output the contents of any arbitrary file, relative to the site's `resources/` directory.",
          null
        );
      }
    };
    themeOutput_default = ThemeOutput;
  }
});

// server/src/antlers/tags/core/scopeTag.ts
var ScopeTag, scopeTag_default;
var init_scopeTag = __esm({
  "server/src/antlers/tags/core/scopeTag.ts"() {
    "use strict";
    init_utils();
    ScopeTag = {
      tagName: "scope",
      hideFromCompletions: false,
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "scope Tag",
          "The `scope` tag creates a copy of all available variables, and saves them to a new  *array* variable defined by the tag's method part.",
          `{{ scope:scope_name }}
    {{ scope_name:title }}
{{ /scope:scope_name }}
`,
          null
        );
      }
    };
    scopeTag_default = ScopeTag;
  }
});

// server/src/antlers/tags/core/conditions/if.ts
var If, if_default;
var init_if = __esm({
  "server/src/antlers/tags/core/conditions/if.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    If = {
      tagName: "if",
      hideFromCompletions: true,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: true,
      introducedIn: null,
      parameters: [],
      resolveDynamicParameter: returnDynamicParameter,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "if Conditional Control Structure",
          "The contents of the `if` tag will be rendered when it's expression evaluates to `true`.",
          "https://statamic.dev/antlers#conditions"
        );
      }
    };
    if_default = If;
  }
});

// server/src/antlers/tags/core/conditions/elseIf.ts
var ElseIf, elseIf_default;
var init_elseIf = __esm({
  "server/src/antlers/tags/core/conditions/elseIf.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    ElseIf = {
      tagName: "elseif",
      hideFromCompletions: true,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: true,
      introducedIn: null,
      parameters: [],
      resolveDynamicParameter: returnDynamicParameter,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "elseif Conditional Control Structure",
          "The contents of the `elseif` tag will be rendered when it's expression evaluates to `true`.",
          "https://statamic.dev/antlers#conditions"
        );
      }
    };
    elseIf_default = ElseIf;
  }
});

// server/src/antlers/tags/core/conditions/else.ts
var Else, else_default;
var init_else = __esm({
  "server/src/antlers/tags/core/conditions/else.ts"() {
    "use strict";
    init_utils();
    Else = {
      tagName: "else",
      hideFromCompletions: true,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: true,
      introducedIn: null,
      parameters: [],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "else Conditional Control Structure",
          "The contents of the `else` control structure will be evaluated when all previous conditional branch conditions were not met.",
          "https://statamic.dev/antlers#conditions"
        );
      }
    };
    else_default = Else;
  }
});

// server/src/antlers/tags/core/sessionHas.ts
var SessionHas, sessionHas_default;
var init_sessionHas = __esm({
  "server/src/antlers/tags/core/sessionHas.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    SessionHas = {
      tagName: "session:has",
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: false,
      allowsArbitraryParameters: true,
      allowsContentClose: true,
      parameters: [],
      introducedIn: "3.1.28",
      resolveDynamicParameter: returnDynamicParameter,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "session:has Tag",
          "The `session:has` tag can be used to determine of the user's session contains a specific variable.",
          "https://statamic.dev/tags/session-has"
        );
      }
    };
    sessionHas_default = SessionHas;
  }
});

// server/src/antlers/tags/core/session.ts
var import_vscode_languageserver_types17, SessionTagCompletionItems, SessionTag, session_default;
var init_session = __esm({
  "server/src/antlers/tags/core/session.ts"() {
    "use strict";
    import_vscode_languageserver_types17 = __toESM(require_main2());
    init_sessionVariableManager();
    init_documentedLabel();
    init_tagManager();
    init_sessionDump();
    init_sessionFlash();
    init_sessionFlush();
    init_sessionForget();
    init_sessionHas();
    init_sessionSet();
    SessionTagCompletionItems = [
      tagToCompletionItem(sessionSet_default),
      tagToCompletionItem(sessionFlash_default),
      tagToCompletionItem(sessionForget_default),
      tagToCompletionItem(sessionFlush_default),
      tagToCompletionItem(sessionHas_default),
      tagToCompletionItem(sessionDump_default)
    ];
    SessionTag = {
      tagName: "session",
      requiresClose: false,
      allowsContentClose: true,
      allowsArbitraryParameters: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "as",
          description: "An optional alias for the session data",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveCompletionItems: (params) => {
        var _a, _b;
        if (params.isPastTagPart == false && (params.leftWord == "session" || params.leftWord == "/session") && params.leftChar == ":") {
          const knownSessionVars = (_b = (_a = sessionVariableManager_default.instance) == null ? void 0 : _a.getKnownSessionVariableNames()) != null ? _b : [];
          let sessionCompletions = [];
          sessionCompletions = sessionCompletions.concat(SessionTagCompletionItems);
          for (let i = 0; i < knownSessionVars.length; i++) {
            sessionCompletions.push({
              label: knownSessionVars[i],
              kind: import_vscode_languageserver_types17.CompletionItemKind.Variable
            });
          }
          return exclusiveResult(sessionCompletions);
        }
        return EmptyCompletionResult;
      },
      augmentScope: (node, scope) => {
        var _a, _b;
        const asParam = node.findParameter("as"), knownParams = (_b = (_a = sessionVariableManager_default.instance) == null ? void 0 : _a.getKnownSessionVariableNames()) != null ? _b : [], scopeVariables = [];
        for (let i = 0; i < knownParams.length; i++) {
          scopeVariables.push({
            dataType: "*",
            name: knownParams[i],
            sourceField: null,
            sourceName: "project.session",
            introducedBy: node
          });
        }
        if (asParam == null) {
          scope.addVariables(scopeVariables);
        } else {
          scope.addVariableArray(asParam.value, scopeVariables);
        }
        return scope;
      }
    };
    session_default = SessionTag;
  }
});

// server/src/antlers/tags/core/userForgotPasswordForm.ts
var UserForgotPasswordForm, MemberForgotPasswordForm;
var init_userForgotPasswordForm = __esm({
  "server/src/antlers/tags/core/userForgotPasswordForm.ts"() {
    "use strict";
    init_utils();
    init_alias();
    init_dynamicParameterResolver();
    UserForgotPasswordForm = {
      tagName: "user:forgot_password_form",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "redirect",
          description: "Where the user should be taken after submitting the form",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDynamicParameter: returnDynamicParameter,
      augmentScope: (node, scope) => {
        scope.addVariables([
          {
            name: "success",
            dataType: "boolean",
            sourceField: null,
            sourceName: "*internal.user.reset_password",
            introducedBy: node
          },
          {
            name: "url_invalid",
            dataType: "boolean",
            sourceField: null,
            sourceName: "*internal.user.reset_password",
            introducedBy: node
          },
          {
            name: "errors",
            dataType: "array",
            sourceField: null,
            sourceName: "*internal.user.reset_password",
            introducedBy: node
          }
        ]);
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:forgot_password_form Tag",
          'The `user:forgot_password_form` tag is used to quickly create a "forgot password" form for site users.',
          "https://statamic.dev/tags/user-forgot_password_form"
        );
      }
    };
    MemberForgotPasswordForm = createDefinitionAlias(
      UserForgotPasswordForm,
      "member:forgot_password_form"
    );
    MemberForgotPasswordForm.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:forgot_password_form Tag",
        'The `member:forgot_password_form` tag is used to quickly create a "forgot password" form for site users.',
        "https://statamic.dev/tags/user-forgot_password_form"
      );
    };
  }
});

// server/src/antlers/variables/forms/fieldsVariables.ts
function makeFieldsVariables(node) {
  return [
    { name: "handle", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "display", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "type", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "field", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "error", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "instructions", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "old", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node }
  ];
}
var init_fieldsVariables = __esm({
  "server/src/antlers/variables/forms/fieldsVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/variables/forms/standardFormVariables.ts
function makeStandardFormVariables(node) {
  return [
    { name: "success", dataType: "string", sourceField: null, sourceName: "*internal.forms", introducedBy: node },
    { name: "submission_created", dataType: "boolean", sourceField: null, sourceName: "*internal.forms", introducedBy: node }
  ];
}
var init_standardFormVariables = __esm({
  "server/src/antlers/variables/forms/standardFormVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/userPasswordForm.ts
function makePasswordFormVariables(symbol) {
  return [
    { name: "current_password", dataType: "string", sourceName: "*internal.user_password_form", sourceField: null, introducedBy: symbol },
    { name: "password", dataType: "string", sourceName: "*internal.user_password_form", sourceField: null, introducedBy: symbol },
    { name: "password_confirmation", dataType: "string", sourceName: "*internal.user_password_form", sourceField: null, introducedBy: symbol }
  ];
}
var UserPasswordForm, userPasswordForm_default;
var init_userPasswordForm = __esm({
  "server/src/antlers/tags/core/userPasswordForm.ts"() {
    "use strict";
    init_fieldsVariables();
    init_standardFormVariables();
    UserPasswordForm = {
      tagName: "user:password_form",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: true,
      parameters: [
        {
          name: "redirect",
          description: "The location to redirect users after a successful form submission",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "error_redirect",
          description: "The location to redirect users to after a failed form submission",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "allow_request_redirect",
          description: "Indicates if query parameters can override redirect or error_redirect",
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      introducedIn: "3.3.61",
      allowsArbitraryParameters: true,
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeStandardFormVariables(symbol));
        scope.addVariable({ dataType: "array", name: "errors", sourceField: null, sourceName: "*internal.forms", introducedBy: symbol });
        scope.addVariableArray("fields", makeFieldsVariables(symbol));
        const scopeVariables = makePasswordFormVariables(symbol);
        scope.addVariableArray("old", scopeVariables);
        scope.addVariableArray("error", scopeVariables);
        return scope;
      }
    };
    userPasswordForm_default = UserPasswordForm;
  }
});

// server/src/antlers/tags/core/userPasswordReset.ts
var UserPasswordReset, MemberPasswordReset;
var init_userPasswordReset = __esm({
  "server/src/antlers/tags/core/userPasswordReset.ts"() {
    "use strict";
    init_utils();
    init_alias();
    init_dynamicParameterResolver();
    UserPasswordReset = {
      tagName: "user:reset_password_form",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "redirect",
          description: "Where the user should be taken after submitting the form",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDynamicParameter: returnDynamicParameter,
      augmentScope: (node, scope) => {
        scope.addVariables([
          {
            name: "success",
            dataType: "boolean",
            sourceField: null,
            sourceName: "*internal.user.password_reset",
            introducedBy: node
          },
          {
            name: "url_invalid",
            dataType: "boolean",
            sourceField: null,
            sourceName: "*internal.user.password_reset",
            introducedBy: node
          },
          {
            name: "errors",
            dataType: "array",
            sourceField: null,
            sourceName: "*internal.user.password_reset",
            introducedBy: node
          }
        ]);
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:reset_password_form Tag",
          "The `user:reset_password_form` tag is used to quickly create password reset forms. Forms created with this tag should be displayed after a user has received and clicked a password reset email link.",
          "https://statamic.dev/tags/user-reset_password_form"
        );
      }
    };
    MemberPasswordReset = createDefinitionAlias(
      UserPasswordReset,
      "member:reset_password_form"
    );
    MemberPasswordReset.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:reset_password_form Tag",
        "The `member:reset_password_form` tag is used to quickly create password reset forms. Forms created with this tag should be displayed after a user has received and clicked a password reset email link.",
        "https://statamic.dev/tags/user-reset_password_form"
      );
    };
  }
});

// server/src/antlers/scope/scopeUtilities.ts
function blueprintFieldToScopeVariable(symbol, field) {
  return {
    sourceName: field.blueprintName,
    dataType: field.type,
    name: field.name,
    sourceField: field,
    introducedBy: symbol
  };
}
function valuesToDataMap(variables) {
  const mapToReturn = /* @__PURE__ */ new Map();
  for (let i = 0; i < variables.length; i++) {
    mapToReturn.set(variables[i].name, variables[i]);
  }
  return mapToReturn;
}
function blueprintFieldsToScopeVariables(symbol, blueprintFields) {
  const variables = [];
  for (let i = 0; i < blueprintFields.length; i++) {
    const field = blueprintFields[i];
    variables.push({
      sourceName: field.blueprintName,
      dataType: field.type,
      name: field.name,
      sourceField: field,
      introducedBy: symbol
    });
  }
  return variables;
}
var init_scopeUtilities = __esm({
  "server/src/antlers/scope/scopeUtilities.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/userProfileForm.ts
var UserProfileForm, userProfileForm_default;
var init_userProfileForm = __esm({
  "server/src/antlers/tags/core/userProfileForm.ts"() {
    "use strict";
    init_scopeUtilities();
    init_fieldsVariables();
    init_standardFormVariables();
    UserProfileForm = {
      tagName: "user:profile_form",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: true,
      parameters: [
        {
          name: "redirect",
          description: "The location to redirect users after a successful form submission",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "error_redirect",
          description: "The location to redirect users to after a failed form submission",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "allow_request_redirect",
          description: "Indicates if query parameters can override redirect or error_redirect",
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      introducedIn: "3.3.61",
      allowsArbitraryParameters: true,
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeStandardFormVariables(symbol));
        scope.addVariable({ dataType: "array", name: "errors", sourceField: null, sourceName: "*internal.forms", introducedBy: symbol });
        scope.addVariableArray("fields", makeFieldsVariables(symbol));
        const userFields = scope.statamicProject.getUserFields(), scopeVariables = blueprintFieldsToScopeVariables(symbol, userFields);
        scope.addVariableArray("old", scopeVariables);
        scope.addVariableArray("error", scopeVariables);
        return scope;
      }
    };
    userProfileForm_default = UserProfileForm;
  }
});

// server/src/antlers/tags/core/userRegister.ts
var UserRegister, MemberRegister;
var init_userRegister = __esm({
  "server/src/antlers/tags/core/userRegister.ts"() {
    "use strict";
    init_utils();
    init_scopeUtilities();
    init_fieldsVariables();
    init_alias();
    init_dynamicParameterResolver();
    UserRegister = {
      tagName: "user:register_form",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "redirect",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          description: "Where the user should be redirected after registering",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "error_redirect",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          description: "Where the user should be redirected after failed registration attempts",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "allow_request_redirect",
          description: "Indicates if query parameters can override the redirect and error_redirect parameters",
          acceptsVariableInterpolation: false,
          allowsVariableReference: true,
          aliases: [],
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDynamicParameter: returnDynamicParameter,
      augmentScope: (node, scope) => {
        scope.addVariableArray("fields", makeFieldsVariables(node));
        scope.addVariable({ name: "errors", dataType: "array", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
        scope.addVariable({ name: "old", dataType: "array", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
        scope.addVariable({ name: "error", dataType: "array", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
        scope.addVariable({ name: "success", dataType: "string", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
        const userFields = scope.statamicProject.getUserFields();
        if (userFields.length > 0) {
          const userFormFields = blueprintFieldsToScopeVariables(node, userFields);
          scope.addVariableArray("old", userFormFields);
          scope.addVariableArray("error", userFormFields);
        }
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:register_form  Form Tag",
          "The `user:register_form` tag can be used to build out public registration forms for new users.",
          "https://statamic.dev/tags/user-register_form"
        );
      }
    };
    MemberRegister = createDefinitionAlias(UserRegister, "member:register_form");
    MemberRegister.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:register_form Tag",
        "The `member:register_form` tag can be used to build out public registration forms for new users.",
        "https://statamic.dev/tags/user-register_form"
      );
    };
  }
});

// server/src/antlers/tags/core/user.ts
var UserTagCompletionItems, User, user_default;
var init_user = __esm({
  "server/src/antlers/tags/core/user.ts"() {
    "use strict";
    init_utils();
    init_fieldFormatter();
    init_documentedLabel();
    init_tagManager();
    init_userCan();
    init_userCant();
    init_userForgotPasswordForm();
    init_userIs();
    init_userIsnt();
    init_userLogout();
    init_userLogoutUrl();
    init_userNotIn();
    init_userPasswordForm();
    init_userPasswordReset();
    init_userProfile();
    init_userProfileForm();
    init_userProfileParameters();
    init_userRegister();
    UserTagCompletionItems = [
      tagToCompletionItem(userIs_default),
      tagToCompletionItem(userNotIn_default),
      tagToCompletionItem(userIsnt_default),
      tagToCompletionItem(userProfile_default),
      tagToCompletionItem(userCan_default),
      tagToCompletionItem(userCant_default),
      tagToCompletionItem(UserForgotPasswordForm),
      tagToCompletionItem(userLogout_default),
      tagToCompletionItem(userLogoutUrl_default),
      tagToCompletionItem(UserRegister),
      tagToCompletionItem(UserPasswordReset),
      tagToCompletionItem(userProfileForm_default),
      tagToCompletionItem(userPasswordForm_default)
    ];
    User = {
      tagName: "user",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      parameters: UserProfileParameters,
      introducedIn: null,
      resovleParameterCompletionItems: (parameter, params) => {
        if (params.isPastTagPart == false && params.currentNode != null && params.currentNode.methodIsEmptyOrMatches("profile")) {
          if (parameter.name == "field") {
            return exclusiveResult(
              formatSuggestionList(params.project.getUserFields())
            );
          }
        }
        return EmptyCompletionResult;
      },
      augmentScope: (node, scope) => {
        if (node.methodIsEmptyOrMatches("profile")) {
          scope.injectUserFields(node);
        }
        return scope;
      },
      resolveCompletionItems: (params) => {
        if ((params.leftWord == "user" || params.leftWord == "/user" || params.leftWord == "member" || params.leftWord == "/member") && params.leftChar == ":") {
          return exclusiveResult(UserTagCompletionItems);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user Tag",
          "The `user` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter.",
          null
        );
      }
    };
    user_default = User;
  }
});

// server/src/antlers/tags/core/memberUserAliases.ts
var MemberTag, MemberIs, MemberIsnt, MemberProfile, MemberCan, MemberLogout, MemberLogoutUrl, MemberIn, MemberNotIn;
var init_memberUserAliases = __esm({
  "server/src/antlers/tags/core/memberUserAliases.ts"() {
    "use strict";
    init_utils();
    init_alias();
    init_user();
    init_userCan();
    init_userIn();
    init_userIs();
    init_userIsnt();
    init_userLogout();
    init_userLogoutUrl();
    init_userNotIn();
    init_userProfile();
    MemberTag = createDefinitionAlias(user_default, "member");
    MemberIs = createDefinitionAlias(userIs_default, "member:is");
    MemberIsnt = createDefinitionAlias(userIsnt_default, "member:isnt");
    MemberProfile = createDefinitionAlias(userProfile_default, "member:profile");
    MemberCan = createDefinitionAlias(userCan_default, "member:can");
    MemberLogout = createDefinitionAlias(userLogout_default, "member:logout");
    MemberLogoutUrl = createDefinitionAlias(userLogoutUrl_default, "member:logout_url");
    MemberIn = createDefinitionAlias(userIn_default, "member:in");
    MemberNotIn = createDefinitionAlias(userNotIn_default, "member:not_in");
    MemberTag.hideFromCompletions = true;
    MemberTag.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member Tag",
        "The `member` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter",
        null
      );
    };
    MemberIs.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:is Tag",
        "The `member:is` tag can be used to check whether the currently authenticated user has one or more roles.",
        "https://statamic.dev/tags/user-is"
      );
    };
    MemberIsnt.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:isnt Tag",
        "The `member:isnt` tag can be used to check whether the currently authenticated user does not have one or more roles.",
        "https://statamic.dev/tags/user-is#isnt"
      );
    };
    MemberProfile.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:profile Tag",
        "The `member:profile` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter",
        null
      );
    };
    MemberCan.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:can Tag",
        "The `member:can` tag is used to check if the currently authenticated user has a specific set of permissions. When used as a tag pair, the tag contents will only be rendered if the user has the specified permissions.",
        "https://statamic.dev/tags/user-can"
      );
    };
    MemberLogout.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:logout Tag",
        "The `member:logout` tag will sign out the currently authenticated user. An optional `redirect` parameter may be used to redirect the visitor to a different page after being logged out.",
        "https://statamic.dev/tags/user-logout"
      );
    };
    MemberLogoutUrl.resolveDocumentation = (params) => {
      return makeTagDocWithCodeSample(
        "member:logout_url",
        "The `member:logout_url` tag can be used to retrieve the URL that will sign the current user out.",
        `<a href="{{ member:logout_url }}">Log out</a>`,
        "https://statamic.dev/tags/user-logout_url"
      );
    };
    MemberIn.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:in Tag",
        "The `member:in` tag can be used to check if the currently authenticated user belongs to one or more user groups. When used as a tag pair, the tag contents will only be rendered if the user belongs to the specified groups.",
        "https://statamic.dev/tags/user-in"
      );
    };
    MemberNotIn.resolveDocumentation = (params) => {
      return makeTagDoc(
        "member:not_in Tag",
        "The `member:not_in` tag can be used to check if the currently authenticated user does not belong to one or more user groups. When used as a tag pair, the tag contents will be rendered if the user does not belong to the specified groups.",
        "https://statamic.dev/tags/user-in#not-in"
      );
    };
  }
});

// server/src/antlers/variables/routeableVariables.ts
function makeRoutableVariables(node) {
  return [
    { name: "title", dataType: "string", sourceField: null, sourceName: "*internal.routeable", introducedBy: node },
    { name: "url", dataType: "string", sourceField: null, sourceName: "*internal.routeable", introducedBy: node }
  ];
}
var init_routeableVariables = __esm({
  "server/src/antlers/variables/routeableVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/taxonomies/resolveTaxonomyParameterCompletions.ts
function resolveTaxonomyParameterCompletions(parameter, params) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (params.nodesInScope.length > 0) {
    const lastSymbolInScope = params.nodesInScope[params.nodesInScope.length - 1];
    if (lastSymbolInScope != null && lastSymbolInScope.currentScope != null) {
      const taxonomyNames = getTaxonomyNames(lastSymbolInScope, params.project), blueprintFields = params.project.getTaxonomyBlueprintFields(taxonomyNames), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
      if (fieldNames.includes(rootLeft)) {
        return exclusiveResult(getConditionCompletionItems(params));
      }
    }
  }
  if (parameter.name == "collection") {
    if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
      return exclusiveResult(makeCollectionNameSuggestions((_d = (_c = (_b = params.context) == null ? void 0 : _b.parameterContext.parameter) == null ? void 0 : _c.getArrayValue()) != null ? _d : [], params.project));
    }
  }
  if (parameter.name == "filter" || parameter.name == "query_scope") {
    return exclusiveResult(makeQueryScopeSuggestions(params.project));
  }
  if (AllSourceParams.includes(parameter.name)) {
    if (((_e = params.context) == null ? void 0 : _e.parameterContext) != null) {
      return exclusiveResult(makeTaxonomyNameSuggestions((_h = (_g = (_f = params.context) == null ? void 0 : _f.parameterContext.parameter) == null ? void 0 : _g.getArrayValue()) != null ? _h : [], params.project));
    }
  }
  return null;
}
var SourceTaxonomyParams, ExcludeTaxonomyParams, AllSourceParams;
var init_resolveTaxonomyParameterCompletions = __esm({
  "server/src/antlers/tags/core/taxonomies/resolveTaxonomyParameterCompletions.ts"() {
    "use strict";
    init_conditionItems();
    init_suggestionManager();
    init_tagManager();
    init_utils2();
    init_utils4();
    SourceTaxonomyParams = ["from", "taxonomy", "is", "use", "folder"];
    ExcludeTaxonomyParams = ["not_from", "not_in", "dont_use", "not_taxonomy"];
    AllSourceParams = SourceTaxonomyParams;
    AllSourceParams = AllSourceParams.concat(ExcludeTaxonomyParams);
  }
});

// server/src/antlers/tags/core/taxonomies/utils.ts
function getTaxonomyNames(symbol, statamicProject) {
  let taxonomyNames = [];
  if (symbol.hasMethodPart()) {
    taxonomyNames.push(symbol.getMethodNameValue());
    return taxonomyNames;
  }
  const fromParam = symbol.findAnyParameter(SourceTaxonomyParams), restrictParam = symbol.findAnyParameter(ExcludeTaxonomyParams);
  let fromList = [], notInList = [];
  if (typeof fromParam !== "undefined" && fromParam !== null) {
    if (fromParam.value.trim() === "*") {
      fromList = statamicProject.getUniqueTaxonomyNames();
      if (typeof restrictParam !== "undefined" && restrictParam !== null) {
        if (restrictParam.isVariableReference == false && restrictParam.hasInterpolations() == false) {
          notInList = restrictParam.getArrayValue();
        }
      }
    } else {
      if (fromParam.isVariableReference == false && fromParam.hasInterpolations() == false) {
        fromList = fromParam.getArrayValue();
      }
    }
  }
  if (notInList.length > 0) {
    taxonomyNames = fromList.filter(function(n) {
      return notInList.includes(n) == false;
    });
  } else {
    taxonomyNames = fromList;
  }
  return taxonomyNames;
}
function makeTaxonomyNameSuggestions(existingValues, project) {
  const items = [], taxonomyNames = project.getUniqueTaxonomyNames().filter((e) => !existingValues.includes(e));
  for (let i = 0; i < taxonomyNames.length; i++) {
    items.push({
      label: taxonomyNames[i],
      kind: import_vscode_languageserver_types18.CompletionItemKind.Variable
    });
  }
  return items;
}
var import_vscode_languageserver_types18;
var init_utils4 = __esm({
  "server/src/antlers/tags/core/taxonomies/utils.ts"() {
    "use strict";
    import_vscode_languageserver_types18 = __toESM(require_main2());
    init_resolveTaxonomyParameterCompletions();
  }
});

// server/src/antlers/tags/core/taxonomies/augmentTaxonomiesScope.ts
function augmentTaxonomyScope(node, scope) {
  const taxonomyNames = getTaxonomyNames(node, scope.statamicProject), fields = scope.statamicProject.getTaxonomyBlueprintFields(taxonomyNames), collectionParam = node.findParameter("collection");
  scope.addBlueprintFields(node, fields);
  scope.addVariables([
    {
      name: "first",
      dataType: "boolean",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "last",
      dataType: "boolean",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "count",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "index",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "total_results",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "entries_count",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    }
  ]);
  scope.addVariables(makeRoutableVariables(node));
  if (typeof collectionParam !== "undefined" && collectionParam !== null) {
    const collectionNames = collectionParam.getArrayValue();
    if (collectionNames.length > 0) {
      const collectionFields = scope.statamicProject.getBlueprintFields(collectionNames), aliasScope = scope.introduceScopedAliasScope(
        node,
        "entries",
        "entries",
        collectionFields
      );
      aliasScope.addVariables(makeContentVariables(node));
    } else {
      scope.addVariableArray(
        "entries",
        makeRoutableVariables(node).concat(makeContentVariables(node))
      );
    }
  } else {
    scope.addVariableArray(
      "entries",
      makeRoutableVariables(node).concat(makeContentVariables(node))
    );
  }
  return scope;
}
var init_augmentTaxonomiesScope = __esm({
  "server/src/antlers/tags/core/taxonomies/augmentTaxonomiesScope.ts"() {
    "use strict";
    init_contentVariables();
    init_routeableVariables();
    init_utils4();
  }
});

// server/src/antlers/tags/core/taxonomies/parameters.ts
var TaxonomyParameters, parameters_default;
var init_parameters3 = __esm({
  "server/src/antlers/tags/core/taxonomies/parameters.ts"() {
    "use strict";
    TaxonomyParameters = [
      {
        name: "from",
        description: "The taxonomy to use.",
        aliases: ["taxonomy", "is", "use", "folder"],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["string", "array"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "not_from",
        description: "Taxonomies to exclude.",
        aliases: ["not_in", "not_folder", "dont_use", "not_taxonomy"],
        allowsVariableReference: false,
        acceptsVariableInterpolation: false,
        expectsTypes: ["string", "array"],
        isRequired: false,
        isDynamic: false
      },
      {
        name: "min_count",
        description: "The minimum number of entries a taxonomy term must have to be returned.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["number"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "collection",
        description: "Filter the terms to those that appear in the specified collections.",
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        aliases: [],
        expectsTypes: ["string", "array"],
        isDynamic: false,
        isRequired: false
      },
      {
        name: "sort",
        description: "The field to sort the terms by.",
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false
      },
      {
        isRequired: false,
        name: "filter",
        aliases: ["query_scope"],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        description: "Specifies a custom query scope.",
        expectsTypes: ["string"],
        isDynamic: false
      }
    ];
    parameters_default = TaxonomyParameters;
  }
});

// server/src/antlers/tags/core/taxonomies/resolveCompletionItems.ts
function resolveTaxonomyCompletions(params) {
  var _a, _b;
  const items = [];
  if (params.currentNode != null && params.currentNode.currentScope != null) {
    const taxonomyNames = getTaxonomyNames(params.currentNode, params.project), blueprintFields = params.project.getTaxonomyBlueprintFields(taxonomyNames), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
    if (fieldNames.includes(rootLeft)) {
      return exclusiveResult(getConditionCompletionItems(params));
    }
    if (params.isCaretInTag && !((_a = params.context) == null ? void 0 : _a.interpolatedContext) && ["taxonomy", "/taxonomy"].includes(params.leftWord) == false) {
      const addedNames = [];
      for (let i = 0; i < blueprintFields.length; i++) {
        const thisField = blueprintFields[i];
        if (addedNames.includes(thisField.name) == false) {
          items.push({
            label: thisField.name,
            detail: thisField.blueprintName,
            documentation: (_b = thisField.instructionText) != null ? _b : "",
            kind: import_vscode_languageserver_types19.CompletionItemKind.Field
          });
          addedNames.push(thisField.name);
        }
      }
      if (items.length > 0) {
        return nonExclusiveResult(items);
      }
    }
  }
  if ((params.leftWord == "taxonomy" || params.leftWord == "/taxonomy") && params.leftChar == ":") {
    const taxonomyNames = params.project.getUniqueTaxonomyNames();
    for (let i = 0; i < taxonomyNames.length; i++) {
      items.push({
        label: taxonomyNames[i],
        kind: import_vscode_languageserver_types19.CompletionItemKind.Field
      });
    }
    return nonExclusiveResult(items);
  }
  return EmptyCompletionResult;
}
var import_vscode_languageserver_types19;
var init_resolveCompletionItems = __esm({
  "server/src/antlers/tags/core/taxonomies/resolveCompletionItems.ts"() {
    "use strict";
    import_vscode_languageserver_types19 = __toESM(require_main2());
    init_conditionItems();
    init_suggestionManager();
    init_tagManager();
    init_utils4();
  }
});

// server/src/antlers/tags/core/taxonomies/taxonomy.ts
var TaxonomyTag, taxonomy_default;
var init_taxonomy = __esm({
  "server/src/antlers/tags/core/taxonomies/taxonomy.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    init_augmentTaxonomiesScope();
    init_parameters3();
    init_resolveCompletionItems();
    init_resolveTaxonomyParameterCompletions();
    TaxonomyTag = {
      tagName: "taxonomy",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      introducedIn: null,
      injectParentScope: false,
      parameters: parameters_default,
      resolveDynamicParameter: returnDynamicParameter,
      resolveCompletionItems: resolveTaxonomyCompletions,
      resovleParameterCompletionItems: resolveTaxonomyParameterCompletions,
      augmentScope: augmentTaxonomyScope,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "taxonomy Tag",
          "The `taxonomy` tag may be used to retrieve taxonomy entries. The taxonomy tag can also be used to access entries associated with any given taxonomy term.",
          "https://statamic.dev/tags/taxonomy"
        );
      }
    };
    taxonomy_default = TaxonomyTag;
  }
});

// server/src/antlers/tags/core/nav/augmentScope.ts
function augmentNavScope(node, scope) {
  scope.addVariables([
    {
      name: "is_published",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_page",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_entry",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "has_entries",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_parent",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_current",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_external",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "depth",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "children",
      dataType: "array",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "first",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "last",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "count",
      dataType: "integer",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "index",
      dataType: "integer",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    }
  ]);
  const collectionNames = scope.statamicProject.getUniqueCollectionNames(), currentHandles = [];
  let isCollection = false;
  if (node.hasMethodPart()) {
    const nodeMethodName = node.getMethodNameValue().trim().toLowerCase();
    if (nodeMethodName.startsWith("collection:")) {
      const handleName = nodeMethodName.split(":").pop();
      isCollection = true;
      currentHandles.push(handleName);
    } else if (nodeMethodName == "pages") {
      isCollection = true;
      currentHandles.push("pages");
    } else {
      isCollection = false;
      currentHandles.push(nodeMethodName);
    }
  } else {
    const handleParam = node.findParameter("handle");
    if (handleParam != null) {
      if (collectionNames.includes(handleParam.value)) {
        isCollection = true;
      } else {
        isCollection = false;
      }
      currentHandles.push(handleParam.value);
    }
  }
  if (isCollection) {
    const blueprintFields = scope.statamicProject.getBlueprintFields(currentHandles);
    scope.addBlueprintFields(node, blueprintFields);
    scope.expandScopedAliasScope(node, "page", "page", blueprintFields);
  } else {
    const blueprintFields = variablesToBlueprintFields(
      makeRoutableVariables(node)
    );
    scope.addBlueprintFields(node, blueprintFields);
    scope.expandScopedAliasScope(node, "page", "page", blueprintFields);
  }
  return scope;
}
var init_augmentScope = __esm({
  "server/src/antlers/tags/core/nav/augmentScope.ts"() {
    "use strict";
    init_fields();
    init_routeableVariables();
  }
});

// server/src/antlers/tags/core/nav/breadcrumbs.ts
var NavBreadcrumbs, breadcrumbs_default;
var init_breadcrumbs = __esm({
  "server/src/antlers/tags/core/nav/breadcrumbs.ts"() {
    "use strict";
    init_utils();
    init_routeableVariables();
    NavBreadcrumbs = {
      tagName: "nav:breadcrumbs",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      introducedIn: null,
      injectParentScope: false,
      parameters: [
        {
          name: "include_home",
          description: "Whether to include the home page in the first level",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "reverse",
          description: "Whether to reverse the order of links",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["boolean"],
          isRequired: false,
          isDynamic: false
        },
        {
          name: "trim",
          description: "Whether to trim the whitespace after each iteration of the loop",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      augmentScope: (node, scope) => {
        scope.addVariables([
          {
            name: "is_current",
            dataType: "boolean",
            sourceName: "*internal.nav.breadcrumbs",
            sourceField: null,
            introducedBy: node
          }
        ]);
        scope.addVariables(makeRoutableVariables(node));
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "nav:breadcrumbs Tag",
          "The `nav:breadcrumbs` tag can be used to retrieve the URLs of all pages that make up the current URL back to the site's home page.",
          "https://statamic.dev/tags/nav-breadcrumbs"
        );
      }
    };
    breadcrumbs_default = NavBreadcrumbs;
  }
});

// server/src/antlers/tags/core/nav/parameterCompletions.ts
function resolveNavParameterCompletions(parameter, params) {
  if (parameter.name == "handle") {
    const collectionNames = params.project.getUniqueCollectionNames(), navNames = params.project.getUniqueNavigationMenuNames();
    let allSuggestions = [];
    allSuggestions = collectionNames;
    allSuggestions = allSuggestions.concat(navNames);
    allSuggestions = [...new Set(allSuggestions)];
    return exclusiveResultList(allSuggestions);
  }
  return null;
}
var init_parameterCompletions2 = __esm({
  "server/src/antlers/tags/core/nav/parameterCompletions.ts"() {
    "use strict";
    init_tagManager();
  }
});

// server/src/antlers/tags/core/nav/parameters.ts
var NavParameters, parameters_default2;
var init_parameters4 = __esm({
  "server/src/antlers/tags/core/nav/parameters.ts"() {
    "use strict";
    NavParameters = [
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: ["handle"],
        allowsVariableReference: false,
        name: "for",
        description: "The navigation or collection to use.",
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        name: "from",
        description: "The starting point for the navigation.",
        allowsVariableReference: true,
        expectsTypes: ["string"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        name: "show_unpublished",
        description: "Whether to include unpublished content.",
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        name: "include_home",
        description: "Whether to include the home page in the tree.",
        expectsTypes: ["boolean"],
        isDynamic: false
      },
      {
        isRequired: false,
        acceptsVariableInterpolation: false,
        aliases: [],
        allowsVariableReference: false,
        name: "max_depth",
        description: "The maximum depth of the navigation or structure.",
        expectsTypes: ["number"],
        isDynamic: false
      }
    ];
    parameters_default2 = NavParameters;
  }
});

// server/src/antlers/tags/core/nav/nav.ts
var import_vscode_languageserver_types20, StructureTag, NavTag;
var init_nav = __esm({
  "server/src/antlers/tags/core/nav/nav.ts"() {
    "use strict";
    import_vscode_languageserver_types20 = __toESM(require_main2());
    init_utils();
    init_fieldFormatter();
    init_documentedLabel();
    init_tagManager();
    init_alias();
    init_augmentScope();
    init_breadcrumbs();
    init_parameterCompletions2();
    init_parameters4();
    StructureTag = {
      tagName: "structure",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      introducedIn: null,
      injectParentScope: false,
      parameters: parameters_default2,
      augmentScope: augmentNavScope,
      resovleParameterCompletionItems: resolveNavParameterCompletions,
      resolveCompletionItems: (params) => {
        const items = [];
        if (params.isPastTagPart == false) {
          if ((params.leftWord == "nav" || params.leftWord == "/nav" || params.leftWord == "structure" || params.leftWord == "/structure") && params.leftChar == ":") {
            const navNames = params.project.getUniqueNavigationMenuNames();
            for (let i = 0; i < navNames.length; i++) {
              items.push(makeFieldSuggest(navNames[i], "", ""));
            }
            if (params.leftWord == "nav" || params.leftWord == "/nav") {
              items.push(tagToCompletionItem(breadcrumbs_default));
            }
            items.push(makeFieldSuggest("collection", "", ""));
            items.push({ label: "collection", kind: import_vscode_languageserver_types20.CompletionItemKind.Text });
            return nonExclusiveResult(items);
          }
        }
        if ((params.leftWord == "nav:collection" || params.leftWord == "/nav:collection" || params.leftWord == "collection" || params.leftWord == "/collection" || params.leftWord == "structure:collection" || params.leftWord == "/structure:collection") && params.leftChar == ":") {
          const collectionNames = params.project.getUniqueCollectionNames();
          for (let i = 0; i < collectionNames.length; i++) {
            items.push({
              label: collectionNames[i],
              kind: import_vscode_languageserver_types20.CompletionItemKind.Field
            });
          }
          return nonExclusiveResult(items);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "nav Tag",
          "The `nav` tag can be used to iterate structured collections or navigation menus.",
          "https://statamic.dev/tags/nav"
        );
      }
    };
    NavTag = createDefinitionAlias(StructureTag, "nav");
  }
});

// server/src/antlers/tags/core/form/formHandleParam.ts
var FormHandleParam, formHandleParam_default;
var init_formHandleParam = __esm({
  "server/src/antlers/tags/core/form/formHandleParam.ts"() {
    "use strict";
    FormHandleParam = {
      name: "in",
      description: "The form to use",
      acceptsVariableInterpolation: true,
      aliases: ["handle", "is", "form", "formset"],
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    };
    formHandleParam_default = FormHandleParam;
  }
});

// server/src/suggestions/defaults/httpVerbItems.ts
var import_vscode_languageserver_types21, FormHttpVerbCompletions, httpVerbItems_default;
var init_httpVerbItems = __esm({
  "server/src/suggestions/defaults/httpVerbItems.ts"() {
    "use strict";
    import_vscode_languageserver_types21 = __toESM(require_main2());
    FormHttpVerbCompletions = [
      { label: "GET", kind: import_vscode_languageserver_types21.CompletionItemKind.EnumMember },
      { label: "POST", kind: import_vscode_languageserver_types21.CompletionItemKind.EnumMember }
    ];
    httpVerbItems_default = FormHttpVerbCompletions;
  }
});

// server/src/antlers/tags/core/form/parameterCompletions.ts
function resolveFormParameterCompletions(parameter, params) {
  if (HandleParams.includes(parameter.name)) {
    return exclusiveResultList(params.project.getUniqueFormNames());
  }
  if (parameter.name == "method") {
    return exclusiveResult(httpVerbItems_default);
  }
  if (parameter.name == "files") {
    return exclusiveResult(BooleanCompletionItems);
  }
  return null;
}
var HandleParams;
var init_parameterCompletions3 = __esm({
  "server/src/antlers/tags/core/form/parameterCompletions.ts"() {
    "use strict";
    init_booleanItems();
    init_httpVerbItems();
    init_tagManager();
    HandleParams = [
      "in",
      "handle",
      "is",
      "form",
      "formset"
    ];
  }
});

// server/src/antlers/tags/core/form/resolveFormSetReference.ts
function resolveFormSetReference(context, project) {
  const parentFormSet = context.structure.findParentWithName("form:set");
  if (parentFormSet != null) {
    return {
      context: parentFormSet,
      issues: []
    };
  }
  return {
    context: null,
    issues: []
  };
}
var init_resolveFormSetReference = __esm({
  "server/src/antlers/tags/core/form/resolveFormSetReference.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/form/utils.ts
function getFormHandle(node) {
  if (node.reference != null && "tagPart" in node.reference) {
    const nodeRef = node.reference;
    if (nodeRef.nameMatches("form:set")) {
      return getFormHandle(nodeRef);
    }
  }
  const handleParam = node.findAnyParameter(HandleParams);
  const nodeMethodName = node.getMethodNameValue();
  if (nodeMethodName != null && IgnoreFormTagParts.includes(nodeMethodName) == false) {
    return nodeMethodName;
  }
  if (typeof handleParam !== "undefined" && handleParam !== null) {
    if (handleParam.containsSimpleValue()) {
      return handleParam.value;
    }
  }
  return "";
}
var IgnoreFormTagParts;
var init_utils5 = __esm({
  "server/src/antlers/tags/core/form/utils.ts"() {
    "use strict";
    init_parameterCompletions3();
    IgnoreFormTagParts = [
      "set",
      "create",
      "errors",
      "success",
      "submissions",
      "submission"
    ];
  }
});

// server/src/antlers/tags/core/form/formCreate.ts
var FormCreate, formCreate_default;
var init_formCreate = __esm({
  "server/src/antlers/tags/core/form/formCreate.ts"() {
    "use strict";
    init_utils();
    init_scopeUtilities();
    init_fieldsVariables();
    init_standardFormVariables();
    init_dynamicParameterResolver();
    init_formHandleParam();
    init_parameterCompletions3();
    init_resolveFormSetReference();
    init_utils5();
    FormCreate = {
      tagName: "form:create",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        formHandleParam_default,
        {
          name: "method",
          description: "The HTTP method to use",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "files",
          description: "Indicates if the form sends file data",
          aliases: [],
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "redirect",
          description: "The location to redirect users after a successful form submission",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "error_redirect",
          description: "The location to redirect users to after a failed form submission",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "allow_request_redirect",
          description: "Indicates if query parameters can override redirect or error_redirect",
          aliases: [],
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveSpecialType: resolveFormSetReference,
      resovleParameterCompletionItems: resolveFormParameterCompletions,
      resolveDynamicParameter: returnDynamicParameter,
      augmentScope: (symbol, scope) => {
        scope.addVariables(makeStandardFormVariables(symbol));
        scope.addVariable({ dataType: "array", name: "errors", sourceField: null, sourceName: "*internal.forms", introducedBy: symbol });
        scope.addVariableArray("fields", makeFieldsVariables(symbol));
        const formHandle = getFormHandle(symbol);
        if (formHandle.length > 0) {
          const formFields = scope.statamicProject.getFormBlueprintFields(formHandle), scopeVariables = blueprintFieldsToScopeVariables(symbol, formFields);
          scope.addVariableArray("old", scopeVariables);
          scope.addVariableArray("error", scopeVariables);
        }
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "form:create Tag",
          "The `form:create` tag can be used to access form data, generate field HTML markup, and handle form validation errors.",
          "https://statamic.dev/tags/form-create"
        );
      }
    };
    formCreate_default = FormCreate;
  }
});

// server/src/antlers/tags/core/form/formErrors.ts
var FormErrors, formErrors_default;
var init_formErrors = __esm({
  "server/src/antlers/tags/core/form/formErrors.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_formHandleParam();
    init_parameterCompletions3();
    init_resolveFormSetReference();
    FormErrors = {
      tagName: "form:errors",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        formHandleParam_default
      ],
      resolveSpecialType: resolveFormSetReference,
      resovleParameterCompletionItems: (parameter, params) => {
        if (HandleParams.includes(parameter.name)) {
          return exclusiveResultList(params.project.getUniqueFormNames());
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "form:errors Tag",
          "The `form:errors` tag can be used to retrieve validation errors after a user has submitted a form.",
          "https://statamic.dev/tags/form-errors"
        );
      }
    };
    formErrors_default = FormErrors;
  }
});

// server/src/antlers/tags/core/form/formSet.ts
var FormSetTag, formSet_default;
var init_formSet = __esm({
  "server/src/antlers/tags/core/form/formSet.ts"() {
    "use strict";
    init_utils();
    init_parameterCompletions3();
    FormSetTag = {
      tagName: "form:set",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "in",
          description: "The form to use",
          acceptsVariableInterpolation: true,
          aliases: ["handle", "is", "form", "formset"],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: true
        }
      ],
      resovleParameterCompletionItems: resolveFormParameterCompletions,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "form:set Tag",
          "The `form:set` tag can be used to set the form handle on all nested form tags.",
          "https://statamic.dev/tags/form-set"
        );
      }
    };
    formSet_default = FormSetTag;
  }
});

// server/src/antlers/tags/core/form/formSubmission.ts
var FormSubmission, formSubmission_default;
var init_formSubmission = __esm({
  "server/src/antlers/tags/core/form/formSubmission.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_formHandleParam();
    init_parameterCompletions3();
    init_resolveFormSetReference();
    init_utils5();
    FormSubmission = {
      tagName: "form:submission",
      requiresClose: true,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [formHandleParam_default],
      resolveSpecialType: resolveFormSetReference,
      resovleParameterCompletionItems: (parameter, params) => {
        if (HandleParams.includes(parameter.name)) {
          return exclusiveResultList(params.project.getUniqueFormNames());
        }
        return null;
      },
      augmentScope: (symbol, scope) => {
        const formHandle = getFormHandle(symbol);
        if (formHandle.length > 0) {
          const formFields = scope.statamicProject.getFormBlueprintFields(formHandle);
          scope.addBlueprintFields(symbol, formFields);
        }
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "form:submission Tag",
          "The `form:submission` tag can be used to access the form submission submitted by the current user.",
          "https://statamic.dev/tags/form-submission"
        );
      }
    };
    formSubmission_default = FormSubmission;
  }
});

// server/src/antlers/tags/core/form/formSubmissions.ts
var FormSubmissions, formSubmissions_default;
var init_formSubmissions = __esm({
  "server/src/antlers/tags/core/form/formSubmissions.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_formHandleParam();
    init_parameterCompletions3();
    init_resolveFormSetReference();
    init_utils5();
    FormSubmissions = {
      tagName: "form:submissions",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      requiresClose: true,
      introducedIn: null,
      parameters: [formHandleParam_default],
      resolveSpecialType: resolveFormSetReference,
      resovleParameterCompletionItems: (parameter, params) => {
        if (HandleParams.includes(parameter.name)) {
          return exclusiveResultList(params.project.getUniqueFormNames());
        }
        return null;
      },
      augmentScope: (symbol, scope) => {
        if (symbol.isClosingTag) {
          return scope;
        }
        const formHandle = getFormHandle(symbol);
        if (formHandle.length > 0) {
          const formFields = scope.statamicProject.getFormBlueprintFields(formHandle);
          scope.addBlueprintFields(symbol, formFields);
        }
        scope.addVariable({
          name: "date",
          dataType: "date",
          sourceField: null,
          sourceName: "*internal.forms.submissions",
          introducedBy: symbol
        });
        scope.addVariable({
          name: "no_results",
          dataType: "boolean",
          sourceField: null,
          sourceName: "*internal.forms.submissions",
          introducedBy: symbol
        });
        scope.addVariable({
          name: "total_results",
          dataType: "number",
          sourceField: null,
          sourceName: "*internal.forms.submissions",
          introducedBy: symbol
        });
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "form:submissions Tag",
          "The `form:submissions` tag can be used to fetch previously saved submissions for a form.",
          "https://statamic.dev/tags/form-submissions"
        );
      }
    };
    formSubmissions_default = FormSubmissions;
  }
});

// server/src/antlers/tags/core/form/formSuccess.ts
var FormSuccess, formSuccess_default;
var init_formSuccess = __esm({
  "server/src/antlers/tags/core/form/formSuccess.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_formHandleParam();
    init_parameterCompletions3();
    init_resolveFormSetReference();
    FormSuccess = {
      tagName: "form:success",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        formHandleParam_default
      ],
      resolveSpecialType: resolveFormSetReference,
      resovleParameterCompletionItems: (parameter, params) => {
        if (HandleParams.includes(parameter.name)) {
          return exclusiveResultList(params.project.getUniqueFormNames());
        }
        return null;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "form:success Tag",
          "The `form:success` tag can be used to check if a form submission was successful or not.",
          "https://statamic.dev/tags/form-success"
        );
      }
    };
    formSuccess_default = FormSuccess;
  }
});

// server/src/antlers/tags/core/form/form.ts
var import_vscode_languageserver_types22, FormCompletions, FormTag, form_default;
var init_form = __esm({
  "server/src/antlers/tags/core/form/form.ts"() {
    "use strict";
    import_vscode_languageserver_types22 = __toESM(require_main2());
    init_documentedLabel();
    init_tagManager();
    init_formCreate();
    init_formErrors();
    init_formSet();
    init_formSubmission();
    init_formSubmissions();
    init_formSuccess();
    init_parameterCompletions3();
    FormCompletions = [
      tagToCompletionItem(formSet_default),
      tagToCompletionItem(formCreate_default),
      tagToCompletionItem(formErrors_default),
      tagToCompletionItem(formSuccess_default),
      tagToCompletionItem(formSubmissions_default),
      tagToCompletionItem(formSubmission_default)
    ];
    FormTag = {
      tagName: "form",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [],
      resovleParameterCompletionItems: resolveFormParameterCompletions,
      resolveCompletionItems: (params) => {
        let items = [];
        if (params.isPastTagPart == false && (params.leftWord == "form" || params.leftWord == "/form") && params.leftChar == ":") {
          const formNames = params.project.getUniqueFormNames();
          items = items.concat(FormCompletions);
          for (let i = 0; i < formNames.length; i++) {
            items.push({
              label: formNames[i],
              kind: import_vscode_languageserver_types22.CompletionItemKind.Field
            });
          }
          return nonExclusiveResult(items);
        }
        return EmptyCompletionResult;
      }
    };
    form_default = FormTag;
  }
});

// server/src/antlers/tags/core/search.ts
function makeDefaultSearchResultVariables(node) {
  return [
    {
      name: "url",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "title",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "content",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "first",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "last",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "is_entry",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "is_term",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "count",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "index",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "search_score",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "_highlightResult",
      dataType: "array",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    }
  ];
}
var SearchResultsTag, SearchCompletionItems, BaseSearchTag;
var init_search = __esm({
  "server/src/antlers/tags/core/search.ts"() {
    "use strict";
    init_utils();
    init_documentedLabel();
    init_tagManager();
    SearchResultsTag = {
      tagName: "search:results",
      allowsArbitraryParameters: false,
      requiresClose: true,
      allowsContentClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "index",
          description: "The index to search in.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "query",
          description: "The query string parameter to use.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "limit",
          description: "The maximum number of search results to return.",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          isRequired: false,
          isDynamic: false,
          expectsTypes: ["number"]
        },
        {
          name: "offset",
          description: "The number of results to skip.",
          allowsVariableReference: false,
          acceptsVariableInterpolation: false,
          aliases: [],
          isRequired: false,
          isDynamic: false,
          expectsTypes: ["number"]
        },
        {
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: null,
          description: "Sets whether or not to paginate entry results.",
          expectsTypes: ["boolean"],
          isRequired: false,
          name: "paginate",
          isDynamic: false
        },
        {
          name: "as",
          description: "Specifies an alias for search results.",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "supplement_data",
          description: "Controls whether non-indexed fields are returned.",
          acceptsVariableInterpolation: false,
          allowsVariableReference: false,
          aliases: [],
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resovleParameterCompletionItems: (parameter, params) => {
        if (parameter.name == "index") {
          return exclusiveResultList(params.project.getSearchIndexes());
        }
        return null;
      },
      augmentScope: (node, scope) => {
        scope.addVariables([
          {
            name: "no_results",
            dataType: "boolean",
            sourceField: null,
            sourceName: "*internal.search.results",
            introducedBy: node
          },
          {
            name: "total_results",
            dataType: "number",
            sourceField: null,
            sourceName: "*internal.search.results",
            introducedBy: node
          }
        ]);
        const asParam = node.findParameter("as");
        if (asParam != null && asParam.value.trim().length > 0) {
          scope.addVariableArray(
            asParam.value,
            makeDefaultSearchResultVariables(node)
          );
        } else {
          scope.addVariables(makeDefaultSearchResultVariables(node));
        }
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "search:results Tag",
          "The `search:results` tag provides access to all data that was returned as a result of a user's search.",
          "https://statamic.dev/tags/search"
        );
      }
    };
    SearchCompletionItems = [
      tagToCompletionItem(SearchResultsTag)
    ];
    BaseSearchTag = {
      tagName: "search",
      allowsArbitraryParameters: false,
      requiresClose: true,
      allowsContentClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [],
      resolveCompletionItems: (params) => {
        if (params.isPastTagPart == false && (params.leftWord == "search" || params.leftWord == "/search") && params.leftChar == ":") {
          return nonExclusiveResult(SearchCompletionItems);
        }
        return EmptyCompletionResult;
      }
    };
  }
});

// server/src/antlers/tags/core/userLoginForm.ts
function makeUserLoginFields(node) {
  return [
    { name: "email", dataType: "string", sourceName: "*internal.user.login", sourceField: null, introducedBy: node },
    { name: "password", dataType: "string", sourceName: "*internal.user.login", sourceField: null, introducedBy: node }
  ];
}
var UserLoginForm, MemberLoginForm;
var init_userLoginForm = __esm({
  "server/src/antlers/tags/core/userLoginForm.ts"() {
    "use strict";
    init_utils();
    init_alias();
    init_dynamicParameterResolver();
    UserLoginForm = {
      tagName: "user:login_form",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: [
        {
          name: "redirect",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          description: "Where the user should be redirected after logging in",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "error_redirect",
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: true,
          description: "Where the user should be redirected after failed login attempts",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false
        },
        {
          name: "allow_request_redirect",
          description: "Indicates if query parameters can override the redirect and error_redirect parameters",
          acceptsVariableInterpolation: false,
          allowsVariableReference: true,
          aliases: [],
          expectsTypes: ["boolean"],
          isDynamic: false,
          isRequired: false
        }
      ],
      resolveDynamicParameter: returnDynamicParameter,
      augmentScope: (node, scope) => {
        scope.addVariables([
          { name: "errors", dataType: "array", sourceName: "*internal.user.login", sourceField: null, introducedBy: node },
          { name: "success", dataType: "string", sourceName: "*internal.user.login", sourceField: null, introducedBy: node }
        ]);
        scope.addVariables(makeUserLoginFields(node));
        scope.addVariableArray("old", makeUserLoginFields(node));
        scope.addVariableArray("error", makeUserLoginFields(node));
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user:login_form Tag",
          "The `user:login_form` tag can be used to quickly create a form that users can use to authenticate with the site.",
          "https://statamic.dev/tags/user-login_form"
        );
      }
    };
    MemberLoginForm = createDefinitionAlias(UserLoginForm, "member:login_form");
  }
});

// server/src/antlers/tags/core/noParse.ts
var NoParse, noParse_default;
var init_noParse = __esm({
  "server/src/antlers/tags/core/noParse.ts"() {
    "use strict";
    init_utils();
    NoParse = {
      tagName: "noparse",
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      parameters: [],
      introducedIn: null,
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "noparse Tag",
          "The `noparse` tag is used prevent blocks of Antlers code from being parsed, removing the need to escape individual Antlers code regions.",
          "https://statamic.dev/antlers#the-noparse-tag"
        );
      }
    };
    noParse_default = NoParse;
  }
});

// server/src/antlers/tags/core/conditions/unless.ts
var Unless, unless_default;
var init_unless = __esm({
  "server/src/antlers/tags/core/conditions/unless.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    Unless = {
      tagName: "unless",
      hideFromCompletions: true,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: true,
      introducedIn: null,
      parameters: [],
      resolveDynamicParameter: returnDynamicParameter,
      resolveDocumentation: (docs) => {
        return makeTagDoc(
          "unless Conditional Control Structure",
          "The `unless` control structure operates the same as an `if` statement, but has it's logic inverted.",
          "https://statamic.dev/antlers#conditions"
        );
      }
    };
    unless_default = Unless;
  }
});

// server/src/antlers/tags/core/conditions/elseUnless.ts
var ElseUnless, elseUnless_default;
var init_elseUnless = __esm({
  "server/src/antlers/tags/core/conditions/elseUnless.ts"() {
    "use strict";
    init_utils();
    init_dynamicParameterResolver();
    ElseUnless = {
      tagName: "elseunless",
      hideFromCompletions: true,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: true,
      injectParentScope: true,
      introducedIn: null,
      parameters: [],
      resolveDynamicParameter: returnDynamicParameter,
      resolveDocumentation: (docs) => {
        return makeTagDoc(
          "elseunless Conditional Control Structure",
          "The `elseunless` control structure operates the same as an `elseif` statement, but has it's logic inverted.",
          "https://statamic.dev/antlers#conditions"
        );
      }
    };
    elseUnless_default = ElseUnless;
  }
});

// server/src/antlers/tags/core/installed.ts
var import_vscode_languageserver8, InstalledTag;
var init_installed = __esm({
  "server/src/antlers/tags/core/installed.ts"() {
    "use strict";
    import_vscode_languageserver8 = __toESM(require_main4());
    init_utils();
    init_tagManager();
    InstalledTag = {
      tagName: "installed",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: true,
      introducedIn: "3.1.19",
      parameters: [],
      resolveCompletionItems: (params) => {
        if (params.project != null) {
          const projectPackages = params.project.getComposerPackages(), packageCompletions = [];
          projectPackages.forEach((composerPackage, packageName) => {
            packageCompletions.push({
              label: composerPackage.name,
              kind: import_vscode_languageserver8.CompletionItemKind.Text
            });
          });
          return exclusiveResult(packageCompletions);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "installed Tag",
          "The `installed` tag is used to check if the site has a specific Composer package available.",
          `{{ if {installed:composer/package-name} }}
    {{# Package is availabl.e #}}
{{ else }}
    {{# Something else. #}}
{{ /if }}`,
          "https://statamic.dev/tags/installed"
        );
      }
    };
  }
});

// server/src/antlers/tags/core/relate.ts
var Relate, relate_default;
var init_relate = __esm({
  "server/src/antlers/tags/core/relate.ts"() {
    "use strict";
    Relate = {
      tagName: "relate",
      hideFromCompletions: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      injectParentScope: false,
      requiresClose: true,
      introducedIn: null,
      parameters: []
    };
    relate_default = Relate;
  }
});

// server/src/antlers/tags/core/getErrors/getErrorsParameters.ts
var GetErrorsParameters;
var init_getErrorsParameters = __esm({
  "server/src/antlers/tags/core/getErrors/getErrorsParameters.ts"() {
    "use strict";
    GetErrorsParameters = [
      {
        name: "bag",
        description: "The error message bag to retrieve errors from.",
        aliases: [],
        acceptsVariableInterpolation: false,
        allowsVariableReference: false,
        expectsTypes: ["string"],
        isDynamic: false,
        isRequired: false
      }
    ];
  }
});

// server/src/antlers/tags/core/getErrors/getErrors.ts
var GetErrors, getErrors_default;
var init_getErrors = __esm({
  "server/src/antlers/tags/core/getErrors/getErrors.ts"() {
    "use strict";
    init_utils();
    init_getErrorsParameters();
    GetErrors = {
      tagName: "get_errors",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      parameters: GetErrorsParameters,
      introducedIn: "3.2.23",
      augmentScope: (node, scope) => {
        var _a;
        if (node.isClosingTag) {
          return scope;
        }
        if (((_a = node.name) == null ? void 0 : _a.methodPart) == null) {
          const fieldsScope = scope.copy();
          fieldsScope.addVariable({
            dataType: "string",
            introducedBy: node,
            name: "field",
            sourceName: "*internal.tag.get_errors",
            sourceField: {
              blueprintName: "*internal.tag.get_errors",
              displayName: "get_errors",
              import: null,
              instructionText: null,
              maxItems: null,
              name: "field",
              refFieldSetField: null,
              sets: null,
              type: "string"
            }
          });
          const messageScope = fieldsScope.copy();
          messageScope.addVariable({
            dataType: "string",
            introducedBy: node,
            name: "message",
            sourceName: "*internal.tag.get_errors",
            sourceField: {
              blueprintName: "*internal.tag.get_errors",
              displayName: "get_errors",
              import: null,
              instructionText: null,
              maxItems: null,
              name: "message",
              refFieldSetField: null,
              sets: null,
              type: "string"
            }
          });
          fieldsScope.addScopeList("messages", messageScope);
          scope.addScopeList("fields", fieldsScope);
        } else {
          const errorScope = scope.copy();
          errorScope.addVariable({
            dataType: "string",
            introducedBy: node,
            name: "message",
            sourceName: "*internal.tag.get_errors",
            sourceField: {
              blueprintName: "*internal.tag.get_errors",
              displayName: "get_errors",
              import: null,
              instructionText: null,
              maxItems: null,
              name: "message",
              refFieldSetField: null,
              sets: null,
              type: "string"
            }
          });
          scope.addScopeList("messages", errorScope);
        }
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "get_errors Tag",
          "The `get_errors` tag can be used to retrieve form validation errors.",
          "https://statamic.dev/tags/get_errors"
        );
      }
    };
    getErrors_default = GetErrors;
  }
});

// server/src/antlers/tags/core/getErrors/getAllErrors.ts
var GetAllErrors, getAllErrors_default;
var init_getAllErrors = __esm({
  "server/src/antlers/tags/core/getErrors/getAllErrors.ts"() {
    "use strict";
    init_utils();
    init_getErrorsParameters();
    GetAllErrors = {
      tagName: "get_errors:all",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      parameters: GetErrorsParameters,
      introducedIn: null,
      augmentScope: (node, scope) => {
        if (node.isClosingTag) {
          return scope;
        }
        const errorScope = scope.copy();
        errorScope.addVariable({
          dataType: "string",
          introducedBy: node,
          name: "message",
          sourceName: "*internal.tag.get_errors.all",
          sourceField: {
            blueprintName: "*internal.tag.get_errors.all",
            displayName: "get_errors:all",
            import: null,
            instructionText: null,
            maxItems: null,
            name: "message",
            refFieldSetField: null,
            sets: null,
            type: "string"
          }
        });
        scope.addScopeList("messages", errorScope);
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "get_errors:all Tag",
          "The `get_errors:all` tag can be used to retrieve all form validation errors.",
          "https://statamic.dev/tags/get_errors#list-all-validation-errors"
        );
      }
    };
    getAllErrors_default = GetAllErrors;
  }
});

// server/src/antlers/tags/core/getErrors/getError.ts
var GetError, getError_default;
var init_getError = __esm({
  "server/src/antlers/tags/core/getErrors/getError.ts"() {
    "use strict";
    init_utils();
    init_getErrorsParameters();
    GetError = {
      tagName: "get_error",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      parameters: GetErrorsParameters,
      introducedIn: null,
      augmentScope: (node, scope) => {
        if (node.isClosingTag) {
          return scope;
        }
        scope.addVariable({
          dataType: "string",
          introducedBy: node,
          name: "message",
          sourceName: "*internal.tag.get_error",
          sourceField: {
            blueprintName: "*internal.tag.get_error",
            displayName: "get_error",
            import: null,
            instructionText: null,
            maxItems: null,
            name: "message",
            refFieldSetField: null,
            sets: null,
            type: "string"
          }
        });
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "get_error Tag",
          "The `get_error` tag can be used to retrieve the first error message for a specific field.",
          "https://statamic.dev/tags/get_errors#get-the-first-error-for-a-specific-field"
        );
      }
    };
    getError_default = GetError;
  }
});

// server/src/antlers/tags/core/set.ts
var SetTag, set_default;
var init_set = __esm({
  "server/src/antlers/tags/core/set.ts"() {
    "use strict";
    SetTag = {
      tagName: "set",
      hideFromCompletions: true,
      allowsArbitraryParameters: true,
      requiresClose: false,
      allowsContentClose: false,
      injectParentScope: false,
      introducedIn: null,
      parameters: []
    };
    set_default = SetTag;
  }
});

// server/src/antlers/tags/core/mountUrl.ts
var import_vscode_languageserver9, MountUrlTag, mountUrl_default;
var init_mountUrl = __esm({
  "server/src/antlers/tags/core/mountUrl.ts"() {
    "use strict";
    import_vscode_languageserver9 = __toESM(require_main4());
    init_utils();
    init_tagManager();
    init_utils2();
    MountUrlTag = {
      tagName: "mount_url",
      hideFromCompletions: false,
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: false,
      injectParentScope: false,
      introducedIn: "3.3.15",
      parameters: [
        {
          isRequired: false,
          acceptsVariableInterpolation: true,
          aliases: [],
          allowsVariableReference: true,
          description: "The collection handle.",
          name: "handle",
          isDynamic: false,
          expectsTypes: ["string"]
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "mount Tag",
          "The `mount` tag can be used to retrieve the mount URL for a given collection.",
          null
        );
      },
      resovleParameterCompletionItems: (parameter, params) => {
        var _a, _b, _c, _d;
        if (parameter.name == "handle") {
          if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
            return exclusiveResult(makeCollectionNameSuggestions((_d = (_c = (_b = params.context) == null ? void 0 : _b.parameterContext.parameter) == null ? void 0 : _c.getArrayValue()) != null ? _d : [], params.project));
          }
        }
        return null;
      },
      resolveCompletionItems: (params) => {
        const items = [];
        if (params.isPastTagPart == false && (params.leftWord == "mount_url" || params.leftWord == "/mount_url") && params.leftChar == ":") {
          const collectionNames = params.project.getCollectionNames();
          for (let i = 0; i < collectionNames.length; i++) {
            items.push({
              label: collectionNames[i],
              kind: import_vscode_languageserver9.CompletionItemKind.Field,
              sortText: "0"
            });
          }
        }
        return {
          items,
          analyzeDefaults: false,
          isExclusiveResult: false
        };
      }
    };
    mountUrl_default = MountUrlTag;
  }
});

// server/src/antlers/tags/core/vite/viteAsset.ts
var ViteAsset, viteAsset_default;
var init_viteAsset = __esm({
  "server/src/antlers/tags/core/vite/viteAsset.ts"() {
    "use strict";
    init_utils();
    ViteAsset = {
      tagName: "vite:asset",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: "3.4.4",
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          name: "src",
          description: "The asset's path",
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "vite Tag",
          "Generates Vite asset URL for the provided resource.",
          `<img src="{{ vite:asset src="resources/images/logo.svg" /}}" />`,
          null
        );
      }
    };
    viteAsset_default = ViteAsset;
  }
});

// server/src/antlers/tags/core/vite.ts
var ViteTagCompletionItems, Vite, vite_default;
var init_vite = __esm({
  "server/src/antlers/tags/core/vite.ts"() {
    "use strict";
    init_utils();
    init_tagManager();
    init_documentedLabel();
    init_viteAsset();
    ViteTagCompletionItems = [
      tagToCompletionItem(viteAsset_default)
    ];
    Vite = {
      tagName: "vite",
      hideFromCompletions: false,
      requiresClose: true,
      injectParentScope: false,
      allowsContentClose: false,
      allowsArbitraryParameters: false,
      introducedIn: null,
      parameters: [
        {
          isRequired: true,
          acceptsVariableInterpolation: false,
          aliases: [],
          allowsVariableReference: false,
          name: "src",
          description: "The entry point",
          expectsTypes: ["string"],
          isDynamic: false
        }
      ],
      resolveCompletionItems: (params) => {
        if ((params.leftWord == "vite" || params.leftWord == "/vite") && params.leftChar == ":") {
          return exclusiveResult(ViteTagCompletionItems);
        }
        return EmptyCompletionResult;
      },
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "vite Tag",
          "Generates Vite tags for an entrypoint.",
          `{{ vite src="entry/point" }}`,
          null
        );
      }
    };
    vite_default = Vite;
  }
});

// server/src/antlers/tags/core/nocache.ts
var NoCache, nocache_default;
var init_nocache = __esm({
  "server/src/antlers/tags/core/nocache.ts"() {
    "use strict";
    init_utils();
    NoCache = {
      tagName: "nocache",
      requiresClose: true,
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      parameters: [],
      introducedIn: null,
      resolveDocumentation: (params) => {
        return makeTagDocWithCodeSample(
          "nocache Tag",
          "The `nocache` tag is used to mark regions of a template. These regions will continue to update even when using caching strategies such as the full or half-measure cache.",
          `{{ nocache }} 
    <!-- This content will remain dynamic. -->
{{ /nocache }}`,
          "https://statamic.dev/tags/nocache"
        );
      }
    };
    nocache_default = NoCache;
  }
});

// server/src/antlers/variables/userPermissionsVariables.ts
function makeUserPermissionsVariables(node) {
  return [
    { name: "no_results", dataType: "boolean", sourceField: null, sourceName: "*internal.user.permissions", introducedBy: node },
    { name: "total_results", dataType: "integer", sourceField: null, sourceName: "*internal.user.permissions", introducedBy: node },
    { name: "handle", dataType: "string", sourceField: null, sourceName: "*internal.user.permissions", introducedBy: node }
  ];
}
var init_userPermissionsVariables = __esm({
  "server/src/antlers/variables/userPermissionsVariables.ts"() {
    "use strict";
  }
});

// server/src/antlers/tags/core/userRoles.ts
var UserRoles, userRoles_default;
var init_userRoles = __esm({
  "server/src/antlers/tags/core/userRoles.ts"() {
    "use strict";
    init_utils();
    init_userPermissionsVariables();
    UserRoles = {
      tagName: "user_roles",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      injectParentScope: false,
      introducedIn: "3.3.31",
      requiresClose: false,
      parameters: [
        {
          name: "handle",
          description: "A list of role handles to include",
          aliases: [],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false,
          acceptsVariableInterpolation: true
        }
      ],
      augmentScope: (node, scope) => {
        if (node.isClosingTag) {
          return scope;
        }
        scope.addVariables(makeUserPermissionsVariables(node));
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user_roles Tag",
          "The `user_roles` tag can be used to return information about a site's user roles.",
          null
        );
      }
    };
    userRoles_default = UserRoles;
  }
});

// server/src/antlers/tags/core/userGroups.ts
var UserGroups, userGroups_default;
var init_userGroups = __esm({
  "server/src/antlers/tags/core/userGroups.ts"() {
    "use strict";
    init_utils();
    init_userPermissionsVariables();
    UserGroups = {
      tagName: "user_groups",
      hideFromCompletions: false,
      allowsArbitraryParameters: false,
      allowsContentClose: true,
      injectParentScope: false,
      introducedIn: "3.3.31",
      requiresClose: false,
      parameters: [
        {
          name: "handle",
          description: "A list of group handles to include",
          aliases: [],
          allowsVariableReference: true,
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: false,
          acceptsVariableInterpolation: true
        }
      ],
      augmentScope: (node, scope) => {
        if (node.isClosingTag) {
          return scope;
        }
        scope.addVariables(makeUserPermissionsVariables(node));
        return scope;
      },
      resolveDocumentation: (params) => {
        return makeTagDoc(
          "user_groups Tag",
          "The `user_groups` tag can be used to return information about a site's user groups.",
          null
        );
      }
    };
    userGroups_default = UserGroups;
  }
});

// server/src/antlers/tags/core/cookie/cookieForget.ts
var CookieForget, cookieForget_default;
var init_cookieForget = __esm({
  "server/src/antlers/tags/core/cookie/cookieForget.ts"() {
    "use strict";
    CookieForget = {
      tagName: "cookie:forget",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: "3.3.38",
      parameters: [
        {
          name: "keys",
          aliases: [],
          acceptsVariableInterpolation: true,
          allowsVariableReference: true,
          description: "The keys to forget",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: true
        }
      ]
    };
    cookieForget_default = CookieForget;
  }
});

// server/src/antlers/tags/core/cookie/cookieHas.ts
var CookieHas, cookieHas_default;
var init_cookieHas = __esm({
  "server/src/antlers/tags/core/cookie/cookieHas.ts"() {
    "use strict";
    CookieHas = {
      tagName: "cookie:has",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: "3.3.38",
      parameters: [
        {
          name: "key",
          aliases: [],
          acceptsVariableInterpolation: true,
          allowsVariableReference: true,
          description: "The cookie name to check for existence",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: true
        }
      ]
    };
    cookieHas_default = CookieHas;
  }
});

// server/src/antlers/tags/core/cookie/cookieSet.ts
var CookieSet, cookieSet_default;
var init_cookieSet = __esm({
  "server/src/antlers/tags/core/cookie/cookieSet.ts"() {
    "use strict";
    CookieSet = {
      tagName: "cookie:set",
      allowsArbitraryParameters: true,
      allowsContentClose: false,
      requiresClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: "3.3.38",
      parameters: [
        {
          name: "minutes",
          aliases: [],
          acceptsVariableInterpolation: true,
          allowsVariableReference: true,
          description: "The lifetime of the cookie, in minutes",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: true
        }
      ]
    };
    cookieSet_default = CookieSet;
  }
});

// server/src/antlers/tags/core/cookie/cookieValue.ts
var CookieValue, cookieValue_default;
var init_cookieValue = __esm({
  "server/src/antlers/tags/core/cookie/cookieValue.ts"() {
    "use strict";
    CookieValue = {
      tagName: "cookie:value",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: "3.3.38",
      parameters: [
        {
          name: "key",
          aliases: [],
          acceptsVariableInterpolation: true,
          allowsVariableReference: true,
          description: "The cookie name to retrieve the value for",
          expectsTypes: ["string"],
          isDynamic: false,
          isRequired: true
        }
      ]
    };
    cookieValue_default = CookieValue;
  }
});

// server/src/antlers/tags/core/cookie/cookie.ts
var CookieCompletions, CookieTag, cookie_default;
var init_cookie = __esm({
  "server/src/antlers/tags/core/cookie/cookie.ts"() {
    "use strict";
    init_documentedLabel();
    init_tagManager();
    init_cookieForget();
    init_cookieHas();
    init_cookieSet();
    init_cookieValue();
    CookieCompletions = [
      tagToCompletionItem(cookieForget_default),
      tagToCompletionItem(cookieValue_default),
      tagToCompletionItem(cookieSet_default),
      tagToCompletionItem(cookieHas_default)
    ];
    CookieTag = {
      tagName: "cookie",
      allowsArbitraryParameters: false,
      allowsContentClose: false,
      requiresClose: false,
      hideFromCompletions: false,
      injectParentScope: false,
      introducedIn: "3.3.38",
      parameters: [],
      resolveCompletionItems: (params) => {
        if ((params.leftWord == "cookie" || params.leftWord == "/cookie") && params.leftChar == ":") {
          return exclusiveResult(CookieCompletions);
        }
        return EmptyCompletionResult;
      }
    };
    cookie_default = CookieTag;
  }
});

// server/src/antlers/tags/coreTags.ts
var coreTags;
var init_coreTags = __esm({
  "server/src/antlers/tags/coreTags.ts"() {
    "use strict";
    init_collection();
    init_cache();
    init_dump();
    init_error404();
    init_link();
    init_loop();
    init_partial();
    init_count();
    init_increment();
    init_yield();
    init_userCan();
    init_userLogout();
    init_userLogoutUrl();
    init_switch();
    init_oauth();
    init_sessionDump();
    init_sessionSet();
    init_sessionForget();
    init_sessionFlush();
    init_sessionFlash();
    init_markdown();
    init_markdownIndent();
    init_route();
    init_redirect();
    init_section();
    init_obfuscate();
    init_parent();
    init_translate();
    init_svg();
    init_asset();
    init_assets();
    init_getContent();
    init_getFiles();
    init_glide();
    init_iterate();
    init_locales();
    init_mix();
    init_userIn();
    init_userNotIn();
    init_userIs();
    init_userIsnt();
    init_previous();
    init_next();
    init_in();
    init_notFound();
    init_is();
    init_widont();
    init_userProfile();
    init_dd();
    init_path();
    init_userCant();
    init_queryTag();
    init_theme();
    init_themePath();
    init_themeCss();
    init_themeImg();
    init_themeJs();
    init_themeOutput();
    init_glideBatch();
    init_scopeTag();
    init_if();
    init_elseIf();
    init_else();
    init_session();
    init_ageDirectional();
    init_memberUserAliases();
    init_taxonomy();
    init_nav();
    init_breadcrumbs();
    init_form();
    init_formSet();
    init_formCreate();
    init_formSubmission();
    init_formSuccess();
    init_formSubmissions();
    init_formErrors();
    init_user();
    init_search();
    init_userLoginForm();
    init_userPasswordReset();
    init_userRegister();
    init_noParse();
    init_unless();
    init_elseUnless();
    init_installed();
    init_relate();
    init_sessionHas();
    init_incrementReset();
    init_localeCount();
    init_userForgotPasswordForm();
    init_partialExists();
    init_partialIfExists();
    init_getErrors();
    init_getAllErrors();
    init_getError();
    init_set();
    init_mountUrl();
    init_vite();
    init_nocache();
    init_userRoles();
    init_userGroups();
    init_glideDataUrl();
    init_cookie();
    init_cookieForget();
    init_cookieHas();
    init_cookieSet();
    init_cookieValue();
    init_userProfileForm();
    init_userPasswordForm();
    init_viteAsset();
    coreTags = [
      if_default,
      elseIf_default,
      else_default,
      unless_default,
      elseUnless_default,
      asset_default,
      assets_default,
      collection_default,
      count_default,
      previous_default,
      next_default,
      CollectionNewer,
      CollectionOlder,
      cookie_default,
      cookieForget_default,
      cookieHas_default,
      cookieSet_default,
      cookieValue_default,
      relate_default,
      form_default,
      formCreate_default,
      formSubmission_default,
      formSubmissions_default,
      formSet_default,
      formSuccess_default,
      formErrors_default,
      set_default,
      getErrors_default,
      getError_default,
      getAllErrors_default,
      BaseSearchTag,
      SearchResultsTag,
      partial_default,
      partialExists_default,
      partialIfExists_default,
      error404_default,
      notFound_default,
      dump_default,
      DddTag,
      DdTag,
      cache_default,
      getContent_default,
      getFiles_default,
      glide_default,
      glideBatch_default,
      glideDataUrl_default,
      link_default,
      Loop,
      RangeTag,
      IterateTag,
      ForeachTag,
      increment_default,
      incrementReset_default,
      locales_default,
      localeCount_default,
      mix_default,
      mountUrl_default,
      NavTag,
      StructureTag,
      breadcrumbs_default,
      Yield,
      Yields,
      userIn_default,
      in_default,
      userNotIn_default,
      userIs_default,
      is_default,
      InstalledTag,
      userRoles_default,
      userGroups_default,
      user_default,
      userIsnt_default,
      userCan_default,
      userCant_default,
      userLogout_default,
      userLogoutUrl_default,
      userProfile_default,
      UserLoginForm,
      UserPasswordReset,
      UserForgotPasswordForm,
      userProfileForm_default,
      userPasswordForm_default,
      UserRegister,
      MemberTag,
      MemberIs,
      MemberIsnt,
      MemberProfile,
      MemberCan,
      MemberLogout,
      MemberLogoutUrl,
      MemberIn,
      MemberNotIn,
      MemberLoginForm,
      MemberPasswordReset,
      MemberForgotPasswordForm,
      MemberRegister,
      noParse_default,
      nocache_default,
      Switch,
      Rotate,
      oauth_default,
      obfuscate_default,
      parent_default,
      path_default,
      redirect_default,
      route_default,
      scopeTag_default,
      section_default,
      session_default,
      sessionFlash_default,
      sessionFlush_default,
      sessionForget_default,
      sessionSet_default,
      sessionHas_default,
      sessionDump_default,
      svg_default,
      taxonomy_default,
      theme_default,
      ThemePath,
      ThemeAsset,
      themeCss_default,
      themeImg_default,
      themeJs_default,
      themeOutput_default,
      Translate,
      TransTag,
      TransChoiceTag,
      queryTag_default,
      markdown_default,
      markdownIndent_default,
      widont_default,
      vite_default,
      viteAsset_default
    ];
  }
});

// server/src/antlers/tagManagerInstance.ts
var import_vscode_languageserver10, TagManager, tagManagerInstance_default;
var init_tagManagerInstance = __esm({
  "server/src/antlers/tagManagerInstance.ts"() {
    "use strict";
    import_vscode_languageserver10 = __toESM(require_main4());
    init_projectManager();
    init_attributeSuggestions();
    init_fieldFormatter();
    init_strings();
    init_coreTags();
    TagManager = class {
      constructor() {
        this.tags = /* @__PURE__ */ new Map();
        this.parameters = /* @__PURE__ */ new Map();
      }
      reset() {
        this.tags.clear();
        this.parameters.clear();
        this.loadCoreTags();
      }
      getVisibleTagsWithDocumentation() {
        var _a, _b;
        const tags = [];
        this.tags.forEach((tag, name) => {
          if (tag.hideFromCompletions == false) {
            let docs = "";
            if (tag.resolveDocumentation != null) {
              docs = tag.resolveDocumentation();
            }
            tags.push({
              label: name,
              documentation: docs
            });
          }
        });
        (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags().forEach((tag) => {
          tags.push({
            label: tag.tagName,
            documentation: ""
          });
        });
        return tags;
      }
      getCustomTagMethodsForTag(tagName) {
        var _a, _b;
        const items = [], len = tagName.length + 1;
        (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags().forEach((tag) => {
          if (tag.tagName.startsWith(`${tagName}:`)) {
            const methodName = tag.tagName.substr(len).trim();
            if (methodName.length > 0) {
              items.push(methodName);
            }
          }
        });
        return items;
      }
      getVisibleTagNames() {
        var _a, _b;
        const tagNames = [];
        this.tags.forEach((tag, name) => {
          if (tag.hideFromCompletions == false) {
            tagNames.push(name);
          }
        });
        (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags().forEach((tag) => {
          tagNames.push(tag.tagName);
        });
        return [...new Set(tagNames)];
      }
      getPossibleTagMethods(tagName) {
        var _a, _b;
        const methodNames = [], len = tagName.length + 1;
        this.tags.forEach((tag, name) => {
          if (name.startsWith(tagName)) {
            const methodName = name.substr(len).trim();
            if (methodName.length > 0) {
              methodNames.push(methodName);
            }
          }
        });
        (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags().forEach((tag) => {
          if (tag.tagName.startsWith(`${tagName}:`)) {
            const methodName = tagName.substr(len).trim();
            if (methodName.length > 0) {
              methodNames.push(methodName);
            }
          }
        });
        return [...new Set(methodNames)];
      }
      getTagNames() {
        var _a, _b;
        const tagNames = [];
        this.tags.forEach((tag, name) => {
          tagNames.push(name);
        });
        (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags().forEach((tag) => {
          tagNames.push(tag.tagName);
        });
        return [...new Set(tagNames)];
      }
      loadCoreTags() {
        this.registerTags(coreTags);
      }
      cleanTagName(name) {
        return trimLeft(name, "/");
      }
      findTag(name) {
        return this.tags.get(this.resolveTagName(name));
      }
      findCustomTag(name) {
        var _a, _b, _c;
        const customTags = (_c = (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags()) != null ? _c : [];
        for (let i = 0; i < customTags.length; i++) {
          if (customTags[i].tagName == name) {
            return customTags[i];
          }
        }
        return;
      }
      isKnownTag(name) {
        return this.tags.has(this.resolveTagName(name)) || this.isCustomTag(name);
      }
      isSymbolKnownTag(node) {
        return this.isKnownTag(node.runtimeName());
      }
      resolveTagName(name) {
        name = this.cleanTagName(name.trim());
        if (this.tags.has(name)) {
          return name;
        }
        if (name.includes(":")) {
          name = name.split(":")[0];
        }
        return name;
      }
      canResolveSpecialTypes(name) {
        name = this.resolveTagName(name);
        const tag = this.tags.get(name);
        if (typeof tag === "undefined" || tag == null) {
          return false;
        }
        if (tag.resolveSpecialType == null) {
          return false;
        }
        return true;
      }
      resolveSpecialType(tagName, symbol, project) {
        tagName = this.resolveTagName(tagName);
        const tag = this.findTag(tagName);
        if (tag.resolveSpecialType == null) {
          throw new Error(tagName + " does not support special types.");
        }
        return tag.resolveSpecialType(symbol, project);
      }
      isCustomTag(name) {
        var _a, _b, _c;
        const customTags = (_c = (_b = (_a = projectManager_default.instance) == null ? void 0 : _a.getStructure()) == null ? void 0 : _b.getCustomAntlersTags()) != null ? _c : [];
        for (var i = 0; i < customTags.length; i++) {
          if (customTags[i].tagName == name) {
            return true;
          }
        }
        return false;
      }
      getCompletionItems(params) {
        var _a;
        let lastScopeItem = null;
        let resolvedParams = [];
        let runDefaultAnalysis = true;
        if (params.context != null && params.context.node != null) {
          params.currentNode = params.context.node;
        }
        if (params.nodesInScope.length > 0) {
          lastScopeItem = params.nodesInScope[params.nodesInScope.length - 1];
        }
        if (params.currentNode != null) {
          if (this.isKnownTag(params.currentNode.runtimeName()) || this.isCustomTag(params.currentNode.getTagName())) {
            let tagReference = this.findTag(
              params.currentNode.runtimeName()
            );
            if (typeof tagReference === "undefined") {
              tagReference = this.findCustomTag(params.currentNode.getTagName());
              if (typeof tagReference === "undefined") {
                return {
                  isExclusive: false,
                  items: []
                };
              }
            }
            const dynamicRefNames = [];
            if (tagReference.resolveCompletionItems != null) {
              const result = tagReference.resolveCompletionItems(params), customMethods = this.getCustomTagMethodsForTag(tagReference.tagName);
              if (customMethods.length > 0) {
                customMethods.forEach((method) => {
                  result.items.push({
                    label: method,
                    kind: import_vscode_languageserver10.CompletionItemKind.Text,
                    insertText: method
                  });
                });
              }
              if (result.isExclusiveResult) {
                return {
                  isExclusive: true,
                  items: result.items
                };
              }
              runDefaultAnalysis = result.analyzeDefaults;
              resolvedParams = resolvedParams.concat(result.items);
            }
            if (params.isPastTagPart == false) {
              const tagMethodNames = this.getPossibleTagMethods(
                tagReference.tagName
              );
              for (let i = 0; i < tagMethodNames.length; i++) {
                resolvedParams.push({
                  label: tagMethodNames[i],
                  kind: import_vscode_languageserver10.CompletionItemKind.Text
                });
              }
            }
            if (runDefaultAnalysis) {
              if (params.isCaretInTag == true && tagReference.parameters.length > 0) {
                resolvedParams = resolvedParams.concat(
                  makeTagParameterSuggestions(params, tagReference.parameters)
                );
                if (tagReference.tagName == "partial") {
                  if (lastScopeItem == null ? void 0 : lastScopeItem.hasMethodPart()) {
                    const lastMethodName = lastScopeItem.getMethodNameValue();
                    if (lastMethodName.trim().length > 0) {
                      if ((_a = projectManager_default.instance) == null ? void 0 : _a.hasStructure()) {
                        const projectView = projectManager_default.instance.getStructure().findPartial(lastMethodName);
                        if (projectView != null && projectView.injectsParameters.length > 0) {
                          resolvedParams = resolvedParams.concat(
                            makeTagParameterSuggestions(
                              params,
                              projectView.injectsParameters
                            )
                          );
                        }
                      }
                    }
                  }
                }
              }
              for (let i = 0; i < params.nodesInScope.length; i++) {
                if (params.nodesInScope[i].runtimeType !== null) {
                  const thisRuntimeType = params.nodesInScope[i].runtimeType;
                  if (thisRuntimeType != null && thisRuntimeType.assumedType == "structure_ref" && thisRuntimeType.supplementedFields != null) {
                    for (let j = 0; j < thisRuntimeType.supplementedFields.length; j++) {
                      resolvedParams.push(
                        formatSuggestion(thisRuntimeType.supplementedFields[j])
                      );
                    }
                  }
                }
              }
            }
            return {
              items: resolvedParams,
              isExclusive: false
            };
          }
        }
        return {
          items: resolvedParams,
          isExclusive: false
        };
      }
      injectParentScope(tag) {
        const tagReference = this.findTag(tag);
        if (typeof tagReference === "undefined" || tagReference == null) {
          return true;
        }
        return tagReference.injectParentScope;
      }
      resolveParameterCompletions(tag, parameter, params) {
        const tagReference = this.findTag(tag);
        if (typeof tagReference !== "undefined" && tagReference !== null) {
          if (typeof tagReference.resovleParameterCompletionItems !== "undefined" && tagReference.resovleParameterCompletionItems !== null) {
            return tagReference.resovleParameterCompletionItems(parameter, params);
          }
        }
        return null;
      }
      canResolveDynamicParameter(tag) {
        const tagName = this.resolveTagName(tag);
        if (this.isKnownTag(tagName)) {
          const tagRef = this.tags.get(tagName);
          if (typeof tagRef === "undefined") {
            return false;
          }
          if (typeof tagRef.resolveDynamicParameter !== "undefined" && tagRef.resolveDynamicParameter != null) {
            return true;
          }
        }
        return false;
      }
      getParameter(tag, param) {
        const tagName = this.resolveTagName(tag);
        if (this.parameters.has(tagName) == false) {
          return null;
        }
        const tagParams = this.parameters.get(tagName);
        if (tagParams == null) {
          return null;
        }
        if (tagParams.has(param) == false) {
          const tagRef = this.findTag(tag);
          if (tagRef != null && typeof tagRef.resolveDynamicParameter !== "undefined" && tagRef.resolveDynamicParameter != null) {
            const dynamicParam = tagRef.resolveDynamicParameter(null, param);
            if (dynamicParam !== null) {
              return dynamicParam;
            }
          }
          return null;
        }
        const tagParam = tagParams.get(param);
        if (typeof tagParam == "undefined" || tagParams == null) {
          return null;
        }
        return tagParam;
      }
      registerTags(tags) {
        for (let i = 0; i < tags.length; i++) {
          this.registerTag(tags[i]);
        }
      }
      registerTag(tag) {
        this.tags.set(tag.tagName, tag);
        if (this.parameters.has(tag.tagName) == false) {
          this.parameters.set(tag.tagName, /* @__PURE__ */ new Map());
        }
        if (tag.parameters.length > 0) {
          const thisTagsMap = this.parameters.get(tag.tagName);
          for (let i = 0; i < tag.parameters.length; i++) {
            const curParam = tag.parameters[i];
            thisTagsMap == null ? void 0 : thisTagsMap.set(curParam.name, curParam);
          }
        }
      }
      requiresClose(node) {
        const nodeTagName = node.getTagName();
        if (this.tags.has(nodeTagName)) {
          const tag = this.findTag(nodeTagName);
          if (tag != null) {
            if (tag.requiresCloseResolver != null) {
              return tag.requiresCloseResolver(node);
            }
            return tag.requiresClose;
          }
        }
        return false;
      }
    };
    TagManager.instance = null;
    if (typeof TagManager.instance == "undefined" || TagManager.instance == null) {
      TagManager.instance = new TagManager();
      TagManager.instance.loadCoreTags();
    }
    tagManagerInstance_default = TagManager;
  }
});

// server/src/antlers/scope/scope.ts
var _Scope, Scope;
var init_scope = __esm({
  "server/src/antlers/scope/scope.ts"() {
    "use strict";
    init_scopeUtilities();
    init_simpleIds();
    _Scope = class {
      constructor(statamicProject) {
        this.generation = 0;
        this.id = "";
        this.name = "";
        this.values = /* @__PURE__ */ new Map();
        this.lists = /* @__PURE__ */ new Map();
        this.pristine = /* @__PURE__ */ new Map();
        this.parentScope = null;
        this.statamicProject = statamicProject;
        _Scope.generationCounter += 1;
        this.generation = _Scope.generationCounter;
        this.id = getId();
      }
      makeNew() {
        return new _Scope(this.statamicProject);
      }
      ancestor() {
        if (this.parentScope != null) {
          return this.parentScope;
        }
        return this;
      }
      canShiftScope(path) {
        if (this.pristine.has(path)) {
          return true;
        }
        return false;
      }
      shiftScope(symbol, path, newScopeName) {
        if (this.pristine.has(path)) {
          const pristineCopy = this.pristine.get(path), newScope = pristineCopy.parentCopy.copy();
          newScope.introduceAliasScope(symbol, newScopeName, pristineCopy.introducedFields);
          return newScope;
        }
        return this;
      }
      containsPath(path) {
        if (path.includes(":")) {
          const parts = path.split(":"), thisPath = parts.shift(), nextPath = parts.join(":");
          if (typeof thisPath === "undefined") {
            return false;
          }
          const nextScope = this.lists.get(thisPath);
          if (typeof nextScope === "undefined") {
            return false;
          }
          return nextScope.containsPath(nextPath);
        }
        if (this.lists.has(path)) {
          return true;
        }
        return false;
      }
      findReference(path) {
        if (path.includes(":")) {
          const parts = path.split(":"), itemToFind = parts.pop(), newPath = parts.join(":"), adjustScope = this.findNestedScope(newPath);
          if (adjustScope != null) {
            return adjustScope.findReference(itemToFind);
          }
        }
        if (this.values.has(path)) {
          return this.values.get(path);
        }
        return null;
      }
      findReferenceWithField(path) {
        if (path.includes(":")) {
          const parts = path.split(":"), itemToFind = parts.pop(), newPath = parts.join(":"), adjustScope = this.findNestedScope(newPath);
          if (adjustScope != null) {
            return adjustScope.findReference(itemToFind);
          }
        }
        if (this.values.has(path)) {
          const varRef = this.values.get(path);
          if (varRef.sourceField == null) {
            if (varRef.introducedBy != null && varRef.introducedBy.currentScope != null && varRef.introducedBy.currentScope != this) {
              return varRef.introducedBy.currentScope.findReferenceWithField(varRef.introducedBy.getTagName());
            }
            if (this.parentScope != null && this.parentScope != this) {
              return this.parentScope.findReferenceWithField(path);
            }
          }
          return varRef;
        }
        return null;
      }
      containsReference(path) {
        const pathRef = this.findReference(path);
        if (pathRef == null) {
          return false;
        }
        return true;
      }
      findNestedScope(path) {
        if (path.includes(":")) {
          const parts = path.split(":"), thisPath = parts.shift(), nextPath = parts.join(":");
          if (typeof thisPath === "undefined") {
            return null;
          }
          const nextScope = this.lists.get(thisPath);
          if (typeof nextScope === "undefined") {
            return null;
          }
          return nextScope.findNestedScope(nextPath);
        }
        if (this.lists.has(path)) {
          return this.lists.get(path);
        }
        if (this.parentScope != null && this.parentScope != this && this.parentScope.hasList(path)) {
          return this.parentScope.lists.get(path);
        }
        return null;
      }
      liftList(name) {
        if (this.lists.has(name)) {
          const list = this.lists.get(name);
          if (typeof list === "undefined" || list === null) {
            return null;
          }
          this.lists.delete(name);
          return list;
        }
        return null;
      }
      hasPristineReference(name) {
        if (this.pristine.has(name)) {
          return true;
        }
        return false;
      }
      hasListInHistory(name) {
        if (this.hasList(name)) {
          return true;
        }
        if (this.parentScope != null) {
          if (this.name == "*root*") {
            return false;
          }
          return this.parentScope.hasList(name);
        }
        return false;
      }
      hasList(name) {
        if (this.lists.has(name)) {
          const list = this.lists.get(name);
          if (typeof list === "undefined" || list === null) {
            return false;
          }
          return true;
        }
        return false;
      }
      bringListIntoMainScope(path) {
        if (path.includes(":")) {
          const parts = path.split(":"), thisPath = parts.shift(), nextPath = parts.join(":");
          if (typeof thisPath === "undefined") {
            return this;
          }
          const nextScope = this.lists.get(thisPath);
          if (typeof nextScope === "undefined") {
            return this;
          }
          return nextScope.bringListIntoMainScope(nextPath);
        }
        const nestedScope = this.lists.get(path);
        this.lists.delete(path);
        return this.mergeScope(nestedScope);
      }
      getListNames() {
        const listNames = [];
        this.lists.forEach((value, name) => {
          listNames.push(name);
        });
        return listNames;
      }
      getVariableNames() {
        const variableNames = [];
        this.values.forEach((variable) => {
          variableNames.push(variable.name);
        });
        return variableNames;
      }
      getList(name) {
        if (this.lists.has(name)) {
          return this.lists.get(name);
        }
        if (this.parentScope != null && this.parentScope != this) {
          return this.parentScope.getList(name);
        }
        return null;
      }
      hasValue(name) {
        return this.values.has(name);
      }
      findAncestorWithList(name) {
        if (this.hasList(name)) {
          return this;
        }
        if (this.parentScope != null && this.parentScope != this) {
          return this.parentScope.findAncestorWithList(name);
        }
        return null;
      }
      findReferenceNotIntroducedBy(name, introducedBy) {
        if (this.hasValue(name)) {
          const varRef = this.values.get(name);
          if (varRef.introducedBy != null && varRef.introducedBy != introducedBy) {
            return varRef;
          }
        }
        if (this.parentScope != null && this.parentScope != this) {
          return this.parentScope.findReferenceNotIntroducedBy(name, introducedBy);
        }
        return null;
      }
      removeThroughIntroduction(name, introducedBy) {
        this.values.delete(name);
        if (this.parentScope != null) {
          const refInSCope = this.findReferenceNotIntroducedBy(name, introducedBy);
          if (refInSCope != null) {
            this.addVariable(refInSCope);
          }
        }
      }
      wasIntroducedBySymbol(name, checkSymbol) {
        if (this.values.has(name) == false) {
          return false;
        }
        const value = this.values.get(name);
        if (value.introducedBy != null) {
          return value.introducedBy == checkSymbol;
        }
        return false;
      }
      referencesArray(name) {
        if (this.values.has(name) == false) {
          return false;
        }
        const ref = this.values.get(name);
        if (ref.dataType == "array") {
          return true;
        }
        return false;
      }
      addScopeList(listName, scope) {
        this.lists.set(listName, scope);
        return this;
      }
      mergeAndList(listName, data) {
        const newListScope = new _Scope(this.statamicProject);
        newListScope.values = valuesToDataMap(data);
        this.lists.set(listName, newListScope);
        this.mergeVariableScope(data);
        return this;
      }
      mergeScope(scope) {
        if (scope == this || scope == null) {
          return this;
        }
        if (typeof scope.values !== "undefined" && scope.values !== null) {
          scope.values.forEach((value, name) => {
            this.values.set(name, value);
          });
        }
        if (typeof scope.lists !== "undefined" && scope.lists !== null) {
          scope.lists.forEach((value, name) => {
            this.lists.set(name, value);
          });
        }
        return this;
      }
      mergeVariableScope(data) {
        for (let i = 0; i < data.length; i++) {
          this.values.set(data[i].name, data[i]);
        }
        return this;
      }
      addVariable(variable) {
        this.values.set(variable.name, variable);
      }
      addVariables(variables) {
        for (let i = 0; i < variables.length; i++) {
          this.addVariable(variables[i]);
        }
      }
      addVariableArray(name, variables) {
        if (this.values.has(name)) {
          this.values.delete(name);
        }
        const array = new _Scope(this.statamicProject);
        array.addVariables(variables);
        this.addScopeList(name, array);
      }
      injectAssetContainer(symbol, container) {
        this.addBlueprintFields(symbol, this.statamicProject.getAssetBlueprintFields(container));
      }
      injectUserFields(symbol) {
        this.addBlueprintFields(symbol, this.statamicProject.getUserFields());
      }
      addBlueprintField(symbol, field) {
        this.addVariable({
          dataType: field.type,
          name: field.name,
          sourceField: field,
          sourceName: field.blueprintName,
          introducedBy: symbol
        });
      }
      introduceScopedAliasScope(symbol, scopeName, aliasName, fields) {
        this.pristine.set(aliasName, {
          introducedFields: fields,
          introducedScope: aliasName,
          parentCopy: this.copy()
        });
        const newAliasScope = new _Scope(this.statamicProject), fieldScope = new _Scope(this.statamicProject);
        fieldScope.addBlueprintFields(symbol, fields);
        newAliasScope.name = aliasName;
        newAliasScope.addScopeList(scopeName, fieldScope);
        this.addScopeList(aliasName, newAliasScope);
        return newAliasScope;
      }
      expandScopedAliasScope(symbol, scopeName, aliasName, fields) {
        if (this.lists.has(aliasName) == false) {
          this.introduceScopedAliasScope(symbol, scopeName, aliasName, fields);
        } else {
          const listRef = this.lists.get(aliasName);
          listRef.addBlueprintFields(symbol, fields);
        }
      }
      introduceAliasScope(symbol, aliasName, fields) {
        this.pristine.set(aliasName, {
          introducedFields: fields,
          introducedScope: aliasName,
          parentCopy: this.copy()
        });
        const newAliasScope = new _Scope(this.statamicProject);
        newAliasScope.addBlueprintFields(symbol, fields);
        newAliasScope.name = aliasName;
        this.addScopeList(aliasName, newAliasScope);
      }
      introduceDynamicScopeList(symbol, listName, fields) {
        this.pristine.set(listName, {
          introducedFields: fields,
          introducedScope: listName,
          parentCopy: this.copy()
        });
        const newListScope = new _Scope(this.statamicProject);
        newListScope.name = listName;
        newListScope.addBlueprintFields(symbol, fields);
        this.addScopeList(listName, newListScope);
      }
      addBlueprintFields(symbol, fields) {
        for (let i = 0; i < fields.length; i++) {
          this.addBlueprintField(symbol, fields[i]);
        }
      }
      injectBlueprint(symbol, handle) {
        const blueprintDetails = this.statamicProject.getBlueprintDetails(handle);
        if (blueprintDetails.length > 0) {
          this.addBlueprintFields(symbol, blueprintDetails);
        }
      }
      copy() {
        const newScope = new _Scope(this.statamicProject);
        newScope.pristine = new Map(this.pristine);
        newScope.values = new Map(this.values);
        newScope.lists = new Map(this.lists);
        newScope.parentScope = this;
        return newScope;
      }
    };
    Scope = _Scope;
    Scope.generationCounter = 0;
  }
});

// server/src/antlers/variables/systemVariables.ts
function getSiteData(project) {
  const siteScope = new Scope(project);
  siteScope.addVariable({ dataType: "string", name: "handle", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "name", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "locale", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "short_locale", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  return siteScope;
}
function getSystemVariables() {
  const systemVariables = [];
  systemVariables.push({ dataType: "number", name: "response_code", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "csrf_field", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "csrf_token", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "environment", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "template", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "xml_header", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "last_segment", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "homepage", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_uri", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "amp_url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "api_url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_full_url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "template_contents", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_template", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_layout", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "boolean", name: "logged_in", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "boolean", name: "logged_out", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "boolean", name: "is_homepage", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "date", name: "now", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "date", name: "today", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "date", name: "current_date", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "get", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "get_post", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "post", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "old", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  return systemVariables;
}
var init_systemVariables = __esm({
  "server/src/antlers/variables/systemVariables.ts"() {
    "use strict";
    init_scope();
  }
});

// server/src/antlers/scope/factories/paginationFactory.ts
function checkNodeForPagination(node, scope) {
  const paginateParam = node.findParameter("paginate");
  if (paginateParam != null) {
    if (paginateParam.value.toLowerCase() == "true" || parseInt(paginateParam.value).toString() == paginateParam.value) {
      const paginationItems = scope.makeNew(), linksScope = scope.makeNew(), allScope = scope.makeNew(), segmentsScope = scope.makeNew();
      paginationItems.addVariable({
        name: "next_page",
        dataType: "string",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "prev_page",
        dataType: "string",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "total_items",
        dataType: "integer",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "total_pages",
        dataType: "integer",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "current_page",
        dataType: "integer",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "auto_links",
        dataType: "string",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      allScope.addVariable({
        name: "url",
        dataType: "string",
        sourceField: null,
        sourceName: "*internal.pagination.all",
        introducedBy: node
      });
      allScope.addVariable({
        name: "page",
        dataType: "integer",
        sourceField: null,
        sourceName: "*internal.pagination.all",
        introducedBy: node
      });
      segmentsScope.addVariable({
        name: "first",
        dataType: "boolean",
        sourceName: "*internal.pagination.segments",
        sourceField: null,
        introducedBy: node
      });
      segmentsScope.addVariable({
        name: "last",
        dataType: "boolean",
        sourceName: "*internal.pagination.segments",
        sourceField: null,
        introducedBy: node
      });
      segmentsScope.addVariable({
        name: "slider",
        dataType: "boolean",
        sourceName: "*internal.pagination.segments",
        sourceField: null,
        introducedBy: node
      });
      linksScope.addScopeList("all", allScope);
      linksScope.addScopeList("segments", segmentsScope);
      paginationItems.addScopeList("links", linksScope);
      scope.addScopeList("paginate", paginationItems);
    }
  }
}
var init_paginationFactory = __esm({
  "server/src/antlers/scope/factories/paginationFactory.ts"() {
    "use strict";
  }
});

// server/src/antlers/scope/injections.ts
var InjectionManager, injections_default;
var init_injections = __esm({
  "server/src/antlers/scope/injections.ts"() {
    "use strict";
    init_strings();
    init_scope();
    InjectionManager = class {
      constructor() {
        this.fileInjections = /* @__PURE__ */ new Map();
        this.project = null;
      }
      updateProject(project) {
        this.project = project;
      }
      registerInjections(fileName, nodes) {
        if (nodes.length == 0) {
          return;
        }
        const newNodes = [];
        for (let i = 0; i < nodes.length; i++) {
          const thisNode = nodes[i];
          if (thisNode.hasParameters) {
            newNodes.push(thisNode);
          }
        }
        if (newNodes.length > 0) {
          const partialName = newNodes[0].getMethodNameValue();
          if (partialName != null && this.project != null) {
            const projectPartial = this.project.findPartial(partialName);
            if (projectPartial != null) {
              if (!this.fileInjections.has(projectPartial.documentUri)) {
                this.fileInjections.set(projectPartial.documentUri, /* @__PURE__ */ new Map());
              }
              const partialFiles = this.fileInjections.get(
                projectPartial.documentUri
              );
              partialFiles.set(fileName, newNodes);
            }
          }
        }
      }
      hasAvailableInjections(documentUri) {
        return this.fileInjections.has(documentUri);
      }
      getScopeInjection(documentUri, project) {
        const newScope = new Scope(project);
        newScope.name = "*injection*";
        const injections = this.fileInjections.get(documentUri);
        injections.forEach((nodes, file) => {
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.hasParameters) {
              for (let j = 0; j < node.parameters.length; j++) {
                const thisParam = node.parameters[j];
                if (thisParam.containsSimpleValue()) {
                  newScope.addVariable({
                    dataType: "string",
                    name: thisParam.name,
                    sourceField: null,
                    sourceName: "scope.injection",
                    introducedBy: node
                  });
                } else if (thisParam.isVariableReference) {
                  if (node.currentScope != null) {
                    if (node.currentScope.hasListInHistory(thisParam.value)) {
                      const injectList = node.currentScope.findNestedScope(
                        thisParam.value
                      );
                      if (injectList != null) {
                        const adjustedName = trimLeft(thisParam.name, ":"), nestedInjection = injectList.copy();
                        nestedInjection.name = adjustedName;
                        newScope.addScopeList(adjustedName, injectList);
                      }
                    }
                  }
                }
              }
            }
          }
        });
        return newScope;
      }
    };
    InjectionManager.instance = null;
    if (typeof InjectionManager.instance == "undefined" || InjectionManager.instance == null) {
      InjectionManager.instance = new InjectionManager();
    }
    injections_default = InjectionManager;
  }
});

// server/src/antlers/scope/engine.ts
var IgnoreArrayContextualData, ChecksForFieldReferences, ScopeEngine;
var init_engine = __esm({
  "server/src/antlers/scope/engine.ts"() {
    "use strict";
    init_parser();
    init_blueprintTypes();
    init_referenceManager();
    init_abstractNode();
    init_tagManagerInstance();
    init_arrayVariables();
    init_contentVariables();
    init_loopVariables();
    init_systemVariables();
    init_paginationFactory();
    init_scopeUtilities();
    init_scope();
    init_fieldtypeManager();
    init_injections();
    IgnoreArrayContextualData = ["collection"];
    ChecksForFieldReferences = ["if", "elseif", "unless", "elseunless"];
    ScopeEngine = class {
      constructor(project, documentUri, document) {
        this.pageVars = [];
        this.viewDataVars = null;
        this.documentUri = "";
        this.lastSymbolId = "";
        this.ideHelperMap = /* @__PURE__ */ new Map();
        this.statamicProject = project;
        this.documentUri = documentUri;
        this.document = document;
        this.makePageScope();
        this.makeViewDataScope();
      }
      makeViewDataScope() {
        if (this.document.hasFrontMatter()) {
          this.viewDataVars = this.document.getFrontMatterScope();
        }
      }
      makePageScope() {
        const newPageVariables = [];
        const projFields = this.statamicProject.getFields();
        if (projFields.has("pages")) {
          const pageFields = projFields.get("pages");
          for (let i = 0; i < pageFields.length; i++) {
            const thisField = pageFields[i];
            newPageVariables.push({
              name: thisField.name,
              dataType: thisField.type,
              sourceField: thisField,
              sourceName: thisField.blueprintName,
              introducedBy: null
            });
          }
        }
        this.pageVars = newPageVariables;
      }
      analyzeScope(nodes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
        const rootScope = new Scope(this.statamicProject);
        rootScope.name = "*root*";
        rootScope.parentScope = rootScope;
        rootScope.addScopeList("site", getSiteData(this.statamicProject));
        rootScope.addScopeList("sites", getSiteData(this.statamicProject));
        rootScope.addVariables(getSystemVariables());
        const rootUserVariableScope = new Scope(this.statamicProject);
        rootUserVariableScope.name = "*root_user*";
        rootUserVariableScope.parentScope = rootScope;
        this.statamicProject.getUserFields().forEach((field) => {
          rootUserVariableScope.addBlueprintField(null, field);
        });
        rootScope.addScopeList("current_user", rootUserVariableScope);
        if ((_a = referenceManager_default.instance) == null ? void 0 : _a.pageScopeDisabled(this.documentUri)) {
          if (this.viewDataVars != null) {
            rootScope.addScopeList("view", this.viewDataVars);
          }
        } else {
          if (this.viewDataVars != null) {
            rootScope.mergeAndList("page", this.pageVars).addScopeList("view", this.viewDataVars);
          } else {
            rootScope.mergeAndList("page", this.pageVars);
          }
        }
        let ideHelper = null;
        if (nodes.length > 0 && nodes[0].isComment) {
          ideHelper = parseIdeHelper(this.documentUri, nodes[0]);
        }
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i].isComment) {
            const varIdeHelper = parseIdeHelper(this.documentUri, nodes[i]);
            if (varIdeHelper.variableHelper != null) {
              this.ideHelperMap.set(nodes[i].id(), varIdeHelper.variableHelper);
            }
          }
        }
        let documentCollectionNames = this.statamicProject.getCollectionNamesForView(this.documentUri);
        if (ideHelper != null) {
          if (ideHelper.collectionInjections.length > 0) {
            documentCollectionNames = documentCollectionNames.concat(ideHelper.collectionInjections);
          }
          if (ideHelper.blueprints.length > 0) {
            documentCollectionNames = documentCollectionNames.concat(ideHelper.blueprints);
          }
          if (ideHelper.variableHelper != null) {
            if (ideHelper.variableHelper.variableName == "@page") {
              const fieldRef = this.statamicProject.getBlueprintField(ideHelper.variableHelper.collectionName, ideHelper.variableHelper.fieldHandle);
              if (fieldRef != null) {
                if (ideHelper.variableHelper.setHandle.length > 0) {
                  if (fieldRef.sets != null) {
                    for (let i = 0; i < fieldRef.sets.length; i++) {
                      if (fieldRef.sets[i].handle == ideHelper.variableHelper.setHandle) {
                        rootScope.addVariables(blueprintFieldsToScopeVariables(nodes[0], fieldRef.sets[i].fields));
                        break;
                      }
                    }
                  }
                } else {
                  rootScope.addBlueprintField(nodes[0], fieldRef);
                }
              }
            }
          }
        }
        if (documentCollectionNames.length > 0) {
          for (let i = 0; i < documentCollectionNames.length; i++) {
            rootScope.injectBlueprint(nodes[0], documentCollectionNames[i]);
          }
          rootScope.addVariables(makeContentVariables(nodes[0]));
        }
        if ((_b = injections_default.instance) == null ? void 0 : _b.hasAvailableInjections(this.documentUri)) {
          rootScope.mergeScope((_c = injections_default.instance) == null ? void 0 : _c.getScopeInjection(this.documentUri, this.statamicProject));
        }
        const currentScopeParts = [], popScopeIds = [], resolvedPaths = [], activeScopes = [];
        activeScopes.push(rootScope);
        for (let i = 0; i < nodes.length; i++) {
          const currentNode = nodes[i];
          if (this.lastSymbolId.length > 0 && popScopeIds.includes(currentNode.id())) {
            currentScopeParts.pop();
            activeScopes.pop();
            if (activeScopes.length == 0) {
              activeScopes.push(rootScope);
            }
          }
          let currentScope = activeScopes[activeScopes.length - 1];
          if (currentNode.hasParameters) {
            for (let j = 0; j < currentNode.parameters.length; j++) {
              if (currentNode.parameters[j].interpolations.length > 0) {
                for (let k = 0; k < currentNode.parameters[j].interpolations.length; k++) {
                  const tInterpolationName = currentNode.parameters[j].interpolations[k];
                  if (currentNode.processedInterpolationRegions.has(tInterpolationName)) {
                    const tIntNodes = currentNode.processedInterpolationRegions.get(tInterpolationName);
                    tIntNodes.forEach((node) => {
                      if (node instanceof AntlersNode) {
                        node.currentScope = currentScope;
                      }
                    });
                  }
                }
              }
            }
          }
          if (((_d = tagManagerInstance_default.instance) == null ? void 0 : _d.isKnownTag(currentNode.getTagName())) == false) {
            currentNode.scopeVariable = currentScope.findReference(currentNode.runtimeName());
            if (i > 0) {
              const lastSymbol = nodes[i - 1];
              if (lastSymbol.isComment && this.ideHelperMap.has(lastSymbol.id()) && !lastSymbol.isClosingTag && !currentNode.isClosingTag) {
                const ideHelper2 = this.ideHelperMap.get(lastSymbol.id());
                if (ideHelper2.variableName == currentNode.getTagName()) {
                  const collectionFieldReference = this.statamicProject.getBlueprintField(ideHelper2.collectionName, ideHelper2.fieldHandle);
                  if (collectionFieldReference != null) {
                    currentNode.scopeVariable = blueprintFieldToScopeVariable(currentNode, collectionFieldReference);
                  }
                }
              }
            }
            if (currentNode.scopeVariable == null) {
              const trimmedRuntimeName = currentNode.runtimeName().trim();
              if (currentScope.hasList(trimmedRuntimeName) || ((_e = currentNode.currentScope) == null ? void 0 : _e.hasListInHistory(trimmedRuntimeName))) {
                currentNode.sourceType = "array";
                const listReference = currentScope.getList(trimmedRuntimeName);
                if (listReference != null && listReference.values.size > 0) {
                  const firstListVar = listReference.values.entries().next().value[1];
                  currentNode.scopeVariable = {
                    dataType: "array",
                    introducedBy: firstListVar.introducedBy,
                    name: trimmedRuntimeName,
                    sourceField: null,
                    sourceName: firstListVar.sourceName
                  };
                }
              }
              let firstName = (_g = (_f = currentNode.name) == null ? void 0 : _f.name) != null ? _g : "";
              if (firstName.includes(".")) {
                firstName = firstName.split(".")[0];
              } else if (firstName.includes(":")) {
                firstName = firstName.split(":")[0];
              }
              const speculativeBlueprintField = this.statamicProject.findAnyBlueprintField(firstName);
              if (speculativeBlueprintField != null) {
                let scopeV = blueprintFieldToScopeVariable(currentNode, speculativeBlueprintField);
                currentNode.scopeVariable = scopeV;
                if (currentNode.scopeVariable.sourceField != null) {
                  if ((_h = fieldtypeManager_default.instance) == null ? void 0 : _h.hasFieldtype(currentNode.scopeVariable.sourceField.type)) {
                    const fieldTypeRef = (_i = fieldtypeManager_default.instance) == null ? void 0 : _i.getFieldType(currentNode.scopeVariable.sourceField.type);
                    fieldTypeRef.augmentScope(currentNode, currentScope);
                  }
                }
              }
            } else {
              currentNode.sourceType = getFieldRuntimeType(currentNode.scopeVariable.dataType);
              if (currentNode.scopeVariable.sourceField != null) {
                if ((_j = fieldtypeManager_default.instance) == null ? void 0 : _j.hasFieldtype(currentNode.scopeVariable.sourceField.type)) {
                  const fieldTypeRef = (_k = fieldtypeManager_default.instance) == null ? void 0 : _k.getFieldType(currentNode.scopeVariable.sourceField.type);
                  fieldTypeRef.augmentScope(currentNode, currentScope);
                }
              }
            }
          }
          if (currentNode.hasParameters) {
            checkNodeForPagination(currentNode, currentScope);
          }
          if (currentNode.modifiers != null && currentNode.modifiers.hasModifiers()) {
            currentNode.manifestType = currentNode.modifiers.getLastManifestedModifierRuntimeType();
          } else {
            currentNode.manifestType = currentNode.sourceType;
          }
          if (currentNode.isClosedBy != null) {
            currentScopeParts.push(currentNode.id());
            popScopeIds.push(currentNode.isClosedBy.id());
            currentScope = currentScope.copy();
            activeScopes.push(currentScope);
          }
          if (currentNode.getTagName() == "scope" && currentNode.hasMethodPart()) {
            if (activeScopes.length > 2) {
              const snapshot = activeScopes[activeScopes.length - 2].copy();
              currentScope.addScopeList(currentNode.getMethodNameValue(), snapshot);
            }
          }
          if (currentScope.containsPath(currentNode.runtimeName())) {
            currentScopeParts.push(currentNode.id());
            if (currentNode.isClosedBy != null) {
              popScopeIds.push(currentNode.isClosedBy.id());
            }
            currentScope = currentScope.copy().bringListIntoMainScope(currentNode.runtimeName());
            activeScopes.push(currentScope);
            currentNode.currentScope = currentScope;
          } else {
            currentNode.currentScope = currentScope;
          }
          if (currentNode.getTagName() != "cache") {
            const scopeParam = currentNode.findParameter("scope");
            if (scopeParam != null && currentScope.canShiftScope(currentNode.runtimeName())) {
              currentScope = currentScope.shiftScope(currentNode, currentNode.runtimeName(), scopeParam.value);
              currentNode.currentScope = currentScope;
              activeScopes.pop();
              activeScopes.push(currentScope);
            }
          }
          if ((_l = tagManagerInstance_default.instance) == null ? void 0 : _l.isKnownTag(currentNode.runtimeName())) {
            const tagRef = (_m = tagManagerInstance_default.instance) == null ? void 0 : _m.findTag(currentNode.runtimeName());
            if (typeof tagRef !== "undefined" && tagRef.augmentScope != null) {
              tagRef.augmentScope(currentNode, currentScope);
            }
          }
          if (currentNode.modifierChain != null && currentNode.modifierChain.modifierChain.length > 0) {
            currentNode.modifierChain.modifierChain.forEach((modifier) => {
              if (modifier.modifier != null && typeof modifier.modifier.augmentScope != "undefined" && modifier.modifier.augmentScope != null) {
                modifier.modifier.augmentScope(currentNode, currentScope);
              }
            });
          }
          if (currentNode.modifiers.hasParameterModifiers()) {
            currentNode.modifiers.parameterModifiers.forEach((param) => {
              if (param.modifier != null && typeof param.modifier.augmentScope != "undefined" && param.modifier.augmentScope != null) {
                param.modifier.augmentScope(currentNode, currentScope);
              }
            });
          }
          if (currentNode.sourceType == "array") {
            const chunkParam = currentNode.findParameter("chunk");
            let injectContextualArrayData = true;
            if (currentNode.parent != null && currentNode.parent instanceof AntlersNode) {
              if (IgnoreArrayContextualData.includes(currentNode.parent.runtimeName())) {
                injectContextualArrayData = false;
              }
            }
            if (typeof chunkParam !== "undefined" && chunkParam !== null) {
              if (currentNode.currentScope.parentScope != null && (currentNode.currentScope.parentScope.hasList(currentNode.runtimeName()) || currentScope.referencesArray(currentNode.runtimeName()))) {
                const adjustedScope = currentNode.currentScope.parentScope.copy();
                let thisArrayValues = adjustedScope.liftList(currentNode.runtimeName());
                if (thisArrayValues == null && currentScope.referencesArray(currentNode.runtimeName())) {
                  thisArrayValues = new Scope(currentScope.statamicProject);
                  if (injectContextualArrayData) {
                    const symbolArrayVariables = makeArrayVariables(currentNode);
                    for (let i2 = 0; i2 < symbolArrayVariables.length; i2++) {
                      const checkVar = symbolArrayVariables[i2];
                      if (adjustedScope.wasIntroducedBySymbol(checkVar.name, currentNode)) {
                        adjustedScope.removeThroughIntroduction(checkVar.name, currentNode);
                      }
                    }
                    thisArrayValues.addVariables(symbolArrayVariables);
                  }
                } else {
                  if (injectContextualArrayData) {
                    adjustedScope.addVariables(makeArrayVariables(currentNode));
                  }
                }
                adjustedScope.addScopeList("chunk", thisArrayValues);
                currentScope = adjustedScope;
                activeScopes.pop();
                activeScopes.push(currentScope);
                currentNode.currentScope = adjustedScope;
              } else {
                const scopeParam = currentNode.findParameter("scope");
                if (typeof scopeParam !== "undefined" && scopeParam !== null) {
                  if (currentNode.currentScope != null && currentNode.currentScope.hasList(scopeParam.value) && currentNode.scopeName != null) {
                    const adjustedScope = currentNode.currentScope.copy(), injectScope = adjustedScope.ancestor().copy(), thisArrayValues = adjustedScope.liftList(currentNode.scopeName);
                    if (injectContextualArrayData) {
                      adjustedScope.addVariables(makeArrayVariables(currentNode));
                    }
                    injectScope.liftList(currentNode.scopeName);
                    adjustedScope.addScopeList(currentNode.scopeName, thisArrayValues);
                    injectScope.addScopeList("chunk", adjustedScope);
                    currentScope = injectScope;
                    activeScopes.pop();
                    activeScopes.push(currentScope);
                    currentNode.currentScope = injectScope;
                  }
                }
              }
            } else {
              if (currentNode.scopeVariable != null && currentNode.scopeVariable.sourceField == null) {
                if (injectContextualArrayData) {
                  currentScope.addVariables(makeArrayVariables(currentNode));
                  currentScope.addVariables(makeLoopVariables(currentNode));
                }
              }
            }
          }
          if (popScopeIds.includes(currentNode.id())) {
            if (currentNode.parent != null && currentNode.parent instanceof AntlersNode) {
              const tRef = currentNode.currentScope.findAncestorWithList(currentNode.getTagName());
              if (tRef != null) {
                currentNode.currentScope = tRef;
                currentScope = tRef.copy();
                activeScopes.pop();
                if (activeScopes.length == 0) {
                  activeScopes.push(rootScope);
                }
                activeScopes.push(currentScope);
              } else {
                if (currentNode.parent.parent != null) {
                  currentNode.currentScope = currentNode.parent.parent.currentScope;
                } else {
                  currentNode.currentScope = currentNode.parent.currentScope;
                }
              }
            }
          }
          if (currentNode.currentScope != null && currentNode.runtimeNodes.length > 0) {
            currentNode.runtimeNodes.forEach((runtimeNode) => {
              var _a2;
              if (runtimeNode instanceof VariableNode) {
                if ((_a2 = currentNode.currentScope) == null ? void 0 : _a2.hasValue(runtimeNode.name)) {
                  const varRef = currentNode.currentScope.findReferenceWithField(runtimeNode.name);
                  runtimeNode.currentScope = currentNode.currentScope;
                  runtimeNode.scopeName = currentNode.scopeName;
                  runtimeNode.scopeVariable = varRef;
                }
              }
            });
          }
          if (ChecksForFieldReferences.includes(currentNode.runtimeName())) {
            if (currentNode.runtimeNodes.length == 3) {
              if (currentNode.runtimeNodes[0] instanceof VariableNode && currentNode.runtimeNodes[1] instanceof EqualCompOperator && currentNode.runtimeNodes[2] instanceof StringValueNode) {
                if (currentNode.runtimeNodes[0].scopeVariable != null && currentNode.runtimeNodes[0].scopeVariable.sourceField != null) {
                  const targetVar = currentNode.runtimeNodes[0].scopeVariable, checkValue = currentNode.runtimeNodes[2].value, targetField = targetVar.sourceField;
                  if (targetField.sets != null) {
                    for (let setIndex = 0; setIndex < targetField.sets.length; setIndex++) {
                      const thisSet = targetField.sets[setIndex];
                      if (thisSet.handle == checkValue && thisSet.fields != null) {
                        currentScope = currentScope.copy();
                        currentScope.addBlueprintFields(currentNode, thisSet.fields);
                        if (currentNode.isClosedBy != null && !currentNode.isSelfClosing) {
                          currentScopeParts.push(currentNode.id());
                          popScopeIds.push(currentNode.isClosedBy.id());
                          activeScopes.push(currentScope);
                        }
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          this.lastSymbolId = currentNode.id();
          const scopePath = currentScopeParts.join("/");
          resolvedPaths.push(scopePath);
        }
      }
    };
  }
});

// server/src/runtime/runtime/globalRuntimeState.ts
var GlobalRuntimeState;
var init_globalRuntimeState = __esm({
  "server/src/runtime/runtime/globalRuntimeState.ts"() {
    "use strict";
    GlobalRuntimeState = class {
    };
    GlobalRuntimeState.globalTagEnterStack = [];
    GlobalRuntimeState.interpolatedVariables = [];
  }
});

// server/src/runtime/nodes/tagIdentifier.ts
var TagIdentifier;
var init_tagIdentifier = __esm({
  "server/src/runtime/nodes/tagIdentifier.ts"() {
    "use strict";
    TagIdentifier = class {
      constructor() {
        this.name = "";
        this.compound = "";
        this.methodPart = "";
        this.content = "";
        this.cachedCompoundTagName = null;
      }
      tagPartIs(check) {
        check = check.toLowerCase().trim();
        const checkAgainst = this.name.toLowerCase().trim();
        return checkAgainst == check;
      }
      isCompound() {
        if (this.methodPart == null) {
          return false;
        }
        return this.methodPart.length > 0;
      }
      getMethodName() {
        if (this.methodPart == "") {
          return "index";
        }
        if (this.methodPart == "null") {
          return "";
        }
        return this.methodPart;
      }
      getRuntimeMethodName() {
      }
      getCompoundTagName() {
        if (this.cachedCompoundTagName == null) {
          const methodName = this.getMethodName();
          this.cachedCompoundTagName = this.name;
          if (methodName != null && methodName != "") {
            this.cachedCompoundTagName = this.cachedCompoundTagName + ":" + methodName;
          }
        }
        return this.cachedCompoundTagName;
      }
    };
  }
});

// server/src/runtime/runtime/environmentDetails.ts
var _EnvironmentDetails, EnvironmentDetails;
var init_environmentDetails = __esm({
  "server/src/runtime/runtime/environmentDetails.ts"() {
    "use strict";
    init_modifierManager();
    init_tagManagerInstance();
    _EnvironmentDetails = class {
      constructor() {
        this.tagNames = [];
        this.modifierNames = [];
      }
      getModifierNames() {
        var _a, _b;
        return this.modifierNames.concat(
          (_b = (_a = modifierManager_default.instance) == null ? void 0 : _a.getModifierNames()) != null ? _b : []
        );
      }
      getTagNames() {
        var _a, _b;
        return this.tagNames.concat((_b = (_a = tagManagerInstance_default.instance) == null ? void 0 : _a.getTagNames()) != null ? _b : []);
      }
      setTagNames(tagNames) {
        this.tagNames = tagNames;
      }
      setModifierNames(modifierNames) {
        this.modifierNames = modifierNames;
      }
      isTag(value) {
        var _a;
        if (_EnvironmentDetails.alwaysLikeTag.includes(value)) {
          return true;
        }
        if ((_a = tagManagerInstance_default.instance) == null ? void 0 : _a.isKnownTag(value)) {
          return true;
        }
        return this.tagNames.includes(value);
      }
      isModifier(value) {
        var _a;
        if ((_a = modifierManager_default.instance) == null ? void 0 : _a.hasModifier(value)) {
          return true;
        }
        return this.modifierNames.includes(value);
      }
    };
    EnvironmentDetails = _EnvironmentDetails;
    EnvironmentDetails.alwaysLikeTag = [
      "if",
      "endif",
      "elseif",
      "else",
      "unless",
      "elseunless"
    ];
  }
});

// server/src/runtime/analyzers/nodeTypeAnalyzer.ts
var _NodeTypeAnalyzer, NodeTypeAnalyzer, nodeTypeAnalyzer_default;
var init_nodeTypeAnalyzer = __esm({
  "server/src/runtime/analyzers/nodeTypeAnalyzer.ts"() {
    "use strict";
    init_abstractNode();
    init_environmentDetails();
    _NodeTypeAnalyzer = class {
      static analyze(nodes, environmentDetails) {
        nodes.forEach((node) => {
          if (node instanceof AntlersNode) {
            if (node.pathReference != null && node.pathReference.isStrictVariableReference) {
              node.isTagNode = false;
              return;
            }
            if (node.name != null) {
              node.isTagNode = environmentDetails.isTag(node.name.name);
            }
          }
        });
      }
      static analyzeNode(node) {
        if (node.pathReference != null && node.pathReference.isStrictVariableReference) {
          node.isTagNode = false;
          return;
        }
        if (_NodeTypeAnalyzer.environmentDetails != null && node.name != null) {
          node.isTagNode = _NodeTypeAnalyzer.environmentDetails.isTag(
            node.name.name
          );
        }
        if (node.name != null) {
          node.isConditionNode = EnvironmentDetails.alwaysLikeTag.includes(
            node.name.name
          );
        }
      }
      static analyzeParametersForModifiers(node) {
        node.parameters.forEach((parameter) => {
          if (_NodeTypeAnalyzer.environmentDetails != null) {
            parameter.isModifierParameter = _NodeTypeAnalyzer.environmentDetails.isModifier(parameter.name);
          }
        });
      }
    };
    NodeTypeAnalyzer = _NodeTypeAnalyzer;
    NodeTypeAnalyzer.environmentDetails = null;
    if (typeof NodeTypeAnalyzer.environmentDetails == "undefined" || NodeTypeAnalyzer.environmentDetails == null) {
      NodeTypeAnalyzer.environmentDetails = new EnvironmentDetails();
    }
    nodeTypeAnalyzer_default = NodeTypeAnalyzer;
  }
});

// server/src/runtime/analyzers/tagIdentifierAnalyzer.ts
var TagIdentifierAnalyzer;
var init_tagIdentifierAnalyzer = __esm({
  "server/src/runtime/analyzers/tagIdentifierAnalyzer.ts"() {
    "use strict";
    init_tagIdentifier();
    TagIdentifierAnalyzer = class {
      static getIdentifier(input) {
        var _a;
        const identifier = new TagIdentifier();
        identifier.content = input.trim();
        const parts = input.split(":");
        if (parts.length == 1) {
          identifier.name = parts[0].trim();
          identifier.methodPart = null;
          identifier.compound = identifier.name;
        } else if (parts.length > 1) {
          const name = (_a = parts.shift()) != null ? _a : "", methodPart = parts.join(":");
          identifier.name = name.trim();
          identifier.methodPart = methodPart.trim();
          identifier.compound = identifier.name + ":" + identifier.methodPart;
        } else {
          identifier.name = input.trim();
          identifier.methodPart = "";
        }
        if (identifier.name.startsWith("/")) {
          identifier.name = identifier.name.substr(1);
          identifier.compound = identifier.compound.substr(1);
        }
        return identifier;
      }
    };
  }
});

// server/src/runtime/errors/typeLabeler.ts
var _TypeLabeler, TypeLabeler;
var init_typeLabeler = __esm({
  "server/src/runtime/errors/typeLabeler.ts"() {
    "use strict";
    init_abstractNode();
    _TypeLabeler = class {
      static getPrettyTypeName(token) {
        if (token instanceof LanguageOperatorConstruct) {
          return _TypeLabeler.TOKEN_LANG_OPERATOR;
        } else if (token instanceof AdditionOperator) {
          return _TypeLabeler.TOKEN_OP_A_ADD;
        } else if (token instanceof VariableNode) {
          return _TypeLabeler.TOKEN_VARIABLE;
        } else if (token instanceof StringValueNode) {
          return _TypeLabeler.TOKEN_STRING;
        } else if (token instanceof NumberNode) {
          return _TypeLabeler.TOKEN_NUMBER;
        } else if (token instanceof FalseConstant) {
          return _TypeLabeler.TOKEN_CONSTANT_FALSE;
        } else if (token instanceof NullConstant) {
          return _TypeLabeler.TOKEN_CONSTANT_NULL;
        } else if (token instanceof TrueConstant) {
          return _TypeLabeler.TOKEN_CONSTANT_TRUE;
        } else if (token instanceof ModifierNode) {
          return _TypeLabeler.TOKEN_MODIFIER_NODE;
        } else if (token instanceof ModifierChainNode) {
          return _TypeLabeler.TOKEN_MODIFIER_CHAIN;
        } else if (token instanceof ModifierParameterNode) {
          return _TypeLabeler.TOKEN_MODIFIER_PARAMETER;
        } else if (token instanceof DivisionOperator) {
          return _TypeLabeler.TOKEN_OP_A_DIVIDE;
        } else if (token instanceof ExponentiationOperator) {
          return _TypeLabeler.TOKEN_OP_A_EXPONENTIATION;
        } else if (token instanceof ModulusOperator) {
          return _TypeLabeler.TOKEN_OP_A_MODULUS;
        } else if (token instanceof MultiplicationOperator) {
          return _TypeLabeler.TOKEN_OP_A_MULTIPLY;
        } else if (token instanceof SubtractionOperator) {
          return _TypeLabeler.TOKEN_OP_A_SUBTRACT;
        } else if (token instanceof AdditionAssignmentOperator) {
          return _TypeLabeler.TOKEN_ASG_ADD;
        } else if (token instanceof DivisionAssignmentOperator) {
          return _TypeLabeler.TOKEN_ASG_DIVIDE;
        } else if (token instanceof ModulusAssignmentOperator) {
          return _TypeLabeler.TOKEN_ASG_MODULUS;
        } else if (token instanceof MultiplicationAssignmentOperator) {
          return _TypeLabeler.TOKEN_ASG_MULTIPLY;
        } else if (token instanceof LeftAssignmentOperator) {
          return _TypeLabeler.TOKEN_ASG_ASSIGN;
        } else if (token instanceof SubtractionAssignmentOperator) {
          return _TypeLabeler.TOKEN_ASG_SUBTRACT;
        } else if (token instanceof EqualCompOperator) {
          return _TypeLabeler.TOKEN_CMP_EQUAL;
        } else if (token instanceof StrictEqualCompOperator) {
          return _TypeLabeler.TOKEN_CMP_SEQUAL;
        } else if (token instanceof GreaterThanCompOperator) {
          return _TypeLabeler.TOKEN_CMP_GT;
        } else if (token instanceof GreaterThanEqualCompOperator) {
          return _TypeLabeler.TOKEN_CMP_GTE;
        } else if (token instanceof LessThanCompOperator) {
          return _TypeLabeler.TOKEN_CMP_LT;
        } else if (token instanceof LessThanEqualCompOperator) {
          return _TypeLabeler.TOKEN_CMP_LTE;
        } else if (token instanceof NotEqualCompOperator) {
          return _TypeLabeler.TOKEN_CMP_NEQ;
        } else if (token instanceof NotStrictEqualCompOperator) {
          return _TypeLabeler.TOKEN_CMP_SNEQ;
        } else if (token instanceof SpaceshipCompOperator) {
          return _TypeLabeler.TOKEN_CMP_SPACESHIP;
        } else if (token instanceof ConditionalVariableFallbackOperator) {
          return _TypeLabeler.TOKEN_OP_VARIABLE_FALLBACK;
        } else if (token instanceof ConditionalFallbackGroup) {
          return _TypeLabeler.TOKEN_COND_FALLBACK_GROUP;
        } else if (token instanceof InlineBranchSeparator) {
          return _TypeLabeler.TOKEN_BRANCH_SEPARATOR;
        } else if (token instanceof InlineTernarySeparator) {
          return _TypeLabeler.TOKEN_TERNARY_SEPARATOR;
        } else if (token instanceof LogicGroupBegin) {
          return _TypeLabeler.TOKEN_GROUP_BEGIN;
        } else if (token instanceof LogicGroupEnd) {
          return _TypeLabeler.TOKEN_GROUP_END;
        } else if (token instanceof ModifierSeparator) {
          return _TypeLabeler.TOKEN_MODIFIER_SEPARATOR;
        } else if (token instanceof ModifierNameNode) {
          return _TypeLabeler.TOKEN_MODIFIER_NAME;
        } else if (token instanceof ModifierValueNode) {
          return _TypeLabeler.TOKEN_MODIFIER_VALUE;
        } else if (token instanceof ModifierValueSeparator) {
          return _TypeLabeler.TOKEN_MODIFIER_VALUE_SEPARATOR;
        } else if (token instanceof NullCoalescenceGroup) {
          return _TypeLabeler.TOKEN_NULL_COALESCE_GROUP;
        } else if (token instanceof SemanticGroup) {
          return _TypeLabeler.TOKEN_SEMANTIC_GROUP;
        } else if (token instanceof StatementSeparatorNode) {
          return _TypeLabeler.TOKEN_STATEMENT_SEPARATOR;
        } else if (token instanceof TernaryCondition) {
          return _TypeLabeler.TOKEN_TERNARY_CONDITION;
        } else if (token instanceof LogicalAndOperator) {
          return _TypeLabeler.TOKEN_OP_AND;
        } else if (token instanceof LogicalNegationOperator) {
          return _TypeLabeler.TOKEN_OP_LOGIC_NEGATION;
        } else if (token instanceof LogicalOrOperator) {
          return _TypeLabeler.TOKEN_OP_OR;
        } else if (token instanceof LogicalXorOperator) {
          return _TypeLabeler.TOKEN_OP_XOR;
        } else if (token instanceof NullCoalesceOperator) {
          return _TypeLabeler.TOKEN_OP_NULL_COALESCE;
        } else if (token instanceof ParameterNode2) {
          return _TypeLabeler.TOKEN_PARAM;
        } else if (token instanceof PathNode) {
          return _TypeLabeler.TOKEN_PATH_ACCESSOR;
        } else if (token instanceof FactorialOperator) {
          return _TypeLabeler.TOKEN_OP_A_FACTORIAL;
        } else if (token instanceof RecursiveNode) {
          return _TypeLabeler.TOKEN_RECURSIVE;
        } else if (token instanceof ArgumentGroup) {
          return _TypeLabeler.TOKEN_ARG_GROUP;
        } else if (token instanceof ArgSeparator) {
          return _TypeLabeler.TOKEN_ARG_SEPARATOR;
        } else if (token instanceof StringConcatenationOperator) {
          return _TypeLabeler.TOKEN_OP_STRING_CONCAT;
        } else if (token instanceof ScopeAssignmentOperator) {
          return _TypeLabeler.TOKEN_OP_SCOPE_REASSIGNMENT;
        } else if (token instanceof SwitchCase) {
          return _TypeLabeler.TOKEN_STRUCT_SWITCH_CASE;
        } else if (token instanceof SwitchGroup) {
          return _TypeLabeler.TOKEN_STRUCT_SWITCH_GROUP;
        } else if (token instanceof DirectionGroup) {
          return _TypeLabeler.TOKEN_STRUCT_DIRECTION_GROUP;
        } else if (token instanceof ScopedLogicGroup) {
          return _TypeLabeler.TOKEN_STRUCT_SCOPED_LOGIC_GROUP;
        } else if (token instanceof LogicGroup) {
          return _TypeLabeler.TOKEN_STRUCT_LOGIC_GROUP;
        } else if (token instanceof ValueDirectionNode) {
          return _TypeLabeler.TOKEN_STRUCT_VALUE_DIRECTION;
        } else if (token instanceof ArrayNode) {
          return _TypeLabeler.TOKEN_STRUCT_ARRAY;
        } else if (token instanceof TupleListStart) {
          return _TypeLabeler.TOKEN_STRUCT_T_LIST_START;
        } else if (token instanceof TupleList) {
          return _TypeLabeler.TOKEN_STRUCT_TUPLE_LIST;
        } else if (token instanceof MethodInvocationNode) {
          return _TypeLabeler.TOKEN_STRUCT_METHOD_CALL;
        }
        return typeof token;
      }
    };
    TypeLabeler = _TypeLabeler;
    TypeLabeler.TOKEN_LANG_OPERATOR = "T_LANG_OPERATOR";
    TypeLabeler.TOKEN_VARIABLE = "T_VAR";
    TypeLabeler.TOKEN_NUMBER = "T_NUMERIC";
    TypeLabeler.TOKEN_STRING = "T_STRING";
    TypeLabeler.TOKEN_RECURSIVE = "T_RECURSIVE";
    TypeLabeler.TOKEN_CONSTANT_FALSE = "T_FALSE";
    TypeLabeler.TOKEN_CONSTANT_NULL = "T_NULL";
    TypeLabeler.TOKEN_CONSTANT_TRUE = "T_TRUE";
    TypeLabeler.TOKEN_MODIFIER_NODE = "T_MODIFIER";
    TypeLabeler.TOKEN_MODIFIER_CHAIN = "T_MODIFIER_CHAIN";
    TypeLabeler.TOKEN_MODIFIER_PARAMETER = "T_MODIFIER_PARAM";
    TypeLabeler.TOKEN_OP_A_ADD = "T_AOP_ADD";
    TypeLabeler.TOKEN_OP_A_DIVIDE = "T_AOP_DIVIDE";
    TypeLabeler.TOKEN_OP_A_EXPONENTIATION = "T_AOP_EXP";
    TypeLabeler.TOKEN_OP_A_MODULUS = "T_AOP_MOD";
    TypeLabeler.TOKEN_OP_A_MULTIPLY = "T_AOP_MULTIPLY";
    TypeLabeler.TOKEN_OP_A_SUBTRACT = "T_AOP_SUBTRACT";
    TypeLabeler.TOKEN_OP_A_FACTORIAL = "T_AOP_FACTORIAL";
    TypeLabeler.TOKEN_ASG_ADD = "T_ASG_ADD";
    TypeLabeler.TOKEN_ASG_DIVIDE = "T_ASG_DIVIDE";
    TypeLabeler.TOKEN_ASG_ASSIGN = "T_ASG";
    TypeLabeler.TOKEN_ASG_MODULUS = "T_ASG_MODULUS";
    TypeLabeler.TOKEN_ASG_MULTIPLY = "T_ASG_MULTIPLY";
    TypeLabeler.TOKEN_ASG_SUBTRACT = "T_ASG_SUBTRACT";
    TypeLabeler.TOKEN_CMP_EQUAL = "T_CMP_EQ";
    TypeLabeler.TOKEN_CMP_SEQUAL = "T_CMP_SEQ";
    TypeLabeler.TOKEN_CMP_GT = "T_CMP_GT";
    TypeLabeler.TOKEN_CMP_GTE = "T_CMP_GTE";
    TypeLabeler.TOKEN_CMP_LT = "T_CMP_LT";
    TypeLabeler.TOKEN_CMP_LTE = "T_CMP_LTE";
    TypeLabeler.TOKEN_CMP_NEQ = "T_CMP_NEQ";
    TypeLabeler.TOKEN_CMP_SNEQ = "T_CMP_SNEQ";
    TypeLabeler.TOKEN_CMP_SPACESHIP = "T_CMP_SPSHP";
    TypeLabeler.TOKEN_OP_VARIABLE_FALLBACK = "T_VFBK";
    TypeLabeler.TOKEN_COND_FALLBACK_GROUP = "T_VFBK_GROUP";
    TypeLabeler.TOKEN_BRANCH_SEPARATOR = "T_BRANCH_SEPARATOR";
    TypeLabeler.TOKEN_TERNARY_SEPARATOR = "T_TERNARY_SEPARATOR";
    TypeLabeler.TOKEN_GROUP_BEGIN = "T_LOGIC_BEGIN";
    TypeLabeler.TOKEN_GROUP_END = "T_LOGIC_END";
    TypeLabeler.TOKEN_MODIFIER_SEPARATOR = "T_MODIFIER_SEPARATOR";
    TypeLabeler.TOKEN_MODIFIER_NAME = "T_MODIFIER_NAME";
    TypeLabeler.TOKEN_MODIFIER_VALUE = "T_MODIFIER_VALUE";
    TypeLabeler.TOKEN_MODIFIER_VALUE_SEPARATOR = "T_MODIFIER_VALUE_SEPARATOR";
    TypeLabeler.TOKEN_NULL_COALESCE_GROUP = "T_NULL_COALESCE_GROUP";
    TypeLabeler.TOKEN_SEMANTIC_GROUP = "T_SEMANTIC_GROUP";
    TypeLabeler.TOKEN_STATEMENT_SEPARATOR = "T_STATEMENT_SEPARATOR";
    TypeLabeler.TOKEN_TERNARY_CONDITION = "T_TERNARY_CONDITION";
    TypeLabeler.TOKEN_OP_AND = "T_AND";
    TypeLabeler.TOKEN_OP_LOGIC_NEGATION = "T_LOGIC_INVERSE";
    TypeLabeler.TOKEN_OP_OR = "T_OR";
    TypeLabeler.TOKEN_OP_XOR = "T_XOR";
    TypeLabeler.TOKEN_OP_NULL_COALESCE = "T_NULL_COALESCE";
    TypeLabeler.TOKEN_PARAM = "T_PARAM";
    TypeLabeler.TOKEN_PATH_ACCESSOR = "T_VAR_SEPARATOR";
    TypeLabeler.TOKEN_ARG_GROUP = "T_ARG_GROUP";
    TypeLabeler.TOKEN_ARG_SEPARATOR = "T_ARG_SEPARATOR";
    TypeLabeler.TOKEN_OP_STRING_CONCAT = "T_STR_CONCAT";
    TypeLabeler.TOKEN_OP_SCOPE_REASSIGNMENT = "T_SCOPE_ASSIGNMENT";
    TypeLabeler.TOKEN_STRUCT_SWITCH_CASE = "T_SWITCH_CASE";
    TypeLabeler.TOKEN_STRUCT_SWITCH_GROUP = "T_SWITCH_GROUP";
    TypeLabeler.TOKEN_STRUCT_DIRECTION_GROUP = "T_DIRECTION_GROUP";
    TypeLabeler.TOKEN_STRUCT_VALUE_DIRECTION = "T_ORDER_DIRECTION";
    TypeLabeler.TOKEN_STRUCT_SCOPED_LOGIC_GROUP = "T_SCOPED_LOGIC_GROUP";
    TypeLabeler.TOKEN_STRUCT_LOGIC_GROUP = "T_LOGIC_GROUP";
    TypeLabeler.TOKEN_STRUCT_ARRAY = "T_ARRAY";
    TypeLabeler.TOKEN_STRUCT_T_LIST_START = "T_LIST_START";
    TypeLabeler.TOKEN_STRUCT_TUPLE_LIST = "T_LIST";
    TypeLabeler.TOKEN_STRUCT_METHOD_CALL = "T_METHOD_CALL";
  }
});

// server/src/runtime/parser/languageKeywords.ts
var LanguageKeywords;
var init_languageKeywords = __esm({
  "server/src/runtime/parser/languageKeywords.ts"() {
    "use strict";
    LanguageKeywords = class {
      static isLanguageLogicalKeyword(value) {
        if (value == this.LogicalAnd || value == this.LogicalNot || value == this.LogicalOr || value == this.LogicalXor) {
          return true;
        }
        return false;
      }
    };
    LanguageKeywords.LogicalAnd = "and";
    LanguageKeywords.LogicalNot = "not";
    LanguageKeywords.LogicalOr = "or";
    LanguageKeywords.LogicalXor = "xor";
    LanguageKeywords.ConstTrue = "true";
    LanguageKeywords.ConstFalse = "false";
    LanguageKeywords.ConstNull = "null";
    LanguageKeywords.ArrList = "list";
    LanguageKeywords.ScopeAs = "as";
  }
});

// server/src/runtime/lexer/antlersLexer.ts
var AntlersLexer;
var init_antlersLexer = __esm({
  "server/src/runtime/lexer/antlersLexer.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_typeLabeler();
    init_abstractNode();
    init_documentParser();
    init_languageKeywords();
    init_stringUtilities();
    AntlersLexer = class {
      constructor() {
        this.chars = [];
        this.inputLen = 0;
        this.currentIndex = 0;
        this.currentContent = [];
        this.rawContent = [];
        this.startIndex = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.isParsingString = false;
        this.isParsingModifierName = false;
        this.isInModifierParameterValue = false;
        this.runtimeNodes = [];
        this.ignorePrevious = false;
        this.lastNode = null;
        this.referenceParser = null;
        this.activeNode = null;
      }
      reset() {
        this.ignorePrevious = false;
        this.runtimeNodes = [];
        this.chars = [];
        this.inputLen = 0;
        this.currentIndex = 0;
        this.currentContent = [];
        this.rawContent = [];
        this.startIndex = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.isParsingString = false;
        this.isParsingModifierName = false;
        this.isInModifierParameterValue = false;
        this.referenceParser = null;
        this.activeNode = null;
      }
      checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (!this.ignorePrevious) {
          if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
          }
        } else {
          this.prev = "";
          this.ignorePrevious = false;
        }
        if (this.currentIndex + 1 < this.inputLen) {
          this.next = this.chars[this.currentIndex + 1];
        }
      }
      isValidChar(char) {
        if (char == null) {
          return false;
        }
        if (char == DocumentParser.Punctuation_Semicolon) {
          return false;
        }
        if (this.isParsingString == false && char == "]") {
          return true;
        }
        if (this.isParsingString == false && char == ")") {
          return false;
        }
        if ((char == "[" || char == "]") && char == this.cur) {
          return true;
        }
        if ((char == "_" || char == "." || char == "[" || char == "]") && (!(this.currentContent.length > 0) || StringUtilities.ctypeAlpha(this.cur) || StringUtilities.ctypeDigit(this.cur))) {
          return true;
        }
        if (StringUtilities.ctypeSpace(char)) {
          return false;
        }
        if (this.isParsingModifierName && (char == DocumentParser.Punctuation_Minus || char == DocumentParser.Punctuation_Underscore)) {
          return true;
        }
        if (StringUtilities.ctypePunct(char)) {
          return false;
        }
        return true;
      }
      isRightOfInterpolationRegion() {
        if (this.activeNode == null) {
          return false;
        }
        if (this.referenceParser == null) {
          return false;
        }
        const relative = this.activeNode._lexerRelativeOffset(this.currentIndex);
        return this.referenceParser.bordersInterpolationRegion(relative);
      }
      scanForwardTo(char, skip = 0) {
        const returnChars = [];
        for (let i = this.currentIndex + 1 + skip; i < this.inputLen; i++) {
          const cur = this.chars[i];
          if (cur == char) {
            returnChars.push(cur);
            break;
          } else {
            returnChars.push(cur);
          }
        }
        return returnChars;
      }
      nextNonWhitespace() {
        for (let i = this.currentIndex + 1; i < this.inputLen; i++) {
          const cur = this.chars[i];
          if (!StringUtilities.ctypeSpace(cur)) {
            return cur;
          }
        }
        return null;
      }
      pushError(error) {
        if (this.referenceParser != null) {
          this.referenceParser.addAntlersError(error);
        }
      }
      guardAgainstNeighboringTypesInModifier(current) {
        if (this.lastNode instanceof ModifierValueNode) {
          this.pushError(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_MODIFIER_INCORRECT_VALUE_POSITION,
            this.lastNode,
            "Incorrect type [" + TypeLabeler.getPrettyTypeName(current) + "] near [" + TypeLabeler.getPrettyTypeName(this.lastNode) + "]"
          ));
        }
        return false;
      }
      appendContent(char) {
        if (char != null) {
          this.currentContent.push(char);
        }
      }
      tokenize(node, input) {
        this.reset();
        this.referenceParser = node.getParser();
        this.activeNode = node;
        this.chars = input.split("");
        this.inputLen = this.chars.length;
        this.runtimeNodes = [];
        this.lastNode = null;
        let stringStartedOn = null;
        this.isParsingString = false;
        this.isParsingModifierName = false;
        let terminator = null;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          let addCurrent = true;
          if (this.cur != null) {
            this.rawContent.push(this.cur);
          }
          if (this.isParsingString == false) {
            if (this.cur == DocumentParser.String_Terminator_DoubleQuote || this.cur == DocumentParser.String_Terminator_SingleQuote) {
              if (this.prev == DocumentParser.String_EscapeCharacter) {
                this.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_ILLEGAL_STRING_ESCAPE_SEQUENCE,
                  node,
                  "Illegal string escape sequence outside string parsing."
                ));
                continue;
              }
              this.rawContent = [];
              this.rawContent.push(this.cur);
              terminator = this.cur;
              this.isParsingString = true;
              stringStartedOn = this.currentIndex;
              continue;
            }
          }
          if (this.isInModifierParameterValue && !this.isParsingString) {
            let breakForKeyword = false;
            if (!this.isParsingString && StringUtilities.ctypeSpace(this.next)) {
              const nextWord = this.scanForwardTo(" ", 1).join("").trim().toLowerCase();
              if (nextWord.length > 0 && LanguageKeywords.isLanguageLogicalKeyword(nextWord)) {
                breakForKeyword = true;
              }
            }
            if (this.next == DocumentParser.String_Terminator_SingleQuote || this.next == DocumentParser.String_Terminator_DoubleQuote || this.next == null || breakForKeyword) {
              this.appendContent(this.cur);
              const implodedCurrentContent = this.currentContent.join("");
              if (implodedCurrentContent.length > 0) {
                const parsedValue = implodedCurrentContent;
                this.currentContent = [];
                this.rawContent = [];
                if (parsedValue.trimRight().length == 0) {
                  const nextNonWhitespace = this.nextNonWhitespace();
                  if (nextNonWhitespace == DocumentParser.String_Terminator_SingleQuote || nextNonWhitespace == DocumentParser.String_Terminator_DoubleQuote) {
                    this.currentContent = [];
                    this.rawContent = [];
                    continue;
                  }
                }
                const modifierValueNode = new ModifierValueNode();
                modifierValueNode.isVirtual = false;
                modifierValueNode.name = parsedValue;
                modifierValueNode.value = parsedValue.trimRight();
                modifierValueNode.startPosition = node._lexerRelativeOffset(this.currentIndex - parsedValue.length);
                modifierValueNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
                modifierValueNode.parent = this.activeNode;
                this.guardAgainstNeighboringTypesInModifier(modifierValueNode);
                this.runtimeNodes.push(modifierValueNode);
                this.lastNode = modifierValueNode;
              }
              if (implodedCurrentContent.length == 0) {
                continue;
              }
              this.currentContent = [];
              this.rawContent = [];
              this.isInModifierParameterValue = false;
              continue;
            }
            if (this.next == DocumentParser.Punctuation_Pipe || this.next == DocumentParser.Punctuation_Colon || this.next == DocumentParser.RightParent) {
              this.isInModifierParameterValue = false;
              this.appendContent(this.cur);
              let additionalSkip = 0, trimStartEnd = false;
              if (this.currentContent[0] == DocumentParser.String_Terminator_SingleQuote || this.currentContent[0] == DocumentParser.String_Terminator_DoubleQuote) {
                const scan = this.scanForwardTo(this.currentContent[0]);
                if (scan.length > 0) {
                  this.currentContent = this.currentContent.concat(scan);
                  additionalSkip = scan.length;
                  trimStartEnd = true;
                }
              }
              let parsedValue = this.currentContent.join("");
              if (trimStartEnd) {
                parsedValue = parsedValue.substr(1);
                parsedValue = parsedValue.slice(0, -1);
              }
              this.currentContent = [];
              this.rawContent = [];
              const modifierValueNode = new ModifierValueNode();
              modifierValueNode.isVirtual = false;
              modifierValueNode.name = parsedValue;
              modifierValueNode.value = parsedValue;
              modifierValueNode.startPosition = node._lexerRelativeOffset(this.currentIndex - parsedValue.length);
              modifierValueNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
              modifierValueNode.parent = this.activeNode;
              this.runtimeNodes.push(modifierValueNode);
              this.guardAgainstNeighboringTypesInModifier(modifierValueNode);
              this.lastNode = modifierValueNode;
              this.currentIndex += additionalSkip;
            } else {
              this.appendContent(this.cur);
            }
            continue;
          }
          if (this.isParsingString && this.cur == terminator) {
            if (this.prev == DocumentParser.String_EscapeCharacter) {
              this.appendContent(terminator);
            } else {
              if (this.isInModifierParameterValue) {
                const parsedValue = this.currentContent.join("");
                const modifierValueNode = new ModifierValueNode();
                modifierValueNode.isVirtual = false;
                modifierValueNode.name = parsedValue;
                modifierValueNode.value = parsedValue;
                modifierValueNode.startPosition = node._lexerRelativeOffset(stringStartedOn != null ? stringStartedOn : 0);
                modifierValueNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
                modifierValueNode.parent = this.activeNode;
                this.runtimeNodes.push(modifierValueNode);
                this.guardAgainstNeighboringTypesInModifier(modifierValueNode);
                this.lastNode = modifierValueNode;
                this.currentContent = [];
                this.rawContent = [];
                this.isParsingString = false;
                this.isInModifierParameterValue = false;
                continue;
              }
              const stringNode = new StringValueNode();
              stringNode.isVirtual = false;
              stringNode.startPosition = node._lexerRelativeOffset(stringStartedOn != null ? stringStartedOn : 0);
              stringNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
              if (this.referenceParser != null) {
                stringNode.sourceContent = this.referenceParser.getText(stringNode.startPosition.index, stringNode.endPosition.index + 1);
              }
              stringNode.parent = this.activeNode;
              if (terminator != null) {
                stringNode.sourceTerminator = terminator;
              }
              terminator = null;
              this.isParsingString = false;
              stringNode.value = this.currentContent.join("");
              stringNode.rawLexContent = this.rawContent.join("").trim();
              this.currentContent = [];
              this.rawContent = [];
              this.guardAgainstNeighboringTypesInModifier(stringNode);
              this.runtimeNodes.push(stringNode);
              this.lastNode = stringNode;
            }
            continue;
          }
          if (this.isParsingString && this.cur == DocumentParser.String_EscapeCharacter) {
            if (this.next == DocumentParser.String_EscapeCharacter) {
              this.appendContent(DocumentParser.String_EscapeCharacter);
              this.ignorePrevious = true;
              this.currentIndex += 1;
              continue;
            } else if (this.next == DocumentParser.String_Terminator_SingleQuote) {
              this.appendContent(DocumentParser.String_Terminator_SingleQuote);
              this.rawContent.push(DocumentParser.String_EscapeCharacter);
              this.rawContent.push(DocumentParser.String_Terminator_SingleQuote);
              this.currentIndex += 1;
              continue;
            } else if (this.next == DocumentParser.String_Terminator_DoubleQuote) {
              this.appendContent(DocumentParser.String_Terminator_DoubleQuote);
              this.rawContent.push(DocumentParser.String_EscapeCharacter);
              this.rawContent.push(DocumentParser.String_Terminator_DoubleQuote);
              this.currentIndex += 1;
              continue;
            } else if (this.next == "n") {
              this.appendContent("\n");
              this.currentIndex += 1;
              continue;
            } else if (this.next == "t") {
              this.appendContent("	");
              this.currentIndex += 1;
              continue;
            } else if (this.next == "r") {
              this.appendContent("\r");
              this.currentIndex += 1;
              continue;
            }
          }
          if (this.isParsingString == false) {
            if (this.isValidChar(this.cur) && this.isValidChar(this.next) == false && this.currentContent.length == 0) {
              this.appendContent(this.cur);
              addCurrent = false;
            }
            if ((this.next == null || this.isValidChar(this.next) == false) && this.currentContent.length > 0) {
              if (addCurrent) {
                this.appendContent(this.cur);
              }
              const parsedValue = this.currentContent.join("").trim(), valueLen = parsedValue.length, valueStartIndex = this.currentIndex - valueLen, startPosition = node._lexerRelativeOffset(valueStartIndex), endPosition = node._lexerRelativeOffset(this.currentIndex);
              this.currentContent = [];
              this.rawContent = [];
              if (parsedValue == LanguageKeywords.LogicalAnd) {
                const logicalAnd = new LogicalAndOperator();
                logicalAnd.isVirtual = false;
                logicalAnd.content = LanguageKeywords.LogicalAnd;
                logicalAnd.startPosition = startPosition;
                logicalAnd.endPosition = endPosition;
                logicalAnd.parent = this.activeNode;
                this.runtimeNodes.push(logicalAnd);
                this.lastNode = logicalAnd;
                continue;
              } else if (parsedValue == LanguageKeywords.LogicalOr) {
                const logicalOr = new LogicalOrOperator();
                logicalOr.isVirtual = false;
                logicalOr.content = LanguageKeywords.LogicalOr;
                logicalOr.startPosition = startPosition;
                logicalOr.endPosition = endPosition;
                logicalOr.parent = this.activeNode;
                this.runtimeNodes.push(logicalOr);
                this.lastNode = logicalOr;
                continue;
              } else if (parsedValue == LanguageKeywords.LogicalXor) {
                const logicalXor = new LogicalXorOperator();
                logicalXor.isVirtual = false;
                logicalXor.content = LanguageKeywords.LogicalXor;
                logicalXor.startPosition = startPosition;
                logicalXor.endPosition = endPosition;
                logicalXor.parent = this.activeNode;
                this.runtimeNodes.push(logicalXor);
                this.lastNode = logicalXor;
                continue;
              } else if (parsedValue == LanguageKeywords.ConstNull) {
                const constNull = new NullConstant();
                constNull.isVirtual = false;
                constNull.content = LanguageKeywords.ConstNull;
                constNull.startPosition = startPosition;
                constNull.endPosition = endPosition;
                constNull.parent = this.activeNode;
                this.runtimeNodes.push(constNull);
                this.lastNode = constNull;
                continue;
              } else if (parsedValue == LanguageKeywords.ConstTrue) {
                const constTrue = new TrueConstant();
                constTrue.isVirtual = false;
                constTrue.content = LanguageKeywords.ConstTrue;
                constTrue.startPosition = startPosition;
                constTrue.endPosition = endPosition;
                constTrue.parent = this.activeNode;
                this.runtimeNodes.push(constTrue);
                this.lastNode = constTrue;
                continue;
              } else if (parsedValue == LanguageKeywords.ConstFalse) {
                const constFalse = new FalseConstant();
                constFalse.isVirtual = false;
                constFalse.content = LanguageKeywords.ConstFalse;
                constFalse.startPosition = startPosition;
                constFalse.endPosition = endPosition;
                constFalse.parent = this.activeNode;
                this.runtimeNodes.push(constFalse);
                this.lastNode = constFalse;
                continue;
              } else if (parsedValue == LanguageKeywords.LogicalNot) {
                const logicNegation = new LogicalNegationOperator();
                logicNegation.isVirtual = false;
                logicNegation.content = LanguageKeywords.LogicalNot;
                logicNegation.startPosition = startPosition;
                logicNegation.endPosition = endPosition;
                logicNegation.parent = this.activeNode;
                this.runtimeNodes.push(logicNegation);
                this.lastNode = logicNegation;
                continue;
              } else if (parsedValue == LanguageKeywords.ArrList && this.next == DocumentParser.LeftParen) {
                const tupleListStart = new TupleListStart();
                tupleListStart.isVirtual = false;
                tupleListStart.content = LanguageKeywords.ArrList;
                tupleListStart.startPosition = startPosition;
                tupleListStart.endPosition = endPosition;
                tupleListStart.parent = this.activeNode;
                this.runtimeNodes.push(tupleListStart);
                this.lastNode = tupleListStart;
                continue;
              }
              if (StringUtilities.isNumeric(parsedValue)) {
                const numberNode = new NumberNode();
                numberNode.isVirtual = false;
                numberNode.startPosition = startPosition;
                numberNode.endPosition = endPosition;
                numberNode.parent = this.activeNode;
                if (parsedValue.includes(".")) {
                  numberNode.value = parseFloat(parsedValue);
                } else {
                  numberNode.value = parseInt(parsedValue);
                }
                numberNode.rawLexContent = parsedValue;
                this.guardAgainstNeighboringTypesInModifier(numberNode);
                this.runtimeNodes.push(numberNode);
                this.lastNode = numberNode;
                continue;
              }
              if (this.runtimeNodes.length > 0) {
                const lastValue = this.runtimeNodes[this.runtimeNodes.length - 1];
                if (lastValue instanceof ModifierSeparator) {
                  const modifierNameNode = new ModifierNameNode();
                  modifierNameNode.isVirtual = false;
                  modifierNameNode.name = parsedValue;
                  modifierNameNode.content = parsedValue;
                  modifierNameNode.startPosition = startPosition;
                  modifierNameNode.endPosition = endPosition;
                  modifierNameNode.parent = this.activeNode;
                  this.runtimeNodes.push(modifierNameNode);
                  this.lastNode = modifierNameNode;
                  continue;
                } else if (lastValue instanceof ModifierValueSeparator) {
                  const modifierValueNode = new ModifierValueNode();
                  modifierValueNode.isVirtual = false;
                  modifierValueNode.name = parsedValue;
                  modifierValueNode.value = parsedValue;
                  modifierValueNode.startPosition = startPosition;
                  modifierValueNode.endPosition = endPosition;
                  modifierValueNode.parent = this.activeNode;
                  this.runtimeNodes.push(modifierValueNode);
                  this.lastNode = modifierValueNode;
                  this.isParsingModifierName = false;
                  continue;
                }
              }
              const variableRefNode = new VariableNode();
              variableRefNode.isVirtual = false;
              variableRefNode.name = parsedValue;
              variableRefNode.startPosition = startPosition;
              variableRefNode.endPosition = endPosition;
              variableRefNode.parent = this.activeNode;
              this.runtimeNodes.push(variableRefNode);
              this.lastNode = variableRefNode;
              continue;
            }
          } else {
            this.appendContent(this.cur);
            continue;
          }
          if (StringUtilities.ctypeSpace(this.cur)) {
            continue;
          }
          if (this.isParsingString == false) {
            if (this.cur == DocumentParser.Punctuation_Equals && this.next == DocumentParser.Punctuation_GreaterThan) {
              const scopeAssignment = new ScopeAssignmentOperator();
              scopeAssignment.isVirtual = false;
              scopeAssignment.content = "=>";
              scopeAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
              scopeAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              scopeAssignment.parent = this.activeNode;
              this.runtimeNodes.push(scopeAssignment);
              this.lastNode = scopeAssignment;
              this.currentContent = [];
              this.rawContent = [];
              this.currentIndex += 1;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Comma) {
              const argSeparator = new ArgSeparator();
              argSeparator.isVirtual = false;
              argSeparator.content = DocumentParser.Punctuation_Comma;
              argSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              argSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              argSeparator.parent = this.activeNode;
              this.runtimeNodes.push(argSeparator);
              this.lastNode = argSeparator;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Semicolon) {
              const statementSeparator = new StatementSeparatorNode();
              statementSeparator.isVirtual = false;
              statementSeparator.content = DocumentParser.Punctuation_Semicolon;
              statementSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              statementSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              statementSeparator.parent = this.activeNode;
              this.runtimeNodes.push(statementSeparator);
              this.lastNode = statementSeparator;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Plus) {
              if (this.next == DocumentParser.Punctuation_Equals) {
                const additionAssignment = new AdditionAssignmentOperator();
                additionAssignment.isVirtual = false;
                additionAssignment.content = "+=";
                additionAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
                additionAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                additionAssignment.parent = this.activeNode;
                this.runtimeNodes.push(additionAssignment);
                this.lastNode = additionAssignment;
                this.currentIndex += 1;
                continue;
              }
              const additionOperator = new AdditionOperator();
              additionOperator.isVirtual = false;
              additionOperator.content = "+";
              additionOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              additionOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              additionOperator.parent = this.activeNode;
              this.runtimeNodes.push(additionOperator);
              this.lastNode = additionOperator;
              continue;
            }
            if (this.isParsingModifierName == false && this.cur == DocumentParser.Punctuation_Minus) {
              if (StringUtilities.ctypeDigit(this.next) && (StringUtilities.ctypeDigit(this.prev) == false && this.prev != DocumentParser.RightParent) && this.isRightOfInterpolationRegion() == false) {
                this.appendContent(this.cur);
                continue;
              }
              if (this.next == DocumentParser.Punctuation_Equals) {
                const subtractionAssignment = new SubtractionAssignmentOperator();
                subtractionAssignment.isVirtual = false;
                subtractionAssignment.content = "-=";
                subtractionAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
                subtractionAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                subtractionAssignment.parent = this.activeNode;
                this.runtimeNodes.push(subtractionAssignment);
                this.lastNode = subtractionAssignment;
                this.currentIndex += 1;
                continue;
              } else if (this.next == DocumentParser.Punctuation_GreaterThan) {
                const methodInvocation = new MethodInvocationNode();
                methodInvocation.isVirtual = false;
                methodInvocation.content = "->";
                methodInvocation.startPosition = node._lexerRelativeOffset(this.currentIndex);
                methodInvocation.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                methodInvocation.parent = this.activeNode;
                this.runtimeNodes.push(methodInvocation);
                this.lastNode = methodInvocation;
                this.currentIndex += 1;
                continue;
              }
              const subtractionOperator = new SubtractionOperator();
              subtractionOperator.isVirtual = false;
              subtractionOperator.content = "-";
              subtractionOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              subtractionOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              subtractionOperator.parent = this.activeNode;
              this.runtimeNodes.push(subtractionOperator);
              this.lastNode = subtractionOperator;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Asterisk) {
              if (this.next == DocumentParser.Punctuation_Asterisk) {
                const exponentiationOperator = new ExponentiationOperator();
                exponentiationOperator.isVirtual = false;
                exponentiationOperator.content = "**";
                exponentiationOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
                exponentiationOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                exponentiationOperator.parent = this.activeNode;
                this.runtimeNodes.push(exponentiationOperator);
                this.lastNode = exponentiationOperator;
                this.currentIndex += 1;
                continue;
              } else if (this.next == DocumentParser.Punctuation_Equals) {
                const multplicationAssignment = new MultiplicationAssignmentOperator();
                multplicationAssignment.isVirtual = false;
                multplicationAssignment.content = "*=";
                multplicationAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
                multplicationAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                multplicationAssignment.parent = this.activeNode;
                this.runtimeNodes.push(multplicationAssignment);
                this.lastNode = multplicationAssignment;
                this.currentIndex += 1;
                continue;
              }
              const multiplicationOperator = new MultiplicationOperator();
              multiplicationOperator.isVirtual = false;
              multiplicationOperator.content = "*";
              multiplicationOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              multiplicationOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              multiplicationOperator.parent = this.activeNode;
              this.runtimeNodes.push(multiplicationOperator);
              this.lastNode = multiplicationOperator;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_ForwardSlash) {
              if (this.next == DocumentParser.Punctuation_Equals) {
                const divisionAssignment = new DivisionAssignmentOperator();
                divisionAssignment.isVirtual = false;
                divisionAssignment.content = "/=";
                divisionAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
                divisionAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                divisionAssignment.parent = this.activeNode;
                this.runtimeNodes.push(divisionAssignment);
                this.lastNode = divisionAssignment;
                this.currentIndex += 1;
                continue;
              }
              const divisionOperator = new DivisionOperator();
              divisionOperator.isVirtual = false;
              divisionOperator.content = "/";
              divisionOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              divisionOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              divisionOperator.parent = this.activeNode;
              this.runtimeNodes.push(divisionOperator);
              this.lastNode = divisionOperator;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Percent) {
              if (this.next == DocumentParser.Punctuation_Equals) {
                const modulusAssignment = new ModulusAssignmentOperator();
                modulusAssignment.isVirtual = false;
                modulusAssignment.content = "%=";
                modulusAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
                modulusAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                modulusAssignment.parent = this.activeNode;
                this.runtimeNodes.push(modulusAssignment);
                this.lastNode = modulusAssignment;
                this.currentIndex += 1;
                continue;
              }
              const modulusOperator = new ModulusOperator();
              modulusOperator.isVirtual = false;
              modulusOperator.content = "%";
              modulusOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              modulusOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              modulusOperator.parent = this.activeNode;
              this.runtimeNodes.push(modulusOperator);
              this.lastNode = modulusOperator;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_LessThan) {
              if (this.next == DocumentParser.Punctuation_Equals) {
                let peek = null;
                if (this.currentIndex + 2 < this.inputLen) {
                  peek = this.chars[this.currentIndex + 2];
                }
                if (peek == DocumentParser.Punctuation_GreaterThan) {
                  const spaceshipOperator = new SpaceshipCompOperator();
                  spaceshipOperator.isVirtual = false;
                  spaceshipOperator.content = "<=>";
                  spaceshipOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
                  spaceshipOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 3);
                  spaceshipOperator.parent = this.activeNode;
                  this.runtimeNodes.push(spaceshipOperator);
                  this.lastNode = spaceshipOperator;
                  this.currentIndex += 2;
                  continue;
                }
                const lessThanEqual = new LessThanEqualCompOperator();
                lessThanEqual.isVirtual = false;
                lessThanEqual.content = "<=";
                lessThanEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
                lessThanEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                lessThanEqual.parent = this.activeNode;
                this.runtimeNodes.push(lessThanEqual);
                this.lastNode = lessThanEqual;
                this.currentIndex += 1;
                continue;
              }
              const lessThan = new LessThanCompOperator();
              lessThan.isVirtual = false;
              lessThan.content = "<";
              lessThan.startPosition = node._lexerRelativeOffset(this.currentIndex);
              lessThan.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              lessThan.parent = this.activeNode;
              this.runtimeNodes.push(lessThan);
              this.lastNode = lessThan;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_GreaterThan) {
              if (this.next == DocumentParser.Punctuation_Equals) {
                const greaterThanEqual = new GreaterThanCompOperator();
                greaterThanEqual.isVirtual = false;
                greaterThanEqual.content = ">=";
                greaterThanEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
                greaterThanEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                greaterThanEqual.parent = this.activeNode;
                this.runtimeNodes.push(greaterThanEqual);
                this.lastNode = greaterThanEqual;
                this.currentIndex += 1;
                continue;
              }
              const greaterThan = new GreaterThanCompOperator();
              greaterThan.isVirtual = false;
              greaterThan.content = ">";
              greaterThan.startPosition = node._lexerRelativeOffset(this.currentIndex);
              greaterThan.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              greaterThan.parent = this.activeNode;
              this.runtimeNodes.push(greaterThan);
              this.lastNode = greaterThan;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Equals && this.next != DocumentParser.Punctuation_Equals) {
              const leftAssignment = new LeftAssignmentOperator();
              leftAssignment.isVirtual = false;
              leftAssignment.content = "=";
              leftAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
              leftAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              leftAssignment.parent = this.activeNode;
              this.runtimeNodes.push(leftAssignment);
              this.lastNode = leftAssignment;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Equals && this.next == DocumentParser.Punctuation_Equals) {
              let peek = null;
              if (this.currentIndex + 2 < this.inputLen) {
                peek = this.chars[this.currentIndex + 2];
              }
              if (peek == DocumentParser.Punctuation_Equals) {
                const strictEqual = new StrictEqualCompOperator();
                strictEqual.isVirtual = false;
                strictEqual.content = "===";
                strictEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
                strictEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 3);
                strictEqual.parent = this.activeNode;
                this.runtimeNodes.push(strictEqual);
                this.lastNode = strictEqual;
                this.currentIndex += 2;
              } else {
                const equalOperator = new EqualCompOperator();
                equalOperator.isVirtual = false;
                equalOperator.content = "==";
                equalOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
                equalOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                equalOperator.parent = this.activeNode;
                this.runtimeNodes.push(equalOperator);
                this.lastNode = equalOperator;
                this.currentIndex += 1;
              }
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Ampersand) {
              if (this.next == DocumentParser.Punctuation_Ampersand) {
                const logicalAnd2 = new LogicalAndOperator();
                logicalAnd2.isVirtual = false;
                logicalAnd2.content = "&&";
                logicalAnd2.startPosition = node._lexerRelativeOffset(this.currentIndex);
                logicalAnd2.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                logicalAnd2.parent = this.activeNode;
                this.runtimeNodes.push(logicalAnd2);
                this.lastNode = logicalAnd2;
                this.currentIndex += 1;
                continue;
              }
              if (this.next == DocumentParser.Punctuation_Equals) {
                const concatOperator = new StringConcatenationOperator();
                concatOperator.isVirtual = false;
                concatOperator.content = "&=";
                concatOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
                concatOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
                concatOperator.parent = this.activeNode;
                this.runtimeNodes.push(concatOperator);
                this.lastNode = concatOperator;
                continue;
              }
              const logicalAnd = new LogicalAndOperator();
              logicalAnd.isVirtual = false;
              logicalAnd.content = "&";
              logicalAnd.startPosition = node._lexerRelativeOffset(this.currentIndex);
              logicalAnd.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              logicalAnd.parent = this.activeNode;
              this.runtimeNodes.push(logicalAnd);
              this.lastNode = logicalAnd;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Pipe && this.next != DocumentParser.Punctuation_Pipe) {
              const modifierSeparator = new ModifierSeparator();
              modifierSeparator.isVirtual = false;
              modifierSeparator.content = "|";
              modifierSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              modifierSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              modifierSeparator.parent = this.activeNode;
              this.runtimeNodes.push(modifierSeparator);
              this.lastNode = modifierSeparator;
              this.isParsingModifierName = true;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Pipe && this.next == DocumentParser.Punctuation_Pipe) {
              const logicalOr = new LogicalOrOperator();
              logicalOr.isVirtual = false;
              logicalOr.content = "||";
              logicalOr.startPosition = node._lexerRelativeOffset(this.currentIndex);
              logicalOr.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
              logicalOr.parent = this.activeNode;
              this.runtimeNodes.push(logicalOr);
              this.lastNode = logicalOr;
              this.currentIndex += 1;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Exclamation) {
              if (this.next == DocumentParser.Punctuation_Equals) {
                let peek = null;
                if (this.currentIndex + 2 < this.inputLen) {
                  peek = this.chars[this.currentIndex + 2];
                }
                if (peek == DocumentParser.Punctuation_Equals) {
                  const strictNotEqual = new NotStrictEqualCompOperator();
                  strictNotEqual.isVirtual = false;
                  strictNotEqual.content = "!==";
                  strictNotEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
                  strictNotEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 3);
                  strictNotEqual.parent = this.activeNode;
                  this.runtimeNodes.push(strictNotEqual);
                  this.lastNode = strictNotEqual;
                  this.currentIndex += 2;
                  continue;
                }
                const notEqual = new NotEqualCompOperator();
                notEqual.isVirtual = false;
                notEqual.content = "!=";
                notEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
                notEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
                notEqual.parent = this.activeNode;
                this.runtimeNodes.push(notEqual);
                this.lastNode = notEqual;
                this.currentIndex += 1;
                continue;
              }
              const logicalNot = new LogicalNegationOperator();
              logicalNot.isVirtual = false;
              logicalNot.content = "!";
              logicalNot.startPosition = node._lexerRelativeOffset(this.currentIndex);
              logicalNot.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              logicalNot.parent = this.activeNode;
              this.runtimeNodes.push(logicalNot);
              this.lastNode = logicalNot;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_Equals) {
              const conditionalFallback = new ConditionalVariableFallbackOperator();
              conditionalFallback.isVirtual = false;
              conditionalFallback.content = "?=";
              conditionalFallback.startPosition = node._lexerRelativeOffset(this.currentIndex);
              conditionalFallback.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
              conditionalFallback.parent = this.activeNode;
              this.runtimeNodes.push(conditionalFallback);
              this.lastNode = conditionalFallback;
              this.currentIndex += 1;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_Question) {
              const nullCoalesceOperator = new NullCoalesceOperator();
              nullCoalesceOperator.isVirtual = false;
              nullCoalesceOperator.content = "??";
              nullCoalesceOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              nullCoalesceOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
              nullCoalesceOperator.parent = this.activeNode;
              this.runtimeNodes.push(nullCoalesceOperator);
              this.lastNode = nullCoalesceOperator;
              this.currentIndex += 1;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_Colon) {
              const nullCoalesceOperator = new NullCoalesceOperator();
              nullCoalesceOperator.isVirtual = false;
              nullCoalesceOperator.content = "?:";
              nullCoalesceOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              nullCoalesceOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
              nullCoalesceOperator.parent = this.activeNode;
              this.runtimeNodes.push(nullCoalesceOperator);
              this.lastNode = nullCoalesceOperator;
              this.currentIndex += 1;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Question) {
              const ternarySeparator = new InlineTernarySeparator();
              ternarySeparator.isVirtual = false;
              ternarySeparator.content = "?";
              ternarySeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              ternarySeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              ternarySeparator.parent = this.activeNode;
              this.runtimeNodes.push(ternarySeparator);
              this.lastNode = ternarySeparator;
              continue;
            }
            if (this.cur == DocumentParser.LeftParen) {
              const logicalGroupBegin = new LogicGroupBegin();
              logicalGroupBegin.isVirtual = false;
              logicalGroupBegin.content = "(";
              logicalGroupBegin.startPosition = node._lexerRelativeOffset(this.currentIndex);
              logicalGroupBegin.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              logicalGroupBegin.parent = this.activeNode;
              this.runtimeNodes.push(logicalGroupBegin);
              this.lastNode = logicalGroupBegin;
              continue;
            }
            if (this.cur == DocumentParser.RightParent) {
              const logicalGroupEnd = new LogicGroupEnd();
              logicalGroupEnd.isVirtual = false;
              logicalGroupEnd.content = ")";
              logicalGroupEnd.startPosition = node._lexerRelativeOffset(this.currentIndex);
              logicalGroupEnd.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              logicalGroupEnd.parent = this.activeNode;
              this.runtimeNodes.push(logicalGroupEnd);
              this.lastNode = logicalGroupEnd;
              continue;
            }
            if (this.cur == DocumentParser.Punctuation_Colon) {
              if (this.runtimeNodes.length > 0) {
                const lastItem = this.runtimeNodes[this.runtimeNodes.length - 1];
                if (lastItem instanceof ModifierNameNode) {
                  const modifierValueSeparator = new ModifierValueSeparator();
                  modifierValueSeparator.isVirtual = false;
                  modifierValueSeparator.content = ":";
                  modifierValueSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
                  modifierValueSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
                  modifierValueSeparator.parent = this.activeNode;
                  this.runtimeNodes.push(modifierValueSeparator);
                  if (this.isInModifierParameterValue == false) {
                    this.isInModifierParameterValue = true;
                  } else {
                    this.isInModifierParameterValue = false;
                  }
                  continue;
                }
              }
              const branchSeparator = new InlineBranchSeparator();
              branchSeparator.isVirtual = false;
              branchSeparator.content = ":";
              branchSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              branchSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              branchSeparator.parent = this.activeNode;
              this.runtimeNodes.push(branchSeparator);
              this.lastNode = branchSeparator;
              this.isParsingModifierName = false;
              continue;
            }
          }
          if (addCurrent) {
            this.appendContent(this.cur);
          }
        }
        const lastIndex = this.runtimeNodes.length - 1;
        for (let i = 0; i < this.runtimeNodes.length; i++) {
          let prev = null, next = null;
          if (i > 0) {
            prev = this.runtimeNodes[i - 1];
          }
          if (i != lastIndex) {
            next = this.runtimeNodes[i + 1];
          }
          const thisNode = this.runtimeNodes[i];
          thisNode.prev = prev;
          thisNode.next = next;
        }
        return this.runtimeNodes;
      }
    };
  }
});

// server/src/runtime/parser/pathParser.ts
var _PathParser, PathParser;
var init_pathParser = __esm({
  "server/src/runtime/parser/pathParser.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_abstractNode();
    init_stringUtilities();
    init_documentParser();
    _PathParser = class {
      constructor() {
        this.chars = [];
        this.currentIndex = 0;
        this.lastIndex = 0;
        this.inputLength = 0;
        this.prev = null;
        this.cur = null;
        this.next = null;
        this.isParsingString = false;
        this.isStringKeyPath = false;
        this.antlersErrors = [];
        this._recusriveEntryCheck = /* @__PURE__ */ new Map();
      }
      isValidChar(char) {
        if (this.isParsingString == false && StringUtilities.ctypeSpace(char)) {
          return false;
        }
        if (this.isParsingString == false && char == _PathParser.LeftBracket) {
          return false;
        }
        if (this.isParsingString == false && char == _PathParser.RightBracket) {
          return false;
        }
        return true;
      }
      normalizePath(path) {
        path = path.replace(":", "_");
        path = path.replace(".", "_");
        path = path.replace("[", "_");
        path = path.replace("]", "_");
        return path.replace("]", "_");
      }
      getAntlersErrors() {
        return this.antlersErrors;
      }
      mergeErrors(errors) {
        errors.forEach((error) => {
          this.antlersErrors.push(error);
        });
      }
      parse(content) {
        this.antlersErrors = [];
        this._recusriveEntryCheck.clear();
        const originalContent = content;
        let isStrictVariableReference = false, isExplicitVariableReference = false, isVariableVariable = false, isStrictTagReference = false;
        if (content.startsWith(DocumentParser.AtChar)) {
          isVariableVariable = true;
          content = content.substr(1);
        }
        if (content.startsWith(DocumentParser.Punctuation_Percent)) {
          isStrictTagReference = true;
          content = content.substr(1);
        } else {
          if (content.startsWith(DocumentParser.Punctuation_Dollar)) {
            isStrictVariableReference = true;
            content = content.substr(1);
          }
          if (content.startsWith(DocumentParser.Punctuation_Dollar)) {
            isExplicitVariableReference = true;
            content = content.substr(1);
          }
        }
        this.chars = [];
        this.currentIndex = 0;
        this.lastIndex = 0;
        this.inputLength = 0;
        this.cur = null;
        this.prev = null;
        this.next = null;
        this.chars = content.split("");
        this.inputLength = this.chars.length;
        this.lastIndex = this.inputLength - 1;
        let currentChars = [], isParsingAccessor = false;
        const parts = [];
        let activeDelimiter = _PathParser.ColonSeparator, ignorePrevious = false, terminator = null, isStringVar = false, addCur = true;
        this.isParsingString = false;
        if (this.inputLength == 0) {
          const emptyRef = new VariableReference();
          emptyRef._isFromEmptyFailState = true;
          return emptyRef;
        }
        for (this.currentIndex; this.currentIndex < this.inputLength; this.currentIndex += 1) {
          this.cur = this.chars[this.currentIndex];
          this.next = null;
          if (!ignorePrevious) {
            if (this.currentIndex > 0) {
              this.prev = this.chars[this.currentIndex - 1];
            }
          } else {
            ignorePrevious = false;
            this.prev = "";
          }
          if (this.currentIndex + 1 < this.inputLength) {
            this.next = this.chars[this.currentIndex + 1];
          }
          if (this.isParsingString == false && this.cur == _PathParser.ColonSeparator) {
            activeDelimiter = _PathParser.ColonSeparator;
          }
          if (this.isParsingString == false && this.cur == _PathParser.DotPathSeparator) {
            activeDelimiter = _PathParser.DotPathSeparator;
          }
          if (this.isParsingString && this.cur == DocumentParser.String_EscapeCharacter && this.next == terminator) {
            if (terminator != null) {
              currentChars.push(terminator);
            }
            this.currentIndex += 1;
            continue;
          }
          if (this.cur == DocumentParser.String_Terminator_SingleQuote || this.cur == DocumentParser.String_Terminator_DoubleQuote) {
            if (this.isParsingString) {
              if (this.cur == terminator) {
                if (this.prev == DocumentParser.String_EscapeCharacter) {
                  currentChars.push(this.cur);
                  continue;
                } else {
                  this.isParsingString = false;
                  addCur = false;
                }
              } else {
                currentChars.push(this.cur);
                continue;
              }
            } else {
              if (this.prev != null && this.prev != DocumentParser.LeftBracket) {
                if (StringUtilities.ctypeAlpha(this.prev) || StringUtilities.ctypeDigit(this.prev)) {
                  this.antlersErrors.push(AntlersError.makeSyntaxError(
                    AntlersErrorCodes.PATH_STRING_NOT_INSIDE_ARRAY_ACCESSOR,
                    null,
                    "Unexpected string start while parsing variable path. String literals must be within array accessors."
                  ));
                }
              }
              this.isParsingString = true;
              isStringVar = true;
              terminator = this.cur;
              this.isStringKeyPath = true;
              continue;
            }
          }
          if (this.isParsingString) {
            if (StringUtilities.ctypeSpace(this.cur)) {
              currentChars.push(this.cur);
              continue;
            } else if (this.cur == DocumentParser.String_EscapeCharacter) {
              if (this.next == DocumentParser.String_EscapeCharacter) {
                currentChars.push(DocumentParser.String_EscapeCharacter);
                this.currentIndex += 1;
                ignorePrevious = true;
                continue;
              } else if (this.next == "n") {
                currentChars.push("\n");
                this.currentIndex += 1;
                continue;
              } else if (this.next == "t") {
                currentChars.push("	");
                this.currentIndex += 1;
                continue;
              } else if (this.next == "r") {
                currentChars.push("\r");
                this.currentIndex += 1;
                continue;
              }
            }
          }
          if (this.isParsingString == false && this.cur == _PathParser.LeftBracket) {
            if (currentChars.length > 0) {
              const pathNode = new PathNode();
              pathNode.name = currentChars.join("");
              pathNode.delimiter = activeDelimiter;
              parts.push(pathNode);
              currentChars = [];
            }
            if (this.next == null || StringUtilities.ctypeSpace(this.next)) {
              this.antlersErrors.push(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SPACE_RIGHT,
                null,
                "Unexpected end of input or whitespace while parsing variable accessor path."
              ));
              continue;
            }
            const results = this.locateEndOfAccessor();
            this.currentIndex = results.foundOn;
            const parser = new _PathParser();
            parts.push(parser.parse(results.nestedContent));
            this.mergeErrors(parser.getAntlersErrors());
            isParsingAccessor = true;
            if (this.currentIndex == -1) {
              this.antlersErrors.push(AntlersError.makeSyntaxError(
                AntlersErrorCodes.PARSER_CANNOT_PARSE_PATH_RECURSIVE,
                null,
                "Cannot parse variable path."
              ));
              isParsingAccessor = false;
              break;
            }
            continue;
          }
          if (this.isParsingString == false && this.next == _PathParser.RightBracket && isParsingAccessor) {
            if (addCur) {
              currentChars.push(this.cur);
            } else {
              addCur = true;
            }
            const accessorNode = new AccessorNode();
            accessorNode.name = currentChars.join("");
            parts.push(accessorNode);
            currentChars = [];
            activeDelimiter = _PathParser.ColonSeparator;
            this.currentIndex += 1;
            isParsingAccessor = false;
            continue;
          }
          if (this.isParsingString == false && (this.cur == _PathParser.LeftBracket || this.cur == _PathParser.ColonSeparator || this.cur == _PathParser.DotPathSeparator || this.currentIndex == this.lastIndex)) {
            if (this.next == null || StringUtilities.ctypeSpace(this.next)) {
              if (this.cur == _PathParser.ColonSeparator) {
                if (currentChars.length == 0) {
                  this.antlersErrors.push(AntlersError.makeSyntaxError(
                    AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR,
                    null,
                    "Unexpected [T_BRANCH_SEPARATOR] while parsing input text."
                  ));
                  continue;
                }
                this.antlersErrors.push(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_RIGHT,
                  null,
                  'Variable paths cannot end with the ":" character.'
                ));
                continue;
              }
              if (this.cur == _PathParser.LeftBracket) {
                this.antlersErrors.push(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SUBPATH_START,
                  null,
                  "Illegal variable sub-path start."
                ));
                continue;
              }
            }
            if (this.currentIndex == this.lastIndex && this.isValidChar(this.cur)) {
              if (addCur) {
                currentChars.push(this.cur);
              } else {
                addCur = true;
              }
            }
            const pathNode = new PathNode();
            pathNode.delimiter = activeDelimiter;
            pathNode.name = currentChars.join("");
            if (isStringVar) {
              pathNode.isStringVar = isStringVar;
              pathNode.name = originalContent.substr(1);
              pathNode.name = pathNode.name.slice(0, -1);
              isStringVar = false;
            }
            parts.push(pathNode);
            currentChars = [];
            continue;
          } else {
            currentChars.push(this.cur);
            continue;
          }
        }
        const partLen = parts.length;
        if (partLen > 0) {
          const lastPart = parts[partLen - 1];
          if (lastPart instanceof PathNode) {
            lastPart.isFinal = true;
          } else if (lastPart instanceof VariableReference) {
            lastPart.isFinal = true;
          }
        }
        const variableReference = new VariableReference();
        variableReference.isStrictTagReference = isStrictTagReference;
        variableReference.isStrictVariableReference = isStrictVariableReference;
        variableReference.isExplicitVariableReference = isExplicitVariableReference;
        variableReference.pathParts = parts;
        variableReference.originalContent = content;
        variableReference.isVariableVariable = isVariableVariable;
        variableReference.normalizedReference = content.replace(":", ".");
        return variableReference;
      }
      locateEndOfAccessor() {
        const nestedChars = [];
        let bracketCount = 1, foundOn = -1, nestedContent = "", isParsingString = false, terminator = null;
        if (this._recusriveEntryCheck.has(this.currentIndex + 1) == false) {
          this._recusriveEntryCheck.set(this.currentIndex + 1, true);
        } else {
          return {
            foundOn,
            nestedContent: ""
          };
        }
        for (let i = this.currentIndex + 1; i < this.inputLength; i++) {
          const cur = this.chars[i];
          let next = null, prev = null;
          if (i > 0) {
            prev = this.chars[i - 1];
          }
          if (i + 1 < this.inputLength) {
            next = this.chars[i + 1];
          }
          if (isParsingString == false && (cur == DocumentParser.String_Terminator_SingleQuote || cur == DocumentParser.String_Terminator_DoubleQuote)) {
            isParsingString = true;
            terminator = cur;
            nestedChars.push(cur);
            continue;
          }
          if (isParsingString == false && cur == _PathParser.LeftBracket) {
            bracketCount += 1;
            nestedChars.push(cur);
            continue;
          }
          if (isParsingString && cur == terminator && prev != DocumentParser.String_EscapeCharacter) {
            nestedChars.push(cur);
            isParsingString = false;
            terminator = null;
            continue;
          }
          if (isParsingString == false && cur == _PathParser.RightBracket) {
            bracketCount -= 1;
            if (bracketCount == 0) {
              foundOn = i;
              nestedContent = nestedChars.join("");
              break;
            } else {
              nestedChars.push(cur);
              continue;
            }
          } else {
            nestedChars.push(cur);
          }
          if (isParsingString == false && StringUtilities.ctypeSpace(next)) {
            this.antlersErrors.push(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_UNEXPECTED_EOI_VARPATH_ACCESSOR,
              null,
              "Unexpected end of input or whitespace while parsing inner variable accessor path."
            ));
          }
          if (next == null) {
            this.antlersErrors.push(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_UNEXPECTED_EOI_VARPATH_ACCESSOR,
              null,
              "Unexpected end of input or whitespace while parsing inner variable accessor path."
            ));
          }
        }
        return {
          foundOn,
          nestedContent
        };
      }
    };
    PathParser = _PathParser;
    PathParser.ColonSeparator = ":";
    PathParser.LeftBracket = "[";
    PathParser.RightBracket = "]";
    PathParser.DotPathSeparator = ".";
  }
});

// server/src/runtime/parser/antlersNodeParser.ts
var AntlersNodeParser;
var init_antlersNodeParser = __esm({
  "server/src/runtime/parser/antlersNodeParser.ts"() {
    "use strict";
    init_conditionPairAnalyzer();
    init_nodeTypeAnalyzer();
    init_tagIdentifierAnalyzer();
    init_antlersError();
    init_antlersErrorCodes();
    init_antlersLexer();
    init_abstractNode();
    init_tagIdentifier();
    init_stringUtilities();
    init_documentParser();
    init_pathParser();
    AntlersNodeParser = class {
      constructor() {
        this.chars = [];
        this.inputLen = 0;
        this.currentIndex = 0;
        this.cur = null;
        this.prev = null;
        this.pathParser = new PathParser();
        this.lexer = new AntlersLexer();
        this.activeNode = null;
      }
      reset() {
        this.chars = [];
        this.inputLen = 0;
        this.currentIndex = 0;
        this.cur = null;
        this.prev = null;
      }
      canBeClosingTag(node) {
        var _a;
        const name = (_a = node.name) == null ? void 0 : _a.name;
        if (name == "elseif" || name == "else") {
          return true;
        }
        if (node.name == null) {
          return false;
        }
        return node.name.content.startsWith("/");
      }
      parseNode(node) {
        var _a, _b, _c, _d;
        this.activeNode = node;
        this.reset();
        if (node.content.startsWith("*subrecursive")) {
          let nodeContent = node.content;
          nodeContent = nodeContent.trim();
          nodeContent = StringUtilities.trimRight(nodeContent, "*");
          nodeContent = nodeContent.substr(13);
          const recursiveNode = new RecursiveNode();
          node.copyBasicDetailsTo(recursiveNode);
          recursiveNode.originalNode = node;
          recursiveNode.name = new TagIdentifier();
          recursiveNode.name.name = nodeContent;
          recursiveNode.isNestedRecursive = true;
          if (!nodeContent.trim().startsWith("[")) {
            recursiveNode.pathReference = this.pathParser.parse(nodeContent);
          }
          recursiveNode.mergeErrors(this.pathParser.getAntlersErrors());
          recursiveNode.content = nodeContent;
          recursiveNode.runtimeContent = nodeContent;
          return recursiveNode;
        }
        if (node.content.trim().startsWith("*recursive")) {
          let nodeContent = node.content;
          nodeContent = nodeContent.trim();
          nodeContent = StringUtilities.trimRight(nodeContent, "*");
          nodeContent = nodeContent.substr(10).trim();
          const recursiveNode = new RecursiveNode();
          node.copyBasicDetailsTo(recursiveNode);
          recursiveNode.originalNode = node;
          recursiveNode.name = new TagIdentifier();
          recursiveNode.name.name = nodeContent;
          recursiveNode.pathReference = this.pathParser.parse(nodeContent);
          recursiveNode.mergeErrors(this.pathParser.getAntlersErrors());
          recursiveNode.content = nodeContent;
          recursiveNode.runtimeContent = nodeContent;
          return recursiveNode;
        }
        this.chars = node.content.split("");
        this.inputLen = this.chars.length;
        const nameContent = [];
        let hasFoundName = false, name = "", isParsingString = false, terminator = null;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.cur = this.chars[this.currentIndex];
          if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
          }
          if (hasFoundName == false) {
            if (isParsingString == false && (this.cur == DocumentParser.String_Terminator_DoubleQuote || this.cur == DocumentParser.String_Terminator_SingleQuote)) {
              terminator = this.cur;
              isParsingString = true;
              nameContent.push(this.cur);
              continue;
            }
            if (isParsingString && StringUtilities.ctypeSpace(this.cur)) {
              nameContent.push(this.cur);
              continue;
            }
            if (isParsingString && this.cur == terminator && this.prev != DocumentParser.String_EscapeCharacter) {
              terminator = null;
              isParsingString = false;
              nameContent.push(this.cur);
              continue;
            }
            if (StringUtilities.ctypeSpace(this.cur) || this.currentIndex == this.inputLen - 1 || this.cur == DocumentParser.Punctuation_Pipe) {
              if (nameContent.length == 0) {
                continue;
              } else {
                if (!StringUtilities.ctypeSpace(this.cur)) {
                  if (this.cur != DocumentParser.Punctuation_Pipe) {
                    nameContent.push(this.cur);
                  }
                }
                name = nameContent.join("");
                hasFoundName = true;
                break;
              }
            }
            nameContent.push(this.cur);
          }
        }
        const tagNameStartsAt = node.getContentRelativeStartIndex();
        node.nameStartsOn = node.relativeOffset(tagNameStartsAt, tagNameStartsAt);
        if (node.nameStartsOn != null) {
          node.nameEndsOn = node.nameStartsOn.shiftRight(name.length - 1);
          if (name.includes(DocumentParser.Punctuation_Colon)) {
            const separatorOffset = name.indexOf(DocumentParser.Punctuation_Colon);
            node.nameMethodPartStartsOn = node.nameStartsOn.shiftRight(separatorOffset + 1);
          }
        }
        node.name = TagIdentifierAnalyzer.getIdentifier(name);
        nodeTypeAnalyzer_default.analyzeNode(node);
        node.parameters = this.getParameters(node);
        node.hasParameters = node.parameters.length > 0;
        if (node.hasParameters) {
          nodeTypeAnalyzer_default.analyzeParametersForModifiers(node);
          node.resetContentCache();
        }
        node.pathReference = this.pathParser.parse(name);
        node.mergeErrors(this.pathParser.getAntlersErrors());
        if (node.pathReference != null) {
          if (node.pathReference.isStrictTagReference) {
            node.name.name = node.name.name.substr(1);
            node.name.content = node.name.content.substr(1);
          }
        }
        node.isClosingTag = this.canBeClosingTag(node);
        let runtimeNodes = [];
        if (node.isClosingTag == false) {
          runtimeNodes = this.lexer.tokenize(node, node.getContent());
        }
        node.runtimeNodes = runtimeNodes;
        const trimmedInner = node.content.trim();
        if (ConditionPairAnalyzer.isConditionalStructure(node) && node.name.name != "else" && runtimeNodes.length == 0 && trimmedInner != "/if" && trimmedInner != "/unless" && trimmedInner != "/endunless" && trimmedInner != "endif" && trimmedInner != "endunless" && trimmedInner != "/endif") {
          const nodeContent = node.getContent().trim();
          if (nodeContent.length == 0) {
            this.pushConditionWithoutExpression(node);
          }
        }
        if (node.name.name == "endif") {
          const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
          if (nodeParser != null) {
            replacedNode.withParser(nodeParser);
          }
          replacedNode.name = new TagIdentifier();
          replacedNode.name.name = "if";
          replacedNode.name.compound = "if";
          replacedNode.isClosingTag = true;
          replacedNode.content = " /if ";
          replacedNode.originalNode = node;
          return replacedNode;
        }
        if (node.name.name == "unless") {
          const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
          if (nodeParser != null) {
            replacedNode.withParser(nodeParser);
          }
          replacedNode.name = new TagIdentifier();
          replacedNode.name.name = "if";
          replacedNode.name.compound = "if";
          if (node.isClosingTag == false) {
            const originalContent = (_a = node.getContent()) != null ? _a : "", unlessContent = " if !(" + originalContent + ") ";
            replacedNode.content = unlessContent;
            replacedNode.originalNode = node;
            replacedNode.resetContentCache();
            replacedNode.runtimeNodes = this.lexer.tokenize(replacedNode, (_b = replacedNode.getContent()) != null ? _b : "");
            this.testUnlessContent(replacedNode);
          } else {
            replacedNode.originalNode = node;
            replacedNode.content = " /if ";
          }
          return replacedNode;
        } else if (node.name.name == "elseunless") {
          const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
          if (nodeParser != null) {
            replacedNode.withParser(nodeParser);
          }
          replacedNode.name = new TagIdentifier();
          replacedNode.name.name = "elseif";
          replacedNode.name.compound = "elseif";
          const originalContent = (_c = node.getContent()) != null ? _c : "", unlessContent = " elseif !(" + originalContent + ") ";
          replacedNode.content = unlessContent;
          replacedNode.originalNode = node;
          replacedNode.resetContentCache();
          replacedNode.runtimeNodes = this.lexer.tokenize(replacedNode, (_d = replacedNode.getContent()) != null ? _d : "");
          this.testUnlessContent(replacedNode);
          return replacedNode;
        } else if (node.name.name == "endunless") {
          const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
          if (nodeParser != null) {
            replacedNode.withParser(nodeParser);
          }
          replacedNode.name = new TagIdentifier();
          replacedNode.name.name = "if";
          replacedNode.name.compound = "if";
          replacedNode.isClosingTag = true;
          replacedNode.content = " /if ";
          replacedNode.originalNode = node;
          return replacedNode;
        }
        return node;
      }
      pushError(error) {
        if (this.activeNode != null) {
          this.activeNode.pushError(error);
        }
      }
      testUnlessContent(node) {
        var _a;
        let testContent = (_a = node.getContent()) != null ? _a : "";
        testContent = testContent.replace("!", "");
        testContent = testContent.replace("(", "");
        testContent = testContent.replace(")", "").trim();
        if (testContent.length == 0) {
          this.pushConditionWithoutExpression(node);
          return;
        }
      }
      pushConditionWithoutExpression(node) {
        this.pushError(AntlersError.makeSyntaxError(
          AntlersErrorCodes.TYPE_PARSE_EMPTY_CONDITIONAL,
          node,
          "Condition structure lacks comparison expression."
        ));
      }
      getParameters(node) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const content = (_a = node.getContent()) != null ? _a : "", chars = content.split(""), improperStringCandidates = [], parameters = [], charCount = chars.length;
        let parseContentOffset = 0;
        if (node.name != null) {
          const trimmedName = StringUtilities.trimLeft(node.content, " "), leadOffset = node.content.length - trimmedName.length, nameLength = node.name.content.length;
          if (leadOffset > 0) {
            parseContentOffset = leadOffset + nameLength;
          } else {
            parseContentOffset = nameLength;
          }
        }
        let hasFoundName = false, currentChars = [], name = "", nameStart = 0, startAt = 0, ignorePrevious = false, terminator = null, blockStartAt = -1, blockEndAt = -1, nameBlockStartAt = -1, nameBlockEndAt = -1, valueBlockStartAt = -1, valueBlockEndAt = -1, nameDelimiter = null;
        for (let i = 0; i < charCount; i++) {
          const current = chars[i];
          let prev = null, next = null;
          if (i + 1 < charCount) {
            next = chars[i + 1];
          }
          if (!ignorePrevious) {
            if (i > 0) {
              prev = chars[i - 1];
            }
          } else {
            prev = "";
            ignorePrevious = false;
          }
          if (hasFoundName == false && StringUtilities.ctypeSpace(current)) {
            currentChars = [];
            blockStartAt = -1;
            blockEndAt = -1;
            nameBlockStartAt = -1;
            nameBlockEndAt = -1;
            valueBlockStartAt = -1;
            valueBlockEndAt = -1;
            continue;
          }
          if (hasFoundName == false && current == DocumentParser.Punctuation_Equals) {
            if (currentChars.length > 0) {
              if ((StringUtilities.ctypeAlpha(currentChars[0]) || StringUtilities.ctypeDigit(currentChars[0]) || currentChars[0] == DocumentParser.Punctuation_Colon || currentChars[0] == DocumentParser.AtChar) == false) {
                currentChars = [];
                continue;
              }
            }
            if (i + 1 >= charCount) {
              this.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT,
                node,
                "Unexpected end of input"
              ));
              continue;
            }
            let peek = null;
            if (i + 1 < charCount) {
              peek = chars[i + 1];
            }
            if (prev == DocumentParser.Punctuation_Equals) {
              currentChars = [];
              blockStartAt = -1;
              blockEndAt = -1;
              nameBlockStartAt = -1;
              nameBlockEndAt = -1;
              valueBlockStartAt = -1;
              valueBlockEndAt = -1;
              continue;
            }
            if (StringUtilities.ctypeSpace(peek) || peek == DocumentParser.Punctuation_Equals) {
              currentChars = [];
              blockStartAt = -1;
              blockEndAt = -1;
              nameBlockStartAt = -1;
              nameBlockEndAt = -1;
              valueBlockStartAt = -1;
              valueBlockEndAt = -1;
              continue;
            }
            if (currentChars.length > 0) {
              nameBlockEndAt = i;
              valueBlockStartAt = i;
              name = currentChars.join("");
              nameStart = startAt;
              hasFoundName = true;
              currentChars = [];
            }
            if (next == DocumentParser.String_Terminator_DoubleQuote) {
              terminator = DocumentParser.String_Terminator_DoubleQuote;
              nameDelimiter = DocumentParser.String_Terminator_DoubleQuote;
              i += 1;
            }
            if (next == DocumentParser.String_Terminator_SingleQuote) {
              terminator = DocumentParser.String_Terminator_SingleQuote;
              nameDelimiter = DocumentParser.String_Terminator_SingleQuote;
              i += 1;
            }
            continue;
          }
          if (hasFoundName && current == DocumentParser.String_EscapeCharacter) {
            let peek = null;
            if (i + 1 < charCount) {
              peek = chars[i + 1];
            }
            if (peek == DocumentParser.String_EscapeCharacter) {
              currentChars.push(DocumentParser.String_EscapeCharacter);
              i += 1;
              ignorePrevious = true;
              continue;
            }
            if (peek == DocumentParser.String_Terminator_DoubleQuote) {
              currentChars.push(DocumentParser.String_Terminator_DoubleQuote);
              i += 1;
              continue;
            }
            if (peek == DocumentParser.String_Terminator_SingleQuote) {
              currentChars.push(DocumentParser.String_Terminator_SingleQuote);
              i += 1;
              continue;
            }
            if (peek == "n") {
              currentChars.push("\n");
              i += 1;
              continue;
            }
            if (peek == "r") {
              currentChars.push("\r");
              i += 1;
              continue;
            }
          }
          if (hasFoundName == false && (terminator != null && current == terminator || terminator == null && StringUtilities.ctypeSpace(current))) {
            improperStringCandidates.push(currentChars.join(""));
          }
          if (hasFoundName && (terminator != null && current == terminator || terminator == null && StringUtilities.ctypeSpace(current))) {
            const content2 = currentChars.join("");
            valueBlockEndAt = i;
            blockEndAt = i;
            hasFoundName = false;
            terminator = null;
            currentChars = [];
            const parameterNode = new ParameterNode2();
            if (name.startsWith(DocumentParser.Punctuation_Colon)) {
              parameterNode.isVariableReference = true;
              name = name.substr(1);
            }
            parameterNode.nameDelimiter = nameDelimiter;
            parameterNode.name = name;
            parameterNode.value = content2;
            if (parameterNode.nameDelimiter == null) {
              parameterNode.hasValidValueDelimiter = false;
              parameterNode.nameDelimiter = '"';
            }
            parameterNode.startPosition = (_b = node.relativePositionFromOffset(startAt, nameStart)) != null ? _b : null;
            if (i + 1 > charCount) {
              this.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NODE_PARAMETER,
                node,
                "Unexpected end of input while parsing parameter content."
              ));
              parameterNode.parent = node;
              parameters.push(parameterNode);
              name = "";
              continue;
            }
            parameterNode.endPosition = (_c = node.relativePositionFromOffset(i + 1, i + 1)) != null ? _c : null;
            parameterNode.parent = node;
            parameterNode.blockPosition = {
              start: (_d = node.relativeOffset(blockStartAt, blockStartAt)) != null ? _d : null,
              end: (_e = node.relativeOffset(blockEndAt, blockEndAt)) != null ? _e : null
            };
            parameterNode.namePosition = {
              start: (_f = node.relativeOffset(nameBlockStartAt, nameBlockStartAt)) != null ? _f : null,
              end: (_g = node.relativeOffset(nameBlockEndAt, nameBlockEndAt)) != null ? _g : null
            };
            parameterNode.valuePosition = {
              start: (_h = node.relativeOffset(valueBlockStartAt + 2, valueBlockStartAt + 2)) != null ? _h : null,
              end: (_i = node.relativeOffset(valueBlockEndAt, valueBlockEndAt)) != null ? _i : null
            };
            parameters.push(parameterNode);
            name = "";
            blockStartAt = -1;
            blockEndAt = -1;
            nameBlockStartAt = -1;
            nameBlockEndAt = -1;
            valueBlockStartAt = -1;
            valueBlockEndAt = -1;
            continue;
          }
          if (hasFoundName == false && (current == DocumentParser.String_Terminator_DoubleQuote || current == DocumentParser.String_Terminator_SingleQuote)) {
            if (i > parseContentOffset) {
              break;
            }
          }
          currentChars.push(current);
          if (blockStartAt == -1) {
            blockStartAt = i;
          }
          if (nameBlockStartAt == -1) {
            nameBlockStartAt = i;
          }
          if (currentChars.length == 1) {
            startAt = i + 1;
          }
        }
        if (terminator != null) {
          let nodeToUse = node;
          if (improperStringCandidates.length > 0) {
            const lastCandidate = improperStringCandidates[improperStringCandidates.length - 1], relativeIndex = node.content.indexOf(lastCandidate);
            if (relativeIndex >= 0) {
              const fakeNode = new AbstractNode5();
              fakeNode.startPosition = node.relativeOffset(relativeIndex - 2, relativeIndex - 2);
              fakeNode.endPosition = node.relativeOffset(relativeIndex + lastCandidate.length, relativeIndex + lastCandidate.length);
              nodeToUse = fakeNode;
            }
          }
          this.pushError(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT,
            nodeToUse,
            "Unexpected string literal while parsing parameters."
          ));
        }
        return parameters;
      }
    };
  }
});

// server/src/runtime/nodes/helpers.ts
function getStartPosition(nodes) {
  if (nodes.length == 0) {
    return null;
  }
  return nodes[0].startPosition;
}
var init_helpers = __esm({
  "server/src/runtime/nodes/helpers.ts"() {
    "use strict";
  }
});

// server/src/runtime/runtime/noParseManager.ts
var import_md5, NoParseManager;
var init_noParseManager = __esm({
  "server/src/runtime/runtime/noParseManager.ts"() {
    "use strict";
    import_md5 = __toESM(require_md5());
    NoParseManager = class {
      static regions() {
        return this.noParseRegions;
      }
      static clear() {
        this.noParseRegions.clear();
      }
      static registerNoParseContent(content) {
        const hash = import_md5.Md5.hashStr(content);
        this.noParseRegions.set(hash, content);
        return hash;
      }
    };
    NoParseManager.noParseRegions = /* @__PURE__ */ new Map();
  }
});

// server/src/runtime/utilities/arrayHelpers.ts
function intersect(a, b) {
  const setA = new Set(a), setB = new Set(b), intersection = new Set([...setA].filter((x) => setB.has(x)));
  return Array.from(intersection);
}
var init_arrayHelpers = __esm({
  "server/src/runtime/utilities/arrayHelpers.ts"() {
    "use strict";
  }
});

// server/src/runtime/analyzers/tagPairAnalyzer.ts
var _TagPairAnalyzer, TagPairAnalyzer;
var init_tagPairAnalyzer = __esm({
  "server/src/runtime/analyzers/tagPairAnalyzer.ts"() {
    "use strict";
    init_antlersDocument();
    init_antlersError();
    init_antlersErrorCodes();
    init_abstractNode();
    init_helpers();
    init_tagIdentifier();
    init_noParseManager();
    init_arrayHelpers();
    init_conditionPairAnalyzer();
    _TagPairAnalyzer = class {
      constructor() {
        this.closingTagIndex = /* @__PURE__ */ new Map();
        this.closingTagIndexCount = /* @__PURE__ */ new Map();
        this.openTagIndexCount = /* @__PURE__ */ new Map();
        this.closingTagNames = /* @__PURE__ */ new Map();
        this.parentNode = null;
        this.stackCount = 0;
        this.createdExecutionBranches = [];
        this.document = null;
      }
      getClosingCandidates(node) {
        var _a, _b;
        if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosingTag == false) {
          const compound = (_b = (_a = node.name) == null ? void 0 : _a.compound) != null ? _b : "";
          if (compound == "if") {
            return ["if", "elseif", "else"];
          } else if (compound == "elseif") {
            return ["elseif", "else", "if"];
          } else if (compound == "else") {
            return ["if"];
          }
          return [compound];
        }
        return [];
      }
      buildCloseIndex(nodes) {
        var _a, _b, _c;
        nodes.forEach((node) => {
          var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j;
          if (node instanceof RecursiveNode) {
            return;
          }
          if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isSelfClosing) {
            return;
          }
          if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosingTag) {
            if (this.closingTagIndex.has(this.stackCount) == false) {
              this.closingTagIndex.set(this.stackCount, /* @__PURE__ */ new Map());
            }
            if (this.closingTagIndexCount.has(this.stackCount) == false) {
              this.closingTagIndexCount.set(this.stackCount, /* @__PURE__ */ new Map());
            }
            const compound = (_b2 = (_a2 = node.name) == null ? void 0 : _a2.compound) != null ? _b2 : "";
            if (((_c2 = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _c2.has(compound)) == false) {
              (_d = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _d.set(compound, []);
              (_e = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _e.set(compound, 0);
            }
            (_g = (_f = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _f.get(compound)) == null ? void 0 : _g.push(node);
            const curCount = (_i = (_h = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _h.get(compound)) != null ? _i : 0;
            (_j = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _j.set(compound, curCount + 1);
          }
        });
        if (this.closingTagNames.has(this.stackCount) == false) {
          this.closingTagNames.set(this.stackCount, []);
        }
        if (this.closingTagIndex.has(this.stackCount)) {
          this.closingTagNames.set(this.stackCount, Array.from((_b = (_a = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _a.keys()) != null ? _b : []));
          (_c = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _c.forEach((indexedNodes, tagName) => {
            var _a2, _b2, _c2, _d, _e, _f, _g;
            const indexedNodeCount = indexedNodes.length;
            if (indexedNodeCount == 0) {
              return;
            }
            const lastIndexedNode = indexedNodes[indexedNodeCount - 1];
            for (let i = 0; i < indexedNodeCount; i++) {
              const node = nodes[i];
              if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
                if (node instanceof RecursiveNode) {
                  continue;
                }
                if (node.index >= lastIndexedNode.index) {
                  break;
                }
                const compound = (_b2 = (_a2 = node.name) == null ? void 0 : _a2.compound) != null ? _b2 : "";
                if (node.isClosingTag == false && tagName == compound && !node.isSelfClosing) {
                  if (this.openTagIndexCount.has(this.stackCount) == false) {
                    this.openTagIndexCount.set(this.stackCount, /* @__PURE__ */ new Map());
                  }
                  if (((_c2 = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _c2.has(tagName)) == false) {
                    (_d = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _d.set(tagName, 0);
                  }
                  const curCount = (_f = (_e = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _e.get(tagName)) != null ? _f : 0;
                  (_g = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _g.set(tagName, curCount + 1);
                }
              }
            }
          });
        }
      }
      getScanForList(node) {
        var _a;
        if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
          const compound = (_a = node.name) == null ? void 0 : _a.compound;
          if (compound == "else") {
            return ["if"];
          }
          if (compound == "elseif") {
            return ["elseif", "else", "if"];
          }
          if (node.isClosingTag == false) {
            const candidates = this.getClosingCandidates(node), indexValues = this.closingTagNames.get(this.stackCount);
            return intersect(candidates, indexValues);
          }
        }
        return [];
      }
      canPossiblyClose(node) {
        var _a, _b;
        if (node instanceof RecursiveNode) {
          return false;
        }
        if (node instanceof AntlersParserFailNode || node instanceof AntlersNode) {
          if (node.isComment) {
            return false;
          }
          if (node.isSelfClosing) {
            return false;
          }
          const compound = (_b = (_a = node.name) == null ? void 0 : _a.compound) != null ? _b : "";
          if (compound == "else" || compound == "elseif") {
            return true;
          }
          if (node.isClosingTag == false) {
            const candidates = this.getClosingCandidates(node), indexValues = this.closingTagNames.get(this.stackCount), overlap = intersect(candidates, indexValues);
            return overlap.length > 0;
          }
        }
        return false;
      }
      findClosingPair(nodes, node, scanFor) {
        var _a, _b, _c, _d;
        const refRuntimeNodeCount = node.runtimeNodes.length, nodeLength = nodes.length;
        let refStack = 0;
        for (let i = 0; i < nodeLength; i++) {
          const candidateNode = nodes[i];
          if (candidateNode instanceof AntlersNode || candidateNode instanceof AntlersParserFailNode) {
            if (node.endPosition != null && candidateNode.startPosition != null) {
              if (node.endPosition.isBefore(candidateNode.startPosition)) {
                if (candidateNode.isClosingTag && candidateNode.isOpenedBy != null) {
                  continue;
                }
                if (candidateNode.isSelfClosing) {
                  continue;
                }
                const compound = (_b = (_a = candidateNode.name) == null ? void 0 : _a.compound) != null ? _b : "";
                if (candidateNode.isClosingTag == false) {
                  if (scanFor.includes(compound)) {
                    const refOpen = (_c = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _c.get(compound), refClose = (_d = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _d.get(compound);
                    if (refOpen != refClose) {
                      if (candidateNode.runtimeNodes.length >= refRuntimeNodeCount) {
                      }
                    }
                    refStack += 1;
                  }
                  continue;
                }
                if (scanFor.includes(compound)) {
                  if (refStack > 0) {
                    refStack -= 1;
                    continue;
                  }
                }
                if (refStack == 0 && scanFor.includes(compound)) {
                  candidateNode.isOpenedBy = node;
                  node.isClosedBy = candidateNode;
                  break;
                }
              }
            } else {
              continue;
            }
          }
        }
      }
      associate(documentNodes, document) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.document = document;
        const nodeStack = [{
          documentNodes,
          parent: null
        }];
        let nodesToReturn = [];
        while (nodeStack.length > 0) {
          const details = nodeStack.pop();
          if (details == null) {
            continue;
          }
          let nodes = details.documentNodes;
          this.parentNode = details.parent;
          this.stackCount += 1;
          this.buildCloseIndex(nodes);
          nodes = ConditionPairAnalyzer.pairConditionals(nodes);
          nodes.forEach((node) => {
            if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && this.canPossiblyClose(node)) {
              if (ConditionPairAnalyzer.isConditionalStructure(node)) {
                return;
              }
              const scanFor = this.getScanForList(node);
              this.findClosingPair(nodes, node, scanFor);
            }
          });
          const nodeCount = nodes.length;
          for (let i = 0; i < nodeCount; i++) {
            const node = nodes[i];
            if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosedBy != null) {
              for (let j = i + 1; j < nodeCount; j++) {
                const childNode = nodes[j];
                if (childNode.index > node.isClosedBy.index) {
                  break;
                }
                childNode.parent = node;
                node.children.push(childNode);
                if (childNode instanceof AntlersNode && childNode.index == node.index) {
                  childNode.parent = node;
                  break;
                }
              }
            }
          }
          nodes.forEach((node) => {
            if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.children.length > 0) {
              const newChildren = [];
              node.children.forEach((childNode) => {
                if (childNode.parent != null) {
                  if (childNode.parent.index == node.index) {
                    childNode.parent = node;
                    newChildren.push(childNode);
                  }
                }
              });
              nodeStack.push({
                documentNodes: newChildren,
                parent: node
              });
            }
          });
          let nestedNodes = [];
          nodes.forEach((node) => {
            if (this.parentNode == null) {
              if (node.parent == null) {
                nestedNodes.push(node);
              }
            } else {
              if (node.parent == this.parentNode) {
                nestedNodes.push(node);
              }
            }
          });
          nestedNodes = this.reduceConditionals(nestedNodes, document);
          const nestedNodeKeyMap = /* @__PURE__ */ new Map();
          nodes.forEach((node) => {
            var _a2, _b2, _c2, _d2;
            if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosedBy != null) {
              if (this.document != null) {
                const content = this.document.getText(
                  ((_b2 = (_a2 = node.endPosition) == null ? void 0 : _a2.index) != null ? _b2 : 0) + 1,
                  (_d2 = (_c2 = node.isClosedBy.startPosition) == null ? void 0 : _c2.index) != null ? _d2 : 0
                );
                node.runtimeContent = content;
              }
            }
          });
          for (let i = 0; i < nestedNodes.length; i++) {
            const node = nestedNodes[i], refId = (_a = node.refId) != null ? _a : "";
            nestedNodeKeyMap.set(refId, 1);
            if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isComment == false && ((_b = node.name) == null ? void 0 : _b.name) == "noparse" && node instanceof EscapedContentNode == false && node.isClosingTag == false) {
              if (node.isClosedBy == null) {
                node.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_NO_PARSE_UNASSOCIATED,
                  node,
                  "Encountered noparse region without a closing tag. All noparse regions must be closed."
                ));
                continue;
              }
              let content = node.content;
              if (this.document != null) {
                content = this.document.getText(
                  ((_d = (_c = node.endPosition) == null ? void 0 : _c.index) != null ? _d : 0) + 1,
                  (_g = (_f = (_e = node.isClosedBy) == null ? void 0 : _e.startPosition) == null ? void 0 : _f.index) != null ? _g : 0
                );
              }
              const noParseNode = new EscapedContentNode(), nodeParser = node.getParser();
              if (nodeParser != null) {
                noParseNode.withParser(nodeParser);
              }
              node.copyBasicDetailsTo(noParseNode);
              noParseNode.name = new TagIdentifier();
              noParseNode.name.name = "noparse";
              noParseNode.name.compound = "noparse";
              noParseNode.content = NoParseManager.registerNoParseContent(content);
              noParseNode.originalNode = node;
              noParseNode.isClosedBy = node.isClosedBy;
              noParseNode.parent = node.parent;
              nestedNodes[i] = noParseNode;
            }
          }
          if (this.parentNode != null && (this.parentNode instanceof AntlersParserFailNode || this.parentNode instanceof AntlersNode)) {
            this.parentNode.children = this.cleanNodes(nestedNodes);
            if (this.parentNode.parent != null && this.parentNode.parent instanceof AntlersNode) {
              const ancestorNodes = this.parentNode.parent.children, newAncestorNodes = [];
              ancestorNodes.forEach((aNode) => {
                var _a2;
                if (nestedNodeKeyMap.has((_a2 = aNode.refId) != null ? _a2 : "") == false) {
                  newAncestorNodes.push(aNode);
                }
              });
              this.parentNode.parent.children = this.cleanNodes(newAncestorNodes);
            }
          }
          if (this.stackCount <= 1) {
            nodesToReturn = nestedNodes;
          }
        }
        if (this.createdExecutionBranches.length > 0) {
          this.createdExecutionBranches.forEach((branch) => {
            if (branch.head != null) {
              branch.nodes = branch.head.children;
            }
          });
        }
        return nodesToReturn;
      }
      cleanNodes(nodes) {
        const cleaned = [], ids = [];
        for (let i = 0; i < nodes.length; i++) {
          const child = nodes[i], refId = child.refId;
          if (ids.includes(refId)) {
            break;
          }
          cleaned.push(child);
          ids.push(refId);
        }
        return cleaned;
      }
      findEndOfBranch(nodes, start, startedAt) {
        const children = [], offset = startedAt;
        let tail = null;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isOpenedBy != null && node.isOpenedBy == start) {
            tail = node;
            break;
          } else {
            children.push(node);
          }
        }
        return {
          children,
          tail,
          offset
        };
      }
      reduceConditionals(nodes, document) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        const reduced = [];
        for (let i = 0; i < nodes.length; i++) {
          let node = nodes[i];
          if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isComment == false && node.isClosingTag == false && node.isClosedBy != null) {
            const compound = (_b = (_a = node.name) == null ? void 0 : _a.compound) != null ? _b : "";
            if (compound == "if") {
              const conditionNode = new ConditionNode();
              conditionNode.index = node.index;
              conditionNode.chain.push(node.index);
              conditionNode.fragment = node.fragment;
              conditionNode.fragmentPosition = node.fragmentPosition;
              conditionNode.containsAnyFragments = node.containsAnyFragments;
              conditionNode.containsChildStructures = node.containsChildStructures;
              const conditionStart = (_d = (_c = node.startPosition) == null ? void 0 : _c.offset) != null ? _d : 0, finalClosing = node.getFinalClosingTag(), conditionEnd = ((_f = (_e = finalClosing.endPosition) == null ? void 0 : _e.offset) != null ? _f : 0) + 1;
              conditionNode.nodeContent = document.getText(conditionStart, conditionEnd);
              if (this.parentNode != null) {
                conditionNode.parent = this.parentNode;
              }
              let exitedOn = null, doContinue = true, currentDepth = 0;
              while (doContinue) {
                currentDepth += 1;
                if (currentDepth > _TagPairAnalyzer.ForceBreakLimit) {
                  doContinue = false;
                  break;
                }
                if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
                  const result = this.findEndOfBranch(nodes.slice(i + 1), node, i), executionBranch = new ExecutionBranch();
                  let tail = result.tail;
                  executionBranch.head = node;
                  executionBranch.tail = tail;
                  executionBranch.nodes = this.cleanNodes(node.children);
                  const branchStart = ((_h = (_g = node.endPosition) == null ? void 0 : _g.offset) != null ? _h : 0) + 1, branchEnd = (_k = (_j = (_i = node.isClosedBy) == null ? void 0 : _i.startPosition) == null ? void 0 : _j.offset) != null ? _k : 0, documentText = document.getText(branchStart, branchEnd);
                  executionBranch.documentText = documentText;
                  if (document.shouldParseChildDocument()) {
                    executionBranch.childDocument = AntlersDocument.childFromText(executionBranch.documentText, getStartPosition(executionBranch.nodes));
                  }
                  if (tail == null) {
                    tail = executionBranch.head.isClosedBy;
                  }
                  if (tail != null && tail.startPosition != null) {
                    executionBranch.startPosition = tail.startPosition;
                  }
                  if (tail != null) {
                    executionBranch.index = tail.index;
                  }
                  if (executionBranch.nodes.length > 0) {
                    const lastNode = executionBranch.nodes[executionBranch.nodes.length - 1];
                    if (lastNode.endPosition != null) {
                      executionBranch.endPosition = lastNode.endPosition;
                    }
                  } else {
                    if (tail != null && tail.endPosition != null) {
                      executionBranch.endPosition = tail.endPosition;
                    }
                  }
                  this.createdExecutionBranches.push(executionBranch);
                  conditionNode.logicBranches.push(executionBranch);
                  if ((tail == null ? void 0 : tail.isClosingTag) && ((_l = tail.name) == null ? void 0 : _l.compound) == "if") {
                    exitedOn = result.offset;
                    doContinue = false;
                    break;
                  } else {
                    if (tail != null) {
                      conditionNode.chain.push(tail.index);
                    }
                    i = result.offset;
                    if (tail instanceof AntlersNode) {
                      node = tail;
                    }
                  }
                } else {
                  doContinue = false;
                }
              }
              if (conditionNode.logicBranches.length > 0) {
                const firstBranch = conditionNode.logicBranches[0], lastBranch = conditionNode.logicBranches[conditionNode.logicBranches.length - 1];
                if (firstBranch.startPosition != null) {
                  conditionNode.startPosition = firstBranch.startPosition;
                }
                if (lastBranch.endPosition != null) {
                  conditionNode.endPosition = lastBranch.endPosition;
                }
              }
              reduced.push(conditionNode);
              if (exitedOn != null) {
                if (exitedOn == nodes.length) {
                  break;
                }
              }
            } else {
              reduced.push(node);
            }
          } else {
            reduced.push(node);
          }
        }
        return reduced;
      }
    };
    TagPairAnalyzer = _TagPairAnalyzer;
    TagPairAnalyzer.ForceBreakLimit = 1e5;
  }
});

// server/src/runtime/analyzers/recursiveParentAnalyzer.ts
var RecursiveParentAnalyzer;
var init_recursiveParentAnalyzer = __esm({
  "server/src/runtime/analyzers/recursiveParentAnalyzer.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_abstractNode();
    init_stringUtilities();
    RecursiveParentAnalyzer = class {
      static associateRecursiveParent(nodes) {
        var _a, _b;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node instanceof RecursiveNode) {
            const recursiveContent = "*recursive " + ((_a = node.name) == null ? void 0 : _a.name);
            if (i - 1 < 0) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_RECURSIVE_NODE_INVALID_POSITION,
                node,
                "Unpaired recursive node. All recursive nodes must have a parent node introducing them."
              ));
              continue;
            }
            let lastNode = null;
            for (let j = i - 1; j >= 0; j -= 1) {
              const subNode = nodes[j];
              if (subNode instanceof LiteralNode) {
                continue;
              }
              if (subNode instanceof AntlersNode && subNode.isClosedBy != null) {
                if (node.isNestedRecursive) {
                  if (subNode.content.trim() == ((_b = node.name) == null ? void 0 : _b.name)) {
                    lastNode = subNode;
                    break;
                  }
                } else {
                  if (subNode.runtimeContent.includes(recursiveContent) && StringUtilities.substringCount(node.runtimeContent, "*recursive") == 1) {
                    lastNode = subNode;
                    continue;
                  } else {
                    if (lastNode != null) {
                      break;
                    }
                  }
                }
              }
            }
            if (lastNode == null) {
              continue;
            }
            if (node.isNestedRecursive) {
              lastNode.hasRecursiveNode = true;
              node.recursiveParent = lastNode;
              lastNode.recursiveReference = node;
            } else {
              if (lastNode.parent != null) {
                if (lastNode.parent instanceof AntlersNode) {
                  lastNode.parent.hasRecursiveNode = true;
                  lastNode.parent.recursiveReference = node;
                  node.recursiveParent = lastNode.parent;
                }
              } else {
                lastNode.hasRecursiveNode = true;
                node.recursiveParent = lastNode;
                lastNode.recursiveReference = node;
              }
            }
          }
        }
      }
    };
  }
});

// server/src/runtime/errors/lineRetriever.ts
var LineRetriever;
var init_lineRetriever = __esm({
  "server/src/runtime/errors/lineRetriever.ts"() {
    "use strict";
    init_abstractNode();
    LineRetriever = class {
      static getNearText(node) {
        var _a, _b, _c, _d;
        if (node instanceof VariableNode) {
          return node.name;
        } else if (node instanceof NumberNode) {
          return (_b = (_a = node.value) == null ? void 0 : _a.toString()) != null ? _b : "";
        } else if (node instanceof StringValueNode) {
          return node.value;
        } else if (node instanceof ModifierNameNode) {
          return node.name;
        } else if (node instanceof ModifierValueNode) {
          return node.value;
        } else if (node instanceof TupleListStart) {
          return node.content;
        }
        if (node instanceof LogicalXorOperator || node instanceof NullConstant || node instanceof TrueConstant || node instanceof FalseConstant || node instanceof LogicalNegationOperator || node instanceof LanguageOperatorConstruct || node instanceof ArgSeparator || node instanceof StatementSeparatorNode || node instanceof AdditionAssignmentOperator || node instanceof AdditionOperator || node instanceof SubtractionAssignmentOperator || node instanceof SubtractionOperator || node instanceof ExponentiationOperator || node instanceof MultiplicationAssignmentOperator || node instanceof MultiplicationOperator || node instanceof DivisionAssignmentOperator || node instanceof DivisionOperator || node instanceof ModulusAssignmentOperator || node instanceof ModulusOperator || node instanceof SpaceshipCompOperator || node instanceof LessThanEqualCompOperator || node instanceof LessThanCompOperator || node instanceof GreaterThanEqualCompOperator || node instanceof GreaterThanCompOperator || node instanceof LeftAssignmentOperator || node instanceof StrictEqualCompOperator || node instanceof EqualCompOperator || node instanceof LogicalAndOperator || node instanceof ModifierSeparator || node instanceof LogicalOrOperator || node instanceof NotStrictEqualCompOperator || node instanceof NotEqualCompOperator || node instanceof ConditionalVariableFallbackOperator || node instanceof NullCoalesceOperator || node instanceof InlineTernarySeparator || node instanceof LogicGroupBegin || node instanceof LogicGroupEnd || node instanceof ModifierValueSeparator || node instanceof InlineBranchSeparator || node instanceof FactorialOperator || node instanceof ScopeAssignmentOperator || node instanceof StringConcatenationOperator || node instanceof MethodInvocationNode) {
          return node.content;
        }
        let text = "";
        if (node instanceof AntlersNode) {
          if (node.originalNode != null) {
            text = node.originalNode.getContent();
          } else {
            text = (_d = (_c = node.startPosition) == null ? void 0 : _c.line.toString()) != null ? _d : "";
          }
        } else {
          if (node.originalAbstractNode != null) {
            text = node.originalAbstractNode.rawContent();
          } else {
            text = node.rawContent();
          }
        }
        if (text.length > 15) {
          text = text.substr(0, -15);
        }
        return text;
      }
    };
  }
});

// server/src/runtime/runtime/libraries/libraryManager.ts
var LibraryManager;
var init_libraryManager = __esm({
  "server/src/runtime/runtime/libraries/libraryManager.ts"() {
    "use strict";
    LibraryManager = class {
    };
    LibraryManager.deferredCoreLibraries = [
      "arr",
      "array",
      "str",
      "string",
      "method",
      "math",
      "sys",
      "convert",
      "scope",
      "stopwatch",
      "file",
      "path",
      "url",
      "request",
      "json",
      "datetime"
    ];
  }
});

// server/src/runtime/runtime/sandbox/languageOperatorRegistry.ts
var LanguageOperatorRegistry;
var init_languageOperatorRegistry = __esm({
  "server/src/runtime/runtime/sandbox/languageOperatorRegistry.ts"() {
    "use strict";
    LanguageOperatorRegistry = class {
    };
    LanguageOperatorRegistry.ARR_PLUCK = "pluck";
    LanguageOperatorRegistry.ARR_TAKE = "take";
    LanguageOperatorRegistry.ARR_SKIP = "skip";
    LanguageOperatorRegistry.ARR_MAKE = "arr";
    LanguageOperatorRegistry.ARR_ORDERBY = "orderby";
    LanguageOperatorRegistry.ARR_GROUPBY = "groupby";
    LanguageOperatorRegistry.ARR_MERGE = "merge";
    LanguageOperatorRegistry.QUERY_WHERE = "where";
    LanguageOperatorRegistry.STRUCT_SWITCH = "switch";
    LanguageOperatorRegistry.BITWISE_AND = "bwa";
    LanguageOperatorRegistry.BITWISE_OR = "bwo";
    LanguageOperatorRegistry.BITWISE_XOR = "bxor";
    LanguageOperatorRegistry.BITWISE_NOT = "bnot";
    LanguageOperatorRegistry.BITWISE_SHIFT_LEFT = "bsl";
    LanguageOperatorRegistry.BITWISE_SHIFT_RIGHT = "bsr";
    LanguageOperatorRegistry.operators = [
      "pluck",
      "take",
      "arr",
      "skip",
      "orderby",
      "groupby",
      "merge",
      "where",
      "switch",
      "bwa",
      "bwo",
      "bxor",
      "bsl",
      "bsr"
    ];
  }
});

// server/src/runtime/parser/languageParser.ts
var LanguageParser;
var init_languageParser = __esm({
  "server/src/runtime/parser/languageParser.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_lineRetriever();
    init_typeLabeler();
    init_abstractNode();
    init_libraryManager();
    init_languageOperatorRegistry();
    init_nodeHelpers();
    init_stringUtilities();
    init_documentParser();
    init_languageKeywords();
    init_pathParser();
    LanguageParser = class {
      constructor() {
        this.pathParser = new PathParser();
        this.tokens = [];
        this.createdVariables = [];
        this.createdModifierChains = [];
        this.createdLanguageOperators = [];
        this.createdArrays = [];
        this.tracedAssignments = [];
        this.mergedVariablePaths = [];
        this.mergedComponents = /* @__PURE__ */ new Map();
        this.modifierNameMapping = /* @__PURE__ */ new Map();
        this.isRealModifierSeparator = /* @__PURE__ */ new Map();
        this.isRoot = true;
        this.retriggerNonVirtualGroupMembers = [];
      }
      hasModifierConstruct(name) {
        return this.modifierNameMapping.has(name);
      }
      getModifierConstruct(name) {
        return this.modifierNameMapping.get(name);
      }
      isActualModifierSeparator(node) {
        return this.isRealModifierSeparator.has(node);
      }
      isMergedVariableComponent(node) {
        return this.mergedComponents.has(node);
      }
      getMergedVariable(node) {
        return this.mergedComponents.get(node);
      }
      getMergedVariablePaths() {
        return this.mergedVariablePaths;
      }
      getCreatedModifierChains() {
        return this.createdModifierChains;
      }
      getCreatedLangaugeOperators() {
        return this.createdLanguageOperators;
      }
      getCreatedArrays() {
        return this.createdArrays;
      }
      getCreatedVariables() {
        return this.createdVariables;
      }
      getRuntimeAssignments() {
        return this.tracedAssignments;
      }
      getAssignedVariables() {
        const variables = [], addedVariableNames = [];
        for (let i = 0; i < this.tracedAssignments.length; i++) {
          const thisAssignment = this.tracedAssignments[i];
          if (thisAssignment.target instanceof VariableNode) {
            if (addedVariableNames.includes(thisAssignment.target.name) == false) {
              addedVariableNames.push(thisAssignment.target.name);
              variables.push(thisAssignment.target);
            }
          }
        }
        return variables;
      }
      getAssignedVariableNames() {
        const addedVariableNames = [];
        for (let i = 0; i < this.tracedAssignments.length; i++) {
          const thisAssignment = this.tracedAssignments[i];
          if (thisAssignment.target instanceof VariableNode) {
            if (addedVariableNames.includes(thisAssignment.target.name) == false) {
              addedVariableNames.push(thisAssignment.target.name);
            }
          }
        }
        return addedVariableNames;
      }
      reset() {
        this.tokens = [];
        this.createdModifierChains = [];
        this.createdLanguageOperators = [];
        this.createdArrays = [];
        this.createdModifierChains = [];
        this.createdLanguageOperators = [];
        this.tracedAssignments = [];
        this.createdArrays = [];
        this.mergedVariablePaths = [];
        this.mergedComponents.clear();
        this.modifierNameMapping.clear();
      }
      parse(tokens) {
        this.tokens = tokens;
        this.tokens = this.combineVariablePaths(this.tokens);
        this.tokens = this.createLanguageOperators(this.tokens);
        this.tokens = this.createLogicalGroups(this.tokens);
        this.tokens = this.associateMethodCalls(this.tokens);
        this.tokens = this.createTupleLists(this.tokens);
        this.tokens = this.createLibraryInvocations(this.tokens);
        this.tokens = this.associateModifiers(this.tokens);
        this.tokens = this.createNullCoalescenceGroups(this.tokens);
        this.tokens = this.correctTypes(this.tokens);
        this.tokens = this.createTernaryGroups(this.tokens);
        this.tokens = this.applyOperationOrder(this.tokens);
        this.validateNeighboringOperators(this.tokens);
        this.tokens = this.createLogicGroupsToRemoveMethodInvocationAmbiguity(this.tokens);
        this.tokens = this.createLogicGroupsToResolveOperatorAmbiguity(this.tokens);
        this.validateNoDanglingLogicGroupEnds(this.tokens);
        if (this.isRoot) {
          this.tokens = this.insertAutomaticStatementSeparators(this.tokens);
          if (this.retriggerNonVirtualGroupMembers.length > 0) {
            this.retriggerNonVirtualGroupMembers.forEach((grouping) => {
              this.markAllNonVirtualAsListGroupMember(grouping);
            });
          }
        }
        return this.createSemanticGroups(this.tokens);
      }
      setIsRoot(isRoot) {
        this.isRoot = isRoot;
        return this;
      }
      validateNeighboringOperators(tokens) {
        const tokenCount = tokens.length;
        for (let i = 0; i < tokenCount; i++) {
          const thisToken = tokens[i];
          if (LanguageParser.isOperatorType(thisToken)) {
            if (i + 1 >= tokenCount) {
              thisToken.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_OPERATOR,
                thisToken,
                "Unexpected operator while parsing input text."
              ));
              return;
            }
            const peek = tokens[i + 1];
            if (LanguageParser.isOperatorType(peek)) {
              peek.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_OPERATOR_INVALID_ON_RIGHT,
                peek,
                "Unexpected operator while parsing input text."
              ));
              continue;
            }
          }
        }
      }
      static isAssignmentOperator(token) {
        if (token instanceof AdditionAssignmentOperator || token instanceof DivisionAssignmentOperator || token instanceof LeftAssignmentOperator || token instanceof ModulusAssignmentOperator || token instanceof MultiplicationAssignmentOperator || token instanceof SubtractionAssignmentOperator) {
          return true;
        }
        return false;
      }
      static isOperatorType(token) {
        if (token instanceof AdditionAssignmentOperator || token instanceof DivisionAssignmentOperator || token instanceof LeftAssignmentOperator || token instanceof ModulusAssignmentOperator || token instanceof MultiplicationAssignmentOperator || token instanceof SubtractionAssignmentOperator || token instanceof ConditionalVariableFallbackOperator || token instanceof LanguageOperatorConstruct || token instanceof LogicalAndOperator || token instanceof LogicalNegationOperator || token instanceof LogicalOrOperator || token instanceof LogicalXorOperator || token instanceof NullCoalesceOperator || token instanceof StringConcatenationOperator || token instanceof AdditionOperator || token instanceof DivisionOperator || token instanceof ExponentiationOperator || token instanceof ModulusOperator || token instanceof MultiplicationOperator || token instanceof SubtractionOperator || token instanceof EqualCompOperator || token instanceof GreaterThanCompOperator || token instanceof GreaterThanEqualCompOperator || token instanceof LessThanCompOperator || token instanceof LessThanEqualCompOperator || token instanceof NotEqualCompOperator || token instanceof NotStrictEqualCompOperator || token instanceof SpaceshipCompOperator || token instanceof StrictEqualCompOperator) {
          return true;
        }
        return false;
      }
      markAllNonVirtualAsListGroupMember(nodes) {
        nodes.forEach((node) => {
          if (node instanceof LogicGroup || node instanceof ScopedLogicGroup || node instanceof AliasedScopeLogicGroup) {
            if (node.start != null && node.start.isVirtual == false) {
              node.start.isListGroupMember = true;
            }
            if (node.end != null && node.end.isVirtual == false) {
              node.end.isListGroupMember = true;
            }
            if (node.scopeOperator != null) {
              node.scopeOperator.isListGroupMember = true;
            }
            node.nodes.forEach((lgNode) => {
              this.markAllNonVirtualAsListGroupMember([lgNode]);
            });
            return;
          } else if (node instanceof SemanticGroup) {
            if (node.separatorToken != null && node.separatorToken.isVirtual == false) {
              node.separatorToken.isListGroupMember = true;
            }
            this.markAllNonVirtualAsListGroupMember(node.nodes);
          }
          if (node.isVirtual == false) {
            node.isListGroupMember = true;
          }
          if (node.originalAbstractNode != null && node.originalAbstractNode != node) {
            this.markAllNonVirtualAsListGroupMember([node.originalAbstractNode]);
          }
        });
      }
      markAllNonVirtualAsSwitch(nodes) {
        nodes.forEach((node) => {
          if (node instanceof LogicGroup || node instanceof ScopedLogicGroup || node instanceof AliasedScopeLogicGroup) {
            if (node.start != null && node.start.isVirtual == false) {
              node.start.isSwitchGroupMember = true;
            }
            if (node.end != null && node.end.isVirtual == false) {
              node.end.isSwitchGroupMember = true;
            }
            if (node.scopeOperator != null) {
              node.scopeOperator.isSwitchGroupMember = true;
            }
            node.nodes.forEach((lgNode) => {
              this.markAllNonVirtualAsSwitch([lgNode]);
            });
            return;
          } else if (node instanceof SemanticGroup) {
            if (node.separatorToken != null && node.separatorToken.isVirtual == false) {
              node.separatorToken.isSwitchGroupMember = true;
            }
            this.markAllNonVirtualAsSwitch(node.nodes);
          }
          if (node.isVirtual == false) {
            node.isSwitchGroupMember = true;
          }
          if (node.originalAbstractNode != null && node.originalAbstractNode != node) {
            this.markAllNonVirtualAsSwitch([node.originalAbstractNode]);
          }
        });
      }
      validateNoDanglingLogicGroupEnds(tokens) {
        tokens.forEach((token) => {
          if (token instanceof LogicGroupEnd) {
            token.pushError(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_START,
              token,
              "Unexpected [T_LOGIC_END] while parsing input text."
            ));
          }
        });
      }
      isValidModifierValue(node) {
        if (node instanceof ModifierValueNode || node instanceof VariableNode || node instanceof TrueConstant || node instanceof FalseConstant || node instanceof NullConstant || node instanceof NumberNode || node instanceof StringValueNode) {
          return true;
        }
        return false;
      }
      wrapNumberInVariable(node) {
        var _a, _b, _c, _d;
        const variableNode = new VariableNode();
        variableNode.startPosition = node.startPosition;
        variableNode.endPosition = node.endPosition;
        variableNode.name = (_b = (_a = node.value) == null ? void 0 : _a.toString()) != null ? _b : "";
        variableNode.content = (_d = (_c = node.value) == null ? void 0 : _c.toString()) != null ? _d : "";
        variableNode.originalAbstractNode = node;
        variableNode.refId = node.refId;
        variableNode.modifierChain = node.modifierChain;
        variableNode.index = node.index;
        this.createdVariables.push(variableNode);
        return variableNode;
      }
      wrapArithmeticModifier(operator, modifierName) {
        const node = new ModifierNameNode();
        node.startPosition = operator.startPosition;
        node.endPosition = operator.endPosition;
        node.originalAbstractNode = operator;
        node.content = modifierName;
        node.name = modifierName;
        node.index = operator.index;
        return node;
      }
      combineVariablePaths(tokens) {
        const newNodes = [], tokenCount = tokens.length;
        for (let i = 0; i < tokenCount; i++) {
          const node = tokens[i], newNodeCount = newNodes.length;
          if (node instanceof InlineBranchSeparator) {
            if (newNodeCount == 0) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR_FOR_VARCOMBINE,
                node,
                "Unexpected [T_BRANCH_SEPARATOR] while parsing input text."
              ));
              continue;
            }
            if (i + 1 > tokenCount) {
              let lastNodeText = "";
              if (i > 0) {
                const lastNode = tokens[i - 1];
                lastNodeText = LineRetriever.getNearText(lastNode);
              }
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_BRANCH_GROUP,
                node,
                'Unexpected end of input while parsing input text near "' + lastNodeText + LineRetriever.getNearText(node) + '".'
              ));
              continue;
            }
            const left = newNodes[newNodeCount - 1];
            let right = tokens[i + 1];
            if (right instanceof NumberNode && NodeHelpers.distance(left, right) == 1) {
              right = this.wrapNumberInVariable(right);
            }
            if (left instanceof VariableNode && right instanceof VariableNode && NodeHelpers.distance(left, right) == 1) {
              newNodes.pop();
              NodeHelpers.mergeVarContentRight(":", node, right);
              NodeHelpers.mergeVarRight(left, right);
              newNodes.push(right);
              this.createdVariables.push(right);
              this.mergedVariablePaths.push(right);
              this.mergedComponents.set(node, right);
              this.mergedComponents.set(left, right);
              this.mergedComponents.set(right, right);
              i += 1;
              continue;
            } else {
              newNodes.push(node);
              continue;
            }
          } else if (node instanceof StringValueNode && newNodeCount > 0) {
            if (i + 1 >= tokenCount) {
              newNodes.push(node);
              continue;
            }
            const left = newNodes[newNodeCount - 1], right = tokens[i + 1];
            if (left instanceof VariableNode && right instanceof VariableNode && NodeHelpers.distance(left, node) <= 1 && NodeHelpers.distance(node, right) <= 1) {
              newNodes.pop();
              NodeHelpers.mergeVarContentLeft(node.sourceTerminator + node.value + node.sourceTerminator, node, left);
              NodeHelpers.mergeVarContentLeft(right.name, right, left);
              this.createdVariables.push(left);
              newNodes.push(left);
              this.mergedVariablePaths.push(left);
              this.mergedComponents.set(node, left);
              this.mergedComponents.set(left, left);
              this.mergedComponents.set(right, left);
              i += 1;
              continue;
            } else {
              newNodes.push(node);
            }
          } else if (node instanceof SubtractionOperator && newNodeCount > 0) {
            const left = newNodes[newNodeCount - 1], right = tokens[i + 1];
            if (left instanceof VariableNode && (right instanceof VariableNode || right instanceof LogicalOrOperator)) {
              const lDistance = NodeHelpers.distance(left, node), rDistance = NodeHelpers.distance(node, right);
              if (lDistance <= 1 && rDistance <= 1) {
                left.endPosition = right.endPosition;
                this.mergedComponents.set(node, left);
                this.mergedComponents.set(left, left);
                this.mergedComponents.set(right, left);
                i += 1;
              } else {
                newNodes.push(node);
              }
            } else {
              newNodes.push(node);
            }
          } else {
            newNodes.push(node);
          }
        }
        newNodes.forEach((node) => {
          if (node instanceof VariableNode && !node.name.trim().startsWith("[")) {
            node.variableReference = this.pathParser.parse(node.name);
            node.mergeErrors(this.pathParser.getAntlersErrors());
          }
        });
        return newNodes;
      }
      convertVarNodeToOperator(variable) {
        const operator = new LanguageOperatorConstruct();
        operator.content = variable.name;
        operator.startPosition = variable.startPosition;
        operator.endPosition = variable.endPosition;
        operator.originalAbstractNode = variable;
        variable.convertedToOperator = true;
        this.createdLanguageOperators.push(operator);
        return operator;
      }
      convertOperatorToVarNode(operator) {
        const varNodeWrap = new VariableNode();
        varNodeWrap.startPosition = operator.startPosition;
        varNodeWrap.endPosition = operator.endPosition;
        varNodeWrap.content = operator.content;
        varNodeWrap.name = operator.content;
        varNodeWrap.originalAbstractNode = operator;
        this.createdVariables.push(varNodeWrap);
        return varNodeWrap;
      }
      createLanguageOperators(tokens) {
        const nodeCount = tokens.length;
        for (let i = 0; i < nodeCount; i++) {
          const thisNode = tokens[i];
          if (thisNode instanceof VariableNode) {
            if (thisNode.name.includes(DocumentParser.Punctuation_FullStop)) {
              const checkParts = thisNode.name.split(DocumentParser.Punctuation_FullStop);
              if (LanguageOperatorRegistry.operators.includes(checkParts[0]) || LibraryManager.deferredCoreLibraries.includes(checkParts[0])) {
                tokens[i] = this.convertVarNodeToOperator(thisNode);
                continue;
              }
            }
            if (LanguageOperatorRegistry.operators.includes(thisNode.name)) {
              tokens[i] = this.convertVarNodeToOperator(thisNode);
              continue;
            }
          }
          if (thisNode instanceof LanguageOperatorConstruct) {
            if (i + 1 >= nodeCount) {
              tokens[i] = this.convertOperatorToVarNode(thisNode);
              continue;
            }
            const next = tokens[i + 1];
            if (next instanceof StatementSeparatorNode) {
              tokens[i] = this.convertOperatorToVarNode(thisNode);
              continue;
            }
          }
        }
        return tokens;
      }
      createLogicalGroups(tokens) {
        const groupedTokens = [], tokenCount = tokens.length;
        const negatedGroupedTokens = [];
        for (let i = 0; i < tokenCount; i++) {
          const token = tokens[i];
          if (token instanceof LogicalNegationOperator) {
            const negationCount = this.countTypeRight(tokens, i, LogicalNegationOperator);
            if (negatedGroupedTokens.length == 0 && tokens.length == negationCount) {
              token.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_LOGIC_NEGATION_OPERATOR,
                token,
                "Unexpected [T_LOGIC_INVERSE] while parsing input text."
              ));
              continue;
            }
            if (i > 0 && negatedGroupedTokens.length > 0) {
              const prev = negatedGroupedTokens[negatedGroupedTokens.length - 1];
              if (prev instanceof NumberNode || prev instanceof LogicGroupEnd || prev instanceof LogicGroup) {
                if (prev instanceof LogicGroup) {
                  if (prev.start instanceof LogicalNegationOperator) {
                    prev.start.pushError(AntlersError.makeSyntaxError(
                      AntlersErrorCodes.TYPE_FACTORIAL_MATERIALIZED_BOOL_DETECTED,
                      prev.start,
                      "[T_AOP_FACTORIAL] operand will always materialize boolean type."
                    ));
                    continue;
                  }
                }
                const factorialOperator = new FactorialOperator();
                factorialOperator.startPosition = token.startPosition;
                factorialOperator.endPosition = token.endPosition;
                factorialOperator.content = "!".repeat(negationCount);
                factorialOperator.originalAbstractNode = token;
                factorialOperator.repeat = negationCount;
                negatedGroupedTokens.push(factorialOperator);
                if (negationCount > 0) {
                  i += negationCount - 1;
                }
                continue;
              }
            }
            if (negationCount % 2 == 0) {
              i += negationCount - 1;
              continue;
            }
            const peek = tokens[i + negationCount];
            if (peek instanceof LogicGroupBegin) {
              const targetSliceOffset = i + negationCount + 1;
              if (targetSliceOffset >= tokenCount) {
                peek.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_NEGATION_OFFSET,
                  peek,
                  "Unexpected end of input while parsing input text."
                ));
                continue;
              }
              const groupResults = this.findLogicalGroupEnd(tokens[i + negationCount], tokens.slice(targetSliceOffset));
              if (groupResults.found) {
                const subGroup = groupResults.logicalGroup;
                const wrapperGroup = new LogicGroup();
                wrapperGroup.start = token;
                wrapperGroup.end = subGroup;
                wrapperGroup.nodes.push(token);
                wrapperGroup.nodes.push(subGroup);
                wrapperGroup.startPosition = token.startPosition;
                wrapperGroup.endPosition = subGroup.endPosition;
                negatedGroupedTokens.push(wrapperGroup);
                i += groupResults.skipCount + negationCount;
              }
              continue;
            }
            const results = this.resolveValueRight(tokens, i);
            if (results.value != null) {
              negatedGroupedTokens.push(results.value);
            }
            i += results.negationCount;
          } else {
            negatedGroupedTokens.push(token);
          }
        }
        const negatedTokenCount = negatedGroupedTokens.length;
        for (let i = 0; i < negatedTokenCount; i++) {
          const token = negatedGroupedTokens[i];
          if (token instanceof LogicGroupBegin) {
            if (i + 1 >= negatedTokenCount) {
              token.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END_DUE_TO_NEGATION,
                token,
                "Unexpected end of input while parsing input text."
              ));
              continue;
            }
            const group = this.findLogicalGroupEnd(token, negatedGroupedTokens.slice(i + 1));
            if (group.found && group.logicalGroup != null) {
              groupedTokens.push(group.logicalGroup);
            }
            i += group.skipCount;
          } else {
            if (token instanceof FactorialOperator) {
              if (groupedTokens.length == 0) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_WHILE_CREATING_GROUPS,
                  token,
                  "Unexpected [T_AOP_FACTORIAL] while parsing input text."
                ));
                continue;
              }
              let prev = groupedTokens[groupedTokens.length - 1];
              if (prev instanceof LogicGroup == false && prev instanceof NumberNode == false) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_OPERAND,
                  token,
                  "Unexpected left operand encountered for [T_AOP_FACTORIAL] while parsing input text."
                ));
                continue;
              }
              prev = groupedTokens.pop();
              const wrapperGroup = new LogicGroup();
              wrapperGroup.startPosition = prev.startPosition;
              wrapperGroup.endPosition = token.endPosition;
              wrapperGroup.originalAbstractNode = token;
              wrapperGroup.nodes.push(prev);
              wrapperGroup.nodes.push(token);
              groupedTokens.push(wrapperGroup);
            } else {
              groupedTokens.push(token);
            }
          }
        }
        return groupedTokens;
      }
      makeArgGroup(nodes) {
        const argGroup = new ArgumentGroup(), nodeCount = nodes.length;
        for (let i = 0; i < nodeCount; i++) {
          const thisNode = nodes[i];
          if (this.isOperand(thisNode) == false) {
            thisNode.pushError(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_WHILE_PARSING_METHOD,
              thisNode,
              "Unexpected [" + TypeLabeler.getPrettyTypeName(thisNode) + "] while parsing argument group."
            ));
            continue;
          }
          let next = null;
          if (i + 1 < nodeCount) {
            next = nodes[i + 1];
          }
          if (next == null || next instanceof ArgSeparator) {
            argGroup.args.push(nodes[i]);
            i += 1;
            continue;
          } else if (next instanceof InlineBranchSeparator) {
            if (i + 2 >= nodeCount) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_ARG_UNEXPECTED_NAMED_ARGUMENT,
                thisNode,
                "Unexpected end of input while parsing named argument."
              ));
              continue;
            }
            const valueNode = nodes[i + 2];
            const namedArgument = new NamedArgumentNode();
            namedArgument.startPosition = thisNode.startPosition;
            namedArgument.endPosition = valueNode.endPosition;
            namedArgument.content = thisNode.content + valueNode.content;
            namedArgument.name = thisNode;
            namedArgument.value = valueNode;
            if (thisNode instanceof VariableNode == false) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_INVALID_NAMED_ARG_IDENTIFIER,
                thisNode,
                "Invalid type [" + TypeLabeler.getPrettyTypeName(thisNode) + "] supplied for named argument name."
              ));
            }
            argGroup.hasNamedArguments = true;
            argGroup.numberOfNamedArguments += 1;
            argGroup.args.push(namedArgument);
            if (i + 3 < nodeCount && nodes[i + 3] instanceof ArgSeparator) {
              i += 3;
            } else {
              i += 2;
            }
            continue;
          }
        }
        let remainderMustBeNamed = false;
        argGroup.args.forEach((arg) => {
          if (arg instanceof NamedArgumentNode) {
            remainderMustBeNamed = true;
          } else {
            if (remainderMustBeNamed) {
              arg.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_UNNAMED_METHOD_ARGUMENT,
                arg,
                "Unnamed arguments are not allowed to appear after a named argument."
              ));
            }
          }
        });
        if (argGroup.args.length > 0) {
          argGroup.startPosition = argGroup.args[0].startPosition;
          argGroup.endPosition = argGroup.args[argGroup.args.length - 1].endPosition;
        }
        return argGroup;
      }
      cleanVariableForMethodInvocation(node) {
        if (node.name.startsWith(":") || node.name.startsWith(".")) {
          node.name = node.name.substr(1);
          if (node.variableReference != null) {
            node.variableReference.originalContent = node.variableReference.originalContent.substr(1);
            node.variableReference.normalizedReference = node.variableReference.normalizedReference.substr(1);
          }
          if (node.startPosition != null) {
            node.startPosition.offset += 1;
            node.startPosition.char += 1;
          }
        }
      }
      reduceVariableReferenceForObjectAccessor(node) {
        var _a;
        const lastPath = (_a = node.variableReference) == null ? void 0 : _a.pathParts.pop(), accessor = lastPath.name, accessorLen = accessor.length + 1;
        node.name = node.name.substr(0, -accessorLen);
        if (node.variableReference != null) {
          node.variableReference.originalContent = node.variableReference.originalContent.substr(0, -accessorLen);
          node.variableReference.normalizedReference = node.variableReference.normalizedReference.substr(0, -accessorLen);
          node.variableReference.pathParts[node.variableReference.pathParts.length - 1].isFinal = true;
        }
        if (node.endPosition != null) {
          node.endPosition.offset -= accessorLen;
          node.endPosition.char -= accessorLen;
        }
        return {
          accessor,
          accessorLen
        };
      }
      associateMethodCalls(tokens) {
        var _a, _b;
        const newTokens = [], nodeCount = tokens.length;
        for (let i = 0; i < nodeCount; i++) {
          const thisNode = tokens[i];
          let prevNode = null, next = null;
          if (newTokens.length > 0) {
            prevNode = newTokens[newTokens.length - 1];
          }
          if (i + 1 < nodeCount) {
            next = tokens[i + 1];
          }
          if (thisNode instanceof VariableNode && next instanceof LogicGroup && prevNode != null && (this.isProperMethodChainTargetStrict(prevNode) || prevNode instanceof InlineBranchSeparator)) {
            const argGroup = next;
            let argNodes = [];
            if (argGroup.nodes.length > 0) {
              if (argGroup.nodes[0] instanceof SemanticGroup) {
                const tSg = argGroup.nodes[0];
                argNodes = tSg.nodes;
              } else {
                argNodes = argGroup.nodes;
              }
            }
            const methodInvocation = new MethodInvocationNode();
            methodInvocation.startPosition = thisNode.startPosition;
            if (prevNode instanceof InlineBranchSeparator) {
              const branchSeparator = newTokens.pop();
              methodInvocation.startPosition = branchSeparator.startPosition;
            }
            this.cleanVariableForMethodInvocation(thisNode);
            methodInvocation.endPosition = argGroup.endPosition;
            methodInvocation.args = this.makeArgGroup(argNodes);
            methodInvocation.method = thisNode;
            prevNode.methodTarget = methodInvocation;
            if (prevNode instanceof VariableNode && prevNode.mergeRefName.length > 0) {
              prevNode.name = NodeHelpers.getUnrefName(prevNode.mergeRefName);
            }
            newTokens.push(methodInvocation);
            i += 1;
            continue;
          } else if (thisNode instanceof LogicGroup && prevNode instanceof VariableNode && prevNode.variableReference != null && prevNode.variableReference.pathParts.length >= 2) {
            let argNodes = [];
            if (thisNode.nodes.length > 0) {
              if (thisNode.nodes[0] instanceof SemanticGroup) {
                const tSg = thisNode.nodes[0];
                argNodes = tSg.nodes;
              } else {
                argNodes = thisNode.nodes;
              }
            }
            if (prevNode.variableReference.pathParts[0] instanceof PathNode) {
              if (LibraryManager.deferredCoreLibraries.includes(prevNode.variableReference.pathParts[0].name)) {
                const varRef = newTokens.pop();
                const libraryInvocation = new LibraryInvocationConstruct();
                libraryInvocation.startPosition = varRef.startPosition;
                libraryInvocation.endPosition = thisNode.endPosition;
                libraryInvocation.content = varRef.content;
                libraryInvocation.originalAbstractNode = thisNode;
                const libraryReference = (_a = varRef.variableReference) == null ? void 0 : _a.pathParts.shift();
                const libraryName = libraryReference.name, methodName = (_b = varRef.variableReference) == null ? void 0 : _b.implodePaths();
                libraryInvocation.libraryName = libraryName;
                libraryInvocation.methodName = methodName;
                libraryInvocation.arguments = this.makeArgGroup(argNodes);
                newTokens.push(libraryInvocation);
                i += 1;
                continue;
              }
            }
            const reductionResult = this.reduceVariableReferenceForObjectAccessor(prevNode);
            const methodInvocation = new MethodInvocationNode();
            methodInvocation.startPosition = thisNode.startPosition;
            methodInvocation.endPosition = thisNode.endPosition;
            prevNode.methodTarget = methodInvocation;
            if (prevNode instanceof VariableNode && prevNode.mergeRefName.length > 0) {
              prevNode.name = NodeHelpers.getUnrefName(prevNode.mergeRefName);
            }
            if (thisNode.start != null) {
              thisNode.start.isPartOfMethodChain = true;
            }
            if (thisNode.end != null) {
              thisNode.end.isPartOfMethodChain = true;
            }
            const wrappedMethod = new VariableNode();
            wrappedMethod.name = reductionResult.accessor;
            wrappedMethod.isPartOfMethodChain = true;
            const args = this.makeArgGroup(argNodes);
            if (methodInvocation.startPosition != null) {
              methodInvocation.startPosition.offset -= reductionResult.accessorLen;
              methodInvocation.startPosition.char -= reductionResult.accessorLen;
            }
            methodInvocation.method = wrappedMethod;
            methodInvocation.args = args;
            if (StringUtilities.isNumeric(prevNode.name)) {
              const varNode = newTokens.pop();
              newTokens.push(this.convertOperatorToVarNode(varNode));
            }
            newTokens.push(methodInvocation);
            continue;
          } else if (thisNode instanceof VariableNode && prevNode instanceof MethodInvocationNode) {
            this.cleanVariableForMethodInvocation(thisNode);
            if (i + 1 > nodeCount) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_ARG_GROUP,
                thisNode,
                "Unexpected end of input while parsing method call."
              ));
              continue;
            }
            const argGroupT = tokens[i + 1];
            if (argGroupT instanceof LogicGroup == false) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP,
                thisNode,
                "Unexpected [" + TypeLabeler.getPrettyTypeName(argGroupT) + "] while parsing [T_METHOD_CALL]; expecting [T_ARG_GROUP]."
              ));
              continue;
            }
            const argGroup = argGroupT;
            let argNodes = [];
            if (argGroup.nodes.length > 0) {
              if (argGroup.nodes[0] instanceof SemanticGroup) {
                const tSg = argGroup.nodes[0];
                argNodes = tSg.nodes;
              } else {
                argNodes = argGroup.nodes;
              }
            }
            const methodInvocation = new MethodInvocationNode();
            methodInvocation.startPosition = thisNode.startPosition;
            methodInvocation.endPosition = argGroup.endPosition;
            methodInvocation.args = this.makeArgGroup(argNodes);
            methodInvocation.method = thisNode;
            prevNode.methodTarget = methodInvocation;
            newTokens.push(methodInvocation);
            i += 1;
            continue;
          } else if (thisNode instanceof InlineBranchSeparator && prevNode instanceof MethodInvocationNode) {
            if (i + 1 > nodeCount) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_METHOD,
                thisNode,
                "Unexpected end of input while parsing method call."
              ));
              continue;
            }
            const next2 = tokens[i + 1];
            if (i + 2 > nodeCount) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_ARG_GROUP,
                thisNode,
                "Unexpected end of input while parsing method call."
              ));
              continue;
            }
            const argGroupT = tokens[i + 2];
            if (argGroupT instanceof LogicGroup == false) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP,
                thisNode,
                "Unexpected [" + TypeLabeler.getPrettyTypeName(argGroupT) + "] while parsing [T_METHOD_CALL]; expecting [T_ARG_GROUP]."
              ));
              continue;
            }
            const argGroup = argGroupT;
            let argNodes = [];
            if (argGroup.nodes.length > 0) {
              if (argGroup.nodes[0] instanceof SemanticGroup) {
                const tSg = argGroup.nodes[0];
                argNodes = tSg.nodes;
              } else {
                argNodes = argGroup.nodes;
              }
            }
            const methodInvocation = new MethodInvocationNode();
            methodInvocation.startPosition = thisNode.startPosition;
            methodInvocation.endPosition = argGroupT.endPosition;
            methodInvocation.args = this.makeArgGroup(argNodes);
            methodInvocation.method = next2;
            prevNode.methodTarget = methodInvocation;
            newTokens.push(methodInvocation);
            i += 2;
            continue;
          } else if (thisNode instanceof MethodInvocationNode) {
            if (i + 1 > nodeCount) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_METHOD,
                thisNode,
                "Unexpected end of input while parsing method call."
              ));
              continue;
            }
            const methodNode = tokens[i + 1];
            if (i + 2 > nodeCount) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP,
                thisNode,
                "Unexpected end of input while parsing method call."
              ));
              continue;
            }
            const nextT = tokens[i + 2];
            if (nextT instanceof LogicGroup == false) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP,
                thisNode,
                "Unexpected [" + TypeLabeler.getPrettyTypeName(nextT) + "] while parsing [T_METHOD_CALL]; expecting [T_ARG_GROUP]."
              ));
              continue;
            }
            const next2 = nextT;
            let argNodes = [];
            if (next2.nodes.length > 0) {
              if (next2.nodes[0] instanceof SemanticGroup) {
                const tSg = next2.nodes[0];
                argNodes = tSg.nodes;
              } else {
                argNodes = next2.nodes;
              }
            }
            const args = this.makeArgGroup(argNodes);
            if (prevNode instanceof VariableNode && LibraryManager.deferredCoreLibraries.includes(prevNode.name)) {
              const varRef = newTokens.pop();
              const libraryInvocation = new LibraryInvocationConstruct();
              libraryInvocation.startPosition = varRef.startPosition;
              libraryInvocation.endPosition = next2.endPosition;
              libraryInvocation.libraryName = varRef.name;
              libraryInvocation.methodName = methodNode.name;
              libraryInvocation.content = libraryInvocation.libraryName + "->" + libraryInvocation.methodName;
              libraryInvocation.arguments = args;
              prevNode.libraryTarget = libraryInvocation;
              newTokens.push(libraryInvocation);
              i += 2;
              continue;
            }
            thisNode.method = methodNode;
            thisNode.args = args;
            if (newTokens.length > 0) {
              newTokens[newTokens.length - 1].methodTarget = thisNode;
            }
            i += 2;
            newTokens.push(thisNode);
            continue;
          } else {
            newTokens.push(thisNode);
          }
        }
        return newTokens;
      }
      convertVariableToStringNode(node) {
        const wrappedNode = new StringValueNode();
        wrappedNode.content = node.name;
        wrappedNode.value = node.name;
        wrappedNode.originalAbstractNode = node;
        wrappedNode.startPosition = node.startPosition;
        wrappedNode.endPosition = node.endPosition;
        wrappedNode.index = node.index;
        return wrappedNode;
      }
      createTupleLists(tokens) {
        const tokenCount = tokens.length, newTokens = [];
        for (let i = 0; i < tokenCount; i++) {
          const thisToken = tokens[i];
          if (thisToken instanceof TupleListStart) {
            thisToken.isListGroupMember = true;
            if (i + 1 >= tokenCount) {
              thisToken.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_TUPLE_LIST,
                thisToken,
                "Unexpected end of input while parsing tuple list."
              ));
              continue;
            }
            const peekT = tokens[i + 1];
            if (peekT instanceof LogicGroup == false) {
              peekT.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_TYPE_FOR_TUPLE_LIST,
                peekT,
                "Unexpected [" + TypeLabeler.getPrettyTypeName(peekT) + "] while parsing tuple list."
              ));
              continue;
            }
            const peek = peekT;
            this.markAllNonVirtualAsListGroupMember([peek]);
            this.retriggerNonVirtualGroupMembers.push([peek]);
            const listNodeLength = peek.nodes.length;
            if (listNodeLength == 0) {
              peek.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_MISSING_BODY_TUPLE_LIST,
                peek,
                "Missing tuple list body while parsing tuple list."
              ));
              continue;
            }
            const nameGroup = peek.nodes.shift();
            const targetGroupLength = nameGroup.nodes.length;
            const listNames = [];
            for (let j = 0; j < targetGroupLength; j++) {
              const subNodeT = nameGroup.nodes[j];
              if (subNodeT instanceof ArgSeparator == false) {
                let breakFromVarRef = false;
                if (subNodeT instanceof VariableNode) {
                  if (subNodeT.variableReference == null) {
                    breakFromVarRef = true;
                  }
                  if (subNodeT.variableReference != null) {
                    if (subNodeT.variableReference.pathParts.length > 1) {
                      breakFromVarRef = true;
                    }
                  }
                  if (subNodeT.name.trim().length == 0) {
                    breakFromVarRef = true;
                  }
                }
                if (breakFromVarRef || subNodeT instanceof VariableNode == false) {
                  peek.pushError(AntlersError.makeSyntaxError(
                    AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_NAME_TYPE,
                    peek,
                    "Invalid [" + TypeLabeler.getPrettyTypeName(subNodeT) + "] name type found while parsing tuple list."
                  ));
                  continue;
                }
                const subNode = subNodeT;
                listNames.push(this.convertVariableToStringNode(subNode));
              }
            }
            const listValueLength = listNames.length;
            if (listValueLength == 0) {
              peek.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_INVALID_MANIFESTED_NAME_GROUP,
                peek,
                "Invalid Name expression produced an invalid name group while parsing tuple list."
              ));
              continue;
            }
            const arrayNode = new ArrayNode();
            this.createdArrays.push(arrayNode);
            arrayNode.startPosition = thisToken.startPosition;
            arrayNode.endPosition = thisToken.endPosition;
            peek.nodes.forEach((valueNodeCandidateT) => {
              if (valueNodeCandidateT instanceof SemanticGroup == false) {
                valueNodeCandidateT.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE_GROUP,
                  valueNodeCandidateT,
                  "Invalid [" + TypeLabeler.getPrettyTypeName(valueNodeCandidateT) + "] name type found while parsing tuple list value expression."
                ));
                return;
              }
              const valueNodeCandidate = valueNodeCandidateT;
              const nestedArrayNode = new ArrayNode();
              this.createdArrays.push(nestedArrayNode);
              nestedArrayNode.startPosition = valueNodeCandidate.startPosition;
              const valueCandidates = [];
              for (let j = 0; j < targetGroupLength; j++) {
                const valueToken = valueNodeCandidate.nodes[j];
                if (typeof valueToken === "undefined" || valueToken == null) {
                  break;
                }
                if (valueToken instanceof ArgSeparator == false) {
                  if (this.isOperand(valueToken) == false) {
                    valueToken.pushError(AntlersError.makeSyntaxError(
                      AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE,
                      valueToken,
                      "Unexpected [" + TypeLabeler.getPrettyTypeName(valueToken) + "]  while parsing tuple list value."
                    ));
                    continue;
                  }
                  valueCandidates.push(valueToken);
                }
              }
              for (let j = 0; j < listValueLength; j++) {
                if (j > valueCandidates.length) {
                  break;
                }
                const valueToken = valueCandidates[j];
                const namedValueNode = new NameValueNode();
                namedValueNode.startPosition = valueToken.startPosition;
                namedValueNode.endPosition = valueToken.endPosition;
                namedValueNode.name = listNames[j];
                namedValueNode.value = valueToken;
                nestedArrayNode.nodes.push(namedValueNode);
                arrayNode.endPosition = valueToken.endPosition;
                nestedArrayNode.endPosition = valueToken.endPosition;
              }
              arrayNode.nodes.push(nestedArrayNode);
            });
            newTokens.push(arrayNode);
            i += 1;
            continue;
          } else {
            newTokens.push(thisToken);
          }
        }
        return tokens;
      }
      makeOrderGroup(nodes) {
        const orders = [], nodeCount = nodes.length;
        let orderCount = 0;
        for (let i = 0; i < nodeCount; i++) {
          const thisNode = nodes[i];
          let next = null;
          if (i + 1 < nodeCount) {
            next = nodes[i + 1];
          }
          if (i > 0) {
            if (next == null || next instanceof ArgSeparator) {
              orderCount += 1;
              const orderNode = new ValueDirectionNode();
              orderNode.order = orderCount;
              orderNode.name = nodes[i - 1];
              orderNode.directionNode = thisNode;
              if (this.isOperand(orderNode.name) == false) {
                orderNode.name.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_INVALID_ORDER_BY_NAME_VALUE,
                  orderNode.name,
                  "Invalid value or expression supplied for order by name."
                ));
              }
              if (this.isOperand(orderNode.directionNode) == false) {
                orderNode.directionNode.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_INVALID_ORDER_BY_SORT_VALUE,
                  orderNode.directionNode,
                  "Invalid value or expression supplied for order by direction."
                ));
              }
              orderNode.startPosition = orderNode.name.startPosition;
              orderNode.endPosition = orderNode.directionNode.endPosition;
              orders.push(orderNode);
              i += 1;
              continue;
            }
          }
        }
        return orders;
      }
      getValues(nodes) {
        const valueNode = new ListValueNode(), nodeCount = nodes.length, values = [];
        for (let i = 0; i < nodeCount; i++) {
          const thisNode = nodes[i];
          let next = null;
          if (i + 1 < nodeCount) {
            next = nodes[i + 1];
          }
          if (next == null || next instanceof ArgSeparator) {
            values.push(thisNode);
            i += 1;
            continue;
          }
        }
        valueNode.values = values;
        return valueNode;
      }
      createLibraryInvocations(tokens) {
        const newTokens = [], tokenCount = tokens.length;
        for (let i = 0; i < tokenCount; i++) {
          const token = tokens[i];
          if (token instanceof LanguageOperatorConstruct) {
            if (token.content.includes(".")) {
              const content = token.content.split("."), libraryName = content.shift(), methodName = content.join(".");
              const libraryInvocationConstruct = new LibraryInvocationConstruct();
              libraryInvocationConstruct.startPosition = token.startPosition;
              libraryInvocationConstruct.endPosition = token.endPosition;
              libraryInvocationConstruct.content = token.content;
              libraryInvocationConstruct.libraryName = libraryName;
              libraryInvocationConstruct.methodName = methodName;
              libraryInvocationConstruct.originalAbstractNode = token;
              if (i + 1 >= tokenCount) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_ARG_GROUP,
                  token,
                  "Unexpected end of input while parsing argument group."
                ));
                continue;
              }
              if (tokens[i + 1] instanceof LogicGroup == false) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_EXPECTING_ARGUMENT_GROUP,
                  token,
                  "Unexpected token while parsing method call. Expecting [T_ARG_SEPARATOR] got [" + TypeLabeler.getPrettyTypeName(token) + "]."
                ));
                continue;
              }
              const logicGroup = tokens[i + 1];
              let argGroup = null;
              if (logicGroup.nodes.length > 0) {
                const semanticGroup = logicGroup.nodes[0];
                argGroup = this.makeArgGroup(semanticGroup.nodes);
              }
              if (argGroup == null) {
                argGroup = new ArgumentGroup();
                argGroup.startPosition = logicGroup.startPosition;
                argGroup.endPosition = logicGroup.endPosition;
                argGroup.originalAbstractNode = logicGroup;
              }
              libraryInvocationConstruct.arguments = argGroup;
              newTokens.push(libraryInvocationConstruct);
              i += 1;
              continue;
            } else if (token.content == LanguageOperatorRegistry.ARR_ORDERBY) {
              if (i + 1 >= tokenCount) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_ORDER_GROUP,
                  token,
                  "Unexpected end of input while parsing order group."
                ));
                continue;
              }
              const nextTokenT = tokens[i + 1];
              if (nextTokenT instanceof LogicGroup == false) {
                nextTokenT.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_EXPECTING_ORDER_GROUP_FOR_ORDER_BY_OPERAND,
                  nextTokenT,
                  "Unexpected [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] while parsing order group."
                ));
                continue;
              }
              const nextToken = nextTokenT;
              let subNodes = nextToken.nodes;
              if (subNodes[0] instanceof SemanticGroup) {
                const tSg = subNodes[0];
                subNodes = tSg.nodes;
              }
              const orderClauses = this.makeOrderGroup(subNodes);
              if (orderClauses.length == 0) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_EMPTY_DIRECTION_GROUP,
                  token,
                  "Unexpected empty [T_DIRECTION_GROUP]. Must have at least one order clause, and each property must have a direction specified."
                ));
              }
              const orderGroup = new DirectionGroup();
              orderGroup.orderClauses = orderClauses;
              if (orderClauses.length > 0) {
                if (orderClauses[0].directionNode != null) {
                  orderGroup.startPosition = orderClauses[0].directionNode.startPosition;
                }
                const ocLastDn = orderClauses[orderClauses.length - 1].directionNode;
                if (ocLastDn != null) {
                  orderGroup.endPosition = ocLastDn.endPosition;
                }
              }
              newTokens.push(token);
              newTokens.push(orderGroup);
              i += 1;
              continue;
            } else if (token.content == LanguageOperatorRegistry.ARR_GROUPBY) {
              if (i + 1 >= tokenCount) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_GROUP_BY,
                  token,
                  "Unexpected end of input while parsing group by clause."
                ));
                continue;
              }
              const nextTokenT = tokens[i + 1];
              if (nextTokenT instanceof AliasedScopeLogicGroup || nextTokenT instanceof ScopedLogicGroup) {
                nextTokenT.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_GROUP_BY_SCOPED_GROUP_MUST_BE_ENCLOSED,
                  nextTokenT,
                  "Type [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] must be enclosed with parenthesis to be used with groupby."
                ));
                continue;
              }
              if (nextTokenT instanceof LogicGroup == false) {
                nextTokenT.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_GROUP_BY,
                  nextTokenT,
                  "Unexpected [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] while parsing group by."
                ));
                continue;
              }
              const nextToken = nextTokenT;
              let subNodes = nextToken.nodes;
              if (subNodes[0] instanceof SemanticGroup) {
                const tSg = subNodes[0];
                subNodes = tSg.nodes;
              }
              const listValues = this.getValues(subNodes);
              newTokens.push(token);
              newTokens.push(listValues);
              if (i + 2 < tokenCount && i + 3 < tokenCount) {
                const peekOne = tokens[i + 2], peekTwo = tokens[i + 3];
                if (NodeHelpers.isVariableMatching(peekOne, LanguageKeywords.ScopeAs)) {
                  if (peekTwo instanceof StringValueNode) {
                    listValues.isNamedNode = true;
                    listValues.parsedName = peekTwo;
                    i += 3;
                    continue;
                  } else {
                    peekTwo.pushError(AntlersError.makeSyntaxError(
                      AntlersErrorCodes.TYPE_UNEXPECTED_GROUP_BY_AS_ALIAS_TYPE,
                      peekTwo,
                      "Expecting [T_STRING] for group by collection alias; got [" + TypeLabeler.getPrettyTypeName(peekTwo) + "]."
                    ));
                  }
                }
              }
              i += 1;
              continue;
            } else if (token.content == LanguageOperatorRegistry.STRUCT_SWITCH) {
              if (i + 1 >= tokenCount) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_SWITCH_GROUP,
                  token,
                  "Unexpected end of input while parsing [T_SWITCH_GROUP]."
                ));
                continue;
              }
              const nextT = tokens[i + 1];
              if (nextT instanceof ScopedLogicGroup == false) {
                nextT.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_SWITCH_GROUP,
                  nextT,
                  "Unexpected [" + TypeLabeler.getPrettyTypeName(nextT) + "] while parsing [T_SWITCH_GROUP]."
                ));
                continue;
              }
              const next = nextT;
              this.markAllNonVirtualAsSwitch([nextT]);
              if (next.scope == null || next.scope instanceof LogicGroup == false) {
                next.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE,
                  next,
                  "Unexpected input while parsing [T_SWITCH_GROUP]."
                ));
                continue;
              }
              const tSwitchScope = next.scope;
              if (tSwitchScope.nodes.length == 0 || tSwitchScope.nodes[0] instanceof SemanticGroup == false) {
                next.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE,
                  next,
                  "Unexpected input while parsing [T_SWITCH_GROUP]."
                ));
                continue;
              }
              const wrapperSemanticGroup = tSwitchScope.nodes[0];
              this.markAllNonVirtualAsSwitch([tSwitchScope]);
              if (wrapperSemanticGroup.nodes.length == 0 || wrapperSemanticGroup.nodes[0] instanceof LogicGroup == false) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE,
                  token,
                  "Unexpected input while parsing [T_SWITCH_GROUP]."
                ));
                continue;
              }
              this.markAllNonVirtualAsSwitch([token]);
              this.markAllNonVirtualAsSwitch(wrapperSemanticGroup.nodes);
              const firstCondition = wrapperSemanticGroup.nodes;
              if (next.nodes.length == 0) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE,
                  token,
                  "Unexpected input while parsing [T_SWITCH_GROUP]."
                ));
              }
              const expressionNodeT = tSwitchScope.nodes[0];
              if (expressionNodeT instanceof SemanticGroup == false) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE,
                  token,
                  "Unexpected input while parsing [T_SWITCH_GROUP]."
                ));
                continue;
              }
              const expressionNode = tSwitchScope.nodes[0];
              this.markAllNonVirtualAsSwitch(expressionNode.nodes);
              const subTokens = expressionNode.nodes;
              const switchGroup = new SwitchGroup();
              const wrapperGroup = new LogicGroup();
              wrapperGroup.nodes = firstCondition;
              wrapperGroup.startPosition = wrapperGroup.nodes[0].startPosition;
              wrapperGroup.endPosition = wrapperGroup.nodes[wrapperGroup.nodes.length - 1].endPosition;
              const firstCase = new SwitchCase();
              firstCase.condition = wrapperGroup;
              const expWrapper = new LogicGroup();
              expWrapper.nodes.push(subTokens.shift());
              expWrapper.startPosition = expWrapper.nodes[0].startPosition;
              expWrapper.endPosition = expWrapper.nodes[expWrapper.nodes.length - 1].endPosition;
              firstCase.expression = expWrapper;
              firstCase.startPosition = firstCase.condition.startPosition;
              firstCase.endPosition = firstCase.expression.nodes[firstCase.expression.nodes.length - 1].endPosition;
              subTokens.shift();
              switchGroup.cases.push(firstCase);
              const subTokenCount = subTokens.length;
              if (subTokenCount > 0) {
                if (subTokens[0] instanceof LogicGroup == false) {
                  token.pushError(AntlersError.makeSyntaxError(
                    AntlersErrorCodes.TYPE_PARSER_INVALID_SWITCH_TOKEN,
                    token,
                    "Invalid [" + TypeLabeler.getPrettyTypeName(subTokens[0]) + "] while parsing case statement."
                  ));
                  continue;
                }
                for (let c = 0; c < subTokenCount; c++) {
                  const thisToken = subTokens[c];
                  let next2 = null;
                  if (thisToken instanceof ArgSeparator) {
                    thisToken.isSwitchGroupMember = true;
                    continue;
                  }
                  if (c + 1 < subTokenCount) {
                    next2 = subTokens[c + 1];
                  }
                  if (next2 instanceof ScopeAssignmentOperator) {
                    next2.isSwitchGroupMember = true;
                    const newCase = new SwitchCase();
                    newCase.condition = thisToken;
                    this.markAllNonVirtualAsSwitch([newCase.condition]);
                    const expWrapper2 = new LogicGroup();
                    expWrapper2.nodes.push(subTokens[c + 2]);
                    expWrapper2.startPosition = expWrapper2.nodes[0].startPosition;
                    expWrapper2.endPosition = expWrapper2.nodes[expWrapper2.nodes.length - 1].endPosition;
                    newCase.expression = expWrapper2;
                    this.markAllNonVirtualAsSwitch([expWrapper2]);
                    newCase.startPosition = newCase.condition.startPosition;
                    newCase.endPosition = newCase.expression.nodes[newCase.expression.nodes.length - 1].endPosition;
                    switchGroup.cases.push(newCase);
                    if (c + 3 < subTokenCount) {
                      if (subTokens[c + 3] instanceof ArgSeparator == false) {
                        subTokens[c + 3].pushError(AntlersError.makeSyntaxError(
                          AntlersErrorCodes.TYPE_PARSER_INVALID_SWITCH_TOKEN,
                          subTokens[c + 3],
                          "Invalid [" + TypeLabeler.getPrettyTypeName(subTokens[c + 3]) + "] while parsing case statement; expecting [T_ARG_SEPARATOR]."
                        ));
                        continue;
                      }
                    }
                    subTokens[c + 3].isSwitchGroupMember = true;
                    c += 2;
                    continue;
                  }
                }
              }
              newTokens.push(new NullConstant());
              newTokens.push(token);
              newTokens.push(switchGroup);
              i += 1;
              continue;
            } else if (token.content == LanguageOperatorRegistry.ARR_MAKE) {
              if (i + 1 >= tokenCount) {
                token.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_TARGET,
                  token,
                  "Missing target variable for arr operator."
                ));
                continue;
              }
              const nextTokenT = tokens[i + 1];
              if (nextTokenT instanceof LogicGroup == false) {
                nextTokenT.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_ARR_MAKE_UNEXPECTED_TYPE,
                  nextTokenT,
                  "Unexpected [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] while parsing array."
                ));
                continue;
              }
              const isNextScopedLogicGroup = nextTokenT instanceof ScopedLogicGroup;
              const nextToken = nextTokenT;
              let subNodes = nextToken.nodes;
              if (subNodes[0] instanceof SemanticGroup) {
                const tSg = subNodes[0];
                subNodes = tSg.nodes;
              }
              if (isNextScopedLogicGroup) {
                const nextTScoped = nextTokenT;
                subNodes.unshift(new ScopeAssignmentOperator());
                subNodes.unshift(nextTScoped.scope);
              }
              const values = this.getArrayValues(subNodes);
              const arrayNode = new ArrayNode();
              arrayNode.startPosition = token.startPosition;
              const valueNodeCount = values.values.length;
              if (valueNodeCount > 0) {
                arrayNode.endPosition = values.values[valueNodeCount - 1].endPosition;
              } else {
                arrayNode.endPosition = token.endPosition;
              }
              if (nextToken.end != null) {
                arrayNode.endPosition = nextToken.end.endPosition;
              }
              arrayNode.nodes = values.values;
              this.createdArrays.push(arrayNode);
              newTokens.push(arrayNode);
              i += 1;
            } else {
              newTokens.push(token);
            }
          } else {
            newTokens.push(token);
          }
        }
        return newTokens;
      }
      getArrayValues(nodes) {
        const valueNode = new ListValueNode(), nodeCount = nodes.length, values = [];
        for (let i = 0; i < nodeCount; i++) {
          const thisNode = nodes[i];
          if (thisNode instanceof ArgSeparator) {
            thisNode.pushError(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_ARR_UNEXPECT_ARG_SEPARATOR,
              thisNode,
              "Unexpected [T_ARG_SEPARATOR] while parsing array."
            ));
            continue;
          }
          if (thisNode instanceof ScopeAssignmentOperator) {
            if (i == 0) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_ARR_KEY_PAIR_MISSING_KEY,
                thisNode,
                "Missing key for key/value pair while parsing array."
              ));
              continue;
            } else {
              if (nodes[i - 1] instanceof ArgSeparator) {
                thisNode.pushError(AntlersError.makeSyntaxError(
                  AntlersErrorCodes.TYPE_ARR_KEY_PAIR_MISSING_KEY,
                  thisNode,
                  "Missing key for key/value pair while parsing array."
                ));
                continue;
              }
            }
          }
          let next = null;
          if (i + 1 < nodeCount) {
            next = nodes[i + 1];
          }
          if (next instanceof ScopeAssignmentOperator) {
            if (i + 2 >= nodeCount) {
              next.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_ARR_KEY_PAIR_VALUE,
                next,
                "Missing key/pair value while parsing array."
              ));
              continue;
            }
            const keyValue = nodes[i + 2];
            const namedValueNode = new NameValueNode();
            if (this.isValidArrayKeyNode(thisNode) == false) {
              thisNode.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_ARR_KEY_PAIR_INVALID_KEY_TYPE,
                thisNode,
                "Invalid [" + TypeLabeler.getPrettyTypeName(thisNode) + "] type for key/value key."
              ));
              continue;
            }
            namedValueNode.name = thisNode;
            namedValueNode.value = keyValue;
            namedValueNode.startPosition = thisNode.startPosition;
            namedValueNode.endPosition = keyValue.endPosition;
            values.push(namedValueNode);
            i += 3;
            continue;
          }
          if (next == null || next instanceof ArgSeparator) {
            const namedValueNode = new NameValueNode();
            namedValueNode.value = thisNode;
            namedValueNode.startPosition = thisNode.startPosition;
            namedValueNode.endPosition = thisNode.endPosition;
            values.push(namedValueNode);
            i += 1;
            continue;
          }
        }
        valueNode.values = values;
        return valueNode;
      }
      isValidArrayKeyNode(node) {
        if (node instanceof NumberNode || node instanceof StringValueNode) {
          return true;
        }
        return false;
      }
      associateModifiers(tokens) {
        const newNodes = [], tokenCount = tokens.length;
        let applyModifiersToNode = null;
        for (let i = 0; i < tokenCount; i++) {
          const node = tokens[i];
          if (node instanceof ModifierSeparator) {
            const newNodeCount = newNodes.length;
            if (newNodeCount == 0) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_MODIFIER_SEPARATOR,
                node,
                "Unexpected [T_MODIFIER_SEPARATOR] while parsing input text."
              ));
              continue;
            }
            this.isRealModifierSeparator.set(node, true);
            applyModifiersToNode = newNodes[newNodeCount - 1];
            if (applyModifiersToNode.modifierChain == null) {
              applyModifiersToNode.modifierChain = new ModifierChainNode();
              applyModifiersToNode.modifierChain.modifierTarget = applyModifiersToNode;
              this.createdModifierChains.push(applyModifiersToNode.modifierChain);
            }
            if (i + 1 >= tokenCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_DETAILS,
                node,
                "Unexpected end of input while preparing to gather modifier details."
              ));
              continue;
            }
            const results = this.scanToEndOfModifier(tokens.slice(i + 1));
            const resultCount = results.length;
            if (resultCount > 1) {
              if (results[1] instanceof InlineBranchSeparator) {
                this.isRealModifierSeparator.set(results[1], true);
                const firstToken = results[0];
                if (firstToken instanceof AdditionOperator) {
                  results[0] = this.wrapArithmeticModifier(firstToken, "add");
                } else if (firstToken instanceof SubtractionOperator) {
                  results[0] = this.wrapArithmeticModifier(firstToken, "subtract");
                } else if (firstToken instanceof DivisionOperator) {
                  results[0] = this.wrapArithmeticModifier(firstToken, "divide");
                } else if (firstToken instanceof MultiplicationOperator) {
                  results[0] = this.wrapArithmeticModifier(firstToken, "multiply");
                } else if (firstToken instanceof ModulusOperator) {
                  results[0] = this.wrapArithmeticModifier(firstToken, "mod");
                }
              }
            }
            if (resultCount == 0) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNSET_MODIFIER_DETAILS,
                node,
                "Invalid or missing modifier details."
              ));
              continue;
            }
            if (results[0] instanceof ModifierNameNode == false) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_MODIFIER_NAME_NOT_START_OF_DETAILS,
                node,
                "Invalid [" + TypeLabeler.getPrettyTypeName(results[0]) + "]; expecting [T_MODIFIER_NAME]"
              ));
              continue;
            }
            const modifier = this.createModifier(results);
            if (modifier.nameNode != null) {
              this.modifierNameMapping.set(modifier.nameNode, modifier);
            }
            i += resultCount;
            applyModifiersToNode.modifierChain.modifierChain.push(modifier);
            applyModifiersToNode.modifierChain.updateValues();
            continue;
          } else {
            newNodes.push(node);
          }
        }
        return newNodes;
      }
      createNullCoalescenceGroups(tokens) {
        const newTokens = [], tokenCount = tokens.length;
        for (let i = 0; i < tokenCount; i++) {
          const node = tokens[i];
          if (node instanceof NullCoalesceOperator) {
            const left = newTokens.pop();
            if (i + 1 >= tokenCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NULL_COALESCENCE_GROUP,
                node,
                "Unexpected end of input while parsing input text."
              ));
              continue;
            }
            const right = tokens[i + 1];
            const nullCoalescenceGroup = new NullCoalescenceGroup();
            nullCoalescenceGroup.left = left;
            nullCoalescenceGroup.right = right;
            newTokens.push(nullCoalescenceGroup);
            i += 1;
            continue;
          } else {
            newTokens.push(node);
          }
        }
        return newTokens;
      }
      isOperand(token) {
        return token instanceof VariableNode || token instanceof LogicGroup || token instanceof StringValueNode || token instanceof NumberNode || token instanceof FalseConstant || token instanceof NullConstant || token instanceof TrueConstant || token instanceof LibraryInvocationConstruct || token instanceof DirectionGroup || token instanceof ListValueNode || token instanceof SwitchGroup || token instanceof ArrayNode || token instanceof TupleListStart;
      }
      isProperMethodChainTargetStrict(token) {
        return token instanceof LogicGroup || token instanceof StringValueNode || token instanceof NumberNode || token instanceof FalseConstant || token instanceof NullConstant || token instanceof TrueConstant || token instanceof LibraryInvocationConstruct || token instanceof DirectionGroup || token instanceof ListValueNode || token instanceof SwitchGroup || token instanceof ArrayNode;
      }
      assertOperandRight(tokens, i) {
        if (i + 1 > tokens.length - 1) {
          tokens[i].pushError(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT,
            tokens[i],
            "Unexpected end of input; expecting operand for operator " + TypeLabeler.getPrettyTypeName(tokens[i]) + ' near "' + LineRetriever.getNearText(tokens[i]) + '".'
          ));
          return false;
        }
        const token = tokens[i + 1];
        if (!this.isOperand(token)) {
          token.pushError(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_EXPECTING_OPERAND,
            tokens[i],
            "Expecting operand, found " + TypeLabeler.getPrettyTypeName(token) + ' near "' + LineRetriever.getNearText(tokens[i]) + '".'
          ));
          return false;
        }
        return true;
      }
      resolveValueRight(nodes, index) {
        let value = null, negationCount = 0, lastNegation = null;
        if (nodes.length > 0) {
          let doContinue = true;
          while (doContinue) {
            const curNode = nodes[index];
            if (curNode instanceof LogicalNegationOperator) {
              lastNegation = curNode;
              negationCount += 1;
              index += 1;
              doContinue = false;
              continue;
            } else if (this.isOperand(curNode)) {
              value = curNode;
              doContinue = false;
              break;
            } else {
              doContinue = false;
              break;
            }
          }
        }
        if (negationCount % 2 != 0) {
          const logicGroup = new LogicGroup();
          logicGroup.nodes = [];
          if (lastNegation != null && value != null) {
            logicGroup.nodes.push(lastNegation);
            logicGroup.nodes.push(value);
          }
          return {
            value: logicGroup,
            negationCount
          };
        }
        return {
          value,
          negationCount
        };
      }
      correctTypes(tokens) {
        const newNodes = [];
        tokens.forEach((node) => {
          if (node instanceof ModifierValueSeparator) {
            const branchSeparator = new InlineBranchSeparator();
            branchSeparator.startPosition = node.startPosition;
            branchSeparator.endPosition = node.endPosition;
            branchSeparator.originalAbstractNode = node;
            newNodes.push(branchSeparator);
          } else if (node instanceof ModifierValueNode) {
            const varNode = new VariableNode();
            varNode.name = node.value;
            varNode.startPosition = node.startPosition;
            varNode.endPosition = node.endPosition;
            varNode.modifierChain = node.modifierChain;
            varNode.originalAbstractNode = node;
            this.createdVariables.push(varNode);
            newNodes.push(varNode);
          } else {
            newNodes.push(node);
          }
        });
        return newNodes;
      }
      createTernaryGroups(tokens) {
        var _a, _b, _c, _d;
        let newTokens = [];
        const tokenCount = tokens.length;
        for (let i = 0; i < tokenCount; i++) {
          const node = tokens[i];
          if (node instanceof InlineTernarySeparator) {
            const separator = this.seek(InlineBranchSeparator, i + 1);
            if (((_a = separator.node) == null ? void 0 : _a.originalAbstractNode) != null) {
              if (separator.node.originalAbstractNode instanceof ModifierValueSeparator) {
                separator.node.originalAbstractNode.isTenaryBranchSeparator = true;
              }
            }
            if (separator.found == false) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_TERNARY_EXPECTING_BRANCH_SEPARATOR,
                node,
                "Unexpected end of input; expecting [T_BRANCH_SEPARATOR]."
              ));
              continue;
            }
            const result = this.collectUntil(newTokens);
            newTokens = result.tokens;
            const condition = result.collectedTokens[0];
            const targetTokenIndex = (_b = separator.foundAt) != null ? _b : 0;
            if (targetTokenIndex >= tokenCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP,
                node,
                "Unexpected end of input while parsing ternary group."
              ));
              continue;
            }
            const truthBranch = tokens.slice(i + 1, targetTokenIndex);
            if (truthBranch.length > 1 || truthBranch.length == 0) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_TERNARY_UNEXPECTED_EXPRESSION_LENGTH,
                node,
                "Unexpected number of operations within ternary truth branch."
              ));
              continue;
            }
            const truthBranchNodes = truthBranch[0];
            const falseBranchStart = ((_c = separator.foundAt) != null ? _c : 0) + 1;
            if (falseBranchStart >= tokenCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP_FALSE_BRANCH,
                node,
                "Unexpected end of input while parsing ternary false execution branch."
              ));
              continue;
            }
            const falseBranch = tokens[falseBranchStart];
            const ternaryStructure = new TernaryCondition();
            ternaryStructure.head = condition;
            ternaryStructure.truthBranch = truthBranchNodes;
            ternaryStructure.falseBranch = falseBranch;
            newTokens.push(ternaryStructure);
            const targetJumpIndex = ((_d = separator.foundAt) != null ? _d : 0) + 1;
            i = targetJumpIndex;
            continue;
          } else {
            newTokens.push(node);
          }
        }
        return newTokens;
      }
      groupNodesByType(nodes, type2) {
        const newNodes = [], nodeCount = nodes.length;
        for (let i = 0; i < nodeCount; i++) {
          const node = nodes[i];
          if (i > 0 && node instanceof type2) {
            const left = [];
            const poppedLeft = newNodes.pop();
            left.push(poppedLeft);
            if (!this.assertOperandRight(nodes, i)) {
              continue;
            }
            if (i + 1 >= nodeCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_REDUCING_NEGATION_OPERATORS,
                node,
                "Unexpected end of input while parsing input text."
              ));
              continue;
            }
            const right = nodes[i + 1];
            if (typeof right !== "undefined") {
              right.isVirtualGroupMember = true;
            }
            if (typeof poppedLeft !== "undefined") {
              poppedLeft.isVirtualGroupMember = true;
            }
            node.isVirtualGroupMember = true;
            const logicGroup = new LogicGroup();
            logicGroup.nodes = left;
            logicGroup.nodes.push(node);
            logicGroup.nodes.push(right);
            i += 1;
            newNodes.push(logicGroup);
            continue;
          } else {
            newNodes.push(node);
          }
        }
        return newNodes;
      }
      flagNodeAsOperatorResolve(node) {
        if (node instanceof LogicGroup) {
          if (node.nodes.length == 0) {
            return;
          }
          this.flagNodeAsOperatorResolve(node.nodes[node.nodes.length - 1]);
        }
        node.isVirtualGroupOperatorResolve = true;
        if (node.next instanceof StatementSeparatorNode == false) {
          node.producesVirtualStatementTerminator = true;
        }
      }
      groupNodesByOperatorType(nodes) {
        const newNodes = [], nodeCount = nodes.length;
        for (let i = 0; i < nodeCount; i++) {
          const node = nodes[i];
          if (i > 0 && LanguageParser.isOperatorType(node)) {
            const left = [];
            const poppedLeft = newNodes.pop();
            left.push(poppedLeft);
            if (!this.assertOperandRight(nodes, i)) {
              continue;
            }
            if (i + 1 >= nodeCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_REDUCING_NEGATION_OPERATORS,
                node,
                "Unexpected end of input while parsing input text."
              ));
              continue;
            }
            const right = nodes[i + 1];
            this.flagNodeAsOperatorResolve(right);
            if (LanguageParser.isAssignmentOperator(node)) {
              this.tracedAssignments.push(new StaticTracedAssignment(poppedLeft, right, node));
            }
            if (typeof poppedLeft !== "undefined") {
              poppedLeft.isVirtualGroupMember = true;
            }
            if (typeof right !== "undefined") {
              right.isVirtualGroupMember = true;
            }
            node.isVirtualGroupMember = true;
            const logicGroup = new LogicGroup();
            logicGroup.nodes = left;
            logicGroup.nodes.push(node);
            logicGroup.nodes.push(right);
            i += 1;
            newNodes.push(logicGroup);
            continue;
          } else {
            newNodes.push(node);
          }
        }
        return newNodes;
      }
      applyOperationOrder(nodes) {
        nodes = this.groupNodesByType(nodes, ExponentiationOperator);
        nodes = this.groupNodesByType(nodes, MultiplicationOperator);
        nodes = this.groupNodesByType(nodes, DivisionOperator);
        nodes = this.groupNodesByType(nodes, AdditionOperator);
        nodes = this.groupNodesByType(nodes, SubtractionOperator);
        return nodes;
      }
      createLogicGroupsToRemoveMethodInvocationAmbiguity(nodes) {
        const newNodes = [], nodeLen = nodes.length, lastNodeIndex = nodeLen - 1;
        for (let i = 0; i < nodeLen; i++) {
          const thisNode = nodes[i];
          if (thisNode instanceof MethodInvocationNode) {
            const lastNode = newNodes.pop();
            const wrapperGroup = new LogicGroup();
            wrapperGroup.startPosition = lastNode.startPosition;
            if (typeof lastNode !== "undefined") {
              lastNode.isVirtualGroupMember = true;
            }
            if (typeof thisNode !== "undefined") {
              thisNode.isVirtualGroupMember = true;
            }
            wrapperGroup.nodes.push(lastNode);
            wrapperGroup.nodes.push(thisNode);
            if (i != lastNodeIndex) {
              for (let j = i + 1; j < nodeLen; j++) {
                if (nodes[j] instanceof MethodInvocationNode) {
                  if (typeof nodes[j] === "undefined") {
                    continue;
                  }
                  nodes[j].isVirtualGroupMember = true;
                  wrapperGroup.nodes.push(nodes[j]);
                  if (j == lastNodeIndex) {
                    j += 1;
                    break;
                  }
                } else {
                  if (j == lastNodeIndex) {
                    j += 1;
                    break;
                  }
                  i = j - 1;
                  break;
                }
              }
            }
            wrapperGroup.endPosition = wrapperGroup.nodes[wrapperGroup.nodes.length - 1].endPosition;
            newNodes.push(wrapperGroup);
          } else {
            newNodes.push(thisNode);
          }
        }
        return newNodes;
      }
      countTypeRight(tokens, start, type2) {
        let count = 0;
        for (let i = start; i < tokens.length; i++) {
          if (tokens[i] instanceof type2) {
            count += 1;
          } else {
            break;
          }
        }
        return count;
      }
      createLogicGroupsToResolveOperatorAmbiguity(nodes) {
        nodes = this.groupNodesByType(nodes, GreaterThanEqualCompOperator);
        nodes = this.groupNodesByType(nodes, GreaterThanCompOperator);
        nodes = this.groupNodesByType(nodes, LessThanEqualCompOperator);
        nodes = this.groupNodesByType(nodes, LessThanCompOperator);
        nodes = this.groupNodesByType(nodes, StrictEqualCompOperator);
        nodes = this.groupNodesByType(nodes, EqualCompOperator);
        nodes = this.groupNodesByType(nodes, NotStrictEqualCompOperator);
        nodes = this.groupNodesByType(nodes, NotEqualCompOperator);
        nodes = this.groupNodesByType(nodes, SpaceshipCompOperator);
        nodes = this.groupNodesByOperatorType(nodes);
        return nodes;
      }
      createModifier(tokens) {
        const modifierName = tokens.shift(), values = [], tokenCount = tokens.length;
        if (tokens.length > 0 && tokens[0] instanceof LogicGroup) {
          const unwrapped = this.unpack(tokens[0].nodes), tArgGroup = this.makeArgGroup(unwrapped);
          tArgGroup.endPosition = tokens[0].endPosition;
          const modifier = new ModifierNode();
          modifier.nameNode = modifierName;
          modifier.methodStyleArguments = tArgGroup;
          if (tokens.length > 1) {
            for (let i = 1; i < tokenCount; i++) {
              tokens[i].pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_TOKEN_METHOD_SYNTAX,
                tokens[i],
                "Unexpected [" + TypeLabeler.getPrettyTypeName(tokens[i]) + "] while parsing modifier argument group. Expecting [T_MODIFIER_SEPARATOR] or end of current expression."
              ));
            }
          }
          modifier.startPosition = modifierName.startPosition;
          modifier.endPosition = tArgGroup.endPosition;
          return modifier;
        }
        for (let i = 0; i < tokenCount; i++) {
          if (tokens[i] instanceof ModifierValueSeparator || tokens[i] instanceof InlineBranchSeparator) {
            if (i + 1 >= tokenCount) {
              tokens[i].pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_END_OF_VALUE_LIST,
                tokens[i],
                "Unexpected end of modifier value list while parsing modifier."
              ));
              return tokens;
            }
            const next = tokens[i + 1];
            if (this.isValidModifierValue(next)) {
              if (next instanceof VariableNode) {
                if (next.variableReference != null && next.variableReference.pathParts.length > 0) {
                  next.variableReference.pathParts.forEach((combinedPart) => {
                    if (combinedPart instanceof PathNode) {
                      const modifierValue = new ModifierValueNode();
                      modifierValue.startPosition = combinedPart.startPosition;
                      modifierValue.endPosition = combinedPart.endPosition;
                      modifierValue.value = combinedPart.name;
                      modifierValue.name = combinedPart.name;
                      modifierValue.originalAbstractNode = combinedPart;
                      if (modifierValue.endPosition == null && modifierValue.startPosition == null) {
                        modifierValue.startPosition = next.startPosition;
                        modifierValue.endPosition = next.endPosition;
                      }
                      values.push(modifierValue);
                    }
                  });
                } else {
                  const modifierValue = new ModifierValueNode();
                  modifierValue.startPosition = next.startPosition;
                  modifierValue.endPosition = next.endPosition;
                  modifierValue.value = next.name;
                  modifierValue.name = next.name;
                  modifierValue.originalAbstractNode = next;
                  values.push(modifierValue);
                }
              } else {
                values.push(next);
              }
              i += 1;
              continue;
            } else {
              next.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_VALUE,
                next,
                "Unexpected [" + TypeLabeler.getPrettyTypeName(next) + "] while parsing modifier value."
              ));
              return tokens;
            }
          }
        }
        const modifierNode = new ModifierNode();
        modifierNode.nameNode = modifierName;
        modifierNode.valueNodes = values;
        modifierNode.startPosition = modifierNode.nameNode.startPosition;
        if (modifierNode.valueNodes.length > 0) {
          modifierNode.endPosition = modifierNode.valueNodes[modifierNode.valueNodes.length - 1].endPosition;
        } else {
          modifierNode.endPosition = modifierNode.nameNode.endPosition;
        }
        return modifierNode;
      }
      scanToEndOfModifier(tokens) {
        const subTokens = [], tokenCount = tokens.length;
        for (let i = 0; i < tokenCount; i++) {
          const subToken = tokens[i];
          if (subToken instanceof ModifierValueSeparator) {
            const subTokenCount = subTokens.length;
            if (subTokenCount == 0) {
              subToken.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_VALUE,
                subToken,
                "Unexpected end of input while parsing modifier value."
              ));
              continue;
            }
            this.isRealModifierSeparator.set(subToken, true);
            const last = subTokens[subTokenCount - 1];
            if (NodeHelpers.distance(last, subToken) > 1) {
              break;
            }
          }
          if (subToken instanceof StringValueNode || subToken instanceof VariableNode || subToken instanceof NumberNode) {
            const subTokenCount = subTokens.length;
            if (subTokenCount > 0) {
              const last = subTokens[subTokenCount - 1];
              if (last instanceof LogicGroup) {
                break;
              }
            }
          }
          if (subToken instanceof ModifierSeparator || subToken instanceof LogicGroupEnd || subToken instanceof LogicGroupBegin || subToken instanceof EqualCompOperator || subToken instanceof GreaterThanCompOperator || subToken instanceof GreaterThanEqualCompOperator || subToken instanceof LessThanCompOperator || subToken instanceof LessThanEqualCompOperator || subToken instanceof NotEqualCompOperator || subToken instanceof NotStrictEqualCompOperator || subToken instanceof SpaceshipCompOperator || subToken instanceof StrictEqualCompOperator || subToken instanceof LogicalAndOperator || subToken instanceof LogicalOrOperator || subToken instanceof LogicalXorOperator || subToken instanceof NullCoalesceOperator || subToken instanceof StringConcatenationOperator || subToken instanceof LanguageOperatorConstruct || subToken instanceof LibraryInvocationConstruct || subToken instanceof MethodInvocationNode || subToken instanceof LogicalNegationOperator) {
            break;
          } else {
            subTokens.push(subToken);
          }
        }
        return subTokens;
      }
      static isAssignmentOperatorNode(node) {
        return node instanceof AdditionAssignmentOperator || node instanceof DivisionAssignmentOperator || node instanceof LeftAssignmentOperator || node instanceof ModulusAssignmentOperator || node instanceof MultiplicationAssignmentOperator || node instanceof SubtractionOperator;
      }
      insertAutomaticStatementSeparators(tokens) {
        const tokenCount = tokens.length, adjustedTokens = [];
        for (let i = 0; i < tokenCount; i++) {
          const thisToken = tokens[i];
          if (LanguageParser.isAssignmentOperatorNode(thisToken)) {
            if (i + 2 < tokenCount) {
              const peek = tokens[i + 2];
              if (peek instanceof StatementSeparatorNode == false) {
                adjustedTokens.push(thisToken);
                adjustedTokens.push(tokens[i + 1]);
                adjustedTokens.push(new StatementSeparatorNode());
                i += 1;
                continue;
              } else {
                adjustedTokens.push(thisToken);
                adjustedTokens.push(tokens[i + 1]);
                adjustedTokens.push(tokens[i + 2]);
                i += 2;
                continue;
              }
            } else {
              adjustedTokens.push(thisToken);
              adjustedTokens.push(tokens[i + 1]);
              adjustedTokens.push(new StatementSeparatorNode());
              break;
            }
          } else {
            adjustedTokens.push(thisToken);
          }
        }
        return tokens;
      }
      createSemanticGroups(tokens) {
        const groups = [], tokenCount = tokens.length;
        let groupNodes = [];
        for (let i = 0; i < tokenCount; i++) {
          if (tokens[i] instanceof StatementSeparatorNode) {
            const semanticGroup = new SemanticGroup();
            semanticGroup.nodes = groupNodes;
            semanticGroup.separatorToken = tokens[i];
            groups.push(semanticGroup);
            groupNodes = [];
            continue;
          } else {
            groupNodes.push(tokens[i]);
            if (i + 1 >= tokenCount) {
              const semanticGroup = new SemanticGroup();
              semanticGroup.nodes = groupNodes;
              groups.push(semanticGroup);
              break;
            }
          }
        }
        return groups;
      }
      findLogicalGroupEnd(root, nodes) {
        const subNodes = [], nodeCount = nodes.length;
        let end = null, skipCount = 0, i = 0;
        for (i; i < nodeCount; i++) {
          const node = nodes[i];
          skipCount += 1;
          if (node instanceof LogicGroupEnd) {
            end = node;
            break;
          } else if (node instanceof LogicGroupBegin) {
            if (i + 1 >= nodeCount) {
              node.pushError(AntlersError.makeSyntaxError(
                AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END,
                node,
                "Unexpected end of input while parsing input text."
              ));
              return {
                found: false,
                logicalGroup: null,
                skipCount
              };
            }
            const subGroup = this.findLogicalGroupEnd(node, nodes.slice(i + 1));
            if (subGroup.found) {
              if (subGroup.logicalGroup != null) {
                subNodes.push(subGroup.logicalGroup);
              }
              skipCount += subGroup.skipCount;
              i += subGroup.skipCount;
              continue;
            } else {
              continue;
            }
          } else {
            subNodes.push(node);
          }
        }
        if (end == null) {
          root.pushError(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_END,
            root,
            "Unexpected end of input while parsing logic group."
          ));
          return {
            found: false,
            logicalGroup: null,
            skipCount
          };
        }
        const parser = new LanguageParser();
        parser.setIsRoot(false);
        let logicalGroup = new LogicGroup();
        if (subNodes.length >= 2 && subNodes[1] instanceof ScopeAssignmentOperator) {
          logicalGroup = new ScopedLogicGroup();
          logicalGroup.scopeOperator = subNodes[1];
          if (i + 2 < nodeCount && nodes[i + 1] instanceof VariableNode && nodes[i + 2] instanceof StringValueNode) {
            const candidateVarNode = nodes[i + 1];
            if (candidateVarNode.name == LanguageKeywords.ScopeAs) {
              const aliasNode = nodes[i + 2];
              logicalGroup = new AliasedScopeLogicGroup();
              if (logicalGroup instanceof AliasedScopeLogicGroup) {
                logicalGroup.alias = aliasNode;
              }
              skipCount += 2;
            }
          }
          const scopedNodes = subNodes.splice(0, 2);
          if (logicalGroup instanceof ScopedLogicGroup || logicalGroup instanceof AliasedScopeLogicGroup) {
            logicalGroup.scope = scopedNodes[0];
          }
        }
        logicalGroup.nodes = parser.parse(subNodes);
        logicalGroup.start = root;
        logicalGroup.end = end;
        logicalGroup.startPosition = root.startPosition;
        logicalGroup.endPosition = end.endPosition;
        if (logicalGroup instanceof AliasedScopeLogicGroup) {
          if (logicalGroup.alias != null) {
            logicalGroup.endPosition = logicalGroup.alias.endPosition;
          }
        }
        return {
          found: true,
          logicalGroup,
          skipCount
        };
      }
      unpack(tokens) {
        if (tokens.length == 0) {
          return [];
        }
        if (tokens[0] instanceof SemanticGroup) {
          const wSg = tokens[0];
          return this.unpack(wSg.nodes);
        }
        return tokens;
      }
      collectUntil(tokens) {
        const len = tokens.length;
        let collectedTokens = [];
        for (let i = len - 1; i >= 0; i--) {
          if (LanguageParser.isAssignmentOperator(tokens[i])) {
            break;
          }
          const token = tokens.pop();
          collectedTokens.push(token);
        }
        collectedTokens = collectedTokens.reverse();
        if (collectedTokens.length >= 3) {
          const parser = new LanguageParser();
          parser.setIsRoot(false);
          return {
            collectedTokens: this.unpack(parser.parse(collectedTokens)),
            tokens
          };
        }
        return {
          collectedTokens,
          tokens
        };
      }
      seek(type2, startingAt) {
        for (let i = startingAt; i < this.tokens.length; i++) {
          if (this.tokens[i] instanceof type2) {
            return {
              found: true,
              foundAt: i,
              node: this.tokens[i]
            };
          }
        }
        return {
          found: false,
          foundAt: null,
          node: null
        };
      }
    };
  }
});

// server/src/runtime/document/scanners/wordScanner.ts
var WordScanner;
var init_wordScanner = __esm({
  "server/src/runtime/document/scanners/wordScanner.ts"() {
    "use strict";
    init_documentParser();
    init_stringUtilities();
    WordScanner = class {
      static findRightBeighboringNextPunctuation(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index + 1; i < text.length; i++) {
          const cur = text[i];
          if (StringUtilities.ctypeSpace(cur)) {
            okayToBreak = true;
          }
          if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
            return null;
          }
          if (StringUtilities.ctypePunct(cur) || cur == DocumentParser.String_Terminator_SingleQuote || cur == DocumentParser.String_Terminator_DoubleQuote) {
            return cur;
          }
        }
        return null;
      }
      static findRightNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index + 1; i < text.length; i++) {
          const cur = text[i];
          if (StringUtilities.ctypeSpace(cur) || StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore) {
            okayToBreak = true;
          }
          if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
            return i + 1;
          }
        }
        return null;
      }
      static findLeftNeighboringNextPunctuation(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index - 2; i >= 0; i--) {
          const cur = text[i];
          if (StringUtilities.ctypeSpace(cur)) {
            okayToBreak = true;
          }
          if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
            return null;
          }
          if (StringUtilities.ctypePunct(cur)) {
            return cur;
          }
        }
        return null;
      }
      static findLeftNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        let okayToBreak = false;
        for (let i = index - 1; i >= 0; i--) {
          const cur = text[i];
          if (StringUtilities.ctypeSpace(cur) || StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore) {
            okayToBreak = true;
          }
          if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
            return i + 1;
          }
        }
        return null;
      }
      static scanWordAt(index, text, tabSize = 4) {
        text = text.replace("	", " ".repeat(tabSize));
        if (index < 0 || index > text.length) {
          return null;
        }
        const leftChars = [], rightChars = [];
        for (let i = index - 1; i >= 0; i--) {
          const cur = text[i];
          if (StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore || StringUtilities.ctypeSpace(cur)) {
            break;
          }
          leftChars.push(cur);
        }
        for (let i = index; i < text.length; i++) {
          const cur = text[i];
          if (StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore || StringUtilities.ctypeSpace(cur)) {
            break;
          }
          rightChars.push(cur);
        }
        return leftChars.reverse().join("") + rightChars.join("");
      }
    };
  }
});

// server/src/runtime/parser/virtualDocument/virtualHierarchy.ts
var VirtualHierarchy;
var init_virtualHierarchy = __esm({
  "server/src/runtime/parser/virtualDocument/virtualHierarchy.ts"() {
    "use strict";
    init_abstractNode();
    VirtualHierarchy = class {
      constructor(parser) {
        this.parser = parser;
      }
      findParentWithName(name, anchor) {
        let currentParent = anchor.parent;
        while (currentParent != null) {
          if (currentParent instanceof AntlersNode && currentParent.nameMatches(name)) {
            return currentParent;
          }
          if (currentParent.parent == currentParent) {
            break;
          }
          currentParent = currentParent.parent;
        }
        return null;
      }
    };
  }
});

// server/src/runtime/analyzers/modifierAnalyzer.ts
var ModifierAnalyzer;
var init_modifierAnalyzer = __esm({
  "server/src/runtime/analyzers/modifierAnalyzer.ts"() {
    "use strict";
    init_modifierManager();
    ModifierAnalyzer = class {
      static analyzeModifierNodeParameters(node) {
        var _a, _b, _c, _d;
        node.parameters.forEach((parameter) => {
          var _a2, _b2, _c2, _d2;
          parameter.isModifierParameter = (_b2 = (_a2 = modifierManager_default.instance) == null ? void 0 : _a2.hasModifier(parameter.name)) != null ? _b2 : false;
          if (parameter.isModifierParameter) {
            node.modifiers.parameterModifiers.push(parameter);
            parameter.modifier = (_d2 = (_c2 = modifierManager_default.instance) == null ? void 0 : _c2.getModifier(parameter.name)) != null ? _d2 : null;
            if (node.modifiers.modifierNames.includes(parameter.name) == false) {
              node.modifiers.modifierNames.push(parameter.name);
            }
          }
        });
        if (node.modifierChain != null && node.modifierChain.modifierChain.length > 0) {
          let lastModifier = null;
          node.modifierChain.modifierChain.forEach((modifier) => {
            var _a2, _b2;
            if (modifier.nameNode != null) {
              modifier.modifier = (_b2 = (_a2 = modifierManager_default.instance) == null ? void 0 : _a2.getModifier(modifier.nameNode.content)) != null ? _b2 : null;
              if (node.modifiers.modifierNames.includes(modifier.nameNode.content) == false) {
                node.modifiers.modifierNames.push(modifier.nameNode.content);
              }
              if (modifier.modifier != null) {
                lastModifier = modifier.modifier;
                if (node.modifierChain != null) {
                  node.modifierChain.lastManifestedModifier = modifier;
                }
              }
            }
          });
          node.modifierChain.lastModifier = lastModifier;
          if (node.modifiers.parameterModifiers.length > 0) {
            node.modifiers.hasMixedModifierStyles = true;
          }
        }
        if (node.runtimeNodes.length > 0) {
          node.runtimeNodes.forEach((runtimeNode) => {
            if (runtimeNode.modifierChain != null && runtimeNode.modifierChain.modifierChain.length > 0) {
              let lastModifier = null;
              runtimeNode.modifierChain.modifierChain.forEach((modifier) => {
                var _a2, _b2;
                if (modifier.nameNode != null) {
                  modifier.modifier = (_b2 = (_a2 = modifierManager_default.instance) == null ? void 0 : _a2.getModifier(modifier.nameNode.content)) != null ? _b2 : null;
                  if (node.modifiers.modifierNames.includes(modifier.nameNode.content) == false) {
                    node.modifiers.modifierNames.push(modifier.nameNode.content);
                  }
                  if (modifier.modifier != null) {
                    lastModifier = modifier.modifier;
                    if (node.modifierChain != null) {
                      node.modifierChain.lastManifestedModifier = modifier;
                    }
                  }
                }
              });
              if (node.modifierChain != null) {
                node.modifierChain.lastModifier = lastModifier;
              }
              if (node.modifiers.parameterModifiers.length > 0) {
                node.modifiers.hasMixedModifierStyles = true;
              }
            }
          });
        }
        const lastManifestModifier = node.modifiers.getLastManifestedModifier();
        if (lastManifestModifier != null) {
          if (lastManifestModifier.name == "macro") {
            const macroName = node.modifiers.getLastManifestedModifierValue();
            node.manifestType = (_b = (_a = modifierManager_default.instance) == null ? void 0 : _a.getMacroManifestingType(macroName)) != null ? _b : "";
          } else {
            node.manifestType = (_d = (_c = modifierManager_default.instance) == null ? void 0 : _c.getProbableReturnType(lastManifestModifier, node.isPaired())) != null ? _d : "";
          }
        }
      }
    };
  }
});

// server/src/runtime/parser/scanners/isStartOfString.ts
function isStartOfString(char) {
  if (char == null) {
    return false;
  }
  if (char == '"' || char == "'") {
    return true;
  }
  return false;
}
var init_isStartOfString = __esm({
  "server/src/runtime/parser/scanners/isStartOfString.ts"() {
    "use strict";
  }
});

// server/src/runtime/parser/scanners/skipToEndOfLine.ts
function skipToEndOfLine(iterator, collect) {
  for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
    iterator.checkCurrentOffsets();
    if (collect) {
      iterator.pushChar(iterator.getCurrent());
    }
    if (iterator.getCurrent() == DocumentParser.NewLine) {
      break;
    }
  }
}
var init_skipToEndOfLine = __esm({
  "server/src/runtime/parser/scanners/skipToEndOfLine.ts"() {
    "use strict";
    init_documentParser();
  }
});

// server/src/runtime/parser/scanners/skipToEndOfMultilineComment.ts
function skipToEndOfMultilineComment(iterator, collect) {
  for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
    iterator.checkCurrentOffsets();
    if (collect) {
      iterator.pushChar(iterator.getCurrent());
    }
    if (iterator.getCurrent() == DocumentParser.Punctuation_Asterisk && iterator.getNext() == DocumentParser.Punctuation_ForwardSlash) {
      if (collect) {
        iterator.pushChar(DocumentParser.Punctuation_ForwardSlash);
      }
      iterator.incrementIndex();
      iterator.checkCurrentOffsets();
      break;
    }
  }
}
var init_skipToEndOfMultilineComment = __esm({
  "server/src/runtime/parser/scanners/skipToEndOfMultilineComment.ts"() {
    "use strict";
    init_documentParser();
  }
});

// server/src/runtime/parser/scanners/skipToEndOfString.ts
function skipToEndOfString(iterator) {
  const stringInitializer = iterator.getCurrent();
  iterator.incrementIndex();
  for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
    iterator.checkCurrentOffsets();
    if (iterator.getCurrent() == stringInitializer && iterator.getPrev() != DocumentParser.String_EscapeCharacter) {
      break;
    }
  }
}
var init_skipToEndOfString = __esm({
  "server/src/runtime/parser/scanners/skipToEndOfString.ts"() {
    "use strict";
    init_documentParser();
  }
});

// server/src/runtime/parser/fragmentsParser.ts
var FragmentsParser;
var init_fragmentsParser = __esm({
  "server/src/runtime/parser/fragmentsParser.ts"() {
    "use strict";
    init_abstractNode();
    init_position();
    init_stringUtilities();
    init_documentParser();
    init_isStartOfString();
    init_skipToEndOfLine();
    init_skipToEndOfMultilineComment();
    init_skipToEndOfString();
    FragmentsParser = class {
      constructor() {
        this.content = "";
        this.nodeIndex = [];
        this.fragmentStartIndex = [];
        this.charLen = 0;
        this.documentOffsets = /* @__PURE__ */ new Map();
        this.inputLen = 0;
        this.seedOffset = 0;
        this.shiftLine = 0;
        this.chars = [];
        this.currentIndex = 0;
        this.lastDocumentOffsetKey = null;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.chunkSize = 5;
        this.currentChunkOffset = 0;
        this.fragments = [];
        this.isScript = false;
        this.fragmentOpeningIndex = /* @__PURE__ */ new Map();
        this.indexedFragments = /* @__PURE__ */ new Map();
        this.embeddedIndexedFragments = /* @__PURE__ */ new Map();
      }
      updateIndex(index) {
        this.currentIndex = index;
      }
      inputLength() {
        return this.inputLen;
      }
      incrementIndex() {
        this.currentIndex += 1;
      }
      getCurrentIndex() {
        return this.currentIndex;
      }
      getCurrent() {
        return this.cur;
      }
      getNext() {
        return this.next;
      }
      getPrev() {
        return this.prev;
      }
      pushChar(value) {
        return;
      }
      getChar(index) {
        return this.chars[index];
      }
      getSeedOffset() {
        return this.seedOffset;
      }
      setDocumentOffsets(offsets, lastOffsetIndex) {
        this.documentOffsets = offsets;
        this.lastDocumentOffsetKey = lastOffsetIndex;
        return this;
      }
      getClosingFragmentAfter(fragment) {
        if (typeof fragment === "undefined") {
          return null;
        }
        const lowerName = fragment.name.toLowerCase();
        for (let i = 0; i < this.fragments.length; i++) {
          const thisFragment = this.fragments[i];
          if (thisFragment.isClosingFragment && !thisFragment.isSelfClosing && thisFragment.name.toLowerCase() == lowerName && thisFragment.index > fragment.index) {
            return thisFragment;
          }
        }
        return null;
      }
      getContentSubstring(from, length) {
        return this.content.substr(from, length);
      }
      resetState() {
        this.fragments = [];
        this.inputLen = 0;
        this.fragmentStartIndex = [];
        this.fragmentOpeningIndex.clear();
        return this;
      }
      resetIntermediateState() {
        this.chars = [];
        this.charLen = 0;
        this.currentIndex = 0;
        this.seedOffset = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
      }
      positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
          if (this.documentOffsets.size == 0) {
            lineToUse = 1;
            charToUse = offset + 1;
          } else {
            let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
            for (const documentOffset of this.documentOffsets.keys()) {
              if (documentOffset >= offset) {
                if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                  nearestOffset = lastOffset;
                  nearestOffsetIndex = lastOffsetIndex;
                } else {
                  nearestOffset = this.documentOffsets.get(documentOffset);
                  nearestOffsetIndex = documentOffset;
                }
                break;
              }
              lastOffset = this.documentOffsets.get(documentOffset);
              lastOffsetIndex = documentOffset;
            }
            if (nearestOffset == null) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            }
            if (nearestOffset != null) {
              if (isRelativeOffset) {
                const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              } else {
                const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              }
            } else {
              if (this.lastDocumentOffsetKey != null) {
                const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
                lineToUse = lastOffset2.line + 1;
                charToUse = offset + this.lastDocumentOffsetKey;
              }
            }
          }
        } else {
          const offsetDetails = this.documentOffsets.get(offset);
          lineToUse = offsetDetails.line;
          charToUse = offsetDetails.char;
        }
        const position = new Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse + this.shiftLine;
        position.char = charToUse;
        return position;
      }
      getFragments() {
        return this.fragments;
      }
      getFragmentsBetween(startIndex, endIndex) {
        const returnFragments = [];
        this.fragments.forEach((fragment) => {
          var _a, _b, _c, _d;
          const start = (_b = (_a = fragment.startPosition) == null ? void 0 : _a.index) != null ? _b : 0, end = (_d = (_c = fragment.endPosition) == null ? void 0 : _c.index) != null ? _d : 0;
          if (start > startIndex && end < endIndex) {
            returnFragments.push(fragment);
          }
        });
        return returnFragments;
      }
      getFragmentContaining(position) {
        var _a, _b, _c, _d;
        for (let i = 0; i < this.fragments.length; i++) {
          const thisFragment = this.fragments[i];
          if (((_b = (_a = thisFragment.startPosition) == null ? void 0 : _a.index) != null ? _b : 0) < position.index && ((_d = (_c = thisFragment.endPosition) == null ? void 0 : _c.index) != null ? _d : 0) > position.index) {
            return thisFragment;
          }
        }
        return null;
      }
      checkCurrentOffsets() {
        if (this.currentIndex > this.chars.length) {
          this.cur = null;
          this.prev = null;
          this.next = null;
          return;
        }
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
        if (this.currentIndex + 1 < this.inputLen) {
          let doPeek = true;
          if (this.currentIndex == this.charLen - 1) {
            const nextChunk = StringUtilities.split(
              StringUtilities.substring(
                this.content,
                this.currentChunkOffset + this.chunkSize,
                this.chunkSize
              )
            );
            this.currentChunkOffset += this.chunkSize;
            if (this.currentChunkOffset == this.inputLen) {
              doPeek = false;
            }
            nextChunk.forEach((nextChar) => {
              this.chars.push(nextChar);
              this.charLen += 1;
            });
          }
          if (doPeek && this.currentIndex + 1 < this.chars.length) {
            this.next = this.chars[this.currentIndex + 1];
          }
        }
      }
      processInputText(input) {
        this.content = input;
        this.inputLen = this.content.length;
        const fragmentCandidates = [...this.content.matchAll(/(<(?!\?[php|?=]))/gm)], newCandidates = [];
        fragmentCandidates.forEach((candidate) => {
          var _a;
          const candidateIndex = (_a = candidate.index) != null ? _a : 0;
          for (let i = 0; i < this.nodeIndex.length; i++) {
            const thisIndex = this.nodeIndex[i];
            if (candidateIndex >= thisIndex.start && candidateIndex <= thisIndex.end) {
              return;
            }
          }
          newCandidates.push(candidateIndex);
        });
        this.fragmentStartIndex = newCandidates;
      }
      setIndexRanges(index) {
        this.nodeIndex = index;
        return this;
      }
      fetchAt(start, length) {
        return this.content.substr(start, length);
      }
      getFragmentsContainingStructures() {
        const structures = [];
        this.fragments.forEach((fragment) => {
          const lowerName = fragment.name.toLowerCase();
          if (lowerName != "script" && lowerName != "style") {
            return;
          }
          if (!fragment.isClosingFragment && !fragment.isSelfClosing && fragment.containsStructures) {
            const close = this.getClosingFragmentAfter(fragment);
            if (close != null) {
              structures.push({
                start: fragment,
                end: close
              });
            }
          }
        });
        return structures;
      }
      parse(text) {
        this.resetState().processInputText(text);
        const indexCount = this.fragmentStartIndex.length;
        if (indexCount == 0) {
          return [];
        }
        for (let i = 0; i < this.fragmentStartIndex.length; i++) {
          const offset = this.fragmentStartIndex[i];
          this.resetIntermediateState();
          this.seedOffset = offset;
          this.currentChunkOffset = offset;
          this.parseIntermediateText();
          if (this.isScript) {
            let didFind = false;
            for (let j = i + 1; j < this.fragmentStartIndex.length; j++) {
              const checkIndex = this.fragmentStartIndex[j], thisChunk = this.fetchAt(checkIndex, 8).toLowerCase();
              if (thisChunk == "<\/script") {
                i = j - 1;
                this.isScript = false;
                didFind = true;
                break;
              }
            }
            if (!didFind) {
              break;
            }
          }
        }
        let fragmentIndex = 0, embeddedIndex = 0;
        this.fragments.forEach((fragment) => {
          const lowerName = fragment.name.toLowerCase();
          if (lowerName == "script" || lowerName == "style") {
            fragment.embeddedIndex = embeddedIndex;
            this.embeddedIndexedFragments.set(embeddedIndex, fragment);
            embeddedIndex += 1;
          }
          fragment.index = fragmentIndex;
          this.indexedFragments.set(fragmentIndex, fragment);
          fragmentIndex += 1;
        });
        return this.fragments;
      }
      getFragment(index) {
        return this.indexedFragments.get(index);
      }
      getEmbeddedFragment(index) {
        if (!this.embeddedIndexedFragments.has(index)) {
          return null;
        }
        return this.embeddedIndexedFragments.get(index);
      }
      hasFragments() {
        return this.fragments.length > 0;
      }
      skipToEndOfPhp() {
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (isStartOfString(this.cur)) {
            skipToEndOfString(this);
          }
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_ForwardSlash) {
            skipToEndOfLine(this, true);
            continue;
          }
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_Asterisk) {
            skipToEndOfMultilineComment(this, true);
            continue;
          }
          if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_GreaterThan || this.next == null) {
            break;
          }
        }
      }
      parseIntermediateText() {
        this.chars = this.content.substr(this.currentChunkOffset, this.chunkSize).split("");
        this.charLen = this.chars.length;
        const fragmentStartedAt = this.currentIndex, potentialParameterRanges = [], nameChars = [];
        let hasFoundName = false, isClosingFragment = false;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (StringUtilities.ctypeSpace(this.cur)) {
            hasFoundName = true;
          }
          if (this.next == DocumentParser.Punctuation_LessThan) {
            let shift = 1;
            if (this.cur == DocumentParser.Punctuation_ForwardSlash) {
              shift = 2;
            }
            const curFetch = this.fetchAt(this.currentChunkOffset + shift, 5);
            if (curFetch.toLowerCase() == "<?php" || curFetch.startsWith("<?=")) {
              this.skipToEndOfPhp();
              continue;
            }
          }
          if (this.currentIndex > 0 && this.cur == DocumentParser.Punctuation_LessThan) {
            break;
          }
          if (this.next == null && this.cur != DocumentParser.Punctuation_GreaterThan) {
            break;
          }
          if (!hasFoundName && this.cur == DocumentParser.Punctuation_LessThan && this.next == DocumentParser.Punctuation_ForwardSlash) {
            isClosingFragment = true;
          }
          if (!hasFoundName && this.cur != DocumentParser.Punctuation_LessThan && this.cur != DocumentParser.Punctuation_ForwardSlash && this.cur != DocumentParser.Punctuation_GreaterThan) {
            nameChars.push(this.cur);
          }
          if (isStartOfString(this.cur)) {
            const stringStartedOn = this.currentIndex;
            skipToEndOfString(this);
            const fragmentParameter = new FragmentParameterNode();
            fragmentParameter.startPosition = this.positionFromOffset(stringStartedOn + this.seedOffset, stringStartedOn + this.seedOffset);
            fragmentParameter.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
            const startedOn = stringStartedOn + this.seedOffset, endedOn = this.currentIndex + this.seedOffset + 1;
            fragmentParameter.content = this.content.substr(startedOn, endedOn - startedOn);
            const nameChars2 = [];
            for (let j = stringStartedOn - 2; j >= 0; j--) {
              const cur = this.chars[j];
              if (StringUtilities.ctypeSpace(cur)) {
                break;
              }
              nameChars2.push(cur);
            }
            fragmentParameter.name = nameChars2.reverse().join("");
            potentialParameterRanges.push(fragmentParameter);
            continue;
          }
          if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_GreaterThan) {
            const fragment = new FragmentNode();
            fragment.startPosition = this.positionFromOffset(fragmentStartedAt + this.seedOffset, fragmentStartedAt + this.seedOffset);
            fragment.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset + 1, this.currentIndex + this.seedOffset + 1);
            fragment.parameters = potentialParameterRanges;
            fragment.isSelfClosing = true;
            fragment.name = nameChars.join("");
            fragment.isClosingFragment = isClosingFragment;
            this.fragments.push(fragment);
            if (isClosingFragment) {
              this.fragmentOpeningIndex.set(fragment.startPosition.index + 1, 1);
            } else {
              this.fragmentOpeningIndex.set(fragment.startPosition.index, 1);
            }
            break;
          }
          if (this.cur == DocumentParser.Punctuation_GreaterThan) {
            const fragment = new FragmentNode();
            fragment.startPosition = this.positionFromOffset(fragmentStartedAt + this.seedOffset, fragmentStartedAt + this.seedOffset);
            fragment.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
            fragment.parameters = potentialParameterRanges;
            fragment.name = nameChars.join("");
            fragment.isClosingFragment = isClosingFragment;
            this.fragments.push(fragment);
            if (isClosingFragment) {
              this.fragmentOpeningIndex.set(fragment.startPosition.index + 1, 1);
            } else {
              this.fragmentOpeningIndex.set(fragment.startPosition.index, 1);
            }
            if (fragment.name.toLowerCase() == "script" && fragment.isClosingFragment == false) {
              this.isScript = true;
            }
            break;
          }
        }
      }
    };
  }
});

// server/src/runtime/analyzers/fragmentPositionAnalyzer.ts
var FragmentPositionAnalyzer;
var init_fragmentPositionAnalyzer = __esm({
  "server/src/runtime/analyzers/fragmentPositionAnalyzer.ts"() {
    "use strict";
    init_abstractNode();
    init_conditionPairAnalyzer();
    FragmentPositionAnalyzer = class {
      constructor(document, fragments) {
        this.documentParser = document;
        this.fragmentsParser = fragments;
      }
      doesContainFragments(node) {
        var _a, _b, _c, _d, _e;
        const startIndex = (_b = (_a = node.endPosition) == null ? void 0 : _a.index) != null ? _b : 0, endIndex = (_e = (_d = (_c = node.isClosedBy) == null ? void 0 : _c.startPosition) == null ? void 0 : _d.index) != null ? _e : 0;
        return this.fragmentsParser.getFragmentsBetween(startIndex, endIndex).length > 0;
      }
      analyze() {
        const allNodes = this.documentParser.getNodes();
        if (!this.fragmentsParser.hasFragments()) {
          return;
        }
        this.fragmentsParser.getFragments().forEach((fragment) => {
          const lowerName = fragment.name.toLowerCase();
          if (fragment.isClosingFragment == false && fragment.isSelfClosing == false && (lowerName == "script" || lowerName == "style")) {
            const closingFragment = this.fragmentsParser.getClosingFragmentAfter(fragment);
            if (closingFragment == null) {
              return;
            }
            if (fragment.endPosition != null && closingFragment.startPosition != null) {
              const containedNodes = this.documentParser.getNodesBetween(fragment.endPosition, closingFragment.startPosition);
              containedNodes.forEach((node) => {
                if (node instanceof ConditionNode) {
                  fragment.containsStructures = true;
                } else if (node instanceof AntlersNode) {
                  if (node.isClosedBy != null) {
                    fragment.containsStructures = true;
                  }
                }
                if (lowerName == "style") {
                  node.isInStyleTag = true;
                } else {
                  node.isInScriptTag = true;
                }
              });
            }
          }
        });
        allNodes.forEach((node) => {
          var _a, _b, _c, _d, _e, _f;
          if (node instanceof LiteralNode) {
            return;
          }
          if (node.startPosition == null) {
            return;
          }
          if (node instanceof AntlersNode && (ConditionPairAnalyzer.isConditionalStructure(node) || !node.isClosingTag) && node.isClosedBy != null) {
            node.containsAnyFragments = this.doesContainFragments(node);
          }
          const fragment = this.fragmentsParser.getFragmentContaining(node.startPosition);
          if (fragment == null) {
            node.fragmentPosition = 3 /* Unresolved */;
            return;
          }
          node.fragment = fragment;
          const startDelta = node.startPosition.index - ((_b = (_a = fragment.startPosition) == null ? void 0 : _a.index) != null ? _b : 0);
          if (startDelta <= 3) {
            node.fragmentPosition = 0 /* IsDynamicFragmentName */;
            return;
          }
          if (fragment.parameters.length == 0) {
            node.fragmentPosition = 2 /* InsideFragment */;
            return;
          }
          let resolvedParam = false;
          for (let i = 0; i < fragment.parameters.length; i++) {
            const thisParam = fragment.parameters[i];
            if (((_d = (_c = thisParam.startPosition) == null ? void 0 : _c.index) != null ? _d : 0) < node.startPosition.index && ((_f = (_e = thisParam.endPosition) == null ? void 0 : _e.index) != null ? _f : 0) > node.startPosition.index) {
              node.fragmentPosition = 1 /* InsideFragmentParameter */;
              node.fragmentParameter = thisParam;
              resolvedParam = true;
              break;
            }
          }
          if (!resolvedParam) {
            node.fragmentPosition = 2 /* InsideFragment */;
          }
        });
      }
    };
  }
});

// server/src/runtime/analyzers/inlineNodeAnalyzer.ts
var InlineNodeAnalyzer;
var init_inlineNodeAnalyzer = __esm({
  "server/src/runtime/analyzers/inlineNodeAnalyzer.ts"() {
    "use strict";
    init_abstractNode();
    init_stringUtilities();
    InlineNodeAnalyzer = class {
      static analyze(nodes) {
        nodes.forEach((node) => {
          var _a, _b, _c, _d, _e, _f;
          if (node instanceof AntlersNode) {
            if (node.prev instanceof AntlersNode && node.isPaired() && node.prev.isInlineAntlers == true) {
              node.isInlineAntlers = false;
              if (node.isClosedBy != null) {
                node.isClosedBy.isInlineAntlers = false;
              }
              return;
            }
            let isRightInline = false, isLeftInline = false;
            if (node.next == null) {
              isRightInline = true;
            } else if (node.next instanceof LiteralNode) {
              const firstLine = StringUtilities.getFirstLine(node.next.content);
              if (node.next.next == null && firstLine.trim().length == 0) {
                isRightInline = true;
              } else {
                if (StringUtilities.trimLeft(firstLine, " 	").startsWith("\n") == false && firstLine.trim().length > 0) {
                  isRightInline = true;
                } else if (node.next.next instanceof EscapedContentNode) {
                  isRightInline = true;
                } else if (node.next.next instanceof AntlersNode) {
                  if (node.next.next.isPaired() == false) {
                    isRightInline = true;
                  } else {
                    if (((_b = (_a = node.next.next.startPosition) == null ? void 0 : _a.line) != null ? _b : 0) != ((_d = (_c = node.startPosition) == null ? void 0 : _c.line) != null ? _d : 0)) {
                      isRightInline = true;
                    }
                  }
                }
              }
            } else if (node.next instanceof AntlersNode) {
              if (node.next.isPaired()) {
                isRightInline = true;
              }
            }
            if (node.prev == null) {
              isLeftInline = true;
            } else if (node.prev instanceof LiteralNode) {
              const lastLine = StringUtilities.getLastLine(node.prev.content);
              if (StringUtilities.trimRight(lastLine, " 	").endsWith("\n") == false && lastLine.trim().length > 0) {
                isLeftInline = true;
              } else if (node.prev.prev instanceof EscapedContentNode) {
                isLeftInline = true;
              } else if (node.prev.prev instanceof AntlersNode) {
                if (node.prev.prev.isInlineAntlers && ((_e = node.prev.prev.endPosition) == null ? void 0 : _e.line) == ((_f = node.startPosition) == null ? void 0 : _f.line)) {
                  isLeftInline = true;
                } else {
                  if (node.prev.prev.isClosingTag && node.prev.prev.isOpenedBy != null) {
                    if (node.prev.prev.isOpenedBy instanceof EscapedContentNode || node.prev.prev.runtimeName() == "noparse") {
                      node.prev.prev.isInlineAntlers = true;
                      isLeftInline = true;
                    }
                  }
                }
              }
            } else if (node.prev instanceof AntlersNode) {
              if (node.prev.isPaired()) {
                isLeftInline = true;
              }
            }
            node.isInlineAntlers = isRightInline && isLeftInline;
          }
        });
      }
    };
  }
});

// server/src/runtime/parser/documentParser.ts
var import_md52, _DocumentParser, DocumentParser;
var init_documentParser = __esm({
  "server/src/runtime/parser/documentParser.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_abstractNode();
    init_position();
    init_globalRuntimeState();
    init_stringUtilities();
    import_md52 = __toESM(require_md5());
    init_tagIdentifier();
    init_antlersNodeParser();
    init_tagPairAnalyzer();
    init_recursiveParentAnalyzer();
    init_languageParser();
    init_wordScanner();
    init_virtualHierarchy();
    init_tagManagerInstance();
    init_modifierAnalyzer();
    init_modifierManager();
    init_fragmentsParser();
    init_fragmentPositionAnalyzer();
    init_antlersDocument();
    init_helpers();
    init_inlineNodeAnalyzer();
    _DocumentParser = class {
      constructor() {
        this.interpolationRegions = /* @__PURE__ */ new Map();
        this.nodeParser = new AntlersNodeParser();
        this.chars = [];
        this.charLen = 0;
        this.lastAntlersNode = null;
        this.content = "";
        this.originalContent = "";
        this.currentIndex = 0;
        this.currentContent = [];
        this.sourceContent = [];
        this.startIndex = 0;
        this._recoveryStartIndex = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.nodes = [];
        this.renderNodes = [];
        this.isInterpolatedParser = false;
        this.inputLen = 0;
        this.documentOffsets = /* @__PURE__ */ new Map();
        this.lineIndex = /* @__PURE__ */ new Map();
        this.lastDocumentOffsetKey = null;
        this.isDoubleBrace = false;
        this.interpolationEndOffsets = /* @__PURE__ */ new Map();
        this.isScanningInterpolations = false;
        this.seedStartLine = 1;
        this.seedStartchar = 1;
        this.frontMatterEndLine = -1;
        this.lastAntlersEndIndex = -1;
        this.seedOffset = 0;
        this.antlersStartIndex = [];
        this.antlersStartPositionIndex = /* @__PURE__ */ new Map();
        this.chunkSize = 5;
        this.maxLine = 1;
        this.currentChunkOffset = 0;
        this.isNoParse = false;
        this.antlersErrors = [];
        this.structureErrors = [];
        this.languageParser = new LanguageParser();
        this.documentPath = null;
        this.pushedErrors = /* @__PURE__ */ new Map();
        this.frontMatter = "";
        this.shiftLine = 0;
        this.doesHaveUncloseIfStructures = false;
        this.doesHaveUnclosedStructures = false;
        this.parseChildDocuments = false;
        this.structuralErrorCodes = [
          AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL,
          AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL,
          AntlersErrorCodes.TYPE_RECURSIVE_UNPAIRED_NODE,
          AntlersErrorCodes.TYPE_RUNTIME_FATAL_UNPAIRED_LOOP_END,
          AntlersErrorCodes.TYPE_UNPAIRED_CLOSING_TAG
        ];
        this.structure = new VirtualHierarchy(this);
        this.fragmentsParser = new FragmentsParser();
        this.fragmentsAnalyzer = new FragmentPositionAnalyzer(this, this.fragmentsParser);
      }
      withChildDocuments(parseChildDocuments) {
        this.parseChildDocuments = parseChildDocuments;
        return this;
      }
      shouldParseChildDocument() {
        return this.parseChildDocuments;
      }
      hasUnclosedIfStructures() {
        return this.doesHaveUncloseIfStructures;
      }
      hasUnclosedStructures() {
        return this.doesHaveUnclosedStructures;
      }
      getFrontMatter() {
        return this.frontMatter;
      }
      setDocumentPath(path) {
        this.documentPath = path;
      }
      getFrontMatterEndLine() {
        return this.frontMatterEndLine;
      }
      pushError(error) {
        if (error.errorCode == AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL || error.errorCode == AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL) {
          this.doesHaveUncloseIfStructures = true;
        }
        const errorHash = error.hash();
        if (!this.pushedErrors.has(errorHash)) {
          this.pushedErrors.set(errorHash, error);
          this.antlersErrors.push(error);
          if (this.structuralErrorCodes.includes(error.errorCode)) {
            this.structureErrors.push(error);
          }
        }
      }
      getInterpolationRegions() {
        return this.interpolationRegions;
      }
      getDocumentPath() {
        return this.documentPath;
      }
      checkCurrentOffsets() {
        if (this.currentIndex > this.chars.length) {
          this.cur = null;
          this.prev = null;
          this.next = null;
          return;
        }
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
        if (this.currentIndex + 1 < this.inputLen) {
          let doPeek = true;
          if (this.currentIndex == this.charLen - 1) {
            const nextChunk = StringUtilities.split(
              StringUtilities.substring(
                this.content,
                this.currentChunkOffset + this.chunkSize,
                this.chunkSize
              )
            );
            this.currentChunkOffset += this.chunkSize;
            if (this.currentChunkOffset == this.inputLen) {
              doPeek = false;
            }
            nextChunk.forEach((nextChar) => {
              this.chars.push(nextChar);
              this.charLen += 1;
            });
          }
          if (doPeek && this.currentIndex + 1 < this.chars.length) {
            this.next = this.chars[this.currentIndex + 1];
          }
        }
      }
      charLeftAt(position) {
        if (position == null) {
          return null;
        }
        if (position.char <= 1) {
          return null;
        }
        return this.charAt(this.positionFromCursor(position.line, position.char - 1));
      }
      charLeftAtCursor(line, char) {
        return this.charLeftAt(this.positionFromCursor(line, char));
      }
      charRightAt(position) {
        if (position == null) {
          return null;
        }
        return this.charAt(this.positionFromCursor(position.line, position.char + 1));
      }
      charRightAtCursor(line, char) {
        return this.charRightAt(this.positionFromCursor(line, char));
      }
      punctuationLeftAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        return WordScanner.findLeftNeighboringNextPunctuation(position.char, lineText, tabSize);
      }
      punctuationLeftAtCursor(line, char, tabSize = 4) {
        return this.punctuationLeftAt(this.positionFromCursor(line, char), tabSize);
      }
      punctuationRightAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        return WordScanner.findRightBeighboringNextPunctuation(position.char, lineText, tabSize);
      }
      punctuationRightAtCursor(line, char, tabSize = 4) {
        return this.punctuationRightAt(this.positionFromCursor(line, char), tabSize);
      }
      wordRightAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        const rightWordChar = WordScanner.findRightNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
        if (rightWordChar == null) {
          return null;
        }
        return WordScanner.scanWordAt(rightWordChar, lineText, tabSize);
      }
      wordRightAtCursor(line, char, tabSize = 4) {
        return this.wordRightAt(this.positionFromCursor(line, char), tabSize);
      }
      wordLeftAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        const leftWordChar = WordScanner.findLeftNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
        if (leftWordChar == null) {
          return null;
        }
        return WordScanner.scanWordAt(leftWordChar, lineText, tabSize);
      }
      wordLeftAtCursor(line, char, tabSize = 4) {
        return this.wordLeftAt(this.positionFromCursor(line, char), tabSize);
      }
      wordAt(position, tabSize = 4) {
        if (position == null) {
          return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
          return null;
        }
        return WordScanner.scanWordAt(position.char, lineText, tabSize);
      }
      getLineText(lineNumber) {
        const index = this.getLineIndex(lineNumber);
        if (index != null) {
          return StringUtilities.trimRight(this.getContent().substring(index.start, index.end + 1));
        }
        return null;
      }
      wordAtCursor(line, char, tabSize = 4) {
        return this.wordAt(this.positionFromCursor(line, char), tabSize);
      }
      charAt(position) {
        if (position == null) {
          return null;
        }
        return this.content.substr(position.offset, 1);
      }
      getLinesAround(line) {
        var _a;
        const lines = /* @__PURE__ */ new Map();
        let startLine = line - 3, endLine = line + 3;
        if (startLine < 1) {
          startLine = 1;
        }
        if (endLine > this.maxLine) {
          endLine = this.maxLine;
        }
        for (let i = startLine; i <= endLine; i++) {
          lines.set(i, (_a = this.getLineText(i)) != null ? _a : "");
        }
        return lines;
      }
      charAtCursor(line, char) {
        return this.charAt(this.positionFromCursor(line, char));
      }
      getLineIndex(line) {
        if (line == this.maxLine) {
          const lastIndex = this.lineIndex.get(line - 1);
          if (lastIndex != null) {
            const startIndex = lastIndex.endIndex + 1, endIndex = this.inputLen - 1;
            return {
              end: endIndex,
              start: startIndex
            };
          }
          return null;
        }
        const indexEntry = this.lineIndex.get(line);
        if (indexEntry != null) {
          return {
            start: indexEntry.startIndex,
            end: indexEntry.endIndex
          };
        }
        return null;
      }
      positionFromCursor(line, char) {
        if (line == this.maxLine) {
          const lastIndex = this.lineIndex.get(line - 1);
          if (lastIndex != null) {
            const startIndex = lastIndex.endIndex + 1, thisOffset = startIndex + (char - 1);
            const position = new Position();
            position.offset = thisOffset;
            position.line = line;
            position.char = char;
            position.index = thisOffset;
            return position;
          }
          return null;
        }
        const indexEntry = this.lineIndex.get(line);
        if (indexEntry != null) {
          const position = new Position();
          position.offset = indexEntry.startIndex + (char - 1);
          position.line = indexEntry.line;
          position.char = char;
          position.index = indexEntry.startIndex + (char - 1);
          return position;
        }
        return null;
      }
      parse(text) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        this.resetState();
        if (!this.processInputText(text)) {
          return [];
        }
        const indexCount = this.antlersStartIndex.length;
        const lastIndex = indexCount - 1;
        if (indexCount == 0 && !this.isNoParse) {
          const fullDocumentLiteral = new LiteralNode();
          fullDocumentLiteral.withParser(this);
          fullDocumentLiteral.content = this.prepareLiteralContent(this.content);
          fullDocumentLiteral.startPosition = this.positionFromOffset(0, 0);
          fullDocumentLiteral.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
          fullDocumentLiteral.sourceContent = this.content;
          this.nodes.push(fullDocumentLiteral);
        } else {
          for (let i = 0; i < indexCount; i += 1) {
            const offset = this.antlersStartIndex[i];
            this.seedOffset = offset;
            if (i == 0 && offset > 0 && !this.isNoParse) {
              const node = new LiteralNode();
              node.withParser(this);
              node.content = this.prepareLiteralContent(
                this.content.substr(0, offset)
              );
              if (node.content.length > 0) {
                node.startPosition = this.positionFromOffset(0, 0);
                node.endPosition = this.positionFromOffset(offset, offset - 1);
                const startOffset = (_a = node.startPosition.index) != null ? _a : 0, endOffset = node.endPosition.index + 1;
                node.sourceContent = this.content.substr(startOffset, endOffset - startOffset);
                this.nodes.push(node);
              }
            }
            if (offset < this.lastAntlersEndIndex) {
              continue;
            }
            this.currentChunkOffset = offset;
            this.resetIntermediateState();
            this.parseIntermediateText();
            if (this.lastAntlersNode != null && this.lastAntlersNode instanceof PhpExecutionNode == false && (this.lastAntlersNode.isComment && !(this.lastAntlersNode instanceof CommentParserFailNode))) {
              if (i + 1 < indexCount) {
                const nextAntlersStart = this.antlersStartPositionIndex.get(i + 1);
                if (this.lastAntlersNode.endPosition != null) {
                  if (nextAntlersStart < this.lastAntlersNode.endPosition.offset) {
                    let skipIndex = null;
                    for (let j = i + 1; j < indexCount; j++) {
                      if (this.antlersStartIndex[j] > this.lastAntlersNode.endPosition.offset) {
                        skipIndex = j;
                        break;
                      }
                    }
                    if (skipIndex == null) {
                      const nodeContent = this.prepareLiteralContent(
                        this.content.substr(this.lastAntlersNode.endPosition.offset + 1)
                      );
                      if (nodeContent.length > 0 && !this.isNoParse) {
                        const literalNode = new LiteralNode();
                        literalNode.withParser(this);
                        literalNode.content = nodeContent;
                        const literalStartOffset = this.lastAntlersNode.endPosition.offset + 1;
                        literalNode.startPosition = this.positionFromOffset(literalStartOffset, literalStartOffset);
                        literalNode.endPosition = this.positionFromOffset(this.inputLen, this.inputLen);
                        const startOffset = (_b = literalNode.startPosition.index) != null ? _b : 0, endOffset = literalNode.endPosition.index + 1;
                        literalNode.sourceContent = this.content.substr(startOffset, endOffset - startOffset);
                        this.nodes.push(literalNode);
                      }
                      break;
                    } else {
                      const nextStart = this.antlersStartIndex[skipIndex], spanLen = nextStart - this.lastAntlersNode.endPosition.offset - 1;
                      if (spanLen > 0) {
                        let spanStart = this.lastAntlersNode.endPosition.offset, spanEnd = nextStart - 1;
                        spanStart += 1;
                        spanEnd -= 1;
                        const nodeContent = this.content.substr(spanStart, spanLen);
                        if (nodeContent.length > 0 && !this.isNoParse) {
                          const literalNode = new LiteralNode();
                          literalNode.withParser(this);
                          literalNode.content = nodeContent;
                          literalNode.startPosition = this.positionFromOffset(spanStart, spanStart);
                          literalNode.endPosition = this.positionFromOffset(spanEnd, spanEnd);
                          const startOffset = (_c = literalNode.startPosition.index) != null ? _c : 0, endOffset = literalNode.endPosition.index + 1;
                          literalNode.sourceContent = this.content.substr(startOffset, endOffset - startOffset);
                          this.nodes.push(literalNode);
                        }
                        continue;
                      }
                      i = skipIndex - 1;
                      continue;
                    }
                  }
                }
              }
            }
            let shouldProduceLiteralNode = false;
            if (!this.antlersStartPositionIndex.has(this.currentChunkOffset)) {
              shouldProduceLiteralNode = true;
            } else if (this.lastAntlersEndIndex < this.currentChunkOffset) {
              shouldProduceLiteralNode = true;
            }
            if (shouldProduceLiteralNode) {
              if (i + 1 < indexCount) {
                let nextAntlersStart = this.antlersStartIndex[i + 1];
                let literalStartIndex = this.lastAntlersEndIndex + 1;
                if (nextAntlersStart < literalStartIndex) {
                  if (this.lastAntlersEndIndex > nextAntlersStart) {
                    if (i + 2 < indexCount) {
                      nextAntlersStart = this.antlersStartIndex[i + 2];
                    }
                  } else {
                    continue;
                  }
                }
                if (i + 1 == lastIndex && nextAntlersStart <= this.lastAntlersEndIndex) {
                  if (this.isNoParse) {
                    break;
                  }
                  const thisOffset = this.currentChunkOffset, nodeContent = this.content.substr(literalStartIndex);
                  const literalNode = new LiteralNode();
                  literalNode.withParser(this);
                  literalNode.content = this.prepareLiteralContent(nodeContent);
                  if (literalNode.content.length > 0) {
                    literalNode.startPosition = this.positionFromOffset(literalStartIndex, thisOffset);
                    literalNode.endPosition = this.positionFromOffset(nextAntlersStart, nextAntlersStart - 1);
                    const startOffset = (_d = literalNode.startPosition.index) != null ? _d : 0, endOffset = literalNode.endPosition.index + 1;
                    literalNode.sourceContent = this.content.substr(literalStartIndex, this.inputLen - startOffset + 2);
                    this.nodes.push(literalNode);
                  }
                  break;
                } else {
                  let literalLength = nextAntlersStart - this.lastAntlersEndIndex - 1;
                  if (literalLength == 0 || this.isNoParse) {
                    continue;
                  }
                  const thisOffset = this.currentChunkOffset;
                  let literalOffset = thisOffset;
                  if (this.lastAntlersNode instanceof CommentParserFailNode) {
                    literalStartIndex = ((_f = (_e = this.lastAntlersNode.endPosition) == null ? void 0 : _e.offset) != null ? _f : 0) + 1;
                    literalLength -= ((_h = (_g = this.lastAntlersNode.endPosition) == null ? void 0 : _g.offset) != null ? _h : 0) + 1;
                    literalOffset = literalStartIndex;
                  }
                  if (this.lastAntlersNode instanceof PhpExecutionNode) {
                    literalStartIndex -= 1;
                    literalLength += 1;
                  }
                  const nodeContent = this.content.substr(literalStartIndex, literalLength);
                  const literalNode = new LiteralNode();
                  literalNode.withParser(this);
                  literalNode.content = this.prepareLiteralContent(nodeContent);
                  if (literalNode.content.length > 0) {
                    literalNode.startPosition = this.positionFromOffset(literalStartIndex, literalStartIndex);
                    literalNode.endPosition = this.positionFromOffset(nextAntlersStart, nextAntlersStart - 1);
                    const startOffset = (_i = literalNode.startPosition.index) != null ? _i : 0, endOffset = literalNode.endPosition.index + 1;
                    literalNode.sourceContent = this.content.substr(startOffset, endOffset - startOffset);
                    this.nodes.push(literalNode);
                  }
                }
                continue;
              }
              if (i !== lastIndex && this.lastAntlersNode != null && this.lastAntlersNode.endPosition != null) {
                const startCandidate = this.positionFromOffset(offset, offset);
                if (startCandidate.isBefore(this.lastAntlersNode.endPosition)) {
                  if (i + 1 < indexCount) {
                    const nextAntlersStart = this.antlersStartIndex[i + 1];
                    if (nextAntlersStart < this.lastAntlersNode.endPosition.offset) {
                      continue;
                    }
                  } else {
                    if (i + 1 != lastIndex) {
                      continue;
                    }
                  }
                }
              }
              if (i == lastIndex) {
                const literalStart = this.currentIndex + offset;
                if (literalStart < this.inputLen && !this.isNoParse) {
                  const literalNode = new LiteralNode();
                  literalNode.withParser(this);
                  literalNode.content = this.prepareLiteralContent(this.content.substr(literalStart));
                  if (literalNode.content.length > 0) {
                    literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                    literalNode.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
                    const startOffset = (_j = literalNode.startPosition.index) != null ? _j : 0, endOffset = literalNode.endPosition.index + 1;
                    literalNode.sourceContent = this.content.substr(startOffset, endOffset - startOffset);
                    this.nodes.push(literalNode);
                  }
                  break;
                }
              }
            }
          }
        }
        let index = 0;
        this.nodes.forEach((node) => {
          node.index = index;
          index += 1;
        });
        if (this.nodes.length > 500) {
          this.parseChildDocuments = false;
        }
        this.nodes.forEach((node) => {
          if (node instanceof AntlersNode && node.isComment) {
            return;
          }
          if (node instanceof AntlersNode && node.interpolationRegions.size > 0) {
            node.interpolationRegions.forEach((content, varName) => {
              const docParser = new _DocumentParser();
              docParser.withChildDocuments(this.parseChildDocuments);
              docParser.setIsInterpolatedParser(true);
              let parseResults = docParser.parse(content.parseContent);
              if (parseResults.length > 1) {
                if (parseResults[1] instanceof AntlersNode) {
                  parseResults = [parseResults[1]];
                }
              }
              if (docParser.hasUnclosedIfStructures()) {
                this.doesHaveUncloseIfStructures = true;
              }
              if (docParser.hasUnclosedStructures()) {
                this.doesHaveUnclosedStructures = true;
              }
              node.processedInterpolationRegions.set(varName, parseResults);
              this.mergeErrors(docParser.getAntlersErrors());
            });
            node.hasProcessedInterpolationRegions = true;
          }
        });
        if (this.content.length > 0) {
          this.fragmentsParser.setIndexRanges(this.getNodeIndexRanges()).parse(this.content);
        }
        const tagPairAnalyzer = new TagPairAnalyzer();
        this.renderNodes = tagPairAnalyzer.associate(this.nodes, this);
        this.createChildDocuments(this.renderNodes);
        let lastNode = null, nextNode = null;
        for (let i = 0; i < this.nodes.length; i++) {
          const thisNode = this.nodes[i];
          if (i + 1 < this.nodes.length) {
            nextNode = this.nodes[i + 1];
          } else {
            nextNode = null;
          }
          thisNode.next = nextNode;
          thisNode.prev = lastNode;
          lastNode = thisNode;
        }
        this.fragmentsAnalyzer.analyze();
        InlineNodeAnalyzer.analyze(this.nodes);
        this.nodes.forEach((node) => {
          if (node instanceof AntlersNode) {
            if (node.isClosedBy != null) {
              const nodeChildren = node.getImmediateChildren();
              for (let i = 0; i < nodeChildren.length; i++) {
                const child = nodeChildren[i];
                if (child instanceof AntlersNode && child.isClosedBy != null) {
                  node.containsChildStructures = true;
                  break;
                } else if (child instanceof ConditionNode) {
                  node.containsChildStructures = true;
                  break;
                }
              }
            }
          }
        });
        this.nodes.forEach((node) => {
          if (node instanceof AntlersNode && node.isClosingTag && node.isOpenedBy == null) {
            let errorMessage = "Unpaired closing tag.";
            if (node.isInterpolationNode) {
              errorMessage += " Tag pairs are not supported within Antlers tags.";
            }
            node.pushError(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_UNPAIRED_CLOSING_TAG,
              node,
              errorMessage
            ));
          }
        });
        RecursiveParentAnalyzer.associateRecursiveParent(this.nodes);
        this.nodes.forEach((node) => {
          var _a2;
          if (node instanceof AntlersNode && node.isComment) {
            return;
          }
          if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
            node.isInterpolationNode = this.isInterpolatedParser;
          }
          if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.interpolationRegions.size > 0) {
            node.runtimeNodes.forEach((runtimeNode) => {
              if (runtimeNode instanceof VariableNode) {
                if (node.interpolationRegions.has(runtimeNode.name)) {
                  runtimeNode.isInterpolationReference = true;
                  runtimeNode.interpolationNodes = node.processedInterpolationRegions.get(runtimeNode.name);
                }
              }
            });
          }
          if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.hasParameters && node.interpolationRegions.size > 0) {
            node.parameters.forEach((parameter) => {
              node.interpolationRegions.forEach((interVar, interpolationVariable) => {
                if (parameter.value.includes(interpolationVariable)) {
                  parameter.interpolations.push(interpolationVariable);
                }
              });
            });
          }
          if (node instanceof AntlersNode && node.runtimeNodes.length > 0) {
            if (node.isClosingTag == false && !node.isComment) {
              node.parsedRuntimeNodes = this.languageParser.parse(node.runtimeNodes);
              node.hasParsedRuntimeNodes = true;
              if (!node.isTagNode && node.parsedRuntimeNodes.length > 0) {
                const principalNode = node.nodeAtIndex(0);
                if (principalNode != null && principalNode instanceof VariableNode) {
                  if (principalNode.name == ((_a2 = node.name) == null ? void 0 : _a2.name)) {
                    node.modifierChain = principalNode.modifierChain;
                  }
                }
              }
            }
          }
        });
        this.languageParser.getCreatedModifierChains().forEach((chain) => {
          if (chain.modifierChain.length > 0) {
            chain.modifierChain.forEach((modifier) => {
              var _a2, _b2;
              if (modifier.nameNode != null && modifierManager_default.instance != null && modifierManager_default.instance.hasModifier((_a2 = modifier.nameNode) == null ? void 0 : _a2.name)) {
                modifier.modifier = (_b2 = modifierManager_default.instance) == null ? void 0 : _b2.getModifier(modifier.nameNode.name);
              }
            });
          }
        });
        let curIndex = 1;
        this.nodes.forEach((node) => {
          var _a2, _b2;
          if (node instanceof AntlersNode) {
            if (node.isComment) {
              return;
            }
            node.isTagNode = (_b2 = (_a2 = tagManagerInstance_default.instance) == null ? void 0 : _a2.isKnownTag(node.getTagName())) != null ? _b2 : false;
            node.scopeName = node.findParameterValue("scope", "");
            node.antlersNodeIndex = curIndex;
            curIndex += 1;
            ModifierAnalyzer.analyzeModifierNodeParameters(node);
          }
        });
        this.nodes.forEach((node) => {
          var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
          if (node instanceof AntlersNode) {
            if (node.isClosedBy != null) {
              const startOffset = ((_b2 = (_a2 = node.endPosition) == null ? void 0 : _a2.offset) != null ? _b2 : 0) + 1, endOffset = (_d2 = (_c2 = node.isClosedBy.startPosition) == null ? void 0 : _c2.offset) != null ? _d2 : 0, nodeStartOffset = (_f2 = (_e2 = node.startPosition) == null ? void 0 : _e2.offset) != null ? _f2 : 0, nodeEndOffset = ((_h2 = (_g2 = node.isClosedBy.endPosition) == null ? void 0 : _g2.offset) != null ? _h2 : 0) + 1;
              node.documentText = this.content.substr(startOffset, endOffset - startOffset);
              node.nodeContent = this.content.substr(nodeStartOffset, nodeEndOffset - nodeStartOffset);
              if (this.parseChildDocuments) {
                node.childDocument = AntlersDocument.childFromText(node.documentText, getStartPosition(node.children));
              }
            }
          }
        });
        return this.renderNodes;
      }
      createChildDocuments(renderNodes) {
        renderNodes.forEach((node) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (node instanceof AntlersNode && node.isClosedBy != null) {
            const isClosedBy = node.isClosedBy, docStart = ((_b = (_a = node.startPosition) == null ? void 0 : _a.index) != null ? _b : 0) - 1, docLength = ((_d = (_c = isClosedBy.endPosition) == null ? void 0 : _c.index) != null ? _d : 0) - docStart;
            node.documentText = this.content.substr(docStart, docLength);
            if (this.parseChildDocuments) {
              const startOffset = (_f = (_e = node.endPosition) == null ? void 0 : _e.index) != null ? _f : 0, length = ((_h = (_g = isClosedBy.startPosition) == null ? void 0 : _g.index) != null ? _h : 0) - 1 - startOffset, childText = this.content.substr(startOffset, length);
              node.childDocument = AntlersDocument.childFromText(childText, getStartPosition(node.getChildren()));
            }
          }
        });
      }
      getNodeIndexRanges() {
        const indexRanges = [];
        this.nodes.forEach((node) => {
          var _a, _b, _c, _d;
          if (node instanceof LiteralNode == false) {
            indexRanges.push({
              start: (_b = (_a = node.startPosition) == null ? void 0 : _a.index) != null ? _b : 0,
              end: (_d = (_c = node.endPosition) == null ? void 0 : _c.index) != null ? _d : 0
            });
          }
        });
        return indexRanges;
      }
      positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
          if (this.documentOffsets.size == 0) {
            lineToUse = 1;
            charToUse = offset + 1;
          } else {
            let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
            for (const documentOffset of this.documentOffsets.keys()) {
              if (documentOffset >= offset) {
                if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                  nearestOffset = lastOffset;
                  nearestOffsetIndex = lastOffsetIndex;
                } else {
                  nearestOffset = this.documentOffsets.get(documentOffset);
                  nearestOffsetIndex = documentOffset;
                }
                break;
              }
              lastOffset = this.documentOffsets.get(documentOffset);
              lastOffsetIndex = documentOffset;
            }
            if (nearestOffset == null) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            }
            if (nearestOffset != null) {
              if (isRelativeOffset) {
                const t_Chars = this.content.split("");
                const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
                const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              } else {
                const t_Chars = this.content.split("");
                const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
                const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              }
            } else {
              if (this.lastDocumentOffsetKey != null) {
                const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
                lineToUse = lastOffset2.line + 1;
                charToUse = offset + this.lastDocumentOffsetKey;
              }
            }
          }
        } else {
          const offsetDetails = this.documentOffsets.get(offset);
          lineToUse = offsetDetails.line;
          charToUse = offsetDetails.char;
        }
        const position = new Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse + this.shiftLine;
        position.char = charToUse;
        return position;
      }
      getLanguageParser() {
        return this.languageParser;
      }
      getText(start, end) {
        return this.content.substr(start, end - start);
      }
      getOriginalContent() {
        return this.originalContent;
      }
      getContent() {
        return this.content;
      }
      getFragments() {
        return this.fragmentsParser.getFragments();
      }
      getFragmentsParser() {
        return this.fragmentsParser;
      }
      getFragmentsContainingStructures() {
        return this.fragmentsParser.getFragmentsContainingStructures();
      }
      setIsInterpolatedParser(isInterpolation) {
        this.isInterpolatedParser = isInterpolation;
        return this;
      }
      setStartLineSeed(startLine) {
        this.seedStartLine = startLine;
        return this;
      }
      setSeedStartChar(startChar) {
        this.seedStartchar = startChar;
        return this;
      }
      resetIntermediateState() {
        this.chars = [];
        this.charLen = 0;
        this.currentIndex = 0;
        this.currentContent = [];
        this.sourceContent = [];
        this.cur = null;
        this.next = null;
        this.prev = null;
      }
      setSeedPosition(position) {
        if (position == null) {
          this.shiftLine = 0;
        } else {
          this.shiftLine = position.line;
        }
        return this;
      }
      resetState() {
        this.languageParser.reset();
        this.charLen = 0;
        this.antlersStartIndex = [];
        this.antlersErrors = [];
        this.pushedErrors.clear();
        this.antlersStartPositionIndex.clear();
        this.lastAntlersEndIndex = -1;
        this.renderNodes = [];
        this.nodes = [];
        if (GlobalRuntimeState.globalTagEnterStack.length > 0) {
          const lastTagNode = GlobalRuntimeState.globalTagEnterStack[GlobalRuntimeState.length - 1];
          if (lastTagNode != null && lastTagNode.endPosition != null) {
            this.setStartLineSeed(lastTagNode.endPosition.line);
          }
        }
        this.seedOffset = 0;
        this.isScanningInterpolations = false;
        this.content = "";
        this.chars = [];
        this.currentIndex = 0;
        this.startIndex = 0;
        this._recoveryStartIndex = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.inputLen = 0;
        this.documentOffsets.clear();
        this.isDoubleBrace = false;
        this.interpolationRegions.clear();
        this.interpolationEndOffsets.clear();
      }
      fetch(count) {
        const start = this.currentChunkOffset + this.chunkSize - this.chars.length;
        return StringUtilities.substring(
          this.content,
          start,
          count
        );
      }
      getParsedContent() {
        return this.content;
      }
      peek(count) {
        if (count == this.charLen) {
          const nextChunk = StringUtilities.split(
            StringUtilities.substring(
              this.content,
              this.currentChunkOffset + this.chunkSize,
              this.chunkSize
            )
          );
          this.currentChunkOffset += this.chunkSize;
          nextChunk.forEach((nextChar) => {
            this.chars.push(nextChar);
            this.charLen += 1;
          });
        }
        return this.chars[count];
      }
      parseIntermediateText() {
        this.currentContent = [];
        this.sourceContent = [];
        this.startIndex = 0;
        this.chars = this.content.substr(this.currentChunkOffset, this.chunkSize).split("");
        this.charLen = this.chars.length;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == _DocumentParser.LeftBrace && this.next == _DocumentParser.LeftBrace && this.prev == _DocumentParser.AtChar) {
            this.dumpLiteralNode(this.currentIndex);
            const escapeNode = new EscapedContentNode();
            escapeNode.withParser(this);
            escapeNode.name = new TagIdentifier();
            escapeNode.name.name = "noparse";
            escapeNode.content = "{{";
            escapeNode.startPosition = this.positionFromOffset(
              this.currentIndex + this.seedOffset,
              this.currentIndex + this.seedOffset
            );
            escapeNode.endPosition = this.positionFromOffset(
              this.currentIndex + this.seedOffset,
              this.currentIndex + this.seedOffset
            );
            this.nodes.push(escapeNode);
            this.currentContent = [];
            this.sourceContent = [];
            this.currentIndex += 1;
            continue;
          }
          if ((this.prev == null || this.prev != null && this.prev != _DocumentParser.AtChar) && this.next != null && this.cur == _DocumentParser.LeftBrace && this.next == _DocumentParser.LeftBrace) {
            this.dumpLiteralNode(this.currentIndex);
            let peek = null;
            if (this.currentIndex + 2 < this.inputLen) {
              peek = this.peek(this.currentIndex + 2);
            }
            if (peek == _DocumentParser.Punctuation_Question && !this.isNoParse) {
              this.isDoubleBrace = true;
              this.currentIndex += 3;
              this._recoveryStartIndex = this.currentIndex;
              this.scanToEndOfPhpRegion(_DocumentParser.Punctuation_Question);
              this.isDoubleBrace = false;
              break;
            }
            if (peek == _DocumentParser.Punctuation_Dollar && !this.isNoParse) {
              this.isDoubleBrace = true;
              this.currentIndex += 3;
              this._recoveryStartIndex = this.currentIndex;
              this.scanToEndOfPhpRegion(_DocumentParser.Punctuation_Dollar);
              this.isDoubleBrace = false;
              break;
            }
            if (peek == _DocumentParser.Punctuation_Octothorp && !this.isNoParse) {
              this.isDoubleBrace = true;
              this.currentIndex += 3;
              this._recoveryStartIndex = this.currentIndex;
              this.scanToEndOfAntlersCommentRegion();
              this.isDoubleBrace = false;
              break;
            }
            if (!this.isNoParse) {
              this.startIndex = this.currentIndex;
              this._recoveryStartIndex = this.currentIndex;
              this.isDoubleBrace = true;
              this.currentIndex += 2;
              this._recoveryStartIndex = this.currentIndex;
              this.scanToEndOfAntlersRegion();
              this.isDoubleBrace = false;
            } else {
              const contentPeek = this.fetch(11).replace(" ", "").toLocaleLowerCase();
              if (contentPeek.startsWith("{{/noparse")) {
                this.startIndex = this.currentIndex;
                this._recoveryStartIndex = this.currentIndex;
                this.isDoubleBrace = true;
                this.currentIndex += 2;
                this._recoveryStartIndex = this.currentIndex;
                this.scanToEndOfAntlersRegion();
                this.isDoubleBrace = false;
                this.isNoParse = false;
                break;
              } else {
                this.currentContent.push(this.cur);
                continue;
              }
            }
            break;
          }
          if (this.cur == _DocumentParser.AtChar && this.next != null && this.next == _DocumentParser.LeftBrace) {
            if (this.currentIndex + 2 >= this.inputLen) {
              this.appendContent(this.next);
              this.dumpLiteralNode(this.currentIndex + 1);
              break;
            }
            let leftBraceCount = 0;
            for (let countIndex = this.currentIndex + 1; countIndex < this.inputLen; countIndex += 1) {
              const subChar = this.chars[countIndex];
              if (subChar == _DocumentParser.LeftBrace) {
                leftBraceCount += 1;
              } else {
                break;
              }
            }
            this.currentContent = this.currentContent.concat(
              _DocumentParser.LeftBrace.repeat(leftBraceCount).split("")
            );
            this.sourceContent = this.currentContent.concat(
              _DocumentParser.LeftBrace.repeat(leftBraceCount).split("")
            );
            this.currentIndex += leftBraceCount;
          }
          this.appendContent(this.cur);
          if (this.next == null && this.currentContent.length > 0) {
            this.dumpLiteralNode(this.currentIndex);
          }
        }
      }
      getRenderNodes() {
        return this.renderNodes;
      }
      processInputText(input) {
        var _a;
        this.originalContent = input;
        this.content = StringUtilities.normalizeLineEndings(input);
        this.inputLen = this.content.length;
        if (this.content.startsWith("---")) {
          const lines = this.content.split("\n"), frontMatter = [];
          let newLines = [];
          newLines.push("");
          for (let i = 1; i < lines.length; i++) {
            const lineText = lines[i];
            if (lineText.startsWith("---")) {
              newLines.push("");
              newLines = newLines.concat(lines.slice(i + 1));
              this.content = newLines.join("\n");
              this.frontMatter = frontMatter.join("\n");
              this.frontMatterEndLine = i + 1;
              break;
            } else {
              frontMatter.push(lineText);
              newLines.push("");
            }
          }
        }
        const documentNewLines = [...this.content.matchAll(/(\n)/gm)];
        const newLineCountLen = documentNewLines.length;
        let currentLine = this.seedStartLine, lastOffset = null, lastStartIndex = 0, lastEndIndex = 0;
        for (let i = 0; i < newLineCountLen; i++) {
          const thisNewLine = documentNewLines[i], thisIndex = (_a = thisNewLine.index) != null ? _a : 0;
          let indexChar = thisIndex;
          if (lastOffset != null) {
            indexChar = thisIndex - lastOffset;
          } else {
            indexChar = indexChar + 1;
          }
          this.documentOffsets.set(thisIndex, {
            char: indexChar,
            line: currentLine
          });
          let thisStartIndex = 0, thisEndIndex = 0;
          if (i == 0) {
            thisEndIndex = indexChar - 1;
            thisStartIndex = 0;
          } else {
            thisStartIndex = lastEndIndex + 1;
            thisEndIndex = thisIndex;
          }
          this.lineIndex.set(currentLine, {
            char: indexChar,
            line: currentLine,
            startIndex: thisStartIndex,
            endIndex: thisEndIndex
          });
          this.lastDocumentOffsetKey = thisIndex;
          this.maxLine = currentLine;
          currentLine += 1;
          lastOffset = thisIndex;
          lastEndIndex = thisEndIndex;
          lastStartIndex = thisStartIndex;
        }
        this.maxLine += 1;
        const antlersStartCandidates = [...this.content.matchAll(/@?{{/gm)];
        let lastAntlersOffset = 0, lastWasEscaped = false;
        antlersStartCandidates.forEach((antlersRegion) => {
          const matchText = antlersRegion[0];
          if (matchText.startsWith(_DocumentParser.AtChar)) {
            lastAntlersOffset = this.content.indexOf(matchText, lastAntlersOffset) + 2;
            lastWasEscaped = true;
            return;
          }
          const offset = this.content.indexOf(matchText, lastAntlersOffset);
          if (lastWasEscaped) {
            if (lastAntlersOffset == offset) {
              lastAntlersOffset = offset;
              return;
            }
          }
          this.antlersStartIndex.push(offset);
          this.antlersStartPositionIndex.set(offset, 1);
          lastAntlersOffset = offset + 2;
          lastWasEscaped = false;
        });
        return true;
      }
      prepareLiteralContent(content) {
        return content.replace("@{{", "{{");
      }
      scanToEndOfPhpRegion(checkChar) {
        if (this.currentIndex == this.inputLen) {
          this.doesHaveUnclosedStructures = true;
        }
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == checkChar && this.next != null && this.next == _DocumentParser.RightBrace) {
            const peek = this.peek(this.currentIndex + 2);
            if (peek == _DocumentParser.RightBrace) {
              const node = this.makeAntlersPhpNode(this.currentIndex, checkChar == _DocumentParser.Punctuation_Dollar);
              this.currentContent = [];
              this.sourceContent = [];
              this.currentIndex += 3;
              this.startIndex = this.currentIndex;
              this._recoveryStartIndex = this.startIndex;
              this.nodes.push(node);
              this.lastAntlersNode = node;
              break;
            }
          }
          this.appendContent(this.cur);
          if (this.next == null) {
            const failNode = this.makeAntlersPhpFailedNode(this.currentIndex);
            this.nodes.push(failNode);
            this.lastAntlersNode = failNode;
            this.doesHaveUnclosedStructures = true;
            this.antlersErrors.push(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_INCOMPLETE_PHP_EVALUATION_REGION,
              failNode,
              "Unexpected end of input while parsing Antlers PHP region."
            ));
            break;
          }
        }
      }
      appendContent(char) {
        if (char == null) {
          return;
        }
        this.currentContent.push(char);
        this.sourceContent.push(char);
      }
      scanToEndOfAntlersCommentRegion() {
        if (this.currentIndex == this.inputLen) {
          this.doesHaveUnclosedStructures = true;
        }
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == _DocumentParser.Punctuation_Octothorp && this.next != null && this.next == _DocumentParser.RightBrace) {
            const peek = this.peek(this.currentIndex + 2);
            if (peek == _DocumentParser.RightBrace) {
              const node = this.makeAntlersTagNode(this.currentIndex, true);
              this.currentContent = [];
              this.sourceContent = [];
              this.currentIndex += 3;
              this.nodes.push(node);
              this.lastAntlersNode = node;
              break;
            }
          }
          this.appendContent(this.cur);
          if (this.next == null) {
            const failNode = this.makeAntlersCommentFailedNode(this.currentIndex);
            this.nodes.push(failNode);
            this.lastAntlersNode = failNode;
            this.doesHaveUnclosedStructures = true;
            this.antlersErrors.push(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_INCOMPLETE_ANTELRS_COMMENT_REGION,
              failNode,
              "Unexpected end of input while parsing Antlers comment region."
            ));
            break;
          }
        }
      }
      scanToEndOfInterpolatedRegion() {
        if (this.currentIndex == this.inputLen) {
          this.doesHaveUnclosedStructures = true;
        }
        const subContent = [];
        this.isScanningInterpolations = true;
        let braceCount = 0;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == _DocumentParser.LeftBrace) {
            if (this.prev == _DocumentParser.AtChar) {
              subContent.push(this.cur);
              continue;
            }
            braceCount += 1;
            subContent.push(this.cur);
          } else if (this.cur == _DocumentParser.RightBrace) {
            if (this.prev == _DocumentParser.AtChar) {
              subContent.push(this.cur);
              continue;
            }
            braceCount -= 1;
            subContent.push(this.cur);
            if (braceCount == 0) {
              this.interpolationEndOffsets.set(this.currentIndex, 1);
              break;
            }
          } else {
            if (this.cur != null) {
              subContent.push(this.cur);
            }
          }
        }
        const content = subContent.join(""), varSlug = "int_" + import_md52.Md5.hashStr(content);
        let varContent = varSlug.substr(0, content.length);
        const newLen = varContent.length, origLen = content.length;
        if (newLen < origLen) {
          const padLen = origLen - newLen;
          varContent += "x".repeat(padLen);
        }
        this.isScanningInterpolations = false;
        return {
          content,
          varContent
        };
      }
      bordersInterpolationRegion(position) {
        if (this.interpolationEndOffsets.size == 0) {
          return false;
        }
        const offsetCheck = position.offset - 1;
        if (offsetCheck <= 0) {
          return false;
        }
        return this.interpolationEndOffsets.has(offsetCheck);
      }
      getParseableContent(toIndex) {
        let newString = "";
        for (let i = 0; i <= toIndex; i++) {
          if (this.content[i] == _DocumentParser.LeftBrace || this.content[i] == _DocumentParser.RightBrace) {
            newString += "~";
          } else {
            newString += this.content[i];
          }
        }
        return newString;
      }
      scanToEndOfAntlersRegion() {
        if (this.currentIndex == this.inputLen) {
          this.doesHaveUnclosedStructures = true;
        }
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
          this.checkCurrentOffsets();
          if (this.cur == _DocumentParser.LeftBrace && this.prev == _DocumentParser.AtChar) {
            this.currentContent.pop();
            this.appendContent(this.cur);
            continue;
          }
          if (this.isInterpolatedParser && this.cur == _DocumentParser.RightBrace && this.prev == _DocumentParser.AtChar) {
            this.currentContent.pop();
            this.appendContent(this.cur);
            continue;
          }
          if (this.cur == _DocumentParser.LeftBrace) {
            const results = this.scanToEndOfInterpolatedRegion();
            const regionEnd = this.currentIndex + this.seedOffset, regionStart = regionEnd - results.content.length, leadingContent = this.getParseableContent(regionStart - 1);
            GlobalRuntimeState.interpolatedVariables.push(results.varContent);
            this.currentContent = this.currentContent.concat(results.varContent.split(""));
            this.sourceContent = this.sourceContent.concat(results.content.split(""));
            const parseContent = leadingContent + "{" + results.content + "}";
            this.interpolationRegions.set(results.varContent, {
              content: results.content,
              parseContent,
              varContent: results.varContent,
              startOffset: regionStart,
              endOffset: regionEnd
            });
            continue;
          }
          if (this.cur == _DocumentParser.RightBrace && this.next != null && this.next == _DocumentParser.RightBrace) {
            const node = this.makeAntlersTagNode(this.currentIndex, false);
            if (node.name != null && node.name.name == "noparse") {
              this.isNoParse = true;
            }
            this.currentIndex += 2;
            this.nodes.push(node);
            this.lastAntlersNode = node;
            break;
          }
          this.appendContent(this.cur);
          if (this.next == null) {
            const failNode = this.makeAntlersFailedNode(this.currentIndex, false);
            this.nodes.push(failNode);
            this.lastAntlersNode = failNode;
            this.doesHaveUnclosedStructures = true;
            let message = "Unexpected end of input while parsing Antlers region.";
            if (this.isScanningInterpolations) {
              message = "Unexpected end of input wihle parsing interpolated Antlers region.";
            }
            this.antlersErrors.push(AntlersError.makeSyntaxError(
              AntlersErrorCodes.TYPE_INCOMPLETE_ANTLERS_REGION,
              failNode,
              message
            ));
            break;
          }
        }
      }
      makeAntlersPhpNode(index, isEcho) {
        const node = new PhpExecutionNode();
        if (isEcho) {
          node.rawStart = "{{$";
          node.rawEnd = "$}}";
        } else {
          node.rawStart = "{{?";
          node.rawEnd = "?}}";
        }
        node.content = this.currentContent.join("");
        node.sourceContent = this.sourceContent.join("");
        node.startPosition = this.positionFromOffset(
          this.startIndex + this.seedOffset,
          this.startIndex + this.seedOffset
        );
        if (index + 3 > this.inputLen) {
          node.endPosition = this.positionFromOffset(this.inputLen, this.inputLen - 1);
          this.doesHaveUnclosedStructures = true;
          this.antlersErrors.push(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_MANIFESTING_ANTLERS_NODE,
            node,
            "Unexpected end of input while locating end of Antlers region."
          ));
          return node;
        }
        this.lastAntlersEndIndex = index + 3 + this.seedOffset;
        node.endPosition = this.positionFromOffset(
          index + this.seedOffset,
          index + 3 + this.seedOffset
        );
        return node;
      }
      makeAntlersPhpFailedNode(index) {
        const node = new PhpParserFailNode();
        node.rawStart = "{{$";
        node.rawEnd = "$}}";
        node._isEndVirtual = true;
        node.content = this.currentContent.join("");
        node.sourceContent = this.sourceContent.join("");
        node.startPosition = this.positionFromOffset(
          this.startIndex + this.seedOffset,
          this.startIndex + this.seedOffset
        );
        const lineContent = this.getLineText(node.startPosition.line), lineIndexEntry = this.getLineIndex(node.startPosition.line);
        if (lineContent != null) {
          const failedContent = lineContent.substr(this._recoveryStartIndex);
          node.content = failedContent;
          node.sourceContent = failedContent;
        }
        let failedNodeEndIndex = index + this.seedOffset;
        if (lineIndexEntry != null) {
          this.currentIndex = lineIndexEntry.end;
          failedNodeEndIndex = lineIndexEntry.end;
        }
        node.endPosition = this.positionFromOffset(
          failedNodeEndIndex,
          failedNodeEndIndex
        );
        return node;
      }
      makeAntlersCommentFailedNode(index) {
        const node = new CommentParserFailNode();
        if (this.isDoubleBrace) {
          node.rawStart = "{{";
          node.rawEnd = "}}";
        } else {
          node.rawStart = "{";
          node.rawEnd = "}";
        }
        node._isEndVirtual = true;
        let isSelfClosing = false;
        const contentLen = this.currentContent.length;
        if (contentLen > 0 && this.currentContent[contentLen - 1] == _DocumentParser.Punctuation_ForwardSlash) {
          this.currentContent.pop();
          isSelfClosing = true;
        }
        node.isComment = true;
        node.isSelfClosing = isSelfClosing;
        node.withParser(this);
        node.content = this.currentContent.join("");
        node.sourceContent = this.sourceContent.join("");
        node.startPosition = this.positionFromOffset(
          this.startIndex + this.seedOffset,
          this.startIndex + this.seedOffset
        );
        const lineContent = this.getLineText(node.startPosition.line), lineIndexEntry = this.getLineIndex(node.startPosition.line);
        if (lineContent != null) {
          const failedContent = lineContent.substr(this._recoveryStartIndex);
          node.content = failedContent;
          node.sourceContent = failedContent;
        }
        let failedNodeEndIndex = index + this.seedOffset;
        if (lineIndexEntry != null) {
          this.currentIndex = lineIndexEntry.end;
          failedNodeEndIndex = lineIndexEntry.end;
        }
        node.endPosition = this.positionFromOffset(
          failedNodeEndIndex,
          failedNodeEndIndex
        );
        node.interpolationRegions = /* @__PURE__ */ new Map();
        this.interpolationRegions.forEach((region, key) => {
          if (node.content.includes(key)) {
            node.interpolationRegions.set(key, region);
          }
        });
        return node;
      }
      makeAntlersFailedNode(index, isComment) {
        const node = new AntlersParserFailNode();
        if (this.isDoubleBrace) {
          node.rawStart = "{{";
          node.rawEnd = "}}";
        } else {
          node.rawStart = "{";
          node.rawEnd = "}";
        }
        node._isEndVirtual = true;
        let isSelfClosing = false;
        const contentLen = this.currentContent.length;
        if (contentLen > 0 && this.currentContent[contentLen - 1] == _DocumentParser.Punctuation_ForwardSlash) {
          this.currentContent.pop();
          isSelfClosing = true;
        }
        node.isComment = isComment;
        node.isSelfClosing = isSelfClosing;
        node.withParser(this);
        node.content = this.currentContent.join("");
        node.sourceContent = this.sourceContent.join("");
        node.startPosition = this.positionFromOffset(
          this.startIndex + this.seedOffset,
          this.startIndex + this.seedOffset
        );
        const lineContent = this.getLineText(node.startPosition.line), lineIndexEntry = this.getLineIndex(node.startPosition.line);
        if (lineContent != null) {
          const failedContent = StringUtilities.trimLeft(this.content.substring(node.startPosition.offset + node.rawStart.length - 1, lineIndexEntry == null ? void 0 : lineIndexEntry.end), "{");
          node.content = failedContent;
          node.sourceContent = failedContent;
        }
        let failedNodeEndIndex = index + this.seedOffset;
        if (lineIndexEntry != null) {
          this.currentIndex = lineIndexEntry.end;
          failedNodeEndIndex = lineIndexEntry.end;
        }
        node.endPosition = this.positionFromOffset(
          failedNodeEndIndex,
          failedNodeEndIndex
        );
        node.interpolationRegions = /* @__PURE__ */ new Map();
        this.interpolationRegions.forEach((region, key) => {
          if (node.content.includes(key)) {
            node.interpolationRegions.set(key, region);
          }
        });
        const returnNode = this.nodeParser.parseNode(node);
        this.mergeErrors(returnNode.getErrors());
        return returnNode;
      }
      makeAntlersTagNode(index, isComment) {
        const node = new AntlersNode();
        if (this.isDoubleBrace) {
          node.rawStart = "{{";
          node.rawEnd = "}}";
        } else {
          node.rawStart = "{";
          node.rawEnd = "}";
        }
        let isSelfClosing = false;
        const contentLen = this.currentContent.length;
        if (contentLen > 0 && this.currentContent[contentLen - 1] == _DocumentParser.Punctuation_ForwardSlash) {
          this.currentContent.pop();
          isSelfClosing = true;
        }
        node.isInterpolationNode = this.isInterpolatedParser;
        node.isComment = isComment;
        node.isSelfClosing = isSelfClosing;
        node.withParser(this);
        node.content = this.currentContent.join("");
        node.sourceContent = this.sourceContent.join("");
        node.startPosition = this.positionFromOffset(
          this.startIndex + this.seedOffset,
          this.startIndex + this.seedOffset
        );
        if (index + 2 > this.inputLen) {
          node.endPosition = this.positionFromOffset(
            this.inputLen,
            this.inputLen - 1
          );
          this.doesHaveUnclosedStructures = true;
          this.antlersErrors.push(AntlersError.makeSyntaxError(
            AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_MANIFESTING_ANTLERS_NODE,
            node,
            "Unexpected end of input while locating end of Antlers region."
          ));
          return node;
        }
        if (isComment) {
          this.lastAntlersEndIndex = index + 2 + this.seedOffset;
        } else {
          this.lastAntlersEndIndex = index + 1 + this.seedOffset;
        }
        node.endPosition = this.positionFromOffset(
          this.lastAntlersEndIndex,
          this.lastAntlersEndIndex
        );
        node.interpolationRegions = /* @__PURE__ */ new Map();
        this.interpolationRegions.forEach((region, key) => {
          if (node.content.includes(key)) {
            node.interpolationRegions.set(key, region);
          }
        });
        if (node.isComment) {
          return node;
        }
        const returnNode = this.nodeParser.parseNode(node);
        this.mergeErrors(returnNode.getErrors());
        return returnNode;
      }
      mergeErrors(errors) {
        errors.forEach((error) => {
          this.antlersErrors.push(error);
        });
      }
      getNodes() {
        return this.nodes;
      }
      getNodesBetween(start, end) {
        const returnNodes = [];
        this.nodes.forEach((node) => {
          var _a, _b, _c, _d;
          if (((_b = (_a = node.startPosition) == null ? void 0 : _a.offset) != null ? _b : 0) > start.offset && ((_d = (_c = node.endPosition) == null ? void 0 : _c.offset) != null ? _d : 0) < end.offset) {
            returnNodes.push(node);
          }
        });
        return returnNodes;
      }
      antlersNodes() {
        return this.nodes.filter(function(node) {
          return node instanceof AntlersNode;
        });
      }
      dumpLiteralNode(index) {
        if (this.isNoParse) {
          return;
        }
        if (this.currentContent.length > 0) {
          this.nodes.push(this.makeLiteralNode(this.currentContent, this.startIndex, index));
        }
        this.currentContent = [];
        this.sourceContent = [];
      }
      makeLiteralNode(buffer, startOffset, currentOffset) {
        const node = new LiteralNode();
        node.content = buffer.join("");
        node.sourceContent = this.sourceContent.join("");
        node.startPosition = this.positionFromOffset(startOffset, startOffset);
        node.endPosition = this.positionFromOffset(currentOffset, currentOffset);
        node.sourceContent = this.content.substr(startOffset, currentOffset);
        node.withParser(this);
        return node;
      }
      addAntlersError(error) {
        this.antlersErrors.push(error);
      }
      getAntlersErrors() {
        return this.antlersErrors;
      }
      getStructureErrors() {
        return this.structureErrors;
      }
    };
    DocumentParser = _DocumentParser;
    DocumentParser.K_CHAR = "char";
    DocumentParser.K_LINE = "line";
    DocumentParser.NewLine = "\n";
    DocumentParser.AtChar = "@";
    DocumentParser.LeftBrace = "{";
    DocumentParser.RightBrace = "}";
    DocumentParser.LeftBracket = "[";
    DocumentParser.RightBracket = "]";
    DocumentParser.String_EscapeCharacter = "\\";
    DocumentParser.String_Terminator_DoubleQuote = '"';
    DocumentParser.String_Terminator_SingleQuote = "'";
    DocumentParser.Punctuation_Question = "?";
    DocumentParser.Punctuation_Equals = "=";
    DocumentParser.Punctuation_Comma = ",";
    DocumentParser.Punctuation_Colon = ":";
    DocumentParser.Punctuation_Semicolon = ";";
    DocumentParser.Punctuation_Exclamation = "!";
    DocumentParser.Punctuation_Pipe = "|";
    DocumentParser.Punctuation_Ampersand = "&";
    DocumentParser.Punctuation_LessThan = "<";
    DocumentParser.Punctuation_GreaterThan = ">";
    DocumentParser.Punctuation_Octothorp = "#";
    DocumentParser.Punctuation_Tilde = "~";
    DocumentParser.Punctuation_FullStop = ".";
    DocumentParser.Punctuation_Dollar = "$";
    DocumentParser.Punctuation_Asterisk = "*";
    DocumentParser.Punctuation_Percent = "%";
    DocumentParser.Punctuation_Plus = "+";
    DocumentParser.Punctuation_Minus = "-";
    DocumentParser.Punctuation_Underscore = "_";
    DocumentParser.Punctuation_ForwardSlash = "/";
    DocumentParser.Punctuation_Caret = "^";
    DocumentParser.LeftParen = "(";
    DocumentParser.RightParent = ")";
  }
});

// server/src/runtime/document/scanners/nodeQueries.ts
var NodeQueries;
var init_nodeQueries = __esm({
  "server/src/runtime/document/scanners/nodeQueries.ts"() {
    "use strict";
    init_abstractNode();
    init_languageParser();
    NodeQueries = class {
      static findAssignmentNodes(nodes) {
        const returnNodes = [];
        for (let i = 0; i < nodes.length; i++) {
          if (LanguageParser.isAssignmentOperatorNode(nodes[i])) {
            returnNodes.push(nodes[i]);
          }
        }
        return returnNodes;
      }
      static findAbstractNodesBefore(node, nodes) {
        return this.findAbstractNodesBeforePosition(node.startPosition, nodes);
      }
      static findAbstractNodesBeforePosition(position, nodes) {
        if (position == null) {
          return [];
        }
        const subNodes = [];
        for (let i = 0; i < nodes.length; i++) {
          const checkNode = nodes[i];
          if (checkNode.startPosition != null) {
            if (checkNode.startPosition.index > position.index) {
              break;
            }
            subNodes.push(checkNode);
          }
        }
        return subNodes;
      }
      static isBefore(node, position) {
        if (node.startPosition == null) {
          return false;
        }
        return node.startPosition.index < position.index;
      }
      static isAfter(node, position) {
        if (node.startPosition == null) {
          return false;
        }
        return node.startPosition.index > position.index;
      }
      static findNodesBeforePosition(position, nodes) {
        const beforeNodes = [];
        if (position == null) {
          return beforeNodes;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null && node.endPosition != null) {
            if (node.startPosition.index > position.index) {
              break;
            }
            beforeNodes.push(node);
          }
        }
        return beforeNodes;
      }
      static findNodesAfterPosition(position, nodes) {
        const afterNodes = [];
        if (position == null) {
          return afterNodes;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null) {
            if (node.startPosition.index > position.index) {
              afterNodes.push(node);
            }
          }
        }
        return afterNodes;
      }
      static findNodeBeforePosition(position, nodes) {
        if (position == null) {
          return null;
        }
        let lastNode = null;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null) {
            if (node.startPosition.index > position.index) {
              break;
            }
            lastNode = node;
          }
        }
        return lastNode;
      }
      static findNodeAfterPosition(position, nodes) {
        if (position == null) {
          return null;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null) {
            if (node.startPosition.index > position.index) {
              return node;
            }
          }
        }
        return null;
      }
      static findNodeAtPosition(position, nodes) {
        if (position == null) {
          return null;
        }
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (NodeQueries.isLiteralType(node)) {
            continue;
          }
          if (node.startPosition != null && node.endPosition != null) {
            if (position.index >= node.startPosition.index && position.index <= node.endPosition.index) {
              return node;
            }
          }
        }
        return null;
      }
      static isLiteralType(node) {
        if (node instanceof EscapedContentNode || node instanceof LiteralNode) {
          return true;
        }
        return false;
      }
    };
  }
});

// server/src/runtime/document/featureContextResolver.ts
var FeatureContextResolver;
var init_featureContextResolver = __esm({
  "server/src/runtime/document/featureContextResolver.ts"() {
    "use strict";
    init_abstractNode();
    init_nodeQueries();
    FeatureContextResolver = class {
      static isModifierLeftOf(node, nodes) {
        return FeatureContextResolver.isModifierLeftOfPosition(node.startPosition, nodes);
      }
      static isModifierLeftOfPosition(position, nodes) {
        const checkNodes = NodeQueries.findAbstractNodesBeforePosition(position, nodes);
        for (let i = checkNodes.length - 1; i >= 0; i--) {
          const thisNode = checkNodes[i];
          if (thisNode instanceof LogicGroupBegin) {
            if (i - 1 > 0 && checkNodes[i - 1] instanceof ModifierNameNode) {
              return true;
            }
          }
          if (thisNode instanceof LogicGroupEnd) {
            if (i == checkNodes.length - 1) {
              continue;
            }
            return false;
          }
          if (thisNode instanceof LogicGroupBegin) {
            return false;
          }
          if (thisNode instanceof ModifierSeparator) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// server/src/runtime/document/contexts/generalContext.ts
var GeneralContext;
var init_generalContext = __esm({
  "server/src/runtime/document/contexts/generalContext.ts"() {
    "use strict";
    init_languageParser();
    GeneralContext = class {
      constructor() {
        this.isRightOfOperator = false;
        this.isLeftOfOperator = false;
      }
      static resolveContext(position, node, feature) {
        const context = new GeneralContext();
        if (feature != null) {
          if (feature.prev != null && LanguageParser.isOperatorType(feature.prev)) {
            context.isRightOfOperator = true;
          }
          if (feature.next != null && LanguageParser.isOperatorType(feature.next)) {
            context.isLeftOfOperator = true;
          }
        }
        return context;
      }
    };
  }
});

// server/src/runtime/document/contexts/identifierContext.ts
var IdentifierContext;
var init_identifierContext = __esm({
  "server/src/runtime/document/contexts/identifierContext.ts"() {
    "use strict";
    IdentifierContext = class {
      constructor() {
        this.inTagPart = false;
        this.inMethodPart = false;
      }
    };
  }
});

// server/src/runtime/document/contexts/modifierContext.ts
var ModifierContext;
var init_modifierContext = __esm({
  "server/src/runtime/document/contexts/modifierContext.ts"() {
    "use strict";
    init_modifierManager();
    init_abstractNode();
    ModifierContext = class {
      constructor() {
        this.modifierChain = null;
        this.activeModifier = null;
        this.name = "";
        this.inModifierName = false;
        this.inModifierParameter = false;
        this.valueCount = 0;
        this.activeValueIndex = -1;
        this.activeValue = null;
      }
      static resolveContext(position, node, feature, document) {
        var _a;
        const parser = node.getParser(), context = new ModifierContext(), chains = parser.getLanguageParser().getCreatedModifierChains();
        let modifier = null;
        for (let i = 0; i < chains.length; i++) {
          const chain = chains[i];
          if (position.isWithin(chain.startPosition, chain.endPosition, 2)) {
            for (let j = 0; j < chain.modifierChain.length; j++) {
              const thisModifier = chain.modifierChain[j];
              if (position.isWithin(thisModifier.startPosition, thisModifier.endPosition, 2)) {
                modifier = thisModifier;
                break;
              }
            }
            if (modifier != null) {
              break;
            }
          }
        }
        if (modifier == null && feature instanceof ModifierNameNode) {
          if (document.getDocumentParser().getLanguageParser().hasModifierConstruct(feature)) {
            modifier = document.getDocumentParser().getLanguageParser().getModifierConstruct(feature);
          }
        }
        const modLeftWord = document.wordLeftAt(position);
        if (modifier == null && modLeftWord != null && ((_a = modifierManager_default.instance) == null ? void 0 : _a.hasModifier(modLeftWord))) {
          if (node.modifierChain != null && node.modifierChain.modifierChain.length > 0) {
            for (let i = 0; i < node.modifierChain.modifierChain.length; i++) {
              const curModifierChainItem = node.modifierChain.modifierChain[i];
              if (curModifierChainItem.modifier != null && curModifierChainItem.modifier.name == modLeftWord) {
                modifier = curModifierChainItem;
                break;
              }
            }
          }
        }
        if (modifier != null) {
          context.activeModifier = modifier;
          if (modifier.nameNode != null) {
            context.name = modifier.nameNode.name;
          }
          if (modifier.nameNode != null && position.isWithin(modifier.nameNode.startPosition, modifier.nameNode.endPosition, 1)) {
            context.inModifierName = true;
          }
          if (modifier.methodStyleArguments != null) {
            context.valueCount = modifier.methodStyleArguments.args.length;
            if (!context.inModifierName) {
              for (let i = 0; i < modifier.methodStyleArguments.args.length; i++) {
                const argValue = modifier.methodStyleArguments.args[i];
                if (position.isWithin(argValue.startPosition, argValue.endPosition, 1)) {
                  context.activeValueIndex = i;
                  context.activeValue = argValue;
                }
              }
              if (context.activeValueIndex === -1 && position.isWithin(modifier.methodStyleArguments.startPosition, modifier.methodStyleArguments.endPosition)) {
                context.valueCount += 1;
                context.activeValueIndex = context.valueCount - 1;
              }
            }
          } else {
            context.valueCount = modifier.valueNodes.length;
            if (!context.inModifierName) {
              for (let i = 0; i < modifier.valueNodes.length; i++) {
                const value = modifier.valueNodes[i];
                if (position.isWithin(value.startPosition, value.endPosition, 1)) {
                  context.activeValueIndex = i;
                  context.activeValue = value;
                  break;
                }
              }
            }
          }
        }
        return context;
      }
    };
  }
});

// server/src/runtime/document/contexts/parameterContext.ts
var ParameterContext;
var init_parameterContext = __esm({
  "server/src/runtime/document/contexts/parameterContext.ts"() {
    "use strict";
    ParameterContext = class {
      constructor() {
        this.parameter = null;
        this.isInName = false;
        this.isInValue = false;
      }
      static resolveContext(position, node) {
        const context = new ParameterContext();
        context.parameter = node;
        if (position.isWithinRange(node.namePosition)) {
          context.isInName = true;
        } else if (position.isWithinRange(node.valuePosition)) {
          context.isInValue = true;
        }
        return context;
      }
    };
  }
});

// server/src/runtime/document/contexts/positionContext.ts
var PositionContext, CursorContext;
var init_positionContext = __esm({
  "server/src/runtime/document/contexts/positionContext.ts"() {
    "use strict";
    init_simpleIds();
    PositionContext = class {
      constructor() {
        this.refId = "";
        this.node = null;
        this.leftPunctuation = null;
        this.rightPunctuation = null;
        this.leftChar = null;
        this.rightChar = null;
        this.word = null;
        this.char = null;
        this.interpolatedContext = false;
        this.leftWord = null;
        this.rightWord = null;
        this.isCursorInIdentifier = false;
        this.root = null;
        this.identifierContext = null;
        this.position = null;
        this.feature = null;
        this.isInParameter = false;
        this.subContext = null;
        this.parameterContext = null;
        this.modifierContext = null;
        this.generalContext = null;
        this.variableContext = null;
        this.cursorContext = CursorContext.Unknown;
        this.refId = getId();
      }
    };
    CursorContext = /* @__PURE__ */ ((CursorContext2) => {
      CursorContext2[CursorContext2["Unknown"] = 0] = "Unknown";
      CursorContext2[CursorContext2["Variable"] = 1] = "Variable";
      CursorContext2[CursorContext2["Modifier"] = 2] = "Modifier";
      CursorContext2[CursorContext2["Parameter"] = 3] = "Parameter";
      CursorContext2[CursorContext2["General"] = 4] = "General";
      CursorContext2[CursorContext2["LanguageOperator"] = 5] = "LanguageOperator";
      return CursorContext2;
    })(CursorContext || {});
  }
});

// server/src/runtime/document/contexts/variableContext.ts
var VariableContext;
var init_variableContext = __esm({
  "server/src/runtime/document/contexts/variableContext.ts"() {
    "use strict";
    init_strings();
    init_abstractNode();
    VariableContext = class {
      constructor() {
        this.variableNode = null;
        this.varPathText = "";
      }
      static resolveContext(position, node, feature, document) {
        var _a;
        if (feature == null) {
          return null;
        }
        let featureToCheck = feature;
        const parser = document.getDocumentParser().getLanguageParser(), context = new VariableContext(), curWord = (_a = document.wordAt(position)) != null ? _a : "";
        if (feature instanceof InlineBranchSeparator && parser.isMergedVariableComponent(feature) == false && feature.prev instanceof VariableNode) {
          featureToCheck = feature.prev;
        }
        let varPathText = "";
        if (parser.isMergedVariableComponent(featureToCheck)) {
          const mergedStructure = parser.getMergedVariable(featureToCheck);
          if (mergedStructure.startPosition != null) {
            varPathText = document.getText(mergedStructure.startPosition.index, position.index).trim();
          }
          context.variableNode = mergedStructure;
        } else if (featureToCheck instanceof VariableNode) {
          context.variableNode = featureToCheck;
          varPathText = featureToCheck.name;
          if (featureToCheck.variableReference != null) {
            varPathText = featureToCheck.variableReference.normalizedReference;
          }
        }
        if (varPathText.length > 0) {
          varPathText = replaceAllInString(varPathText, "\\.", ":");
        }
        const varParts = varPathText.split(":");
        if (curWord.trim().length > 0) {
          varParts.pop();
        }
        varPathText = varParts.join(":");
        if (varPathText.endsWith(":")) {
          varPathText = trimRight(varPathText, ":");
        }
        context.varPathText = varPathText;
        return context;
      }
    };
  }
});

// server/src/runtime/document/contexts/contextResolver.ts
var ContextResolver;
var init_contextResolver = __esm({
  "server/src/runtime/document/contexts/contextResolver.ts"() {
    "use strict";
    init_abstractNode();
    init_featureContextResolver();
    init_generalContext();
    init_identifierContext();
    init_modifierContext();
    init_parameterContext();
    init_positionContext();
    init_variableContext();
    ContextResolver = class {
      static resolveIdentifierContext(position, node) {
        const identifierContext = new IdentifierContext();
        if (node.nameMethodPartStartsOn != null) {
          if (position.char < node.nameMethodPartStartsOn.char) {
            identifierContext.inTagPart = true;
            identifierContext.inMethodPart = false;
          } else {
            identifierContext.inTagPart = false;
            identifierContext.inMethodPart = true;
          }
        } else {
          identifierContext.inMethodPart = false;
          identifierContext.inTagPart = true;
        }
        return identifierContext;
      }
      static resolveContext(position, node, document, isInterpolated = false, root = null) {
        var _a, _b, _c, _d, _e, _f;
        if (node == null || position == null) {
          return null;
        }
        if (node instanceof ParserFailNode || node instanceof AntlersNode) {
          const cursorContext = new PositionContext();
          if (node.nameStartsOn != null && position.line == node.nameStartsOn.line) {
            let isInName = false;
            if (position.char >= node.nameStartsOn.char) {
              isInName = true;
            }
            if (node.nameEndsOn != null) {
              if (position.char > node.nameEndsOn.char) {
                isInName = false;
              }
            }
            if (isInName) {
              cursorContext.isCursorInIdentifier = true;
              cursorContext.identifierContext = ContextResolver.resolveIdentifierContext(position, node);
            }
          }
          node.addContext(cursorContext);
          if (root != null) {
            root.addContext(cursorContext);
          }
          cursorContext.interpolatedContext = isInterpolated;
          cursorContext.node = node;
          cursorContext.position = position;
          cursorContext.root = root;
          cursorContext.leftPunctuation = document.punctuationLeftAt(position);
          cursorContext.rightPunctuation = document.punctuationRightAt(position);
          cursorContext.leftChar = document.charLeftAt(position);
          cursorContext.rightChar = document.charRightAt(position);
          if (cursorContext.isCursorInIdentifier == true && cursorContext.leftChar == " ") {
            cursorContext.leftChar = ":";
          }
          cursorContext.word = document.wordAt(position);
          cursorContext.char = document.charAt(position);
          cursorContext.leftWord = document.wordLeftAt(position);
          cursorContext.rightWord = document.wordRightAt(position);
          let foundParameterContext = false;
          if (node.parameters.length > 0) {
            for (let i = 0; i < node.parameters.length; i++) {
              const thisParam = node.parameters[i];
              if (thisParam.blockPosition != null && thisParam.blockPosition.start != null && thisParam.blockPosition.end != null) {
                if (position.char > thisParam.blockPosition.start.char && position.char <= thisParam.blockPosition.end.char + 1 && position.line >= ((_c = (_b = (_a = thisParam.namePosition) == null ? void 0 : _a.start) == null ? void 0 : _b.line) != null ? _c : thisParam.blockPosition.start.line) && position.line <= ((_f = (_e = (_d = thisParam.valuePosition) == null ? void 0 : _d.end) == null ? void 0 : _e.line) != null ? _f : thisParam.blockPosition.end.line)) {
                  cursorContext.cursorContext = 3 /* Parameter */;
                  cursorContext.parameterContext = ParameterContext.resolveContext(position, thisParam);
                  cursorContext.isInParameter = true;
                  cursorContext.feature = thisParam;
                  foundParameterContext = true;
                  break;
                }
              }
            }
          }
          if (!foundParameterContext) {
            node.runtimeNodes.forEach((runtimeNode) => {
              if (runtimeNode.startPosition != null && runtimeNode.endPosition != null) {
                if (position.isWithin(runtimeNode.startPosition, runtimeNode.endPosition, 1)) {
                  cursorContext.feature = runtimeNode;
                }
              }
            });
          }
          if (foundParameterContext) {
            if (node.interpolationRegions.size > 0) {
              const regions = Array.from(node.interpolationRegions, ([name, region]) => region);
              for (let j = 0; j < regions.length; j++) {
                const interpolatedRegion = regions[j];
                if (position.index >= interpolatedRegion.startOffset && position.index <= interpolatedRegion.endOffset) {
                  const interpolatedNode = node.getInterpolationNode(interpolatedRegion.varContent);
                  return ContextResolver.resolveContext(position, interpolatedNode, document, true, root);
                }
              }
            }
          }
          if (cursorContext.feature instanceof VariableNode && cursorContext.feature.isInterpolationReference && cursorContext.feature.parent != null && cursorContext.feature.parent instanceof AntlersNode && cursorContext.feature.parent.processedInterpolationRegions.has(cursorContext.feature.name)) {
            return ContextResolver.resolveContext(position, cursorContext.feature.parent.getInterpolationNode(cursorContext.feature.name), document, true, root);
          }
          const isInModifier = FeatureContextResolver.isModifierLeftOfPosition(position, node.runtimeNodes);
          if (isInModifier) {
            cursorContext.cursorContext = 2 /* Modifier */;
            cursorContext.modifierContext = ModifierContext.resolveContext(position, node, cursorContext.feature, document);
          } else {
            if (!foundParameterContext) {
              cursorContext.cursorContext = 4 /* General */;
              cursorContext.generalContext = GeneralContext.resolveContext(position, node, cursorContext.feature);
            }
          }
          cursorContext.variableContext = VariableContext.resolveContext(position, node, cursorContext.feature, document);
          return cursorContext;
        }
        return null;
      }
    };
  }
});

// server/src/runtime/document/scanners/antlersNodeQueries.ts
var AntlersNodeQueries;
var init_antlersNodeQueries = __esm({
  "server/src/runtime/document/scanners/antlersNodeQueries.ts"() {
    "use strict";
    init_tagManagerInstance();
    init_abstractNode();
    AntlersNodeQueries = class {
      static isPairedNode(node) {
        if (node instanceof ConditionNode) {
          return true;
        }
        if (node instanceof ParserFailNode || node instanceof AntlersNode) {
          return node.isClosedBy != null;
        }
        return false;
      }
      static findAncestorsBeforePosition(position, documentNodes) {
        var _a, _b, _c, _d, _e, _f;
        const nodesToReturn = [];
        const skippedNodes = [];
        let forceSkipLine = -1, forceSkipOffset = -1;
        for (let i = 0; i < documentNodes.length; i++) {
          const currentNode = documentNodes[i];
          if (currentNode.isClosedBy != null) {
            if ((_a = currentNode.isClosedBy.endPosition) == null ? void 0 : _a.isBefore(position)) {
              skippedNodes.push(currentNode);
              skippedNodes.push(currentNode.isClosedBy);
              forceSkipLine = currentNode.isClosedBy.endPosition.line;
              forceSkipOffset = currentNode.isClosedBy.endPosition.char;
            }
          }
          if (forceSkipLine > -1) {
            if (currentNode.endPosition != null) {
              if (currentNode.endPosition.line < forceSkipLine) {
                continue;
              }
              if (currentNode.endPosition.line == forceSkipLine && forceSkipOffset > -1) {
                if (currentNode.endPosition.char < forceSkipOffset) {
                  continue;
                }
              }
            }
          }
          if (currentNode.startPosition != null) {
            if (position.isBefore(currentNode.startPosition)) {
              break;
            }
            if (currentNode.startPosition.line == position.line && position.char <= currentNode.startPosition.char) {
              skippedNodes.push(currentNode);
              continue;
            }
          }
          if (((_b = tagManagerInstance_default.instance) == null ? void 0 : _b.requiresClose(currentNode)) && currentNode.isClosedBy != null) {
            const closingNode = currentNode.isClosedBy;
            if ((_c = closingNode.startPosition) == null ? void 0 : _c.isBefore(position)) {
              skippedNodes.push(currentNode);
              skippedNodes.push(closingNode);
              continue;
            } else if (((_d = closingNode.startPosition) == null ? void 0 : _d.line) == position.line && ((_e = closingNode.startPosition) == null ? void 0 : _e.char) < position.char) {
              skippedNodes.push(currentNode);
            } else {
              nodesToReturn.push(currentNode);
            }
          } else {
            if (currentNode.parent != null) {
              const parent = currentNode.parent;
              if (skippedNodes.includes(parent)) {
                skippedNodes.push(currentNode);
                continue;
              } else {
                if ((_f = currentNode.endPosition) == null ? void 0 : _f.isBefore(position)) {
                  nodesToReturn.push(currentNode);
                } else {
                  skippedNodes.push(currentNode);
                }
              }
            } else {
              nodesToReturn.push(currentNode);
            }
          }
        }
        return nodesToReturn;
      }
    };
  }
});

// server/src/runtime/document/documentCursor.ts
var DocumentCursor;
var init_documentCursor = __esm({
  "server/src/runtime/document/documentCursor.ts"() {
    "use strict";
    init_nodeQueries();
    init_contextResolver();
    init_antlersNodeQueries();
    init_abstractNode();
    DocumentCursor = class {
      constructor(doc) {
        this.doc = doc;
      }
      getAncestorsAt(line, char) {
        const position = this.position(line, char);
        if (position == null) {
          return [];
        }
        return AntlersNodeQueries.findAncestorsBeforePosition(position, this.doc.getAllAntlersNodes());
      }
      getNameAt(line, char) {
        const node = this.getNodeAt(line, char);
        if (node instanceof AntlersNode) {
          return node.name;
        }
        return null;
      }
      getScopeAt(line, char) {
        const node = this.getNodeAt(line, char);
        if (node instanceof AntlersNode) {
          if (node.currentScope != null) {
            return node.currentScope;
          }
        }
        return null;
      }
      getFeaturesAt(line, char) {
        const position = this.position(line, char), node = this.getNodeAt(line, char);
        return ContextResolver.resolveContext(position, node, this.doc, false, node);
      }
      getNodeAt(line, char) {
        return NodeQueries.findNodeAtPosition(this.position(line, char), this.doc.getDocumentParser().getNodes());
      }
      getNodeBefore(line, char) {
        return NodeQueries.findNodeBeforePosition(
          this.position(line, char),
          this.doc.getDocumentParser().getNodes()
        );
      }
      getNodeAfter(line, char) {
        return NodeQueries.findNodeAfterPosition(
          this.position(line, char),
          this.doc.getDocumentParser().getNodes()
        );
      }
      getNodesBefore(line, char) {
        return NodeQueries.findNodesBeforePosition(
          this.position(line, char),
          this.doc.getDocumentParser().getNodes()
        );
      }
      getAssignmentsBefore(line, char) {
        const assignments = this.doc.getDocumentParser().getLanguageParser().getRuntimeAssignments(), returnNodes = [], pos = this.position(line, char);
        if (pos != null) {
          assignments.forEach((assignment) => {
            if (NodeQueries.isBefore(assignment.target, pos)) {
              returnNodes.push(assignment);
            }
          });
        }
        return returnNodes;
      }
      getAssignmentsAfter(line, char) {
        const assignments = this.doc.getDocumentParser().getLanguageParser().getRuntimeAssignments(), returnNodes = [], pos = this.position(line, char);
        if (pos != null) {
          assignments.forEach((assignment) => {
            if (NodeQueries.isAfter(assignment.target, pos)) {
              returnNodes.push(assignment);
            }
          });
        }
        return returnNodes;
      }
      getNodesAfter(line, char) {
        return NodeQueries.findNodesAfterPosition(
          this.position(line, char),
          this.doc.getDocumentParser().getNodes()
        );
      }
      getIsWithinPairedNode(line, char) {
        const node = this.getNodeBefore(line, char);
        if (node == null) {
          return false;
        }
        return AntlersNodeQueries.isPairedNode(node);
      }
      position(line, char) {
        return this.doc.getDocumentParser().positionFromCursor(line, char);
      }
      charLeftAt(line, char) {
        return this.doc.getDocumentParser().charLeftAtCursor(line, char);
      }
      charAt(line, char) {
        return this.doc.getDocumentParser().charAtCursor(line, char);
      }
      charRightAt(line, char) {
        return this.doc.getDocumentParser().charRightAtCursor(line, char);
      }
      wordLeftAt(line, char, tabSize = 4) {
        return this.doc.getDocumentParser().wordLeftAtCursor(line, char, tabSize);
      }
      wordRightAt(line, char, tabSize = 4) {
        return this.doc.getDocumentParser().wordRightAtCursor(line, char, tabSize);
      }
      wordAt(line, char, tabSize = 4) {
        return this.doc.getDocumentParser().wordAtCursor(line, char, tabSize);
      }
      punctuationLeftAt(line, char, tabSize = 4) {
        return this.doc.getDocumentParser().punctuationLeftAtCursor(line, char, tabSize);
      }
      punctuationRightAt(line, char, tabSize = 4) {
        return this.doc.getDocumentParser().punctuationRightAtCursor(line, char, tabSize);
      }
    };
  }
});

// server/src/runtime/document/documentErrors.ts
var DocumentErrors;
var init_documentErrors = __esm({
  "server/src/runtime/document/documentErrors.ts"() {
    "use strict";
    DocumentErrors = class {
      constructor(doc) {
        this.doc = doc;
      }
      hasStructureErrors() {
        return this.doc.getDocumentParser().getStructureErrors().length > 0;
      }
      getFirstStructureError() {
        return this.doc.getDocumentParser().getStructureErrors()[0];
      }
      hasAny() {
        return this.all().length > 0;
      }
      all() {
        const errorHashes = [], errors = [];
        this.doc.getAllAntlersNodes().forEach((node) => {
          node.getErrors().forEach((error) => {
            if (errorHashes.includes(error.hash()) == false) {
              errorHashes.push(error.hash());
              errors.push(error);
            }
          });
        });
        this.doc.getDocumentParser().getAntlersErrors().forEach((error) => {
          if (errorHashes.includes(error.hash()) == false) {
            errorHashes.push(error.hash());
            errors.push(error);
          }
        });
        return errors;
      }
    };
  }
});

// server/node_modules/yaml/dist/PlainValue-ec8e588e.js
var require_PlainValue_ec8e588e = __commonJS({
  "server/node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports) {
    "use strict";
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src) {
      const ls = [0];
      let offset = src.indexOf("\n");
      while (offset !== -1) {
        offset += 1;
        ls.push(offset);
        offset = src.indexOf("\n", offset);
      }
      return ls;
    }
    function getSrcInfo(cst) {
      let lineStarts, src;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src = cst;
      } else {
        if (Array.isArray(cst))
          cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts)
            cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src = cst.context.src;
        }
      }
      return {
        lineStarts,
        src
      };
    }
    function getLinePos(offset, cst) {
      if (typeof offset !== "number" || offset < 0)
        return null;
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !src || offset > src.length)
        return null;
      for (let i = 0; i < lineStarts.length; ++i) {
        const start = lineStarts[i];
        if (offset < start) {
          return {
            line: i,
            col: offset - lineStarts[i - 1] + 1
          };
        }
        if (offset === start)
          return {
            line: i + 1,
            col: 1
          };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset - lineStarts[line - 1] + 1
      };
    }
    function getLine2(line, cst) {
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length)
        return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src[end - 1] === "\n")
        --end;
      return src.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src = getLine2(start.line, cst);
      if (!src)
        return null;
      let {
        col
      } = start;
      if (src.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src = src.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src.length > col + halfWidth)
            src = src.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src.length - maxWidth;
          src = "\u2026" + src.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src}
${offset}${err}${errEnd}`;
    }
    var Range3 = class {
      static copy(orig) {
        return new Range3(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      setOrigRange(cr, offset) {
        const {
          start,
          end
        } = this;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        let i = offset;
        while (i < cr.length) {
          if (cr[i] > start)
            break;
          else
            ++i;
        }
        this.origStart = start + i;
        const nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end)
            break;
          else
            ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    };
    var Node3 = class {
      static addStringTerminator(src, offset, str2) {
        if (str2[str2.length - 1] === "\n")
          return str2;
        const next = Node3.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str2 + "\n" : str2;
      }
      static atDocumentBoundary(src, offset, sep) {
        const ch0 = src[offset];
        if (!ch0)
          return true;
        const prev = src[offset - 1];
        if (prev && prev !== "\n")
          return false;
        if (sep) {
          if (ch0 !== sep)
            return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
            return false;
        }
        const ch1 = src[offset + 1];
        const ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0)
          return false;
        const ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src, offset) {
        let ch = src[offset];
        const isVerbatim = ch === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1)
          ch = src[offset += 1];
        if (isVerbatim && ch === ">")
          offset += 1;
        return offset;
      }
      static endOfIndent(src, offset) {
        let ch = src[offset];
        while (ch === " ")
          ch = src[offset += 1];
        return offset;
      }
      static endOfLine(src, offset) {
        let ch = src[offset];
        while (ch && ch !== "\n")
          ch = src[offset += 1];
        return offset;
      }
      static endOfWhiteSpace(src, offset) {
        let ch = src[offset];
        while (ch === "	" || ch === " ")
          ch = src[offset += 1];
        return offset;
      }
      static startOfLine(src, offset) {
        let ch = src[offset - 1];
        if (ch === "\n")
          return offset;
        while (ch && ch !== "\n")
          ch = src[offset -= 1];
        return offset + 1;
      }
      static endOfBlockIndent(src, indent, lineStart) {
        const inEnd = Node3.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = Node3.endOfWhiteSpace(src, inEnd);
          const ch = src[wsEnd];
          if (!ch || ch === "\n")
            return wsEnd;
        }
        return null;
      }
      static atBlank(src, offset, endAsBlank) {
        const ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
      static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0)
          return false;
        if (indentDiff > 0)
          return true;
        return indicatorAsIndent && ch === "-";
      }
      static normalizeOffset(src, offset) {
        const ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node3.endOfWhiteSpace(src, offset);
      }
      static foldNewline(src, offset, indent) {
        let inCount = 0;
        let error = false;
        let fold = "";
        let ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent)
                error = true;
              offset = Node3.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold)
          fold = " ";
        if (ch && inCount <= indent)
          error = true;
        return {
          fold,
          offset,
          error
        };
      }
      constructor(type2, props, context) {
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type2;
        this.value = null;
      }
      getPropValue(idx, key, skipKey) {
        if (!this.context)
          return null;
        const {
          src
        } = this.context;
        const prop = this.props[idx];
        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i = 0; i < this.props.length; ++i) {
          const anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null)
            return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i = 0; i < this.props.length; ++i) {
          const comment = this.getPropValue(i, Char.COMMENT, true);
          if (comment != null)
            comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src
        } = this.context;
        if (this.header && start === this.header.end)
          return false;
        if (!this.valueRange)
          return false;
        const {
          end
        } = this.valueRange;
        return start !== end || Node3.atBlank(src, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context)
          return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start)
          return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context)
          return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i = 0; i < this.props.length; ++i) {
          const tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context)
          return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        for (let i = start; i < end; ++i) {
          if (src[i] === "\n")
            return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src
        } = this.context;
        if (src[start] === Char.COMMENT) {
          const end = Node3.endOfLine(src, start + 1);
          const commentRange = new Range3(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      setOrigRanges(cr, offset) {
        if (this.range)
          offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange)
          this.valueRange.setOrigRange(cr, offset);
        this.props.forEach((prop) => prop.setOrigRange(cr, offset));
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          range,
          value
        } = this;
        if (value != null)
          return value;
        const str2 = src.slice(range.start, range.end);
        return Node3.addStringTerminator(src, range.end, str2);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source, message) {
        if (!message || !(source instanceof Node3))
          throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source;
      }
      makePretty() {
        if (!this.source)
          return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range3(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx)
            this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLReferenceError", source, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSemanticError", source, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSyntaxError", source, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source, message) {
        super("YAMLWarning", source, message);
      }
    };
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var PlainValue = class extends Node3 {
      static endOfLine(src, start, inFlow) {
        let ch = src[start];
        let offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
            break;
          const next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
            break;
          if ((ch === " " || ch === "	") && next === "#")
            break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        let ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " "))
          ch = src[--end - 1];
        let str2 = "";
        for (let i = start; i < end; ++i) {
          const ch2 = src[i];
          if (ch2 === "\n") {
            const {
              fold,
              offset
            } = Node3.foldNewline(src, i, -1);
            str2 += fold;
            i = offset;
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str2 += ch2;
          }
        }
        const ch0 = src[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          default:
            return str2;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src
        } = this.context;
        let offset = start;
        let valueEnd = start;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node3.atDocumentBoundary(src, offset + 1))
            break;
          const end = Node3.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#")
            break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = PlainValue.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty())
          this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      parse(context, start) {
        this.context = context;
        const {
          inFlow,
          src
        } = context;
        let offset = start;
        const ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = PlainValue.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range3(start, offset);
        offset = Node3.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    };
    exports.Char = Char;
    exports.Node = Node3;
    exports.PlainValue = PlainValue;
    exports.Range = Range3;
    exports.Type = Type;
    exports.YAMLError = YAMLError;
    exports.YAMLReferenceError = YAMLReferenceError;
    exports.YAMLSemanticError = YAMLSemanticError;
    exports.YAMLSyntaxError = YAMLSyntaxError;
    exports.YAMLWarning = YAMLWarning;
    exports._defineProperty = _defineProperty;
    exports.defaultTagPrefix = defaultTagPrefix;
    exports.defaultTags = defaultTags;
  }
});

// server/node_modules/yaml/dist/parse-cst.js
var require_parse_cst = __commonJS({
  "server/node_modules/yaml/dist/parse-cst.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var BlankLine = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.BLANK_LINE);
      }
      get includesTrailingLines() {
        return true;
      }
      parse(context, start) {
        this.context = context;
        this.range = new PlainValue.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          atLineStart,
          lineStart
        } = context;
        if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM)
          this.error = new PlainValue.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context.indent;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        let ch = src[offset];
        const inlineComment = ch === "#";
        const comments = [];
        let blankLine = null;
        while (ch === "\n" || ch === "#") {
          if (ch === "#") {
            const end2 = PlainValue.Node.endOfLine(src, offset + 1);
            comments.push(new PlainValue.Range(offset, end2));
            offset = end2;
          } else {
            atLineStart = true;
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
            if (src[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
            }
            offset = PlainValue.Node.endOfIndent(src, lineStart);
          }
          ch = src[offset];
        }
        if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset);
        } else if (ch && lineStart > start + 1) {
          offset = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context.parent.items || context.parent.contents;
            if (items)
              items.push(blankLine);
          }
          if (comments.length)
            Array.prototype.push.apply(this.props, comments);
          offset = this.node.range.end;
        } else {
          if (inlineComment) {
            const c = comments[0];
            this.props.push(c);
            offset = c.end;
          } else {
            offset = PlainValue.Node.endOfLine(src, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset;
        this.valueRange = new PlainValue.Range(start, end);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.node ? this.node.setOrigRanges(cr, offset) : offset;
      }
      toString() {
        const {
          context: {
            src
          },
          node,
          range,
          value
        } = this;
        if (value != null)
          return value;
        const str2 = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Comment = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.COMMENT);
      }
      parse(context, start) {
        this.context = context;
        const offset = this.parseComment(start);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    function grabCollectionEndComments(node) {
      let cnode = node;
      while (cnode instanceof CollectionItem)
        cnode = cnode.node;
      if (!(cnode instanceof Collection3))
        return null;
      const len = cnode.items.length;
      let ci = -1;
      for (let i = len - 1; i >= 0; --i) {
        const n = cnode.items[i];
        if (n.type === PlainValue.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n.context;
          if (indent > 0 && n.range.start >= lineStart + indent)
            break;
          ci = i;
        } else if (n.type === PlainValue.Type.BLANK_LINE)
          ci = i;
        else
          break;
      }
      if (ci === -1)
        return null;
      const ca = cnode.items.splice(ci, len - ci);
      const prevEnd = ca[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd)
          cnode.valueRange.end = prevEnd;
        if (cnode === node)
          break;
        cnode = cnode.context.parent;
      }
      return ca;
    }
    var Collection3 = class extends PlainValue.Node {
      static nextContentHasIndent(src, offset, indent) {
        const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
        offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
        const ch = src[offset];
        if (!ch)
          return false;
        if (offset >= lineStart + indent)
          return true;
        if (ch !== "#" && ch !== "\n")
          return false;
        return Collection3.nextContentHasIndent(src, offset, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);
        for (let i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let lineStart = PlainValue.Node.startOfLine(src, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset = start;
        offset = PlainValue.Node.normalizeOffset(src, offset);
        let ch = src[offset];
        let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
        let prevIncludesTrailingLines = false;
        while (ch) {
          while (ch === "\n" || ch === "#") {
            if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset = blankLine.parse({
                src
              }, offset);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
              this.items.push(blankLine);
              offset -= 1;
            } else if (ch === "#") {
              if (offset < lineStart + indent && !Collection3.nextContentHasIndent(src, offset, indent)) {
                return offset;
              }
              const comment = new Comment();
              offset = comment.parse({
                indent,
                lineStart,
                src
              }, offset);
              this.items.push(comment);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
            }
            lineStart = offset + 1;
            offset = PlainValue.Node.endOfIndent(src, lineStart);
            if (PlainValue.Node.atBlank(src, offset)) {
              const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
              const next = src[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset = wsEnd;
              }
            }
            ch = src[offset];
            atLineStart = true;
          }
          if (!ch) {
            break;
          }
          if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
            if (offset < lineStart + indent) {
              if (lineStart > start)
                offset = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
            if (ch !== "-") {
              if (lineStart > start)
                offset = lineStart;
              break;
            }
          } else if (ch === "-" && !this.error) {
            const next = src[offset + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          const node = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset);
          if (!node)
            return offset;
          this.items.push(node);
          this.valueRange.end = node.valueRange.end;
          offset = PlainValue.Node.normalizeOffset(src, node.range.end);
          ch = src[offset];
          atLineStart = false;
          prevIncludesTrailingLines = node.includesTrailingLines;
          if (ch) {
            let ls = offset - 1;
            let prev = src[ls];
            while (prev === " " || prev === "	")
              prev = src[--ls];
            if (prev === "\n") {
              lineStart = ls + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node);
          if (ec)
            Array.prototype.push.apply(this.items, ec);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null)
          return value;
        let str2 = src.slice(range.start, items[0].range.start) + String(items[0]);
        for (let i = 1; i < items.length; ++i) {
          const item = items[i];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart)
            for (let i2 = 0; i2 < indent; ++i2)
              str2 += " ";
          str2 += String(item);
        }
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Directive = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "	" && ch !== " ")
          ch = src[offset += 1];
        this.name = src.slice(start, offset);
        return offset;
      }
      parseParameters(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "#")
          ch = src[offset += 1];
        this.valueRange = new PlainValue.Range(start, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        let offset = this.parseName(start + 1);
        offset = this.parseParameters(offset);
        offset = this.parseComment(offset);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    var Document = class extends PlainValue.Node {
      static startCommentOrEndBlankLine(src, start) {
        const offset = PlainValue.Node.endOfWhiteSpace(src, start);
        const ch = src[offset];
        return ch === "#" || ch === "\n" ? offset : start;
      }
      constructor() {
        super(PlainValue.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset = start;
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
          offset = Document.startCommentOrEndBlankLine(src, offset);
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset = directive.parse({
                  parent: this,
                  src
                }, offset);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset;
          }
        }
        if (src[offset]) {
          this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
          return offset + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset;
      }
      parseContents(start) {
        const {
          parseNode,
          src
        } = this.context;
        if (!this.contents)
          this.contents = [];
        let lineStart = start;
        while (src[lineStart - 1] === "-")
          lineStart -= 1;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue.Range(offset);
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              lineStart = offset;
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue.Node.endOfIndent(src, offset);
              const context = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node = parseNode(context, iEnd);
              if (!node)
                return this.valueRange.end = iEnd;
              this.contents.push(node);
              offset = node.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node);
              if (ec)
                Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset = Document.startCommentOrEndBlankLine(src, offset);
        }
        this.valueRange.end = offset;
        if (src[offset]) {
          this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
          offset += 3;
          if (src[offset]) {
            offset = PlainValue.Node.endOfWhiteSpace(src, offset);
            if (src[offset] === "#") {
              const comment = new Comment();
              offset = comment.parse({
                src
              }, offset);
              this.contents.push(comment);
            }
            switch (src[offset]) {
              case "\n":
                offset += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset;
      }
      parse(context, start) {
        context.root = this;
        this.context = context;
        const {
          src
        } = context;
        let offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
        offset = this.parseDirectives(offset);
        offset = this.parseContents(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.directives.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.directivesEndMarker)
          offset = this.directivesEndMarker.setOrigRange(cr, offset);
        this.contents.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.documentEndMarker)
          offset = this.documentEndMarker.setOrigRange(cr, offset);
        return offset;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null)
          return value;
        let str2 = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT)
            str2 += "---\n";
          str2 += contents.join("");
        }
        if (str2[str2.length - 1] !== "\n")
          str2 += "\n";
        return str2;
      }
    };
    var Alias2 = class extends PlainValue.Node {
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
        this.valueRange = new PlainValue.Range(start + 1, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (this.valueRange.isEmpty())
          return "";
        let lastNewLine = null;
        let ch = src[end - 1];
        while (ch === "\n" || ch === "	" || ch === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP)
              break;
            else
              return "";
          }
          if (ch === "\n")
            lastNewLine = end;
          ch = src[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi = indent + this.blockIndent;
        const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
        let atStart = true;
        let str2 = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i = start; i < end; ++i) {
          for (let j = 0; j < bi; ++j) {
            if (src[i] !== " ")
              break;
            i += 1;
          }
          const ch2 = src[i];
          if (ch2 === "\n") {
            if (sep === "\n")
              str2 += "\n";
            else
              sep = "\n";
          } else {
            const lineEnd = PlainValue.Node.endOfLine(src, i);
            const line = src.slice(i, lineEnd);
            i = lineEnd;
            if (folded && (ch2 === " " || ch2 === "	") && i < keepStart) {
              if (sep === " ")
                sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n")
                sep = "\n\n";
              str2 += sep + line;
              sep = lineEnd < end && src[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str2 += sep + line;
              sep = folded && i < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "")
              atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str2 : str2 + "\n";
      }
      parseBlockHeader(start) {
        const {
          src
        } = this.context;
        let offset = start + 1;
        let bi = "";
        while (true) {
          const ch = src[offset];
          switch (ch) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi += ch;
              break;
            default:
              this.blockIndent = Number(bi) || null;
              this.header = new PlainValue.Range(start, offset);
              return offset;
          }
          offset += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          offset += 1;
          if (PlainValue.Node.atDocumentBoundary(src, offset))
            break;
          const end = PlainValue.Node.endOfBlockIndent(src, indent, offset);
          if (end === null)
            break;
          const ch2 = src[end];
          const lineIndent = end - (offset + indent);
          if (!this.blockIndent) {
            if (src[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch2 && ch2 !== "\n" && lineIndent < this.blockIndent) {
            if (src[end] === "#")
              break;
            if (!this.error) {
              const src2 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src2}`;
              this.error = new PlainValue.YAMLSemanticError(this, msg);
            }
          }
          if (src[end] === "\n") {
            offset = end;
          } else {
            offset = valueEnd = PlainValue.Node.endOfLine(src, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue.Range(start + 1, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = this.parseBlockHeader(start);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        offset = this.parseBlockValue(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.header ? this.header.setOrigRange(cr, offset) : offset;
      }
    };
    var FlowCollection = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node = this.items[idx - 1];
        return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          indent,
          lineStart
        } = context;
        let char = src[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        char = src[offset];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset + 1;
                const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
                if (src[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset = PlainValue.Node.endOfIndent(src, lineStart);
                if (offset <= lineStart + indent) {
                  char = src[offset];
                  if (offset < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              const next = src[offset + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
                break;
              }
            }
            default: {
              const node = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset);
              if (!node) {
                this.valueRange = new PlainValue.Range(start, offset);
                return offset;
              }
              this.items.push(node);
              offset = PlainValue.Node.normalizeOffset(src, node.range.end);
            }
          }
          offset = PlainValue.Node.endOfWhiteSpace(src, offset);
          char = src[offset];
        }
        this.valueRange = new PlainValue.Range(start, offset + 1);
        if (char) {
          this.items.push({
            char,
            offset
          });
          offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
          offset = this.parseComment(offset);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node) => {
          if (node instanceof PlainValue.Node) {
            offset = node.setOrigRanges(cr, offset);
          } else if (cr.length === 0) {
            node.origOffset = node.offset;
          } else {
            let i = offset;
            while (i < cr.length) {
              if (cr[i] > node.offset)
                break;
              else
                ++i;
            }
            node.origOffset = node.offset + i;
            offset = i;
          }
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null)
          return value;
        const nodes = items.filter((item) => item instanceof PlainValue.Node);
        let str2 = "";
        let prevEnd = range.start;
        nodes.forEach((node) => {
          const prefix = src.slice(prevEnd, node.range.start);
          prevEnd = node.range.end;
          str2 += prefix + String(node);
          if (str2[str2.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str2 += src.slice(prevEnd, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var QuoteDouble = class extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch && ch !== '"') {
          offset += ch === "\\" ? 2 : 1;
          ch = src[offset];
        }
        return offset + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== '"')
          errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1))
              errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error)
              errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch === "\\") {
            i += 1;
            switch (src[i]) {
              case "0":
                str2 += "\0";
                break;
              case "a":
                str2 += "\x07";
                break;
              case "b":
                str2 += "\b";
                break;
              case "e":
                str2 += "\x1B";
                break;
              case "f":
                str2 += "\f";
                break;
              case "n":
                str2 += "\n";
                break;
              case "r":
                str2 += "\r";
                break;
              case "t":
                str2 += "	";
                break;
              case "v":
                str2 += "\v";
                break;
              case "N":
                str2 += "\x85";
                break;
              case "_":
                str2 += "\xA0";
                break;
              case "L":
                str2 += "\u2028";
                break;
              case "P":
                str2 += "\u2029";
                break;
              case " ":
                str2 += " ";
                break;
              case '"':
                str2 += '"';
                break;
              case "/":
                str2 += "/";
                break;
              case "\\":
                str2 += "\\";
                break;
              case "	":
                str2 += "	";
                break;
              case "x":
                str2 += this.parseCharCode(i + 1, 2, errors);
                i += 2;
                break;
              case "u":
                str2 += this.parseCharCode(i + 1, 4, errors);
                i += 4;
                break;
              case "U":
                str2 += this.parseCharCode(i + 1, 8, errors);
                i += 8;
                break;
              case "\n":
                while (src[i + 1] === " " || src[i + 1] === "	")
                  i += 1;
                break;
              default:
                errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
                str2 += "\\" + src[i];
            }
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      parseCharCode(offset, length, errors) {
        const {
          src
        } = this.context;
        const cc = src.substr(offset, length);
        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
          return src.substr(offset - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = QuoteDouble.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var QuoteSingle = class extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch) {
          if (ch === "'") {
            if (src[offset + 1] !== "'")
              break;
            ch = src[offset += 2];
          } else {
            ch = src[offset += 1];
          }
        }
        return offset + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== "'")
          errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1))
              errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error)
              errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch === "'") {
            str2 += ch;
            i += 1;
            if (src[i] !== "'")
              errors.push(new PlainValue.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = QuoteSingle.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    function createNewNode(type2, props) {
      switch (type2) {
        case PlainValue.Type.ALIAS:
          return new Alias2(type2, props);
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
          return new BlockValue(type2, props);
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.FLOW_SEQ:
          return new FlowCollection(type2, props);
        case PlainValue.Type.MAP_KEY:
        case PlainValue.Type.MAP_VALUE:
        case PlainValue.Type.SEQ_ITEM:
          return new CollectionItem(type2, props);
        case PlainValue.Type.COMMENT:
        case PlainValue.Type.PLAIN:
          return new PlainValue.PlainValue(type2, props);
        case PlainValue.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type2, props);
        case PlainValue.Type.QUOTE_SINGLE:
          return new QuoteSingle(type2, props);
        default:
          return null;
      }
    }
    var ParseContext = class {
      static parseType(src, offset, inFlow) {
        switch (src[offset]) {
          case "*":
            return PlainValue.Type.ALIAS;
          case ">":
            return PlainValue.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue.Type.FLOW_MAP;
          case "[":
            return PlainValue.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;
          case '"':
            return PlainValue.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue.Type.QUOTE_SINGLE;
          default:
            return PlainValue.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue.Node.atDocumentBoundary(this.src, start))
            return null;
          const context = new ParseContext(this, overlay);
          const {
            props,
            type: type2,
            valueStart
          } = context.parseProps(start);
          const node = createNewNode(type2, props);
          let offset = node.parse(context, valueStart);
          node.range = new PlainValue.Range(start, offset);
          if (offset <= start) {
            node.error = new Error(`Node#parse consumed no characters`);
            node.error.parseEnd = offset;
            node.error.source = node;
            node.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node)) {
            if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
              node.error = new PlainValue.YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection3(node);
            offset = collection.parse(new ParseContext(context), offset);
            collection.range = new PlainValue.Range(start, offset);
            return collection;
          }
          return node;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node) {
        const {
          inCollection,
          inFlow,
          src
        } = this;
        if (inCollection || inFlow)
          return false;
        if (node instanceof CollectionItem)
          return true;
        let offset = node.range.end;
        if (src[offset] === "\n" || src[offset - 1] === "\n")
          return false;
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        return src[offset] === ":";
      }
      parseProps(offset) {
        const {
          inFlow,
          parent,
          src
        } = this;
        const props = [];
        let lineHasProps = false;
        offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
        let ch = src[offset];
        while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === "\n") {
          if (ch === "\n") {
            let inEnd = offset;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue.Node.endOfIndent(src, lineStart);
            } while (src[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src[inEnd] !== "#" && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
              break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset = inEnd;
          } else if (ch === PlainValue.Char.COMMENT) {
            const end = PlainValue.Node.endOfLine(src, offset + 1);
            props.push(new PlainValue.Range(offset, end));
            offset = end;
          } else {
            let end = PlainValue.Node.endOfIdentifier(src, offset + 1);
            if (ch === PlainValue.Char.TAG && src[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
              end = PlainValue.Node.endOfIdentifier(src, end + 5);
            }
            props.push(new PlainValue.Range(offset, end));
            lineHasProps = true;
            offset = PlainValue.Node.endOfWhiteSpace(src, end);
          }
          ch = src[offset];
        }
        if (lineHasProps && ch === ":" && PlainValue.Node.atBlank(src, offset + 1, true))
          offset -= 1;
        const type2 = ParseContext.parseType(src, offset, inFlow);
        return {
          props,
          type: type2,
          valueStart: offset
        };
      }
    };
    function parse(src) {
      const cr = [];
      if (src.indexOf("\r") !== -1) {
        src = src.replace(/\r\n?/g, (match, offset2) => {
          if (match.length > 1)
            cr.push(offset2);
          return "\n";
        });
      }
      const documents = [];
      let offset = 0;
      do {
        const doc = new Document();
        const context = new ParseContext({
          src
        });
        offset = doc.parse(context, offset);
        documents.push(doc);
      } while (offset < src.length);
      documents.setOrigRanges = () => {
        if (cr.length === 0)
          return false;
        for (let i = 1; i < cr.length; ++i)
          cr[i] -= i;
        let crOffset = 0;
        for (let i = 0; i < documents.length; ++i) {
          crOffset = documents[i].setOrigRanges(cr, crOffset);
        }
        cr.splice(0, cr.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    exports.parse = parse;
  }
});

// server/node_modules/yaml/dist/resolveSeq-d03cb037.js
var require_resolveSeq_d03cb037 = __commonJS({
  "server/node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    function addCommentBefore(str2, indent, comment) {
      if (!comment)
        return str2;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str2}`;
    }
    function addComment(str2, indent, comment) {
      return !comment ? str2 : comment.indexOf("\n") === -1 ? `${str2} #${comment}` : `${str2}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node3 = class {
    };
    function toJSON(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJSON(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor)
          ctx.onCreate = (res2) => {
            anchor.res = res2;
            delete ctx.onCreate;
          };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint")
        return Number(value);
      return value;
    }
    var Scalar3 = class extends Node3 {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema2, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, k, {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return schema2.createNode(v, false);
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
    var Collection3 = class extends Node3 {
      constructor(schema2) {
        super();
        PlainValue._defineProperty(this, "items", []);
        this.schema = schema2;
      }
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (node instanceof Collection3)
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (node instanceof Collection3)
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && node instanceof Scalar3 ? node.value : node;
        else
          return node instanceof Collection3 ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node) => {
          if (!node || node.type !== "PAIR")
            return false;
          const n = node.value;
          return n == null || n instanceof Scalar3 && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return node instanceof Collection3 ? node.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (node instanceof Collection3)
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify
        } = ctx;
        const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow)
          itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore)
              nodes2.push({
                type: "comment",
                str: ""
              });
            if (item.commentBefore)
              item.commentBefore.match(/^.*$/gm).forEach((line) => {
                nodes2.push({
                  type: "comment",
                  str: `#${line}`
                });
              });
            if (item.comment)
              comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
              hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str3 = stringify(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str3.includes("\n"))
            hasItemWithNewLine = true;
          if (inFlow && i < this.items.length - 1)
            str3 += ",";
          str3 = addComment(str3, itemIndent, comment);
          if (chompKeep && (comment || inFlow))
            chompKeep = false;
          nodes2.push({
            type: "item",
            str: str3
          });
          return nodes2;
        }, []);
        let str2;
        if (nodes.length === 0) {
          str2 = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n) => n.str);
          if (hasItemWithNewLine || strings.reduce((sum, str3) => sum + str3.length + 2, 2) > Collection3.maxFlowStringSingleLineLength) {
            str2 = start;
            for (const s of strings) {
              str2 += s ? `
${indentStep}${indent}${s}` : "\n";
            }
            str2 += `
${indent}${end}`;
          } else {
            str2 = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str2 = strings.shift();
          for (const s of strings)
            str2 += s ? `
${indent}${s}` : "\n";
        }
        if (this.comment) {
          str2 += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment)
            onComment();
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str2;
      }
    };
    PlainValue._defineProperty(Collection3, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key) {
      let idx = key instanceof Scalar3 ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq2 = class extends Collection3 {
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && it instanceof Scalar3 ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items)
          seq2.push(toJSON(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key, jsKey, ctx) => {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (key instanceof Node3 && ctx && ctx.doc)
        return key.toString({
          anchors: /* @__PURE__ */ Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    var Pair3 = class extends Node3 {
      constructor(key, value = null) {
        super();
        this.key = key;
        this.value = value;
        this.type = Pair3.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node3 ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null)
          this.key = new Scalar3(null);
        if (this.key instanceof Node3)
          this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map2) {
        const key = toJSON(this.key, "", ctx);
        if (map2 instanceof Map) {
          const value = toJSON(this.value, key, ctx);
          map2.set(key, value);
        } else if (map2 instanceof Set) {
          map2.add(key);
        } else {
          const stringKey = stringifyKey(this.key, key, ctx);
          const value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map2)
            Object.defineProperty(map2, stringKey, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map2[stringKey] = value;
        }
        return map2;
      }
      toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc)
          return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key,
          value
        } = this;
        let keyComment = key instanceof Node3 && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection3) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node3 ? key instanceof Collection3 || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str2 = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
        str2 = addComment(str2, ctx.indent, keyComment);
        if (!explicitKey && str2.length > 1024) {
          if (simpleKeys)
            throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str2 = addComment(str2, ctx.indent, this.comment);
            if (onComment)
              onComment();
          } else if (chompKeep && !keyComment && onChompKeep)
            onChompKeep();
          return ctx.inFlow && !explicitKey ? str2 : `? ${str2}`;
        }
        str2 = explicitKey ? `? ${str2}
${indent}:` : `${str2}:`;
        if (this.comment) {
          str2 = addComment(str2, ctx.indent, this.comment);
          if (onComment)
            onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node3) {
          if (value.spaceBefore)
            vcb = "\n";
          if (value.commentBefore) {
            const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar3)
          ctx.indentAtStart = str2.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq2 && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws = " ";
        if (vcb || this.comment) {
          ws = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection3) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n"))
            ws = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n")
          ws = "";
        if (chompKeep && !valueComment && onChompKeep)
          onChompKeep();
        return addComment(str2 + ws + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue._defineProperty(Pair3, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node, anchors) => {
      if (node instanceof Alias2) {
        const anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection3) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(item, anchors);
          if (c > count)
            count = c;
        }
        return count;
      } else if (node instanceof Pair3) {
        const kc = getAliasCount(node.key, anchors);
        const vc = getAliasCount(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias2 = class extends Node3 {
      static stringify({
        range,
        source
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
        if (!anchor && inStringifyKey)
          anchor = doc.anchors.getName(source) || doc.anchors.newName();
        if (anchor)
          return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range}]`);
      }
      constructor(source) {
        super();
        this.source = source;
        this.type = PlainValue.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx)
          return toJSON(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode)
            throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
          else
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0)
            anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode)
              throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      toString(ctx) {
        return Alias2.stringify(this, ctx);
      }
    };
    PlainValue._defineProperty(Alias2, "default", true);
    function findPair(items, key) {
      const k = key instanceof Scalar3 ? key.value : key;
      for (const it of items) {
        if (it instanceof Pair3) {
          if (it.key === key || it.key === k)
            return it;
          if (it.key && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap2 = class extends Collection3 {
      add(pair, overwrite) {
        if (!pair)
          pair = new Pair3(pair);
        else if (!(pair instanceof Pair3))
          pair = new Pair3(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite)
            prev.value = pair.value;
          else
            throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i === -1)
            this.items.push(pair);
          else
            this.items.splice(i, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it && it.value;
        return !keepScalar && node instanceof Scalar3 ? node.value : node;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair3(key, value), true);
      }
      toJSON(_, ctx, Type) {
        const map2 = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          item.addToJSMap(ctx, map2);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair3))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n) => n.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge2 = class extends Pair3 {
      constructor(pair) {
        if (pair instanceof Pair3) {
          let seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq2)) {
            seq2 = new YAMLSeq2();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          super(pair.key, seq2);
          this.range = pair.range;
        } else {
          super(new Scalar3(MERGE_KEY), new YAMLSeq2());
        }
        this.type = Pair3.Type.MERGE_PAIR;
      }
      addToJSMap(ctx, map2) {
        for (const {
          source
        } of this.value.items) {
          if (!(source instanceof YAMLMap2))
            throw new Error("Merge sources must be maps");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key, value] of srcMap) {
            if (map2 instanceof Map) {
              if (!map2.has(key))
                map2.set(key, value);
            } else if (map2 instanceof Set) {
              map2.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
              Object.defineProperty(map2, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map2;
      }
      toString(ctx, onComment) {
        const seq2 = this.value;
        if (seq2.items.length > 1)
          return super.toString(ctx, onComment);
        this.value = seq2.items[0];
        const str2 = super.toString(ctx, onComment);
        this.value = seq2;
        return str2;
      }
    };
    var binaryOptions2 = {
      defaultType: PlainValue.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions2 = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions2 = {
      asBigInt: false
    };
    var nullOptions2 = {
      nullStr: "null"
    };
    var strOptions2 = {
      defaultType: PlainValue.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str2, tags, scalarFallback) {
      for (const {
        format: format2,
        test,
        resolve
      } of tags) {
        if (test) {
          const match = str2.match(test);
          if (match) {
            let res = resolve.apply(null, match);
            if (!(res instanceof Scalar3))
              res = new Scalar3(res);
            if (format2)
              res.format = format2;
            return res;
          }
        }
      }
      if (scalarFallback)
        str2 = scalarFallback(str2);
      return new Scalar3(str2);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i) => {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    function foldFlowLines(text, indent, mode, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions2.fold) : strOptions2.fold;
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions2.doubleQuoted;
      const json2 = JSON.stringify(value);
      if (jsonEncoding)
        return json2;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
        if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
          str2 += json2.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json2[i + 1]) {
            case "u":
              {
                str2 += json2.slice(start, i);
                const code = json2.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str2 += "\\0";
                    break;
                  case "0007":
                    str2 += "\\a";
                    break;
                  case "000b":
                    str2 += "\\v";
                    break;
                  case "001b":
                    str2 += "\\e";
                    break;
                  case "0085":
                    str2 += "\\N";
                    break;
                  case "00a0":
                    str2 += "\\_";
                    break;
                  case "2028":
                    str2 += "\\L";
                    break;
                  case "2029":
                    str2 += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str2 += "\\x" + code.substr(2);
                    else
                      str2 += json2.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
                i += 1;
              } else {
                str2 += json2.slice(start, i) + "\n\n";
                while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                  str2 += "\n";
                  i += 2;
                }
                str2 += indent;
                if (json2[i + 2] === " ")
                  str2 += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str2 = start ? str2 + json2.slice(start) : json2;
      return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value))
          return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value))
          return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type: type2,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal = type2 === PlainValue.Type.BLOCK_FOLDED ? false : type2 === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions2.fold.lineWidth, indent.length);
      let header = literal ? "|" : ">";
      if (!value)
        return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf("\n");
        if (n === -1) {
          header += "-";
        } else if (value === ws || n !== ws.length - 1) {
          header += "+";
          if (onChompKeep)
            onChompKeep();
        }
        wsEnd = ws.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(" ") !== -1)
          header += indentSize;
        const m = ws.match(/ +$/);
        if (m) {
          wsStart = ws.slice(0, -m[0].length);
          return m[0];
        } else {
          wsStart = ws;
          return "";
        }
      });
      if (wsEnd)
        wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart)
        wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment)
          onComment();
      }
      if (!value)
        return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions2.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type: type2,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type2 !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str2 = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags
        } = ctx.doc.schema;
        const resolved = resolveScalar(str2, tags, tags.scalarFallback).value;
        if (typeof resolved !== "string")
          return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment)
          onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions2;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type: type2,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue.Type.BLOCK_FOLDED:
          case PlainValue.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type2 !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type2 === PlainValue.Type.BLOCK_FOLDED || type2 === PlainValue.Type.BLOCK_LITERAL)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type2);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null)
          throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format: format2,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint")
        return String(value);
      if (!isFinite(value))
        return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i = cst.items.length - 1; i >= 0; --i) {
        const item = cst.items[i];
        if (!item || item.type !== PlainValue.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end)
            err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source, key) {
      const sk = String(key);
      const k = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment)
              collection.comment += "\n" + comment;
            else
              collection.comment = comment;
          }
        } else {
          if (afterKey && item.value)
            item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore)
              item.spaceBefore = true;
          } else {
            if (item.commentBefore)
              item.commentBefore += "\n" + comment;
            else
              item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node) {
      const res = node.strValue;
      if (!res)
        return "";
      if (typeof res === "string")
        return res;
      res.errors.forEach((error) => {
        if (!error.source)
          error.source = node;
        doc.errors.push(error);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node) {
      const {
        handle,
        suffix
      } = node.tag;
      let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp)
          prefix = dtp.find((p) => p.handle === handle);
        if (!prefix)
          throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix)
        throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue.YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node) {
      const {
        tag,
        type: type2
      } = node;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!")
            return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node);
          } catch (error) {
            doc.errors.push(error);
          }
        }
      }
      switch (type2) {
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
        case PlainValue.Type.QUOTE_DOUBLE:
        case PlainValue.Type.QUOTE_SINGLE:
          return PlainValue.defaultTags.STR;
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        case PlainValue.Type.PLAIN:
          return nonSpecific ? PlainValue.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node, tagName) {
      const {
        tags
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags) {
        if (tag.tag === tagName) {
          if (tag.test)
            matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node);
            return res instanceof Collection3 ? res : new Scalar3(res);
          }
        }
      }
      const str2 = resolveString(doc, node);
      if (typeof str2 === "string" && matchWithTest.length > 0)
        return resolveScalar(str2, matchWithTest, tags.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type: type2
    }) {
      switch (type2) {
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        default:
          return PlainValue.defaultTags.STR;
      }
    }
    function resolveTag(doc, node, tagName) {
      try {
        const res = resolveByTagName(doc, node, tagName);
        if (res) {
          if (tagName && node.tag)
            res.tag = tagName;
          return res;
        }
      } catch (error) {
        if (!error.source)
          error.source = node;
        doc.errors.push(error);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node);
        if (!fallback)
          throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
        const res = resolveByTagName(doc, node, fallback);
        res.tag = tagName;
        return res;
      } catch (error) {
        const refError = new PlainValue.YAMLReferenceError(node, error.message);
        refError.stack = error.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node) => {
      if (!node)
        return false;
      const {
        type: type2
      } = node;
      return type2 === PlainValue.Type.MAP_KEY || type2 === PlainValue.Type.MAP_VALUE || type2 === PlainValue.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
      for (const {
        start,
        end
      } of props) {
        switch (node.context.src[start]) {
          case PlainValue.Char.COMMENT: {
            if (!node.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            const {
              header,
              valueRange
            } = node;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node) {
      const {
        anchors,
        errors,
        schema: schema2
      } = doc;
      if (node.type === PlainValue.Type.ALIAS) {
        const name = node.rawValue;
        const src = anchors.getNode(name);
        if (!src) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
        const res = new Alias2(src);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node);
      if (tagName)
        return resolveTag(doc, node, tagName);
      if (node.type !== PlainValue.Type.PLAIN) {
        const msg = `Failed to resolve ${node.type} node here`;
        errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        return null;
      }
      try {
        const str2 = resolveString(doc, node);
        return resolveScalar(str2, schema2.tags, schema2.tags.scalarFallback);
      } catch (error) {
        if (!error.source)
          error.source = node;
        errors.push(error);
        return null;
      }
    }
    function resolveNode(doc, node) {
      if (!node)
        return null;
      if (node.error)
        doc.errors.push(node.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node.anchor;
        const prev = anchors.getNode(name);
        if (prev)
          anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node;
      }
      if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
      }
      const res = resolveNodeValue(doc, node);
      if (res) {
        res.range = [node.range.start, node.range.end];
        if (doc.options.keepCstNodes)
          res.cstNode = node;
        if (doc.options.keepNodeTypes)
          res.type = node.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca = comments.after.join("\n");
        if (ca)
          res.comment = res.comment ? `${res.comment}
${ca}` : ca;
      }
      return node.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map2 = new YAMLMap2();
      map2.items = items;
      resolveComments(map2, comments);
      let hasCollectionKey = false;
      for (let i = 0; i < items.length; ++i) {
        const {
          key: iKey
        } = items[i];
        if (iKey instanceof Collection3)
          hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i] = new Merge2(items[i]);
          const sources = items[i].value.items;
          let error = null;
          sources.some((node) => {
            if (node instanceof Alias2) {
              const {
                type: type2
              } = node.source;
              if (type2 === PlainValue.Type.MAP || type2 === PlainValue.Type.FLOW_MAP)
                return false;
              return error = "Merge nodes aliases can only point to maps";
            }
            return error = "Merge nodes can only have Alias nodes as values";
          });
          if (error)
            doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
        } else {
          for (let j = i + 1; j < items.length; ++j) {
            const {
              key: jKey
            } = items[j];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = map2;
      return map2;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node,
        src
      },
      props
    }) => {
      if (props.length === 0)
        return false;
      const {
        start
      } = props[0];
      if (node && start > node.valueRange.start)
        return false;
      if (src[start] !== PlainValue.Char.COMMENT)
        return false;
      for (let i = lineStart; i < start; ++i)
        if (src[i] === "\n")
          return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item))
        return;
      const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found)
        pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let keyStart = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key,
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              afterKey: !!key,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue.Type.MAP_KEY:
            if (key !== void 0)
              items.push(new Pair3(key));
            if (item.error)
              doc.errors.push(item.error);
            key = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue.Type.MAP_VALUE:
            {
              if (key === void 0)
                key = null;
              if (item.error)
                doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair3(key, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
              }
              key = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key !== void 0)
              items.push(new Pair3(key));
            key = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error)
              doc.errors.push(item.error);
            next:
              for (let j = i + 1; ; ++j) {
                const nextItem = cst.items[j];
                switch (nextItem && nextItem.type) {
                  case PlainValue.Type.BLANK_LINE:
                  case PlainValue.Type.COMMENT:
                    continue next;
                  case PlainValue.Type.MAP_VALUE:
                    break next;
                  default: {
                    const msg = "Implicit map keys need to be followed by map values";
                    doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                    break next;
                  }
                }
              }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key !== void 0)
        items.push(new Pair3(key));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char === "?" && key === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key === void 0)
              key = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key === void 0 && char !== ",")
                key = null;
              explicitKey = false;
            }
            if (key !== void 0) {
              items.push(new Pair3(key));
              key = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i === cst.items.length - 1)
              continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue.YAMLSyntaxError(cst, msg);
          err.offset = offset;
          doc.errors.push(err);
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key,
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
        } else if (key === void 0) {
          if (next === ",")
            doc.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
          key = resolveNode(doc, item);
        } else {
          if (next !== ",")
            doc.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair3(key, resolveNode(doc, item)));
          key = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair3(key));
      return {
        comments,
        items
      };
    }
    function resolveSeq(doc, cst) {
      if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq2 = new YAMLSeq2();
      seq2.items = items;
      resolveComments(seq2, comments);
      if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair3 && it.key instanceof Collection3)) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = seq2;
      return seq2;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue.Type.SEQ_ITEM:
            if (item.error)
              doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error)
              doc.errors.push(item.error);
            doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char !== ":" && (explicitKey || key !== void 0)) {
            if (explicitKey && key === void 0)
              key = next ? items.pop() : null;
            items.push(new Pair3(key));
            explicitKey = false;
            key = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key === void 0) {
            if (next === ",") {
              key = items.pop();
              if (key instanceof Pair3) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
                const {
                  src
                } = prevItem.context;
                for (let i2 = keyStart; i2 < keyEnd; ++i2)
                  if (src[i2] === "\n") {
                    const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                    doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                    break;
                  }
              }
            } else {
              key = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue.YAMLSyntaxError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair3(key, value));
            key = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair3(key));
      return {
        comments,
        items
      };
    }
    exports.Alias = Alias2;
    exports.Collection = Collection3;
    exports.Merge = Merge2;
    exports.Node = Node3;
    exports.Pair = Pair3;
    exports.Scalar = Scalar3;
    exports.YAMLMap = YAMLMap2;
    exports.YAMLSeq = YAMLSeq2;
    exports.addComment = addComment;
    exports.binaryOptions = binaryOptions2;
    exports.boolOptions = boolOptions2;
    exports.findPair = findPair;
    exports.intOptions = intOptions2;
    exports.isEmptyPath = isEmptyPath;
    exports.nullOptions = nullOptions2;
    exports.resolveMap = resolveMap;
    exports.resolveNode = resolveNode;
    exports.resolveSeq = resolveSeq;
    exports.resolveString = resolveString;
    exports.strOptions = strOptions2;
    exports.stringifyNumber = stringifyNumber;
    exports.stringifyString = stringifyString;
    exports.toJSON = toJSON;
  }
});

// server/node_modules/yaml/dist/warnings-1000a372.js
var require_warnings_1000a372 = __commonJS({
  "server/node_modules/yaml/dist/warnings-1000a372.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var binary2 = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve: (doc, node) => {
        const src = resolveSeq.resolveString(doc, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: resolveSeq.binaryOptions,
      stringify: ({
        comment,
        type: type2,
        value
      }, ctx, onComment, onChompKeep) => {
        let src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < value.length; ++i)
            s += String.fromCharCode(value[i]);
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type2)
          type2 = resolveSeq.binaryOptions.defaultType;
        if (type2 === PlainValue.Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          const {
            lineWidth
          } = resolveSeq.binaryOptions;
          const n = Math.ceil(src.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = src.substr(o, lineWidth);
          }
          value = lines.join(type2 === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq.stringifyString({
          comment,
          type: type2,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq2 = resolveSeq.resolveSeq(doc, cst);
      for (let i = 0; i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (item instanceof resolveSeq.Pair)
          continue;
        else if (item instanceof resolveSeq.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq.Pair();
          if (item.commentBefore)
            pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment)
            pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq2.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
      }
      return seq2;
    }
    function createPairs(schema2, iterable, ctx) {
      const pairs3 = new resolveSeq.YAMLSeq(schema2);
      pairs3.tag = "tag:yaml.org,2002:pairs";
      for (const it of iterable) {
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else
            throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key = it;
        }
        const pair = schema2.createPair(key, value, ctx);
        pairs3.items.push(pair);
      }
      return pairs3;
    }
    var pairs2 = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class extends resolveSeq.YAMLSeq {
      constructor() {
        super();
        PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
        PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
        PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
        PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
        PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
        this.tag = YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        const map2 = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (pair instanceof resolveSeq.Pair) {
            key = resolveSeq.toJSON(pair.key, "", ctx);
            value = resolveSeq.toJSON(pair.value, key, ctx);
          } else {
            key = resolveSeq.toJSON(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
    };
    PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs3 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key
      } of pairs3.items) {
        if (key instanceof resolveSeq.Scalar) {
          if (seenKeys.includes(key.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs3);
    }
    function createOMap(schema2, iterable, ctx) {
      const pairs3 = createPairs(schema2, iterable, ctx);
      const omap3 = new YAMLOMap();
      omap3.items = pairs3.items;
      return omap3;
    }
    var omap2 = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class extends resolveSeq.YAMLMap {
      constructor() {
        super();
        this.tag = YAMLSet.tag;
      }
      add(key) {
        const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
        const prev = resolveSeq.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = resolveSeq.findPair(this.items, key);
        return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues())
          return super.toString(ctx, onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map2 = resolveSeq.resolveMap(doc, cst);
      if (!map2.hasAllNullValues())
        throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map2);
    }
    function createSet(schema2, iterable, ctx) {
      const set3 = new YAMLSet();
      for (const value of iterable)
        set3.items.push(schema2.createPair(value, null, ctx));
      return set3;
    }
    var set2 = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
      return sign === "-" ? -n : n;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value))
        return resolveSeq.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp2 = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str2, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
          return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined")
        return !YAML_SILENCE_WARNINGS;
      return !env.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type2) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit)
          emit(warning, type2);
        else {
          console.warn(type2 ? `${type2}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename) {
      if (shouldWarn(true)) {
        const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    exports.binary = binary2;
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.omap = omap2;
    exports.pairs = pairs2;
    exports.set = set2;
    exports.timestamp = timestamp2;
    exports.warn = warn;
    exports.warnFileDeprecation = warnFileDeprecation;
    exports.warnOptionDeprecation = warnOptionDeprecation;
  }
});

// server/node_modules/yaml/dist/Schema-88e323a7.js
var require_Schema_88e323a7 = __commonJS({
  "server/node_modules/yaml/dist/Schema-88e323a7.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var warnings = require_warnings_1000a372();
    function createMap(schema2, obj, ctx) {
      const map3 = new resolveSeq.YAMLMap(schema2);
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          map3.items.push(schema2.createPair(key, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          map3.items.push(schema2.createPair(key, obj[key], ctx));
      }
      if (typeof schema2.sortMapEntries === "function") {
        map3.items.sort(schema2.sortMapEntries);
      }
      return map3;
    }
    var map2 = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq.resolveMap
    };
    function createSeq(schema2, obj, ctx) {
      const seq3 = new resolveSeq.YAMLSeq(schema2);
      if (obj && obj[Symbol.iterator]) {
        for (const it of obj) {
          const v = schema2.createNode(it, ctx.wrapScalars, null, ctx);
          seq3.items.push(v);
        }
      }
      return seq3;
    }
    var seq2 = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq.strOptions
    };
    var failsafe2 = [map2, seq2, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    function intStringify$1(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
      return resolveSeq.stringifyNumber(node);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => str2[0] === "t" || str2[0] === "T",
      options: resolveSeq.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str2, oct) => intResolve$1(str2, oct, 8),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2) => intResolve$1(str2, str2, 10),
      options: resolveSeq.intOptions,
      stringify: resolveSeq.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str2, hex) => intResolve$1(str2, hex, 16),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str2, frac1, frac2) {
        const frac = frac1 || frac2;
        const node = new resolveSeq.Scalar(parseFloat(str2));
        if (frac && frac[frac.length - 1] === "0")
          node.minFractionDigits = frac.length;
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    };
    var core2 = failsafe2.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json2 = [map2, seq2, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str2) => str2 === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str2) => resolveSeq.intOptions.asBigInt ? BigInt(str2) : parseInt(str2, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str2) => parseFloat(str2),
      stringify: stringifyJSON
    }];
    json2.scalarFallback = (str2) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src, radix) {
      let str2 = src.replace(/_/g, "");
      if (resolveSeq.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify(value)) {
        const str2 = value.toString(radix);
        return value < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
      }
      return resolveSeq.stringifyNumber(node);
    }
    var yaml11 = failsafe2.concat([{
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str2, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node) => intStringify(node, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str2, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node) => intStringify(node, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str2, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str2, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node) => intStringify(node, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str2, frac) {
        const node = new resolveSeq.Scalar(parseFloat(str2.replace(/_/g, "")));
        if (frac) {
          const f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
    var schemas = {
      core: core2,
      failsafe: failsafe2,
      json: json2,
      yaml11
    };
    var tags = {
      binary: warnings.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings.intTime,
      map: map2,
      null: nullObj,
      omap: warnings.omap,
      pairs: warnings.pairs,
      seq: seq2,
      set: warnings.set,
      timestamp: warnings.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match = tags2.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) || match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (value instanceof resolveSeq.Node)
        return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema: schema2,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema2.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object")
          return wrapScalars ? new resolveSeq.Scalar(value) : value;
        tagObj = value instanceof Map ? map2 : value[Symbol.iterator] ? seq2 : map2;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias = new resolveSeq.Alias(prev);
          ctx.aliasNodes.push(alias);
          return alias;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq.Node)
        obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i = 0; i < tags2.length; ++i) {
        const tag = tags2[i];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema2 = class {
      constructor({
        customTags,
        merge: merge2,
        schema: schema2,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge2;
        this.name = schema2;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnings.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema2);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: Schema2.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode(value, tagName, createCtx);
      }
      createPair(key, value, ctx) {
        if (!ctx)
          ctx = {
            wrapScalars: true
          };
        const k = this.createNode(key, ctx.wrapScalars, null, ctx);
        const v = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq.Pair(k, v);
      }
    };
    PlainValue._defineProperty(Schema2, "defaultPrefix", PlainValue.defaultTagPrefix);
    PlainValue._defineProperty(Schema2, "defaultTags", PlainValue.defaultTags);
    exports.Schema = Schema2;
  }
});

// server/node_modules/yaml/dist/Document-9b4560a1.js
var require_Document_9b4560a1 = __commonJS({
  "server/node_modules/yaml/dist/Document-9b4560a1.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema2 = require_Schema_88e323a7();
    var defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc, tag) {
      if ((doc.version || doc.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv)
          return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p = doc.tagPrefixes.find((p2) => tag.indexOf(p2.prefix) === 0);
      if (!p) {
        const dtp = doc.getDefaults().tagPrefixes;
        p = dtp && dtp.find((p2) => tag.indexOf(p2.prefix) === 0);
      }
      if (!p)
        return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, (ch) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch]);
      return p.handle + suffix;
    }
    function getTagObject(tags, item) {
      if (item instanceof resolveSeq.Alias)
        return resolveSeq.Alias;
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) || match[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match = tags.filter((t) => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
        tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, {
      anchors,
      doc
    }) {
      const props = [];
      const anchor = doc.anchors.getName(node);
      if (anchor) {
        anchors[anchor] = node;
        props.push(`&${anchor}`);
      }
      if (node.tag) {
        props.push(stringifyTag(doc, node.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema: schema2
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o) => tagObj = o,
          prevObjects: /* @__PURE__ */ new Map()
        };
        item = schema2.createNode(item, true, null, createCtx);
        for (const alias of createCtx.aliasNodes) {
          alias.source = alias.source.node;
          let name = anchors.getName(alias.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair)
        return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj)
        tagObj = getTagObject(schema2.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str2;
      return item instanceof resolveSeq.Scalar || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    var Anchors = class {
      static validAnchorNode(node) {
        return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue._defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node, name) {
        this.setAnchor(node, name);
        return new resolveSeq.Alias(node);
      }
      createMergePair(...sources) {
        const merge2 = new resolveSeq.Merge();
        merge2.value.items = sources.map((s) => {
          if (s instanceof resolveSeq.Alias) {
            if (s.source instanceof resolveSeq.YAMLMap)
              return s;
          } else if (s instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge2;
      }
      getName(node) {
        const {
          map: map2
        } = this;
        return Object.keys(map2).find((a) => map2[a] === node);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name) {
        return this.map[name];
      }
      newName(prefix) {
        if (!prefix)
          prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i = 1; true; ++i) {
          const name = `${prefix}${i}`;
          if (!names.includes(name))
            return name;
        }
      }
      resolveNodes() {
        const {
          map: map2,
          _cstAliases
        } = this;
        Object.keys(map2).forEach((a) => {
          map2[a] = map2[a].resolved;
        });
        _cstAliases.forEach((a) => {
          a.source = a.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node, name) {
        if (node != null && !Anchors.validAnchorNode(node)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map: map2
        } = this;
        const prev = node && Object.keys(map2).find((a) => map2[a] === node);
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node;
          }
        } else {
          if (!name) {
            if (!node)
              return null;
            name = this.newName();
          }
          map2[name] = node;
        }
        return name;
      }
    };
    var visit = (node, tags) => {
      if (node && typeof node === "object") {
        const {
          tag
        } = node;
        if (node instanceof resolveSeq.Collection) {
          if (tag)
            tags[tag] = true;
          node.items.forEach((n) => visit(n, tags));
        } else if (node instanceof resolveSeq.Pair) {
          visit(node.key, tags);
          visit(node.value, tags);
        } else if (node instanceof resolveSeq.Scalar) {
          if (tag)
            tags[tag] = true;
        }
      }
      return tags;
    };
    var listTagNames = (node) => Object.keys(visit(node, {}));
    function parseContents(doc, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node of contents) {
        if (node.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc, node);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node.comment);
        } else if (node.type === PlainValue.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc.contents = body || null;
      if (!body) {
        doc.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p) => p.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc, directive) {
      let [version] = directive.parameters;
      if (directive.name === "YAML:1.0")
        version = "1.0";
      if (!version) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version]) {
        const v0 = doc.version || doc.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
        doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
      }
      return version;
    }
    function parseDirectives(doc, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment,
          name
        } = directive;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
              doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
            }
        }
        if (comment)
          directiveComments.push(comment);
      }
      if (prevDoc && !hasDirectives && "1.1" === (doc.version || prevDoc.version || doc.options.version)) {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc.version = prevDoc.version;
      }
      doc.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection)
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document = class {
      constructor(options) {
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path, value) {
        assertCollection(this.contents);
        this.contents.addIn(path, value);
      }
      delete(key) {
        assertCollection(this.contents);
        return this.contents.delete(key);
      }
      deleteIn(path) {
        if (resolveSeq.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path);
      }
      getDefaults() {
        return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
      }
      get(key, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (resolveSeq.isEmptyPath(path))
          return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
      }
      hasIn(path) {
        if (resolveSeq.isEmptyPath(path))
          return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
      }
      set(key, value) {
        assertCollection(this.contents);
        this.contents.set(key, value);
      }
      setIn(path, value) {
        if (resolveSeq.isEmptyPath(path))
          this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema)
          return;
        if (typeof id === "number")
          id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version)
            this.version = id;
          else
            this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags))
          this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema2.Schema(opt);
      }
      parse(node, prevDoc) {
        if (this.options.keepCstNodes)
          this.cstNode = node;
        if (this.options.keepNodeTypes)
          this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error,
          valueRange
        } = node;
        if (error) {
          if (!error.source)
            error.source = this;
          this.errors.push(error);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker)
          this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error2 of this.errors)
            if (error2 instanceof PlainValue.YAMLError)
              error2.makePretty();
          for (const warn of this.warnings)
            if (warn instanceof PlainValue.YAMLError)
              warn.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t) => t.indexOf(Schema2.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
          throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p) => p.handle === handle);
          if (prev)
            prev.prefix = prefix;
          else
            this.tagPrefixes.push({
              handle,
              prefix
            });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p) => p.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0)
          ctx.anchors = new Map(anchorNames.map((name) => [this.anchors.map[name], {
            alias: [],
            aliasCount: 0,
            count: 1
          }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors)
          for (const {
            count,
            res: res2
          } of ctx.anchors.values())
            onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0")
              vd = "%YAML:1.0";
            else if (this.version === "1.1")
              vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker)
          lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker)
            lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
              lines.push("");
            if (this.contents.commentBefore)
              lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue._defineProperty(Document, "defaults", documentOptions);
    exports.Document = Document;
    exports.defaultOptions = defaultOptions;
    exports.scalarOptions = scalarOptions;
  }
});

// server/node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "server/node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var parseCst = require_parse_cst();
    var Document$1 = require_Document_9b4560a1();
    var Schema2 = require_Schema_88e323a7();
    var PlainValue = require_PlainValue_ec8e588e();
    var warnings = require_warnings_1000a372();
    require_resolveSeq_d03cb037();
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema2 = new Schema2.Schema(options);
      return schema2.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options) {
        super(Object.assign({}, Document$1.defaultOptions, options));
      }
    };
    function parseAllDocuments(src, options) {
      const stream = [];
      let prev;
      for (const cstDoc of parseCst.parse(src)) {
        const doc = new Document(options);
        doc.parse(cstDoc, prev);
        stream.push(doc);
        prev = doc;
      }
      return stream;
    }
    function parseDocument3(src, options) {
      const cst = parseCst.parse(src);
      const doc = new Document(options).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc;
    }
    function parse(src, options) {
      const doc = parseDocument3(src, options);
      doc.warnings.forEach((warning) => warnings.warn(warning));
      if (doc.errors.length > 0)
        throw doc.errors[0];
      return doc.toJSON();
    }
    function stringify(value, options) {
      const doc = new Document(options);
      doc.contents = value;
      return String(doc);
    }
    var YAML3 = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument: parseDocument3,
      scalarOptions: Document$1.scalarOptions,
      stringify
    };
    exports.YAML = YAML3;
  }
});

// server/node_modules/yaml/index.js
var require_yaml = __commonJS({
  "server/node_modules/yaml/index.js"(exports, module2) {
    module2.exports = require_dist().YAML;
  }
});

// server/node_modules/yaml/dist/types.js
var require_types = __commonJS({
  "server/node_modules/yaml/dist/types.js"(exports) {
    "use strict";
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema2 = require_Schema_88e323a7();
    require_PlainValue_ec8e588e();
    require_warnings_1000a372();
    exports.Alias = resolveSeq.Alias;
    exports.Collection = resolveSeq.Collection;
    exports.Merge = resolveSeq.Merge;
    exports.Node = resolveSeq.Node;
    exports.Pair = resolveSeq.Pair;
    exports.Scalar = resolveSeq.Scalar;
    exports.YAMLMap = resolveSeq.YAMLMap;
    exports.YAMLSeq = resolveSeq.YAMLSeq;
    exports.binaryOptions = resolveSeq.binaryOptions;
    exports.boolOptions = resolveSeq.boolOptions;
    exports.intOptions = resolveSeq.intOptions;
    exports.nullOptions = resolveSeq.nullOptions;
    exports.strOptions = resolveSeq.strOptions;
    exports.Schema = Schema2.Schema;
  }
});

// server/node_modules/yaml/types.mjs
var import_types, binaryOptions, boolOptions, intOptions, nullOptions, strOptions, Schema, Alias, Collection2, Merge, Node, Pair, Scalar, YAMLMap, YAMLSeq;
var init_types = __esm({
  "server/node_modules/yaml/types.mjs"() {
    import_types = __toESM(require_types(), 1);
    binaryOptions = import_types.default.binaryOptions;
    boolOptions = import_types.default.boolOptions;
    intOptions = import_types.default.intOptions;
    nullOptions = import_types.default.nullOptions;
    strOptions = import_types.default.strOptions;
    Schema = import_types.default.Schema;
    Alias = import_types.default.Alias;
    Collection2 = import_types.default.Collection;
    Merge = import_types.default.Merge;
    Node = import_types.default.Node;
    Pair = import_types.default.Pair;
    Scalar = import_types.default.Scalar;
    YAMLMap = import_types.default.YAMLMap;
    YAMLSeq = import_types.default.YAMLSeq;
  }
});

// server/src/runtime/document/frontMatter/frontMatterParser.ts
var YAML, FrontMatterParser;
var init_frontMatterParser = __esm({
  "server/src/runtime/document/frontMatter/frontMatterParser.ts"() {
    "use strict";
    YAML = __toESM(require_yaml());
    init_types();
    init_scope();
    FrontMatterParser = class {
      constructor(projectProvider) {
        this.documentScope = null;
        this.project = projectProvider;
      }
      getKeyValue(node) {
        if (node instanceof Scalar) {
          return node.value;
        }
        return "";
      }
      getNodeValue(node) {
        if (node instanceof Scalar) {
          return node.value;
        } else if (node instanceof YAMLMap) {
          return this.analyzeDocument(node.items);
        } else if (node instanceof YAMLSeq) {
          return this.analyzeDocument(node.items);
        }
        return "";
      }
      getScalarRuntimeType(value) {
        if (parseFloat(value).toString() == value || parseInt(value).toString() == value) {
          return "number";
        }
        return "string";
      }
      analyzeDocument(items) {
        const nestedScope = new Scope(this.project);
        items.forEach((item) => {
          if (item instanceof Pair) {
            const varName = this.getKeyValue(item.key), varValue = this.getNodeValue(item.value);
            if (item.value instanceof Scalar) {
              nestedScope.addVariable({
                dataType: this.getScalarRuntimeType(varValue),
                introducedBy: null,
                name: varName,
                sourceField: null,
                sourceName: "*frontmatter"
              });
            } else if (item.value instanceof YAMLSeq && item.key instanceof Scalar) {
              const sequenceVariables = new Scope(this.project);
              item.value.items.forEach((seqValue) => {
                const sValue = this.getNodeValue(seqValue);
                sequenceVariables.addVariable({
                  dataType: this.getScalarRuntimeType(sValue),
                  introducedBy: null,
                  name: seqValue.value,
                  sourceField: null,
                  sourceName: "*frontmatter"
                });
              });
              nestedScope.addScopeList(item.key.value, sequenceVariables);
            } else {
              nestedScope.addScopeList(varName, varValue);
            }
          }
        });
        return nestedScope;
      }
      parse(text) {
        try {
          const docs = YAML.parseDocument(text);
          if (docs.contents instanceof YAMLMap) {
            this.documentScope = this.analyzeDocument(docs.contents.items);
          }
        } catch (err) {
          this.documentScope = null;
        }
      }
      hasScope() {
        if (this.documentScope == null) {
          return false;
        }
        return true;
      }
      getScope() {
        return this.documentScope;
      }
    };
  }
});

// server/src/runtime/document/scanners/nodeScanner.ts
var NodeScanner;
var init_nodeScanner = __esm({
  "server/src/runtime/document/scanners/nodeScanner.ts"() {
    "use strict";
    init_abstractNode();
    init_antlersNodeQueries();
    init_nodeQueries();
    NodeScanner = class {
      constructor(doc) {
        this.doc = doc;
      }
      getAncestors(position) {
        return AntlersNodeQueries.findAncestorsBeforePosition(position, this.doc.getAllAntlersNodes());
      }
      getNodeAt(position) {
        return NodeQueries.findNodeAtPosition(position, this.doc.getDocumentParser().getNodes());
      }
      getNodesBefore(position) {
        return NodeQueries.findNodesBeforePosition(position, this.doc.getDocumentParser().getNodes());
      }
      getNodeBefore(position) {
        return NodeQueries.findNodeBeforePosition(position, this.doc.getDocumentParser().getNodes());
      }
      getNodeAfter(position) {
        return NodeQueries.findNodeAfterPosition(position, this.doc.getDocumentParser().getNodes());
      }
      getNodesAfter(position) {
        return NodeQueries.findNodesAfterPosition(position, this.doc.getDocumentParser().getNodes());
      }
      getIsWithinPairedNode(position) {
        const node = this.getNodeBefore(position);
        if (node == null) {
          return false;
        }
        return AntlersNodeQueries.isPairedNode(node);
      }
      filter(predicate) {
        return this.doc.getDocumentParser().getNodes().filter(predicate);
      }
      getComments() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof AntlersNode && node.isComment) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      getMultilineNodes() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          var _a, _b;
          if (node instanceof AntlersNode && !node.isComment && ((_a = node.startPosition) == null ? void 0 : _a.line) != ((_b = node.endPosition) == null ? void 0 : _b.line)) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      getMultiLineComments() {
        const nodes = [];
        this.getComments().forEach((comment) => {
          var _a, _b;
          if (((_a = comment.startPosition) == null ? void 0 : _a.line) != ((_b = comment.endPosition) == null ? void 0 : _b.line)) {
            nodes.push(comment);
          }
        });
        return nodes;
      }
      getAllLiteralNodes() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof LiteralNode || node instanceof EscapedContentNode) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      getStructuralNodes() {
        const nodes = [];
        this.doc.getDocumentParser().getRenderNodes().forEach((node) => {
          if (node instanceof AntlersNode) {
            nodes.push(node);
          } else if (node instanceof ConditionNode) {
            if (node.logicBranches.length > 0) {
              node.logicBranches.forEach((branch) => {
                if (branch.head != null) {
                  const tBrancHead = branch.head;
                  if (tBrancHead.originalNode != null) {
                    nodes.push(tBrancHead.originalNode);
                  } else {
                    nodes.push(tBrancHead);
                  }
                }
              });
            }
          }
        });
        return nodes;
      }
      getAllRuntimeNodes() {
        const allNodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof ParserFailNode || node instanceof AntlersNode) {
            if (node.runtimeNodes.length > 0) {
              node.runtimeNodes.forEach((runtimeNode) => {
                allNodes.push(runtimeNode);
              });
            }
          }
        });
        return allNodes;
      }
      getAllParameterNodes() {
        const allParameters = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof ParserFailNode || node instanceof AntlersNode) {
            if (node.hasParameters) {
              node.parameters.forEach((parameter) => {
                allParameters.push(parameter);
              });
            }
          }
        });
        return allParameters;
      }
      getAssignmentNodes() {
        return NodeQueries.findAssignmentNodes(this.getAllRuntimeNodes());
      }
    };
  }
});

// server/src/runtime/document/scanners/rangeScanner.ts
var RangeScanner;
var init_rangeScanner = __esm({
  "server/src/runtime/document/scanners/rangeScanner.ts"() {
    "use strict";
    init_abstractNode();
    RangeScanner = class {
      constructor(doc) {
        this.doc = doc;
      }
      getAllSelfClosingNodes() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof AntlersNode) {
            if (node.isSelfClosing) {
              nodes.push(node);
            }
          }
        });
        return nodes;
      }
      getAllPairedNodes() {
        const nodes = [];
        this.doc.getAllNodes().forEach((node) => {
          if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
            if (node.isClosedBy != null && !node.isSelfClosing) {
              nodes.push(node);
            }
          }
        });
        return nodes;
      }
    };
  }
});

// server/src/runtime/document/printers/commentPrinter.ts
var CommentPrinter;
var init_commentPrinter = __esm({
  "server/src/runtime/document/printers/commentPrinter.ts"() {
    "use strict";
    init_stringUtilities();
    CommentPrinter = class {
      static printCommentLines(comment, tabSize, targetIndent) {
        const sourceContent = comment.getContent(), content = sourceContent.trim();
        if (content.includes("\n")) {
          const lines = StringUtilities.breakByNewLine(sourceContent), reflowedLines = [];
          lines.forEach((line) => {
            if (line.trim().length == 0) {
              reflowedLines.push(" ".repeat(tabSize + targetIndent) + line.trim());
              return;
            }
            let curRelIndent = line.length - line.trim().length;
            const checkLine = line.trim();
            if (checkLine.startsWith("@desc") || checkLine.startsWith("@set") || checkLine.startsWith("@name")) {
              curRelIndent = tabSize;
            }
            reflowedLines.push(" ".repeat(tabSize + targetIndent + curRelIndent - tabSize) + line.trim());
          });
          if (reflowedLines.length > 0) {
            if (reflowedLines[reflowedLines.length - 1].trim().length == 0) {
              reflowedLines.pop();
            }
          }
          const content2 = reflowedLines.join("\n");
          let newComment = "{{#\n";
          newComment += content2;
          newComment += "\n" + " ".repeat(targetIndent) + "#}}";
          return newComment;
        }
        return "{{# " + content + " #}}";
      }
      static printComment(comment, tabSize, targetIndent, stringFormatter) {
        const sourceContent = comment.getContent(), content = sourceContent.trim();
        if (content.includes("\n") && !(content.includes("@desc") || content.includes("@set") || content.includes("@name"))) {
          try {
            let formattedCommentContent = content;
            if (stringFormatter != null) {
              formattedCommentContent = stringFormatter(formattedCommentContent);
            }
            const lines = StringUtilities.breakByNewLine(formattedCommentContent), reflowedLines = [];
            lines.forEach((line) => {
              if (line.trim().length == 0) {
                reflowedLines.push(" ".repeat(tabSize + targetIndent) + line.trim());
                return;
              }
              let curRelIndent = line.length - line.trim().length;
              reflowedLines.push(" ".repeat(tabSize + targetIndent + curRelIndent) + line.trim());
            });
            if (reflowedLines.length > 0) {
              if (reflowedLines[reflowedLines.length - 1].trim().length == 0) {
                reflowedLines.pop();
              }
            }
            return "{{#\n" + reflowedLines.join("\n") + "\n" + " ".repeat(targetIndent) + "#}}";
            ;
          } catch (err) {
          }
        }
        return this.printCommentLines(comment, tabSize, targetIndent);
      }
    };
  }
});

// server/src/runtime/document/printers/indentLevel.ts
var IndentLevel;
var init_indentLevel = __esm({
  "server/src/runtime/document/printers/indentLevel.ts"() {
    "use strict";
    init_stringUtilities();
    IndentLevel = class {
      static indentRelative(value, targetIndent) {
        const sourceLines = StringUtilities.breakByNewLine(value);
        let reflowedLines = [];
        for (let i = 0; i < sourceLines.length; i++) {
          const thisLine = sourceLines[i];
          if (thisLine.trim().length > 0) {
            reflowedLines = sourceLines.slice(i);
            break;
          }
        }
        for (let i = reflowedLines.length - 1; i >= 0; i--) {
          const thisLine = reflowedLines[i];
          if (thisLine.trim().length == 0) {
            reflowedLines.pop();
          } else {
            break;
          }
        }
        let leastIndentChange = -1;
        let thatLine = "";
        for (let i = 0; i < reflowedLines.length; i++) {
          const thisLine = reflowedLines[i], checkLine = thisLine.trimLeft(), wsDiff = thisLine.length - checkLine.length;
          if (i == 0) {
            leastIndentChange = wsDiff;
            thatLine = thisLine;
          } else {
            if (wsDiff < leastIndentChange) {
              leastIndentChange = wsDiff;
              thatLine = thisLine;
            }
          }
        }
        if (leastIndentChange >= 0) {
          const targetWs = " ".repeat(targetIndent);
          for (let i = 0; i < reflowedLines.length; i++) {
            const thisLine = reflowedLines[i];
            if (thisLine.trim().length == 0) {
              reflowedLines[i] = "";
              continue;
            }
            const reflowed = thisLine.substring(leastIndentChange);
            if (i == 0) {
              reflowedLines[i] = thisLine.trimLeft();
              continue;
            } else {
              reflowedLines[i] = targetWs + reflowed.trimLeft();
            }
          }
        }
        return reflowedLines.join("\n");
      }
      static shiftIndent(value, targetIndent, skipFirst = false, tabSize = 4, adjustStructures = true) {
        if (targetIndent < 0) {
          targetIndent = 0;
        }
        let lines = StringUtilities.breakByNewLine(value.trim()), reflowedLines = [];
        for (let i = 0; i < lines.length; i++) {
          if (i == 0 && skipFirst) {
            reflowedLines.push(lines[i]);
            continue;
          }
          const line = lines[i];
          reflowedLines.push(" ".repeat(targetIndent) + line);
        }
        let result = reflowedLines.join("\n");
        if (adjustStructures && reflowedLines.length > 0 && targetIndent - tabSize > tabSize && reflowedLines[reflowedLines.length - 1].trim() == ") }}") {
          lines = StringUtilities.breakByNewLine(result.trim());
          reflowedLines = [];
          for (let i = 0; i < lines.length; i++) {
            if (i == 0 && skipFirst) {
              reflowedLines.push(lines[i]);
              continue;
            }
            const line = lines[i];
            if (i == lines.length - 1) {
              reflowedLines.push(line);
              break;
            }
            reflowedLines.push(" ".repeat(tabSize) + line);
          }
          result = reflowedLines.join("\n");
        }
        return result;
      }
      static shiftClean(value, indent) {
        const lines = StringUtilities.breakByNewLine(value), reflowedLines = [], pad = " ".repeat(indent);
        let hasFoundContent = false;
        lines.forEach((line) => {
          if (line.trim().length > 0) {
            hasFoundContent = true;
          }
          if (!hasFoundContent) {
            return;
          }
          reflowedLines.push(pad + line);
        });
        return reflowedLines.join("\n");
      }
      static inferIndentLevel(structureLines, value, defaultIndent) {
        let targetLevel = 0, targetLevelFoundOn = -1;
        for (let i = 0; i < structureLines.length; i++) {
          const thisLine = structureLines[i];
          if (thisLine.includes(value)) {
            const trimmed = thisLine.trimLeft();
            targetLevel = thisLine.length - trimmed.length;
            targetLevelFoundOn = i;
            break;
          }
        }
        if (targetLevelFoundOn > 0) {
          for (let i = targetLevelFoundOn - 1; i >= 0; i--) {
            const thisLine = structureLines[i], trimmed = thisLine.trim(), trimmedLeft = thisLine.trimLeft(), checkLevel = thisLine.length - trimmed.length;
            if (trimmedLeft.length == 0) {
              continue;
            }
            if (checkLevel != targetLevel && checkLevel < targetLevel) {
              const inferred = targetLevel - checkLevel;
              return {
                targetLevel,
                referenceLevel: checkLevel,
                sourceTabSize: inferred
              };
            }
          }
        }
        return {
          targetLevel,
          referenceLevel: targetLevel,
          sourceTabSize: defaultIndent
        };
      }
      static indent(structureLines, value, defaultIndent) {
        const levels = IndentLevel.inferIndentLevel(structureLines, value, defaultIndent);
        return " ".repeat(levels.targetLevel);
      }
    };
  }
});

// server/src/runtime/document/printers/nodeBuffer.ts
var NodeBuffer;
var init_nodeBuffer = __esm({
  "server/src/runtime/document/printers/nodeBuffer.ts"() {
    "use strict";
    init_strings();
    NodeBuffer = class {
      constructor(node, indent, prepend) {
        this.buffer = "";
        this.closeString = "";
        this.relativeIndentSize = 0;
        this.indentSeed = 0;
        var _a;
        this.baseIndent = indent;
        if (node.isInterpolationNode) {
          this.buffer = "{";
          this.closeString = "}";
        } else {
          this.buffer = "{{ ";
          if (node.isSelfClosing) {
            this.closeString = " /}}";
          } else {
            this.closeString = " }}";
          }
        }
        if ((_a = node.pathReference) == null ? void 0 : _a.isStrictTagReference) {
          this.buffer += "%";
        }
        if (prepend != null && prepend.trim().length > 0) {
          this.buffer += prepend + " ";
        }
      }
      setIndentSeed(indent) {
        this.indentSeed = indent;
        return this;
      }
      close() {
        if (this.closeString == " }}") {
          if (this.buffer.endsWith(" ")) {
            this.buffer += "}}";
          } else {
            this.buffer += this.closeString;
          }
        } else {
          this.buffer += this.closeString;
        }
        return this;
      }
      appendT(text) {
        if (this.buffer.endsWith(" ")) {
          this.buffer = this.buffer.trimEnd();
        }
        this.buffer += text;
        return this;
      }
      appendTS(text, preserveSpace = false) {
        if (this.buffer.endsWith(" ")) {
          this.buffer = this.buffer.trimEnd();
        }
        if (this.buffer.endsWith("{") && !preserveSpace) {
          text = text.trimStart();
        }
        this.buffer += text;
        return this;
      }
      append(text) {
        this.buffer += text;
        return this;
      }
      appendOS(text) {
        if (this.buffer.endsWith(" ") == false && this.buffer.endsWith("(") == false && this.buffer.endsWith("{") == false && this.buffer.endsWith("[") == false && this.buffer.endsWith(":") == false) {
          this.buffer += " ";
        }
        return this.append(text);
      }
      appendS(text) {
        let appendBuffer = "";
        if (this.buffer.endsWith(" ") == false) {
          appendBuffer += " ";
        }
        appendBuffer += text + " ";
        this.buffer += appendBuffer;
        return this;
      }
      indent() {
        let repeatCount = this.baseIndent;
        if (repeatCount == 0) {
          repeatCount = 1;
        } else {
          repeatCount += 2;
        }
        if (this.relativeIndentSize > 0) {
          repeatCount += this.relativeIndentSize;
        }
        this.buffer += " ".repeat(repeatCount);
        return this;
      }
      addIndent(number) {
        if (number <= 0) {
          return this;
        }
        this.buffer += " ".repeat(number);
        return this;
      }
      paramS(param) {
        let bParam = " ";
        if (param.isVariableReference) {
          bParam += ":";
        }
        bParam += param.name + "=" + param.nameDelimiter + param.value + param.nameDelimiter;
        this.append(bParam);
        return this;
      }
      replace(find, replace) {
        this.buffer = replaceAllInString(this.buffer, find, replace);
        return this;
      }
      relativeIndent(relativeTo) {
        const bufferLines = this.buffer.split("\n");
        if (bufferLines.length == 0) {
          return this;
        }
        let lastLine = bufferLines[bufferLines.length - 1].trimEnd();
        if (lastLine.endsWith("(")) {
          lastLine = lastLine.slice(0, -1);
        }
        if (lastLine.endsWith(relativeTo) == false) {
          return this;
        }
        this.relativeIndentSize = lastLine.lastIndexOf(relativeTo);
        return this;
      }
      newlineIndent() {
        this.newLine();
        this.indent();
        return this;
      }
      newlineNDIndent() {
        this.buffer = this.buffer.trimEnd();
        this.newLine();
        this.indent();
        return this;
      }
      newLine() {
        this.buffer += "\n";
        return this;
      }
      getContent() {
        return this.buffer;
      }
      endsWith(value) {
        return this.buffer.endsWith(value);
      }
    };
  }
});

// server/src/runtime/document/printers/nodePrinter.ts
var NodePrinter;
var init_nodePrinter = __esm({
  "server/src/runtime/document/printers/nodePrinter.ts"() {
    "use strict";
    init_strings();
    init_abstractNode();
    init_languageParser();
    init_nodeHelpers();
    init_nodeBuffer();
    NodePrinter = class {
      static prettyPrintNode(antlersNode, doc, indent, options, prepend, seedIndent) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const lexerNodes = antlersNode.getTrueRuntimeNodes();
        let nodeStatements = 0, nodeOperators = 0;
        if (lexerNodes.length > 0) {
          const nodeBuffer = new NodeBuffer(antlersNode, indent, prepend);
          if (seedIndent != null) {
            nodeBuffer.setIndentSeed(seedIndent);
          }
          let lastPrintedNode = null;
          for (let i = 0; i < lexerNodes.length; i++) {
            const node = lexerNodes[i];
            if (lastPrintedNode != null) {
              if ((_a = node.endPosition) == null ? void 0 : _a.isBefore(lastPrintedNode.startPosition)) {
                continue;
              }
            }
            let insertNlAfter = false;
            if (node instanceof LogicGroupEnd) {
              if (node.next instanceof LogicGroupEnd == false && node.next != null) {
                if (!LanguageParser.isOperatorType(node.next) || !LanguageParser.isAssignmentOperator(node.next)) {
                  if (node.next instanceof StatementSeparatorNode == false && node.next instanceof InlineBranchSeparator == false) {
                    if (!node.isSwitchGroupMember && !LanguageParser.isOperatorType(node.next)) {
                      insertNlAfter = true;
                      if (node.next instanceof VariableNode && node.next.name == "as") {
                        insertNlAfter = false;
                      }
                    }
                  }
                  if (node.next instanceof ModifierSeparator) {
                    insertNlAfter = false;
                  }
                }
              }
            } else {
              if (!((_b = node.prev) == null ? void 0 : _b.isVirtual) && ((_c = node.prev) == null ? void 0 : _c.isVirtualGroupOperatorResolve) && node.prev.producesVirtualStatementTerminator) {
                if (node.next != null) {
                  if (!(node.prev instanceof VariableNode) && !(node.next instanceof InlineTernarySeparator) && !(node instanceof InlineTernarySeparator)) {
                    nodeBuffer.newlineIndent();
                  }
                }
              }
            }
            if (node instanceof VariableNode) {
              if (node.convertedToOperator) {
                if (node.name == "arr") {
                  nodeBuffer.appendT(" arr");
                } else if (node.name == "switch" || node.name == "list") {
                  nodeBuffer.appendTS(" " + node.name, true);
                  if (i + 1 < lexerNodes.length) {
                    const next = lexerNodes[i + 1];
                    if (!(next instanceof LogicGroupBegin)) {
                      break;
                    }
                    nodeBuffer.append("(");
                    if (node.name != "list") {
                      nodeBuffer.relativeIndent(node.name).newLine().indent();
                    }
                    i += 1;
                    lastPrintedNode = lexerNodes[i + 1];
                    continue;
                  } else {
                    break;
                  }
                } else {
                  nodeOperators += 1;
                  if (nodeOperators > 1) {
                    nodeBuffer.newlineNDIndent().indent().addIndent(6).appendS(node.name);
                  } else {
                    if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                      nodeBuffer.append(node.name);
                      continue;
                    }
                    nodeBuffer.appendS(node.name);
                  }
                }
                lastPrintedNode = node;
                continue;
              }
              if (node.mergeRefName != null && node.mergeRefName.trim().length > 0 && node.mergeRefName != node.name) {
                nodeBuffer.append(node.mergeRefName.trim());
              } else {
                if (node.name == "as") {
                  nodeBuffer.appendOS("as");
                } else {
                  nodeBuffer.append(node.name.trim());
                }
              }
            } else if (node instanceof TupleListStart) {
              nodeBuffer.appendTS(" list");
              if (i + 1 < lexerNodes.length) {
                const next = lexerNodes[i + 1];
                if (!(next instanceof LogicGroupBegin)) {
                  break;
                }
                nodeBuffer.append("(");
                i += 1;
                lastPrintedNode = lexerNodes[i + 1];
                continue;
              } else {
                break;
              }
            } else if (node instanceof ModifierSeparator) {
              nodeBuffer.appendS("|");
            } else if (node instanceof InlineBranchSeparator) {
              if (lastPrintedNode != null) {
                if ((_d = node.startPosition) == null ? void 0 : _d.isBefore(lastPrintedNode.endPosition)) {
                  continue;
                }
              }
              if (node.next instanceof VariableNode) {
                if (node.next.mergeRefName.startsWith(":")) {
                  continue;
                }
              }
              if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                if (!nodeBuffer.endsWith(":")) {
                  nodeBuffer.append(":");
                }
                continue;
              }
              if (node.prev != null && node.next != null) {
                if (NodeHelpers.distance(node.prev, node) <= 1 && NodeHelpers.distance(node.next, node) <= 1) {
                  nodeBuffer.append(":");
                  lastPrintedNode = node;
                  continue;
                }
              }
              if (doc.getDocumentParser().getLanguageParser().isActualModifierSeparator(node)) {
                nodeBuffer.append(":");
                lastPrintedNode = node;
                continue;
              }
              if (lastPrintedNode instanceof ModifierNameNode || lastPrintedNode instanceof ModifierValueNode) {
                nodeBuffer.append(":");
                lastPrintedNode = node;
                continue;
              }
              nodeBuffer.appendS(":");
            } else if (node instanceof ModifierNameNode) {
              nodeBuffer.append(node.name);
            } else if (node instanceof InlineTernarySeparator) {
              nodeBuffer.appendS("?");
            } else if (node instanceof ModifierValueSeparator) {
              if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                continue;
              }
              if (node.isTenaryBranchSeparator) {
                nodeBuffer.appendS(":");
                lastPrintedNode = node;
                continue;
              }
              if (doc.getDocumentParser().getLanguageParser().isActualModifierSeparator(node)) {
                nodeBuffer.append(":");
                lastPrintedNode = node;
                continue;
              }
              nodeBuffer.append(":");
            } else if (node instanceof ModifierValueNode) {
              nodeBuffer.append(node.value.trim());
            } else if (node instanceof LogicGroupBegin) {
              nodeBuffer.append("(");
            } else if (node instanceof LogicGroupEnd) {
              nodeBuffer.append(")");
            } else if (node instanceof StringValueNode) {
              if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                continue;
              }
              if (node.sourceContent != "") {
                nodeBuffer.appendOS(node.sourceContent);
              } else {
                nodeBuffer.appendOS(node.sourceTerminator + node.value + node.sourceTerminator);
              }
            } else if (node instanceof ArgSeparator) {
              if (node.isSwitchGroupMember) {
                nodeBuffer.append(",").newlineIndent();
              } else {
                nodeBuffer.append(", ");
              }
            } else if (node instanceof NumberNode) {
              lastPrintedNode = node;
              if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                continue;
              }
              let valueToPrint = (_f = (_e = node.value) == null ? void 0 : _e.toString()) != null ? _f : "";
              if (node.rawLexContent != null && node.rawLexContent.trim().length > 0) {
                valueToPrint = node.rawLexContent.trim();
              }
              nodeBuffer.append(valueToPrint);
            } else if (node instanceof LeftAssignmentOperator) {
              nodeBuffer.appendS("=");
            } else if (node instanceof ScopeAssignmentOperator) {
              nodeBuffer.appendS("=>");
            } else if (node instanceof AdditionOperator) {
              nodeBuffer.appendS("+");
            } else if (node instanceof SubtractionOperator) {
              if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                nodeBuffer.append("-");
                continue;
              }
              if (node.prev != null && node.next != null) {
                if (NodeHelpers.distance(node.prev, node) <= 1 && NodeHelpers.distance(node.next, node) <= 1) {
                  if (node.next instanceof NumberNode && node.prev instanceof NumberNode) {
                    nodeBuffer.appendS("-");
                  } else {
                    nodeBuffer.append("-");
                  }
                  lastPrintedNode = node;
                  continue;
                }
              }
              nodeBuffer.appendS("-");
            } else if (node instanceof MultiplicationOperator) {
              nodeBuffer.appendS("*");
            } else if (node instanceof DivisionOperator) {
              lastPrintedNode = node;
              if ((_g = node.startPosition) == null ? void 0 : _g.isBefore(antlersNode.nameEndsOn)) {
                nodeBuffer.append("/");
                continue;
              }
              if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
                continue;
              }
              nodeBuffer.appendS("/");
              continue;
            } else if (node instanceof StatementSeparatorNode) {
              if (node.isListGroupMember) {
                nodeBuffer.append(";").newlineIndent().indent().addIndent(7);
                if (i + 1 < lexerNodes.length && lexerNodes[i + 1] instanceof LogicGroupEnd == false) {
                  nodeBuffer.indent();
                }
              } else {
                nodeStatements += 1;
                if (nodeStatements < options.maxAntlersStatementsPerLine) {
                  nodeBuffer.appendT("; ");
                } else {
                  nodeBuffer.appendT(";").newlineIndent();
                  nodeStatements = 0;
                }
              }
            } else if (node instanceof LogicalNegationOperator) {
              if (node.content == "not") {
                nodeBuffer.appendS("not");
              } else {
                nodeBuffer.append("!");
              }
            } else if (node instanceof ModulusOperator) {
              if (i == 0 && ((_h = antlersNode.pathReference) == null ? void 0 : _h.isStrictTagReference)) {
              } else {
                nodeBuffer.appendS(node.rawContent());
              }
            } else {
              nodeBuffer.appendS(node.rawContent());
            }
            if (insertNlAfter) {
              nodeBuffer.newlineIndent();
            }
            lastPrintedNode = node;
          }
          if (antlersNode.hasParameters) {
            antlersNode.parameters.forEach((param) => {
              nodeBuffer.paramS(param);
            });
          }
          nodeBuffer.close();
          let bContent = nodeBuffer.getContent();
          if (antlersNode.processedInterpolationRegions.size > 0) {
            const regions = new Map([...antlersNode.processedInterpolationRegions.entries()].sort().reverse());
            regions.forEach((region, key) => {
              const iTResult = NodePrinter.prettyPrintNode(region[0], doc, indent, options, null, null);
              bContent = replaceAllInString(bContent, key, iTResult);
            });
          }
          return bContent;
        }
        return antlersNode.getTrueRawContent();
      }
    };
  }
});

// server/src/runtime/document/transformer.ts
var Transformer;
var init_transformer = __esm({
  "server/src/runtime/document/transformer.ts"() {
    "use strict";
    init_strings();
    init_conditionPairAnalyzer();
    init_abstractNode();
    init_stringUtilities();
    init_antlersDocument();
    init_commentPrinter();
    init_indentLevel();
    init_nodePrinter();
    Transformer = class {
      constructor(doc) {
        this.formatIgnoreStart = "format-ignore-start";
        this.formatIgnoreEnd = "format-ignore-end";
        this.htmlFormatter = null;
        this.yamlFormatter = null;
        this.phpFormatter = null;
        this.slugs = [];
        this.removeLines = [];
        this.virtualStructureOpens = [];
        this.virtualStructureClose = [];
        this.structureLines = [];
        this.parentTransformer = null;
        this.tagPairs = /* @__PURE__ */ new Map();
        this.conditions = [];
        this.inlineIfs = /* @__PURE__ */ new Map();
        this.createExraStructuralPairs = false;
        this.spanNodes = /* @__PURE__ */ new Map();
        this.inlineNodes = /* @__PURE__ */ new Map();
        this.virtualBlocks = [];
        this.inlineComments = /* @__PURE__ */ new Map();
        this.blockComments = [];
        this.extractedEmbeddedDocuments = /* @__PURE__ */ new Map();
        this.dynamicElementAntlers = /* @__PURE__ */ new Map();
        this.dynamicElementAntlersNodes = /* @__PURE__ */ new Map();
        this.dynamicElementPairedAntlers = /* @__PURE__ */ new Map();
        this.dynamicElementPairedAntlersNodes = /* @__PURE__ */ new Map();
        this.dynamicElementConditionAntlers = /* @__PURE__ */ new Map();
        this.dynamicElementConditionAntlersNodes = /* @__PURE__ */ new Map();
        this.noParses = /* @__PURE__ */ new Map();
        this.forceBreaks = [];
        this.inlineFormatter = null;
        this.ignoredLiteralBlocks = /* @__PURE__ */ new Map();
        this.activeLiteralSlug = "";
        this.isInsideIgnoreFormatter = false;
        this.forceCleanLines = [
          "{{ if ",
          "{{ /if",
          "{{ /unless",
          "{{ /noparse",
          "{{ else",
          "{{ unless"
        ];
        this.doc = doc;
        this.options = {
          tabSize: 4,
          newlinesAfterFrontMatter: 1,
          maxAntlersStatementsPerLine: 3,
          endNewline: true
        };
      }
      withInlineFormatter(inlineFormatter) {
        this.inlineFormatter = inlineFormatter;
        return this;
      }
      produceExtraStructuralPairs(doCreate) {
        this.createExraStructuralPairs = doCreate;
        return this;
      }
      withHtmlFormatter(formatter) {
        this.htmlFormatter = formatter;
        return this;
      }
      withYamlFormatter(formatter) {
        this.yamlFormatter = formatter;
        return this;
      }
      withPhpFormatter(formatter) {
        this.phpFormatter = formatter;
        return this;
      }
      withOptions(options) {
        this.options = options;
        if (this.options.tabSize <= 0) {
          this.options.tabSize = 4;
        }
        if (this.options.newlinesAfterFrontMatter < 0) {
          this.options.newlinesAfterFrontMatter = 1;
        }
        return this;
      }
      setParentTransformer(transformer) {
        this.parentTransformer = transformer;
        return this;
      }
      close(value) {
        return "</" + value + ">";
      }
      open(value) {
        return "<" + value + ">";
      }
      selfClosing(value) {
        return "<" + value + " />";
      }
      selfClosingNs(value) {
        return "<" + value + "/>";
      }
      pair(value, innerContent = "") {
        return "<" + value + ">" + innerContent + "</" + value + ">";
      }
      makeSlug(length) {
        if (length <= 2) {
          length = 7;
        }
        let result = "";
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", charactersLength = characters.length;
        for (let i = 0; i < length - 1; i++) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        let slug = "A" + result + "A";
        slug = slug.toLowerCase();
        if (this.slugs.includes(slug)) {
          return this.makeSlug(length + 1);
        }
        this.slugs.push(slug.toLowerCase());
        return slug.toLowerCase();
      }
      transformInlineConditions(value) {
        let results = value;
        this.inlineIfs.forEach((condition, slug) => {
          results = results.replace(slug, condition.nodeContent);
        });
        return results;
      }
      registerCondition(transformedCondition) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerCondition(transformedCondition);
        } else {
          this.conditions.push(transformedCondition);
        }
      }
      registerInlineCondition(slug, node) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerInlineCondition(slug, node);
        } else {
          this.inlineIfs.set(slug, node);
        }
      }
      registerVirtualBlock(structure) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerVirtualBlock(structure);
        } else {
          this.virtualBlocks.push(structure);
        }
      }
      registerNoParse(slug, node) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerNoParse(slug, node);
        } else {
          this.noParses.set(slug, node);
        }
      }
      prepareNoParse(node) {
        const slug = this.makeSlug(35);
        this.registerNoParse(slug, node);
        return slug;
      }
      registerForcedBreak() {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerForcedBreak();
        } else {
          const breakSlug = this.makeSlug(15), innerSlug = this.makeSlug(10);
          this.forceBreaks.push(breakSlug);
          this.forceBreaks.push(innerSlug);
          this.removeLines.push(this.open(breakSlug));
          this.removeLines.push(this.close(breakSlug));
          this.removeLines.push(this.selfClosing(innerSlug));
          return this.pair(breakSlug, this.selfClosing(innerSlug));
        }
      }
      transformVirtualStructures(content) {
        let value = content;
        this.virtualBlocks.forEach((block) => {
          var _a;
          this.removeLines.push(block.pairClose);
          const targetIndent = this.indentLevel(block.pairOpen);
          if (block.virtualElement.length > 0) {
            this.removeLines.push(this.open(block.virtualElement));
            this.removeLines.push(this.close(block.virtualElement));
          }
          if (block.node instanceof EscapedContentNode) {
            const replaceNoParse = "{{ noparse }}" + block.node.getInnerDocumentText();
            value = value.replace(block.pairOpen, replaceNoParse);
          }
          if (block.node instanceof AntlersNode) {
            const antlersNode = block.node;
            value = value.replace(block.pairClose, (_a = antlersNode.isClosedBy) == null ? void 0 : _a.getOriginalContent());
          } else {
            this.removeLines.push(block.pairClose);
          }
        });
        this.noParses.forEach((node, slug) => {
          value = value.replace(slug, `{{ noparse }}${node.getInnerDocumentText()}{{ /noparse }}`);
        });
        return value;
      }
      printNode(node, targetIndent = null) {
        var _a, _b;
        const printNode = node.getTrueNode();
        if ((printNode.rawStart == "{{?" || printNode.rawStart == "{{$") && this.phpFormatter != null) {
          try {
            const formattedPhp = this.phpFormatter(printNode.content);
            return `${printNode.rawStart} ${formattedPhp} ${printNode.rawEnd}`;
          } catch (err) {
          }
        }
        let doc = this.doc;
        if (node.childDocument != null) {
          doc = node.childDocument.document;
        }
        let prepend = null;
        if (ConditionPairAnalyzer.isConditionalStructure(node)) {
          prepend = printNode.runtimeName();
          if (node.isClosingTag && (prepend == "if" || prepend == "unless")) {
            return `{{ /${prepend} }}`;
          }
        }
        if (node.isClosingTag) {
          if (printNode.runtimeName() == "endunless") {
            return `{{ /unless }}`;
          }
          return `{{ ${printNode.sourceContent.trim()} }}`;
        }
        let result = NodePrinter.prettyPrintNode(printNode, doc, 0, this.options, prepend, null);
        const forceBreakOperatorNames = ["switch", "list"];
        if (targetIndent != null && result.includes("\n")) {
          if (node.isVirtual && (((_a = node.name) == null ? void 0 : _a.name) == "switch" || ((_b = node.name) == null ? void 0 : _b.name) == "list")) {
            result = IndentLevel.shiftIndent(result, targetIndent + this.options.tabSize, true);
          } else {
            result = IndentLevel.shiftIndent(result, targetIndent - this.options.tabSize * 2, true);
          }
        }
        return result;
      }
      transformConditions(content) {
        let value = content;
        this.conditions.forEach((condition) => {
          condition.structures.forEach((structure) => {
            const structureTag = structure.branch.head;
            if (structure.virtualBreakOpen.length > 0) {
              this.removeLines.push(structure.virtualBreakOpen);
            }
            if (structure.virtualBreakClose.length > 0) {
              value = value.replace(structure.virtualBreakClose, structure.virtualBreakClose + "\n");
              this.removeLines.push(structure.virtualBreakClose);
            }
            this.virtualStructureOpens.push(structure.virtualOpen);
            this.removeLines.push(structure.virtualOpen);
            this.removeLines.push(structure.virtualClose);
            if (!structure.isLast) {
              const virtualInline = this.selfClosing(structure.virtualSlug);
              if (!value.includes(virtualInline)) {
                const replaceRegex = "<" + structure.virtualSlug + "(\\s)+\\/>", regex = new RegExp(replaceRegex, "gm");
                value = value.replace(regex, virtualInline);
              }
              if (value.includes(virtualInline)) {
                value = value.replace(virtualInline, structure.doc.trim());
              }
              this.removeLines.push(structure.pairClose);
              value = value.replace(structure.pairOpen, this.printNode(structureTag, this.indentLevel(structure.pairOpen)));
            } else {
              const virtualInline = this.selfClosing(structure.virtualSlug);
              if (!value.includes(virtualInline)) {
                const replaceRegex = "<" + structure.virtualSlug + "(\\s)+\\/>", regex = new RegExp(replaceRegex, "gm");
                value = value.replace(regex, virtualInline);
              }
              if (value.includes(virtualInline)) {
                value = value.replace(virtualInline, structure.doc.trim());
              }
              value = value.replace(structure.pairOpen, this.printNode(structureTag, this.indentLevel(structure.pairOpen)));
              value = value.replace(structure.pairClose, this.printNode(structureTag.isClosedBy));
            }
          });
        });
        return value;
      }
      transformExtractedDocuments(content) {
        let value = content;
        this.extractedEmbeddedDocuments.forEach((document, slug) => {
          let target = "", indent = 0;
          if (document.isScript) {
            target = "//" + slug;
          } else {
            target = "/*" + slug + "*/";
          }
          indent = this.indentLevel(target);
          if (value.includes(target)) {
            let replaceContent = "";
            if (document.content.includes("{{ /") || document.content.includes("{{/")) {
              replaceContent = document.content.trim();
            } else {
              replaceContent = IndentLevel.indentRelative(document.content, indent);
            }
            value = value.replace(target, replaceContent);
          }
        });
        return value;
      }
      getAntlersChildDoc(node) {
        if (node.childDocument != null) {
          return node.childDocument.document.transform().setParentTransformer(this).toStructure();
        }
        return this.clone().toStructure(node.getImmediateChildren());
      }
      prepareCondition(node) {
        const headNode = node.logicBranches[0].head;
        if (headNode.fragmentPosition == 2 /* InsideFragment */ || headNode.fragmentPosition == 1 /* InsideFragmentParameter */) {
          const slug = this.makeSlug(node.nodeContent.length);
          this.registerInlineCondition(slug, node);
          return slug;
        }
        if (headNode.fragmentPosition == 0 /* IsDynamicFragmentName */) {
          return this.prepareDynamicCondition(node);
        }
        const transformedBranches = [];
        let result = "";
        if (headNode.prev instanceof AntlersNode && headNode.prev.isInlineAntlers) {
          result += this.registerForcedBreak();
        }
        node.logicBranches.forEach((branch, index) => {
          var _a, _b, _c, _d;
          const tag = branch.head, innerDoc = this.getAntlersChildDoc(branch);
          const openSlug = this.makeSlug(tag.sourceContent.length), virtualSlug = this.makeSlug(10);
          const tBranch = {
            branch,
            slug: openSlug,
            doc: innerDoc,
            pairOpen: this.open(openSlug),
            pairClose: this.close(openSlug),
            virtualOpen: this.open(virtualSlug),
            virtualClose: this.close(virtualSlug),
            virtualSlug,
            isFirst: index == 0,
            isLast: index == node.logicBranches.length - 1,
            virtualBreakClose: "",
            virtualBreakOpen: ""
          };
          if (((_b = (_a = branch.head) == null ? void 0 : _a.name) == null ? void 0 : _b.getCompoundTagName()) == "else") {
            result += "\n" + tBranch.pairOpen;
            const virtualBreakSlug = this.makeSlug(25);
            if (this.createExraStructuralPairs && branch.head.containsChildStructures == false && branch.head.containsAnyFragments == false) {
              tBranch.virtualBreakOpen = this.open(virtualBreakSlug);
              tBranch.virtualBreakClose = this.close(virtualBreakSlug);
              tBranch.virtualSlug = virtualBreakSlug;
              result += "\n" + this.selfClosing(virtualBreakSlug);
              result += tBranch.pairClose + "\n";
            } else {
              tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
              result += tBranch.virtualBreakOpen + "\n";
              result += innerDoc;
              result += "\n" + tBranch.pairClose;
            }
          } else {
            if (this.createExraStructuralPairs && ((_c = branch.head) == null ? void 0 : _c.containsAnyFragments) == false && ((_d = branch.head) == null ? void 0 : _d.containsChildStructures) == false) {
              const ifBreakSlug = this.makeSlug(25);
              tBranch.virtualBreakOpen = this.open(ifBreakSlug);
              tBranch.virtualBreakClose = this.close(ifBreakSlug);
              tBranch.virtualSlug = ifBreakSlug;
              result += "\n" + tBranch.pairOpen;
              result += "\n" + this.selfClosing(ifBreakSlug);
              result += tBranch.pairClose + "\n";
            } else {
              result += tBranch.pairOpen;
              result += "\n";
              result += innerDoc;
              result += "\n";
              result += tBranch.pairClose;
            }
          }
          transformedBranches.push(tBranch);
        });
        const pairOpen = transformedBranches[0].pairOpen, pairClose = transformedBranches[transformedBranches.length - 1].pairClose;
        const tCond = {
          pairOpen,
          pairClose,
          structures: transformedBranches,
          condition: node
        };
        this.registerCondition(tCond);
        return result;
      }
      registerPairedAntlers(slug, transformedTag) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerPairedAntlers(slug, transformedTag);
        } else {
          this.tagPairs.set(slug, transformedTag);
        }
      }
      preparePairedAntlers(node) {
        const slug = this.makeSlug(node.getOriginalContent().length), innerDoc = this.getAntlersChildDoc(node);
        if (node.fragmentPosition != 0 /* IsDynamicFragmentName */) {
          let virtualSlug = "";
          let result = "";
          if (node.prev instanceof AntlersNode && node.prev.isPaired() == false) {
            result += this.registerForcedBreak();
          }
          result += `${this.open(slug)}
`;
          if (node.containsChildStructures == false && node.containsAnyFragments == false) {
            let createVirtual = false, literalsAllWhiteSpace = true, allAntlersInline = true, antlersCount = 0;
            for (let i = 0; i < node.children.length; i++) {
              const thisNode = node.children[i];
              if (thisNode instanceof LiteralNode) {
                if (thisNode.sourceContent.trim().length > 0) {
                  createVirtual = true;
                  literalsAllWhiteSpace = false;
                  break;
                }
              }
            }
            if (node.children.length == 2 && node.children[0] instanceof AntlersNode) {
              createVirtual = true;
            }
            let inlineAntlers = 0;
            for (let i = 0; i < node.children.length - 1; i++) {
              const thisNode = node.children[i];
              if (thisNode instanceof AntlersNode) {
                antlersCount += 1;
                if (thisNode.isInlineAntlers) {
                  inlineAntlers += 1;
                } else {
                  allAntlersInline = false;
                }
              }
            }
            if (inlineAntlers == 0) {
              createVirtual = true;
            }
            if (allAntlersInline == false) {
              createVirtual = false;
            }
            if (literalsAllWhiteSpace == false && antlersCount == 0) {
              createVirtual = false;
            }
            if (createVirtual) {
              virtualSlug = this.makeSlug(15);
              result += this.pair(virtualSlug, innerDoc);
            } else {
              result += innerDoc;
            }
          } else {
            result += innerDoc;
          }
          result += `
${this.close(slug)}
`;
          this.virtualStructureOpens.push(this.open(virtualSlug));
          this.virtualStructureClose.push(this.close(virtualSlug));
          this.virtualStructureClose.push(this.close(slug));
          this.registerPairedAntlers(slug, {
            innerDoc,
            slug,
            tag: node,
            virtualElementSlug: virtualSlug,
            isInline: false
          });
          return result;
        }
        return this.prepareConditionalAntlersPair(node);
      }
      registerInlineAntlers(node) {
        if (node.fragmentPosition == 2 /* InsideFragment */ || node.fragmentPosition == 1 /* InsideFragmentParameter */) {
          node.isInlineAntlers = true;
        }
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerInlineAntlers(node);
        } else {
          const slug = this.makeSlug(node.getOriginalContent().length);
          if (node.isInlineAntlers) {
            this.spanNodes.set(slug, node);
            return slug;
          } else {
            this.inlineNodes.set(slug, node);
            return this.selfClosing(slug);
          }
        }
      }
      registerVirtualComment(structure) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerVirtualComment(structure);
        } else {
          this.blockComments.push(structure);
        }
      }
      registerComment(slug, comment) {
        if (this.parentTransformer != null) {
          this.parentTransformer.registerComment(slug, comment);
        } else {
          this.inlineComments.set(slug, comment);
        }
      }
      prepareComment(node) {
        const sourceContent = node.getContent(), content = sourceContent.trim();
        if (content.includes("\n")) {
          const slug2 = this.makeSlug(10), virtualSlug = this.makeSlug(10), virtualStructure = {
            node,
            pairOpen: this.open(slug2),
            pairClose: this.close(slug2),
            virtualElement: this.selfClosing(virtualSlug)
          };
          this.registerVirtualComment(virtualStructure);
          return virtualStructure.pairOpen + "\n" + virtualStructure.virtualElement + "\n" + virtualStructure.pairClose;
        }
        const slug = this.makeSlug(sourceContent.length);
        this.registerComment(slug, node);
        return this.selfClosing(slug);
      }
      registerDynamicAntlersPair(slug, node) {
        if (this.parentTransformer != null) {
          this.dynamicElementPairedAntlers.set(node.nodeContent, slug);
          this.parentTransformer.registerDynamicAntlersPair(slug, node);
        } else {
          this.dynamicElementPairedAntlers.set(node.nodeContent, slug);
          this.dynamicElementPairedAntlersNodes.set(slug, node);
        }
      }
      prepareConditionalAntlersPair(node) {
        if (this.dynamicElementPairedAntlers.has(node.nodeContent)) {
          return this.dynamicElementPairedAntlers.get(node.nodeContent);
        }
        const slug = this.makeSlug(node.nodeContent.length);
        this.registerDynamicAntlersPair(slug, node);
        return slug;
      }
      registerDynamicCondition(slug, node) {
        if (this.parentTransformer != null) {
          this.dynamicElementConditionAntlers.set(node.nodeContent, slug);
          this.parentTransformer.registerDynamicCondition(slug, node);
        } else {
          this.dynamicElementConditionAntlers.set(node.nodeContent, slug);
          this.dynamicElementConditionAntlersNodes.set(slug, node);
        }
      }
      prepareDynamicCondition(node) {
        if (this.dynamicElementConditionAntlers.has(node.nodeContent)) {
          return this.dynamicElementConditionAntlers.get(node.nodeContent);
        }
        const slug = this.makeSlug(node.nodeContent.length);
        this.registerDynamicCondition(slug, node);
        return slug;
      }
      registerDynamicAntlers(slug, node) {
        if (this.parentTransformer != null) {
          this.dynamicElementAntlers.set(node.content, slug);
          this.parentTransformer.registerDynamicAntlers(slug, node);
        } else {
          this.dynamicElementAntlers.set(node.content, slug);
          this.dynamicElementAntlersNodes.set(slug, node);
        }
      }
      prepareConditionalAntlers(node) {
        if (this.dynamicElementAntlers.has(node.content)) {
          return this.dynamicElementAntlers.get(node.content);
        }
        const slug = this.makeSlug(node.content.length);
        this.registerDynamicAntlers(slug, node);
        return slug;
      }
      prepareAntlers(node) {
        if (node.isClosedBy != null) {
          return this.preparePairedAntlers(node);
        }
        if (node.fragmentPosition == 0 /* IsDynamicFragmentName */) {
          return this.prepareConditionalAntlers(node);
        }
        return this.registerInlineAntlers(node);
      }
      transformDynamicAntlers(content) {
        let value = content;
        this.dynamicElementAntlersNodes.forEach((node, slug) => {
          const antlersContent = this.printNode(node);
          value = replaceAllInString(value, slug, antlersContent);
        });
        this.dynamicElementPairedAntlersNodes.forEach((node, slug) => {
          const antlersContent = node.nodeContent;
          value = replaceAllInString(value, slug, antlersContent);
        });
        this.dynamicElementConditionAntlersNodes.forEach((node, slug) => {
          const antlersContent = node.nodeContent;
          value = replaceAllInString(value, slug, antlersContent);
        });
        return value;
      }
      transformPairedAntlers(content) {
        let value = content;
        this.tagPairs.forEach((tag, slug) => {
          const originalTag = tag.tag;
          if (tag.virtualElementSlug.length > 0) {
            const open2 = this.open(tag.virtualElementSlug), close2 = this.close(tag.virtualElementSlug);
            this.virtualStructureOpens.push(open2);
            this.removeLines.push(open2);
            this.removeLines.push(close2);
          }
          const open = this.open(slug), close = this.close(slug);
          value = value.replace(open, this.printNode(originalTag, this.indentLevel(open)));
          value = value.replace(close, this.printNode(originalTag.isClosedBy));
        });
        return value;
      }
      transformInlineAntlers(content) {
        let value = content;
        this.inlineNodes.forEach((node, slug) => {
          const inline = this.selfClosing(slug), inlineNs = this.selfClosingNs(slug), printed = this.printNode(node, this.indentLevel(inline));
          value = value.replace(inline, printed);
          value = value.replace(inlineNs, printed);
        });
        this.spanNodes.forEach((node, slug) => {
          var _a, _b;
          let level = 0;
          if (node.isVirtual && (((_a = node.name) == null ? void 0 : _a.name) == "switch" || ((_b = node.name) == null ? void 0 : _b.name) == "list")) {
            level = this.indentLevel(slug, true);
          }
          const printed = this.printNode(node, level), slugNs = this.selfClosingNs(slug);
          value = value.replace(slug, printed);
          value = value.replace(slugNs, printed);
        });
        return value;
      }
      transformComments(content) {
        let value = content;
        this.inlineComments.forEach((comment, slug) => {
          const open = this.selfClosing(slug), commentResult = CommentPrinter.printComment(comment, this.options.tabSize, 0, this.inlineFormatter);
          value = value.replace(open, commentResult);
        });
        this.blockComments.forEach((structure) => {
          const comment = structure.node, commentResult = CommentPrinter.printComment(comment, this.options.tabSize, this.indentLevel(structure.pairOpen), this.inlineFormatter);
          value = value.replace(structure.pairOpen, commentResult);
          this.removeLines.push(structure.pairClose);
          this.removeLines.push(structure.virtualElement);
        });
        return value;
      }
      registerEmbeddedDocument(slug, content, isScript) {
        if (this.parentTransformer != null) {
          return this.parentTransformer.registerEmbeddedDocument(slug, content, isScript);
        }
        this.extractedEmbeddedDocuments.set(slug, {
          slug,
          content,
          isScript
        });
        return slug;
      }
      clone() {
        const cloned = new Transformer(this.doc);
        cloned.withOptions(this.options).setParentTransformer(this);
        return cloned;
      }
      toStructure(renderNodes = null) {
        let result = "";
        if (renderNodes == null) {
          renderNodes = this.doc.getDocumentParser().getRenderNodes();
        }
        renderNodes.forEach((node) => {
          var _a, _b;
          if (this.isInsideIgnoreFormatter) {
            (_a = this.ignoredLiteralBlocks.get(this.activeLiteralSlug)) == null ? void 0 : _a.push(node);
            if (node instanceof AntlersNode && node.isComment) {
              if (node.content.trim().toLowerCase() == this.formatIgnoreEnd) {
                this.isInsideIgnoreFormatter = false;
                return;
              }
            }
            return;
          }
          if (node instanceof LiteralNode) {
            if (node.sourceContent == "") {
              result += node.content;
            } else {
              result += node.sourceContent;
            }
          } else if (node instanceof ConditionNode) {
            result += this.prepareCondition(node);
          } else if (node instanceof EscapedContentNode) {
            result += this.prepareNoParse(node);
          } else if (node instanceof AntlersNode) {
            if (node.isComment) {
              if (node.content.trim() == this.formatIgnoreStart) {
                this.isInsideIgnoreFormatter = true;
                this.activeLiteralSlug = this.makeSlug(16);
                this.ignoredLiteralBlocks.set(this.activeLiteralSlug, []);
                (_b = this.ignoredLiteralBlocks.get(this.activeLiteralSlug)) == null ? void 0 : _b.push(node);
                result += this.selfClosing(this.activeLiteralSlug);
              } else {
                result += this.prepareComment(node);
              }
            } else {
              result += this.prepareAntlers(node);
            }
          }
        });
        const structures = this.doc.getDocumentParser().getFragmentsContainingStructures();
        if (structures.length > 0) {
          const referenceDocument = new AntlersDocument();
          referenceDocument.loadString(result);
          structures.forEach((pair) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const ref = this.doc.getDocumentParser().getText(((_b = (_a = pair.start.endPosition) == null ? void 0 : _a.offset) != null ? _b : 0) + 1, (_d = (_c = pair.end.startPosition) == null ? void 0 : _c.offset) != null ? _d : 0), refOpen = referenceDocument.getDocumentParser().getFragmentsParser().getEmbeddedFragment(pair.start.embeddedIndex);
            if (refOpen == null) {
              return;
            }
            const refClose = referenceDocument.getDocumentParser().getFragmentsParser().getClosingFragmentAfter(refOpen);
            if (refClose == null) {
              return;
            }
            const curRef = referenceDocument.getDocumentParser().getText(((_f = (_e = refOpen.endPosition) == null ? void 0 : _e.offset) != null ? _f : 0) + 1, (_h = (_g = refClose == null ? void 0 : refClose.startPosition) == null ? void 0 : _g.offset) != null ? _h : 0), refSlug = this.makeSlug(16), isScript = pair.start.name.toLowerCase() == "script";
            let replaceSlug = refSlug;
            if (isScript) {
              replaceSlug = "//" + refSlug;
            } else {
              replaceSlug = "/*" + refSlug + "*/";
            }
            result = result.replace(curRef, replaceSlug);
            this.registerEmbeddedDocument(refSlug, ref, isScript);
          });
        }
        return result;
      }
      removeVirtualStructures(content) {
        let value = content;
        this.removeLines.forEach((line) => {
          value = value.replace(line, "");
        });
        return value;
      }
      indentLevel(value, includeIndex = false) {
        for (let i = 0; i < this.structureLines.length; i++) {
          const thisLine = this.structureLines[i];
          if (thisLine.includes(value)) {
            const trimmed = thisLine.trimLeft();
            let indent = thisLine.length - trimmed.length;
            if (includeIndex) {
              indent += thisLine.indexOf(value);
            }
            return indent;
          }
        }
        return 0;
      }
      shouldCleanAfter(line) {
        for (let i = 0; i < this.removeLines.length; i++) {
          if (line.startsWith(this.removeLines[i])) {
            return true;
          }
        }
        for (let i = 0; i < this.forceCleanLines.length; i++) {
          if (line.startsWith(this.forceCleanLines[i])) {
            return true;
          }
        }
        return false;
      }
      shouldCleanLine(line) {
        for (let i = 0; i < this.forceCleanLines.length; i++) {
          const trimmedLine = line.trim();
          if (line.startsWith(this.forceCleanLines[i]) || trimmedLine.startsWith("{{ /") && trimmedLine.endsWith("}}")) {
            return true;
          }
        }
        return false;
      }
      cleanVirtualStructures(content) {
        const newLines = [], contentLines = StringUtilities.breakByNewLine(content);
        let removeNewLines = false;
        for (let i = 0; i < contentLines.length; i++) {
          const checkLine = contentLines[i].trim();
          if (removeNewLines) {
            if (checkLine.length == 0) {
              continue;
            } else {
              removeNewLines = false;
            }
          } else {
            removeNewLines = this.shouldCleanAfter(checkLine);
          }
          if (this.shouldCleanLine(checkLine)) {
            for (let j = newLines.length - 1; j > 0; j--) {
              const tLine = newLines[j];
              if (tLine.trim().length == 0) {
                newLines.pop();
              } else {
                break;
              }
            }
          }
          if (this.removeLines.includes(checkLine)) {
            continue;
          } else {
            let newLine = contentLines[i];
            this.removeLines.forEach((line) => {
              if (newLine.includes(line)) {
                newLine = newLine.replace(line, "");
              }
            });
            newLines.push(newLine);
          }
        }
        return newLines.join("\n");
      }
      cleanStructuralNewLines(content) {
        const lines = StringUtilities.breakByNewLine(content), newLines = [];
        let pruneLines = false;
        lines.forEach((line) => {
          const checkLine = line.trim();
          if (checkLine.startsWith("{{") && checkLine.endsWith("}}")) {
            newLines.push(line);
            pruneLines = true;
            return;
          }
          if (pruneLines && checkLine.length > 0) {
            pruneLines = false;
          }
          if (!pruneLines) {
            newLines.push(line);
          }
        });
        return newLines.join("\n");
      }
      reflowSlugs(content) {
        let result = content;
        this.slugs.forEach((slug) => {
          const open = this.open(slug), close = this.close(slug), selfClose = this.selfClosing(slug), openRegex = "/<" + slug + "(.*?)>/gms", closeRegex = "/</" + slug + "(.*?)>/gms", selfCloseRegex = "/<" + slug + "(.*?)/>/gms";
          result = result.replace(openRegex, open);
          result = result.replace(closeRegex, close);
          result = result.replace(selfCloseRegex, selfClose);
        });
        return result;
      }
      cleanLines(content) {
        const lines = StringUtilities.breakByNewLine(content), newLines = [];
        let pruneLines = false, prunedCount = 0, isProbablyOpen = false, isPartial = false;
        for (let i = 0; i < lines.length; i++) {
          const checkLine = lines[i].trim(), line = lines[i];
          if (checkLine.startsWith("{{")) {
            if (checkLine.endsWith("}}")) {
              isPartial = false;
            } else {
              isPartial = true;
            }
            if (checkLine.startsWith("{{#")) {
              isPartial = false;
            }
            if (pruneLines) {
              prunedCount = 0;
            }
            if (checkLine.startsWith("{{ /") == false) {
              isProbablyOpen = true;
            } else {
              isProbablyOpen = false;
            }
            pruneLines = true;
            newLines.push(line);
            continue;
          }
          if (!pruneLines) {
            newLines.push(line);
          } else {
            if (isPartial) {
              newLines.push(line);
              if (line.trim().endsWith("}}")) {
                isPartial = false;
              }
              continue;
            }
            if (checkLine.length == 0) {
              if (isProbablyOpen == false) {
                prunedCount = 0;
                pruneLines = false;
                continue;
              }
              prunedCount += 1;
              continue;
            } else {
              if (isProbablyOpen && prunedCount > 1) {
                newLines.push("");
              }
              prunedCount = 0;
              newLines.push(line);
              pruneLines = false;
            }
          }
        }
        return newLines.join("\n");
      }
      fromStructure(structure) {
        const reflowedContent = this.reflowSlugs(structure);
        this.structureLines = StringUtilities.breakByNewLine(reflowedContent);
        let results = this.transformInlineConditions(reflowedContent);
        results = this.transformConditions(results);
        results = this.transformInlineAntlers(results);
        results = this.transformComments(results);
        results = this.transformVirtualStructures(results);
        results = this.transformDynamicAntlers(results);
        results = this.transformPairedAntlers(results);
        results = this.transformExtractedDocuments(results);
        results = this.cleanVirtualStructures(results);
        results = this.cleanLines(results);
        if (this.doc.hasFrontMatter()) {
          let frontMatter = this.doc.getFrontMatter();
          const frontMatterDoc = this.doc.getFrontMatterDoc();
          if (frontMatterDoc != null && frontMatterDoc.isValid && this.yamlFormatter != null) {
            frontMatter = this.yamlFormatter(frontMatter);
          }
          const insertFrontMatter = `---
${frontMatter}
---
` + "\n".repeat(this.options.newlinesAfterFrontMatter);
          results = insertFrontMatter + results.trimLeft();
        }
        results = results.trimRight();
        this.ignoredLiteralBlocks.forEach((nodes, slug) => {
          const replace = this.selfClosing(slug), startIndent = this.indentLevel(replace);
          results = results.replace(replace, this.dumpPreservedNodes(nodes, startIndent));
        });
        if (this.options.endNewline) {
          results += "\n";
        }
        return results;
      }
      dumpPreservedNodes(nodes, finalIndent) {
        let stringResults = "";
        nodes.forEach((node) => {
          if (node instanceof LiteralNode) {
            stringResults += node.sourceContent;
          } else if (node instanceof ConditionNode) {
            stringResults += node.nodeContent;
          } else if (node instanceof EscapedContentNode) {
            stringResults += node.documentText;
          } else if (node instanceof AntlersNode) {
            if (node.isComment) {
              if (node.content.trim().toLowerCase() == this.formatIgnoreEnd) {
                let preservedLines = stringResults.split("\n");
                if (preservedLines.length > 0) {
                  if (preservedLines[preservedLines.length - 1].trim().length == 0) {
                    preservedLines.pop();
                    preservedLines.push("");
                    stringResults = preservedLines.join("\n");
                  }
                }
                stringResults += " ".repeat(finalIndent) + "{{#" + node.content + "#}}";
              } else {
                stringResults += "{{#" + node.content + "#}}";
              }
              return;
            }
            if (node.isPaired()) {
              stringResults += node.nodeContent;
            } else {
              stringResults += "{{" + node.content + "}}";
            }
          }
        });
        return stringResults;
      }
    };
  }
});

// server/src/runtime/document/yamlDocument.ts
var YAML2, YamlDocument;
var init_yamlDocument = __esm({
  "server/src/runtime/document/yamlDocument.ts"() {
    "use strict";
    YAML2 = __toESM(require_yaml());
    init_types();
    init_position();
    init_stringUtilities();
    YamlDocument = class {
      constructor() {
        this.content = "";
        this.ranges = [];
        this.lastDocumentOffsetKey = null;
        this.documentOffsets = /* @__PURE__ */ new Map();
        this.lineIndex = /* @__PURE__ */ new Map();
        this.keys = [];
        this.values = [];
        this.isValid = false;
        this.parseError = null;
      }
      loadString(text) {
        var _a;
        this.content = StringUtilities.normalizeLineEndings(text);
        let doc = null;
        try {
          doc = YAML2.parseDocument(this.content);
          this.isValid = true;
        } catch (err) {
          this.isValid = false;
          this.parseError = err;
        }
        if (doc == null) {
          return;
        }
        const documentNewLines = [...this.content.matchAll(/(\n)/gm)], newLineCountLen = documentNewLines.length;
        let currentLine = 2, lastOffset = null, lastStartIndex = 0, lastEndIndex = 0;
        for (let i = 0; i < newLineCountLen; i++) {
          const thisNewLine = documentNewLines[i], thisIndex = (_a = thisNewLine.index) != null ? _a : 0;
          let indexChar = thisIndex;
          if (lastOffset != null) {
            indexChar = thisIndex - lastOffset;
          } else {
            indexChar = indexChar + 1;
          }
          this.documentOffsets.set(thisIndex, {
            char: indexChar,
            line: currentLine
          });
          let thisStartIndex = 0, thisEndIndex = 0;
          if (i == 0) {
            thisEndIndex = indexChar - 1;
            thisStartIndex = 0;
          } else {
            thisStartIndex = lastEndIndex + 1;
            thisEndIndex = thisIndex;
          }
          this.lineIndex.set(currentLine, {
            char: indexChar,
            line: currentLine,
            startIndex: thisStartIndex,
            endIndex: thisEndIndex
          });
          this.lastDocumentOffsetKey = thisIndex;
          currentLine += 1;
          lastOffset = thisIndex;
          lastEndIndex = thisEndIndex;
          lastStartIndex = thisStartIndex;
        }
        const docContents = doc.contents;
        this.processMap(docContents);
      }
      processMap(map2) {
        if (typeof map2.items === "undefined") {
          return;
        }
        map2.items.forEach((item) => {
          this.processItem(item);
        });
      }
      processItem(item) {
        if (item.type == "PAIR") {
          if (item.value instanceof YAMLMap || item.value instanceof YAMLSeq) {
            const key2 = item.key;
            if (key2.range != null) {
              const s1 = this.positionFromOffset(key2.range[0], key2.range[0]), e1 = this.positionFromOffset(key2.range[1], key2.range[1]);
              this.ranges.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: "property" });
              this.keys.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: key2.value });
              if (item.value instanceof YAMLSeq) {
                this.processMap(item.value.items[0]);
              } else {
                this.processMap(item.value);
              }
              return;
            }
          }
          const pair = item, key = pair.key, value = pair.value;
          if (key.range != null && value.range != null) {
            const s1 = this.positionFromOffset(key.range[0], key.range[0]), e1 = this.positionFromOffset(key.range[1], key.range[1]), s2 = this.positionFromOffset(value.range[0], value.range[0]), e2 = this.positionFromOffset(value.range[1], value.range[1]);
            let vValue = "string";
            if (parseInt(value.value) == value.value) {
              vValue = "number";
            }
            this.ranges.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: "property" });
            this.keys.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: key.value });
            this.ranges.push({ start: s2, end: e2, length: e2.char - s2.char + 1, content: vValue });
            this.values.push({ start: s2, end: e2, length: e2.char - s2.char + 1, content: value.value });
          }
        }
      }
      positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
          if (this.documentOffsets.size == 0) {
            lineToUse = 1;
            charToUse = offset + 1;
          } else {
            let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
            for (const documentOffset of this.documentOffsets.keys()) {
              if (documentOffset >= offset) {
                if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                  nearestOffset = lastOffset;
                  nearestOffsetIndex = lastOffsetIndex;
                } else {
                  nearestOffset = this.documentOffsets.get(documentOffset);
                  nearestOffsetIndex = documentOffset;
                }
                break;
              }
              lastOffset = this.documentOffsets.get(documentOffset);
              lastOffsetIndex = documentOffset;
            }
            if (nearestOffset == null) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            }
            if (nearestOffset != null) {
              if (isRelativeOffset) {
                const t_Chars = this.content.split("");
                const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
                const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              } else {
                const t_Chars = this.content.split("");
                const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
                const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
                charToUse = tChar;
                lineToUse = nearestOffset.line;
                if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
                  lineToUse = nearestOffset.line;
                  charToUse = offset + 1;
                } else {
                  lineToUse = nearestOffset.line + 1;
                }
              }
            } else {
              if (this.lastDocumentOffsetKey != null) {
                const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
                lineToUse = lastOffset2.line + 1;
                charToUse = offset + this.lastDocumentOffsetKey;
              }
            }
          }
        } else {
          const offsetDetails = this.documentOffsets.get(offset);
          lineToUse = offsetDetails.line;
          charToUse = offsetDetails.char;
        }
        const position = new Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse;
        position.char = charToUse;
        return position;
      }
      getRanges() {
        return this.ranges;
      }
      getKeys() {
        return this.keys;
      }
      getValues() {
        return this.values;
      }
    };
  }
});

// server/src/runtime/document/antlersDocument.ts
var AntlersDocument;
var init_antlersDocument = __esm({
  "server/src/runtime/document/antlersDocument.ts"() {
    "use strict";
    init_engine();
    init_tagManagerInstance();
    init_tags();
    init_parser();
    init_abstractNode();
    init_documentParser();
    init_contextResolver();
    init_documentCursor();
    init_documentErrors();
    init_frontMatterParser();
    init_nodeScanner();
    init_rangeScanner();
    init_transformer();
    init_yamlDocument();
    AntlersDocument = class {
      constructor() {
        this.documentParser = new DocumentParser();
        this.transformer = null;
        this.originalText = "";
        this.ranges = new RangeScanner(this);
        this.nodes = new NodeScanner(this);
        this.cursor = new DocumentCursor(this);
        this.errors = new DocumentErrors(this);
        this.project = null;
        this.documentUri = "";
      }
      static fromText(text, project) {
        const document = new AntlersDocument();
        if (typeof project != "undefined") {
          document.project = project;
        }
        return document.loadString(text);
      }
      static childFromText(text, seedPosition = null) {
        const document = new AntlersDocument();
        if (seedPosition != null) {
          document.getDocumentParser().setSeedPosition(seedPosition);
        }
        document.getDocumentParser().withChildDocuments(true);
        document.loadString(text);
        return {
          renderNodes: document.getDocumentParser().getRenderNodes(),
          content: text,
          document
        };
      }
      isValid() {
        if (this.hasInvalidControlFlowStructures() || this.hasUnclosedStructures()) {
          return false;
        }
        return true;
      }
      getDocumentOptions() {
        const nodes = this.getAllNodes();
        if (nodes.length == 0 || nodes[0] instanceof AntlersNode == false) {
          return null;
        }
        const checkNode = nodes[0];
        if (checkNode.isComment == false) {
          return null;
        }
        return parseIdeHelper(this.documentUri, checkNode);
      }
      isFormattingEnabled() {
        const options = this.getDocumentOptions();
        if (options == null) {
          return true;
        }
        return options.formatterEnabled;
      }
      hasInvalidControlFlowStructures() {
        return this.documentParser.hasUnclosedIfStructures();
      }
      hasUnclosedStructures() {
        return this.documentParser.hasUnclosedStructures();
      }
      getFrontMatterDoc() {
        if (this.hasFrontMatter()) {
          const yamlDoc = new YamlDocument();
          yamlDoc.loadString(this.getFrontMatter());
          return yamlDoc;
        }
        return null;
      }
      hasFrontMatter() {
        return this.documentParser.getFrontMatter().trim().length > 0;
      }
      getFrontMatter() {
        return this.documentParser.getFrontMatter();
      }
      getFrontMatterScope() {
        if (this.project == null) {
          return null;
        }
        const frontMatterParser = new FrontMatterParser(this.project);
        frontMatterParser.parse(this.getFrontMatter());
        return frontMatterParser.getScope();
      }
      updateProject(project) {
        this.project = project;
        this.updateProjectDetails();
      }
      updateProjectDetails() {
        try {
          if (this.project != null) {
            const scopeEngine = new ScopeEngine(this.project, this.documentUri, this), analysisNodes = this.documentParser.antlersNodes();
            analysisNodes.forEach((node) => {
              var _a, _b;
              if (this.project != null && ((_a = tagManagerInstance_default.instance) == null ? void 0 : _a.canResolveSpecialTypes(node.getTagName()))) {
                const specialResults = (_b = tagManagerInstance_default.instance) == null ? void 0 : _b.resolveSpecialType(
                  node.getTagName(),
                  node,
                  this.project
                );
                if (specialResults.context != null) {
                  node.reference = specialResults.context;
                }
              }
            });
            scopeEngine.analyzeScope(analysisNodes);
            for (let i = 0; i < analysisNodes.length; i++) {
              const node = analysisNodes[i];
              if (node.hasParameters) {
                for (let j = 0; j < node.parameters.length; j++) {
                  const thisParam = node.parameters[j];
                  if (thisParam.hasInterpolations()) {
                    for (let l = 0; l < thisParam.interpolations.length; l++) {
                      const thisInterpolation = thisParam.interpolations[l];
                      if (node.processedInterpolationRegions.has(thisInterpolation)) {
                        const tInterpolation = node.processedInterpolationRegions.get(
                          thisInterpolation
                        );
                        tInterpolation.forEach((interpolationNode) => {
                          if (interpolationNode instanceof AntlersNode) {
                            interpolationNode.currentScope = node.currentScope;
                          }
                        });
                      }
                    }
                  }
                }
              }
            }
            resolveTypedTree(this);
          }
        } catch (err) {
          console.log(err);
        }
      }
      loadString(text) {
        this.originalText = text;
        this.documentParser.parse(text);
        this.updateProjectDetails();
        return this;
      }
      getDocumentParser() {
        return this.documentParser;
      }
      getParsedContent() {
        return this.documentParser.getParsedContent();
      }
      getAllNodes() {
        return this.documentParser.getNodes();
      }
      getAllAntlersNodes() {
        return this.documentParser.antlersNodes();
      }
      extractText() {
        const parts = [];
        this.nodes.getAllLiteralNodes().forEach((node) => {
          parts.push(node.content);
        });
        return parts.join("");
      }
      getNameAt(position) {
        const node = this.nodes.getNodeAt(position);
        if (node instanceof AntlersNode) {
          return node.name;
        }
        return null;
      }
      getLinesAround(line) {
        return this.documentParser.getLinesAround(line);
      }
      getContent() {
        return this.documentParser.getContent();
      }
      getOriginalContent() {
        return this.documentParser.getOriginalContent();
      }
      reloadDocument() {
        this.loadString(this.originalText);
      }
      getFeaturesAt(position) {
        const node = this.nodes.getNodeAt(position);
        return ContextResolver.resolveContext(position, node, this, false, node);
      }
      getText(start, end) {
        return this.documentParser.getText(start, end);
      }
      charLeftAt(position) {
        return this.documentParser.charLeftAt(position);
      }
      charAt(position) {
        return this.documentParser.charAt(position);
      }
      charRightAt(position) {
        return this.documentParser.charRightAt(position);
      }
      getLineIndex(lineNumber) {
        return this.documentParser.getLineIndex(lineNumber);
      }
      getLineText(lineNumber) {
        return this.documentParser.getLineText(lineNumber);
      }
      wordAt(position, tabSize = 4) {
        return this.documentParser.wordAt(position, tabSize);
      }
      wordLeftAt(position, tabSize = 4) {
        return this.documentParser.wordLeftAt(position, tabSize);
      }
      wordRightAt(position, tabSize = 4) {
        return this.documentParser.wordRightAt(position, tabSize);
      }
      punctuationLeftAt(position, tabSize = 4) {
        return this.documentParser.punctuationLeftAt(position, tabSize);
      }
      punctuationRightAt(position, tabSize = 4) {
        return this.documentParser.punctuationRightAt(position, tabSize);
      }
      getLineChars(lineNumber) {
        const lineText = this.getLineText(lineNumber);
        if (lineText != null) {
          return lineText.split("");
        }
        return null;
      }
      transform() {
        if (this.transformer == null) {
          this.transformer = new Transformer(this);
        }
        return this.transformer;
      }
    };
  }
});

// server/src/diagnostics/handlers/interleavedNodes.ts
var InterleavedNodeHandler, interleavedNodes_default;
var init_interleavedNodes = __esm({
  "server/src/diagnostics/handlers/interleavedNodes.ts"() {
    "use strict";
    init_antlersError();
    init_antlersErrorCodes();
    init_abstractNode();
    InterleavedNodeHandler = {
      checkNode(node) {
        var _a;
        const errors = [];
        if (node.isClosedBy == null) {
          return errors;
        }
        if (node.parent == null) {
          return errors;
        }
        if (node.parent instanceof AntlersNode == false) {
          return errors;
        }
        const nodeParent = node.parent;
        if (nodeParent.isClosedBy == null) {
          return errors;
        }
        const runtimeName = node.runtimeName();
        if (runtimeName == "if" || runtimeName == "if:index" || runtimeName == "else" || runtimeName == "else:index" || runtimeName == "elseif" || runtimeName == "elseif:index" || runtimeName == "elseunless" || runtimeName == "elseunless:index") {
          return errors;
        }
        if ((_a = nodeParent.isClosedBy.startPosition) == null ? void 0 : _a.isBefore(node.isClosedBy.endPosition)) {
          errors.push(AntlersError.makeSyntaxError(
            AntlersErrorCodes.LINT_INTERLEAVED_TAG_PAIRS,
            node,
            "Closing tag cannot appear after parent closing tag."
          ));
          errors.push(AntlersError.makeSyntaxError(
            AntlersErrorCodes.LINT_INTERLEAVED_TAG_PAIRS,
            node.isClosedBy,
            "Closing tag cannot appear after parent closing tag."
          ));
        }
        return errors;
      }
    };
    interleavedNodes_default = InterleavedNodeHandler;
  }
});

// server/src/formatting/documentFormatter.ts
var DocumentFormatter;
var init_documentFormatter = __esm({
  "server/src/formatting/documentFormatter.ts"() {
    "use strict";
    init_interleavedNodes();
    init_antlersDocument();
    DocumentFormatter = class {
      constructor() {
        this.htmlFormatter = null;
        this.yamlFormatter = null;
        this.phpFormatter = null;
        this.preFormatter = null;
        this.transformOptions = null;
        this.createExtraVirtualStructures = false;
      }
      withTransformOptions(options) {
        this.transformOptions = options;
        return this;
      }
      withPreFormatter(preFormatter) {
        this.preFormatter = preFormatter;
        return this;
      }
      withHtmlFormatter(formatter) {
        this.htmlFormatter = formatter;
        return this;
      }
      withYamlFormatter(formatter) {
        this.yamlFormatter = formatter;
        return this;
      }
      withPhpFormatter(formatter) {
        this.phpFormatter = formatter;
        return this;
      }
      formatText(text, settings) {
        const document = new AntlersDocument();
        document.getDocumentParser().withChildDocuments(true);
        document.loadString(text);
        return this.formatDocument(document, settings);
      }
      formatDocument(document, currentSettings) {
        if (!document.isFormattingEnabled()) {
          return document.getOriginalContent();
        }
        if (this.preFormatter != null) {
          const preformatResult = this.preFormatter(document);
          if (preformatResult != null) {
            return preformatResult;
          }
        }
        const antlersNodes = document.getAllAntlersNodes();
        for (let i = 0; i < antlersNodes.length; i++) {
          if (interleavedNodes_default.checkNode(antlersNodes[i], currentSettings).length > 0) {
            return document.getOriginalContent();
          }
        }
        if (this.htmlFormatter == null || document.isValid() == false) {
          return document.getOriginalContent();
        }
        document.transform().withInlineFormatter((content) => this.formatText(content, currentSettings)).produceExtraStructuralPairs(this.createExtraVirtualStructures).withHtmlFormatter(this.htmlFormatter).withPhpFormatter(this.phpFormatter).withYamlFormatter(this.yamlFormatter);
        if (this.transformOptions != null) {
          document.transform().withOptions(this.transformOptions);
        }
        const structure = document.transform().toStructure(), formatted = this.htmlFormatter(structure);
        return document.transform().fromStructure(formatted);
      }
    };
  }
});

// server/node_modules/@prettier/plugin-php/standalone.js
var require_standalone = __commonJS({
  "server/node_modules/@prettier/plugin-php/standalone.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? e(exports, require("prettier/standalone")) : "function" == typeof define && define.amd ? define(["exports", "prettier/standalone"], e) : e(((t = "undefined" != typeof globalThis ? globalThis : t || self).prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.php = {}), t.prettier);
    }(exports, function(t, e) {
      "use strict";
      function i(t2) {
        return t2 && "object" == typeof t2 && "default" in t2 ? t2 : { default: t2 };
      }
      var n = i(e), s = { matchST_ATTRIBUTE: function() {
        var t2 = 0, e2 = this.input();
        if (this.is_WHITESPACE()) {
          do {
            e2 = this.input();
          } while (this.is_WHITESPACE());
          return this.unput(1), null;
        }
        switch (e2) {
          case "]":
            return 0 === t2 ? this.popState() : t2--, "]";
          case "(":
          case ")":
          case ":":
          case "=":
            return this.consume_TOKEN();
          case "[":
            return t2++, "[";
          case ",":
            return ",";
          case '"':
            return this.ST_DOUBLE_QUOTES();
          case "'":
            return this.T_CONSTANT_ENCAPSED_STRING();
          case "/":
            if ("/" === this._input[this.offset])
              return this.T_COMMENT();
            if ("*" === this._input[this.offset])
              return this.input(), this.T_DOC_COMMENT();
        }
        if (this.is_LABEL_START() || "\\" === e2) {
          for (; this.offset < this.size; ) {
            var i2 = this.input();
            if (!this.is_LABEL() && "\\" !== i2) {
              i2 && this.unput(1);
              break;
            }
          }
          return this.tok.T_STRING;
        }
        if (this.is_NUM())
          return this.consume_NUM();
        throw new Error('Bad terminal sequence "'.concat(e2, '" at line ').concat(this.yylineno, " (offset ").concat(this.offset, ")"));
      } };
      s.matchST_ATTRIBUTE;
      var r = { T_COMMENT: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if ("\n" === t2 || "\r" === t2)
            return this.tok.T_COMMENT;
          if ("?" === t2 && !this.aspTagMode && ">" === this._input[this.offset])
            return this.unput(1), this.tok.T_COMMENT;
          if ("%" === t2 && this.aspTagMode && ">" === this._input[this.offset])
            return this.unput(1), this.tok.T_COMMENT;
        }
        return this.tok.T_COMMENT;
      }, T_DOC_COMMENT: function() {
        var t2 = this.input(), e2 = this.tok.T_COMMENT;
        if ("*" === t2) {
          if (t2 = this.input(), this.is_WHITESPACE() && (e2 = this.tok.T_DOC_COMMENT), "/" === t2)
            return e2;
          this.unput(1);
        }
        for (; this.offset < this.size; )
          if ("*" === (t2 = this.input()) && "/" === this._input[this.offset]) {
            this.input();
            break;
          }
        return e2;
      } };
      r.T_COMMENT, r.T_DOC_COMMENT;
      var o = { nextINITIAL: function() {
        return this.conditionStack.length > 1 && "INITIAL" === this.conditionStack[this.conditionStack.length - 1] ? this.popState() : this.begin("ST_IN_SCRIPTING"), this;
      }, matchINITIAL: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if ("<" == t2) {
            if ("?" == (t2 = this.ahead(1))) {
              if (this.tryMatch("?=")) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
                break;
              }
              if (this.tryMatchCaseless("?php") && (" " === (t2 = this._input[this.offset + 4]) || "	" === t2 || "\n" === t2 || "\r" === t2)) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();
                break;
              }
              if (this.short_tags) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
                break;
              }
            } else if (this.asp_tags && "%" == t2) {
              if (this.tryMatch("%=")) {
                this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
                break;
              }
              this.aspTagMode = true, this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
              break;
            }
          }
        }
        return this.yytext.length > 0 && this.tok.T_INLINE_HTML;
      } };
      o.nextINITIAL, o.matchINITIAL;
      var a = { consume_NUM: function() {
        var t2 = this.yytext[0], e2 = "." === t2;
        if ("0" === t2)
          if ("x" === (t2 = this.input()) || "X" === t2) {
            if ("_" !== (t2 = this.input()) && this.is_HEX())
              return this.consume_HNUM();
            this.unput(t2 ? 2 : 1);
          } else if ("b" === t2 || "B" === t2) {
            if ("_" !== (t2 = this.input()) && "0" === t2 || "1" === t2)
              return this.consume_BNUM();
            this.unput(t2 ? 2 : 1);
          } else
            this.is_NUM() || t2 && this.unput(1);
        for (; this.offset < this.size; ) {
          var i2 = t2;
          if ("_" === (t2 = this.input())) {
            if ("_" === i2) {
              this.unput(2);
              break;
            }
            if ("." === i2) {
              this.unput(1);
              break;
            }
            if ("e" === i2 || "E" === i2) {
              this.unput(2);
              break;
            }
          } else {
            if ("." === t2) {
              if (e2) {
                this.unput(1);
                break;
              }
              if ("_" === i2) {
                this.unput(2);
                break;
              }
              e2 = true;
              continue;
            }
            if ("e" === t2 || "E" === t2) {
              if ("_" === i2) {
                this.unput(1);
                break;
              }
              var n2 = 2;
              if ("+" !== (t2 = this.input()) && "-" !== t2 || (n2 = 3, t2 = this.input()), this.is_NUM_START())
                return this.consume_LNUM(), this.tok.T_DNUMBER;
              this.unput(t2 ? n2 : n2 - 1);
              break;
            }
          }
          if (!this.is_NUM()) {
            t2 && this.unput(1);
            break;
          }
        }
        return e2 ? this.tok.T_DNUMBER : this.yytext.length < 9 || this.yytext.length < 10 || 10 == this.yytext.length && this.yytext < "2147483648" ? this.tok.T_LNUMBER : this.tok.T_DNUMBER;
      }, consume_HNUM: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if (!this.is_HEX()) {
            t2 && this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      }, consume_LNUM: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if (!this.is_NUM()) {
            t2 && this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      }, consume_BNUM: function() {
        for (var t2; this.offset < this.size; )
          if ("0" !== (t2 = this.input()) && "1" !== t2 && "_" !== t2) {
            t2 && this.unput(1);
            break;
          }
        return this.tok.T_LNUMBER;
      } };
      a.consume_NUM, a.consume_HNUM, a.consume_LNUM, a.consume_BNUM;
      var h = { matchST_LOOKING_FOR_PROPERTY: function() {
        var t2 = this.input();
        if ("-" === t2) {
          if (">" === (t2 = this.input()))
            return this.tok.T_OBJECT_OPERATOR;
          t2 && this.unput(1);
        } else {
          if (this.is_WHITESPACE())
            return this.tok.T_WHITESPACE;
          if (this.is_LABEL_START())
            return this.consume_LABEL(), this.popState(), this.tok.T_STRING;
        }
        return this.popState(), t2 && this.unput(1), false;
      }, matchST_LOOKING_FOR_VARNAME: function() {
        var t2 = this.input();
        if (this.popState(), this.begin("ST_IN_SCRIPTING"), this.is_LABEL_START()) {
          if (this.consume_LABEL(), "[" === (t2 = this.input()) || "}" === t2)
            return this.unput(1), this.tok.T_STRING_VARNAME;
          this.unput(this.yytext.length);
        } else
          t2 && this.unput(1);
        return false;
      }, matchST_VAR_OFFSET: function() {
        var t2 = this.input();
        if (this.is_NUM_START())
          return this.consume_NUM(), this.tok.T_NUM_STRING;
        if ("]" === t2)
          return this.popState(), "]";
        if ("$" === t2) {
          if (this.input(), this.is_LABEL_START())
            return this.consume_LABEL(), this.tok.T_VARIABLE;
          throw new Error("Unexpected terminal");
        }
        if (this.is_LABEL_START())
          return this.consume_LABEL(), this.tok.T_STRING;
        if (this.is_WHITESPACE() || "\\" === t2 || "'" === t2 || "#" === t2)
          return this.tok.T_ENCAPSED_AND_WHITESPACE;
        if ("[" === t2 || "{" === t2 || "}" === t2 || '"' === t2 || "`" === t2 || this.is_TOKEN())
          return t2;
        throw new Error("Unexpected terminal");
      } };
      h.matchST_LOOKING_FOR_PROPERTY, h.matchST_LOOKING_FOR_VARNAME, h.matchST_VAR_OFFSET;
      var l = { matchST_IN_SCRIPTING: function() {
        var t2 = this.input();
        switch (t2) {
          case " ":
          case "	":
          case "\n":
          case "\r":
          case "\r\n":
            return this.T_WHITESPACE();
          case "#":
            return "[" === this._input[this.offset] ? (this.input(), this.begin("ST_ATTRIBUTE"), this.tok.T_ATTRIBUTE) : this.T_COMMENT();
          case "/":
            return "/" === this._input[this.offset] ? this.T_COMMENT() : "*" === this._input[this.offset] ? (this.input(), this.T_DOC_COMMENT()) : this.consume_TOKEN();
          case "'":
            return this.T_CONSTANT_ENCAPSED_STRING();
          case '"':
            return this.ST_DOUBLE_QUOTES();
          case "`":
            return this.begin("ST_BACKQUOTE"), "`";
          case "?":
            if (!this.aspTagMode && this.tryMatch(">")) {
              this.input();
              var e2 = this._input[this.offset];
              return "\n" !== e2 && "\r" !== e2 || this.input(), this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG;
            }
            return this.consume_TOKEN();
          case "%":
            return this.aspTagMode && ">" === this._input[this.offset] ? (this.input(), "\n" !== (t2 = this._input[this.offset]) && "\r" !== t2 || this.input(), this.aspTagMode = false, this.conditionStack.length > 1 && this.begin("INITIAL"), this.tok.T_CLOSE_TAG) : this.consume_TOKEN();
          case "{":
            return this.begin("ST_IN_SCRIPTING"), "{";
          case "}":
            return this.conditionStack.length > 2 && this.popState(), "}";
          default:
            if ("." === t2) {
              if (t2 = this.input(), this.is_NUM_START())
                return this.consume_NUM();
              t2 && this.unput(1);
            }
            if (this.is_NUM_START())
              return this.consume_NUM();
            if (this.is_LABEL_START())
              return this.consume_LABEL().T_STRING();
            if (this.is_TOKEN())
              return this.consume_TOKEN();
        }
        throw new Error('Bad terminal sequence "' + t2 + '" at line ' + this.yylineno + " (offset " + this.offset + ")");
      }, T_WHITESPACE: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if (" " !== t2 && "	" !== t2 && "\n" !== t2 && "\r" !== t2) {
            t2 && this.unput(1);
            break;
          }
        }
        return this.tok.T_WHITESPACE;
      } };
      l.matchST_IN_SCRIPTING, l.T_WHITESPACE;
      var c = ["\n", "\r"], u = ["\n", "\r", ";"], _ = u.concat(["	", " ", ",", "]", ")", "/", "=", "!"]), d = { T_CONSTANT_ENCAPSED_STRING: function() {
        for (var t2; this.offset < this.size; )
          if ("\\" == (t2 = this.input()))
            this.input();
          else if ("'" == t2)
            break;
        return this.tok.T_CONSTANT_ENCAPSED_STRING;
      }, is_HEREDOC: function() {
        var t2 = this.offset;
        if ("<" === this._input[this.offset - 1] && "<" === this._input[this.offset] && "<" === this._input[this.offset + 1]) {
          if (this.offset += 3, this.is_TABSPACE())
            for (; this.offset < this.size && (this.offset++, this.is_TABSPACE()); )
              ;
          var e2 = this._input[this.offset - 1];
          if ("'" === e2 || '"' === e2 ? this.offset++ : e2 = null, this.is_LABEL_START()) {
            for (var i2 = this.offset - 1; this.offset < this.size && (this.offset++, this.is_LABEL()); )
              ;
            var n2 = this._input.substring(i2, this.offset - 1);
            if ((!e2 || e2 === this._input[this.offset - 1]) && (e2 && this.offset++, c.includes(this._input[this.offset - 1])))
              return this.heredoc_label.label = n2, this.heredoc_label.length = n2.length, this.heredoc_label.finished = false, i2 = this.offset - t2, this.offset = t2, this.consume(i2), "'" === e2 ? this.begin("ST_NOWDOC") : this.begin("ST_HEREDOC"), this.prematch_ENDOFDOC(), this.tok.T_START_HEREDOC;
          }
        }
        return this.offset = t2, false;
      }, ST_DOUBLE_QUOTES: function() {
        for (var t2; this.offset < this.size; )
          if ("\\" == (t2 = this.input()))
            this.input();
          else {
            if ('"' == t2)
              break;
            if ("$" == t2) {
              if ("{" == (t2 = this.input()) || this.is_LABEL_START()) {
                this.unput(2);
                break;
              }
              t2 && this.unput(1);
            } else if ("{" == t2) {
              if ("$" == (t2 = this.input())) {
                this.unput(2);
                break;
              }
              t2 && this.unput(1);
            }
          }
        if ('"' == t2)
          return this.tok.T_CONSTANT_ENCAPSED_STRING;
        var e2 = 1;
        return "b" !== this.yytext[0] && "B" !== this.yytext[0] || (e2 = 2), this.yytext.length > 2 && this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - e2), this.unput(this.yytext.length - e2), this.begin("ST_DOUBLE_QUOTES"), this.yytext;
      }, isDOC_MATCH: function(t2, e2) {
        var i2 = this._input[t2 - 2];
        if (!c.includes(i2))
          return false;
        var n2 = false, s2 = false, r2 = 0, o2 = this._input[t2 - 1];
        if (this.version >= 703) {
          for (; "	" === o2 || " " === o2; )
            " " === o2 ? n2 = true : "	" === o2 && (s2 = true), o2 = this._input[t2 + r2], r2++;
          if (t2 += r2, c.includes(this._input[t2 - 1]))
            return false;
        }
        if (this._input.substring(t2 - 1, t2 - 1 + this.heredoc_label.length) === this.heredoc_label.label) {
          var a2 = this._input[t2 - 1 + this.heredoc_label.length];
          if ((this.version >= 703 ? _ : u).includes(a2)) {
            if (e2) {
              if (this.consume(r2), n2 && s2)
                throw new Error("Parse error:  mixing spaces and tabs in ending marker at line " + this.yylineno + " (offset " + this.offset + ")");
            } else
              this.heredoc_label.indentation = r2, this.heredoc_label.indentation_uses_spaces = n2, this.heredoc_label.first_encaps_node = true;
            return true;
          }
        }
        return false;
      }, prematch_ENDOFDOC: function() {
        this.heredoc_label.indentation_uses_spaces = false, this.heredoc_label.indentation = 0, this.heredoc_label.first_encaps_node = true;
        for (var t2 = this.offset + 1; t2 < this._input.length; ) {
          if (this.isDOC_MATCH(t2, false))
            return;
          if (!c.includes(this._input[t2 - 1]))
            for (; !c.includes(this._input[t2++]) && t2 < this._input.length; )
              ;
          t2++;
        }
      }, matchST_NOWDOC: function() {
        if (this.isDOC_MATCH(this.offset, true))
          return this.consume(this.heredoc_label.length), this.popState(), this.tok.T_END_HEREDOC;
        for (var t2 = this._input[this.offset - 1]; this.offset < this.size; )
          if (c.includes(t2)) {
            if (t2 = this.input(), this.isDOC_MATCH(this.offset, true))
              return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
          } else
            t2 = this.input();
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }, matchST_HEREDOC: function() {
        var t2 = this.input();
        if (this.isDOC_MATCH(this.offset, true))
          return this.consume(this.heredoc_label.length - 1), this.popState(), this.tok.T_END_HEREDOC;
        for (; this.offset < this.size; )
          if ("\\" === t2 && (t2 = this.input(), c.includes(t2) || (t2 = this.input())), c.includes(t2)) {
            if (t2 = this.input(), this.isDOC_MATCH(this.offset, true))
              return this.unput(1).popState(), this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length), this.tok.T_ENCAPSED_AND_WHITESPACE;
          } else if ("$" === t2) {
            if ("{" === (t2 = this.input()))
              return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
            if (this.is_LABEL_START()) {
              var e2 = this.offset, i2 = this.consume_VARIABLE();
              return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i2, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i2;
            }
          } else if ("{" === t2) {
            if ("$" === (t2 = this.input()))
              return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
          } else
            t2 = this.input();
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }, consume_VARIABLE: function() {
        this.consume_LABEL();
        var t2 = this.input();
        if ("[" == t2)
          return this.unput(1), this.begin("ST_VAR_OFFSET"), this.tok.T_VARIABLE;
        if ("-" === t2) {
          if (">" === this.input())
            return this.input(), this.is_LABEL_START() && this.begin("ST_LOOKING_FOR_PROPERTY"), this.unput(3), this.tok.T_VARIABLE;
          this.unput(2);
        } else
          t2 && this.unput(1);
        return this.tok.T_VARIABLE;
      }, matchST_BACKQUOTE: function() {
        var t2 = this.input();
        if ("$" === t2) {
          if ("{" === (t2 = this.input()))
            return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          if (this.is_LABEL_START())
            return this.consume_VARIABLE();
        } else if ("{" === t2) {
          if ("$" === this._input[this.offset])
            return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
        } else if ("`" === t2)
          return this.popState(), "`";
        for (; this.offset < this.size; ) {
          if ("\\" === t2)
            this.input();
          else {
            if ("`" === t2) {
              this.unput(1), this.popState(), this.appendToken("`", 1);
              break;
            }
            if ("$" === t2) {
              if ("{" === (t2 = this.input()))
                return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              if (this.is_LABEL_START()) {
                var e2 = this.offset, i2 = this.consume_VARIABLE();
                return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i2, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i2;
              }
              continue;
            }
            if ("{" === t2) {
              if ("$" === (t2 = this.input()))
                return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
              continue;
            }
          }
          t2 = this.input();
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }, matchST_DOUBLE_QUOTES: function() {
        var t2 = this.input();
        if ("$" === t2) {
          if ("{" === (t2 = this.input()))
            return this.begin("ST_LOOKING_FOR_VARNAME"), this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          if (this.is_LABEL_START())
            return this.consume_VARIABLE();
        } else if ("{" === t2) {
          if ("$" === this._input[this.offset])
            return this.begin("ST_IN_SCRIPTING"), this.tok.T_CURLY_OPEN;
        } else if ('"' === t2)
          return this.popState(), '"';
        for (; this.offset < this.size; ) {
          if ("\\" === t2)
            this.input();
          else {
            if ('"' === t2) {
              this.unput(1), this.popState(), this.appendToken('"', 1);
              break;
            }
            if ("$" === t2) {
              if ("{" === (t2 = this.input()))
                return this.begin("ST_LOOKING_FOR_VARNAME"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              if (this.is_LABEL_START()) {
                var e2 = this.offset, i2 = this.consume_VARIABLE();
                return this.yytext.length > this.offset - e2 + 2 ? (this.appendToken(i2, this.offset - e2 + 2), this.unput(this.offset - e2 + 2), this.tok.T_ENCAPSED_AND_WHITESPACE) : i2;
              }
              t2 && this.unput(1);
            } else if ("{" === t2) {
              if ("$" === (t2 = this.input()))
                return this.begin("ST_IN_SCRIPTING"), this.yytext.length > 2 ? (this.appendToken(this.tok.T_CURLY_OPEN, 1), this.unput(2), this.tok.T_ENCAPSED_AND_WHITESPACE) : (this.unput(1), this.tok.T_CURLY_OPEN);
              t2 && this.unput(1);
            }
          }
          t2 = this.input();
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      } };
      d.T_CONSTANT_ENCAPSED_STRING, d.is_HEREDOC, d.ST_DOUBLE_QUOTES, d.isDOC_MATCH, d.prematch_ENDOFDOC, d.matchST_NOWDOC, d.matchST_HEREDOC, d.consume_VARIABLE, d.matchST_BACKQUOTE, d.matchST_DOUBLE_QUOTES;
      var p = { T_STRING: function() {
        var t2 = this.yytext.toLowerCase(), e2 = this.keywords[t2];
        if ("number" != typeof e2) {
          if ("yield" === t2)
            this.version >= 700 && this.tryMatch(" from") ? (this.consume(5), e2 = this.tok.T_YIELD_FROM) : e2 = this.tok.T_YIELD;
          else if (e2 = this.tok.T_STRING, "b" === t2 || "B" === t2) {
            var i2 = this.input(1);
            if ('"' === i2)
              return this.ST_DOUBLE_QUOTES();
            if ("'" === i2)
              return this.T_CONSTANT_ENCAPSED_STRING();
            i2 && this.unput(1);
          }
        }
        return e2;
      }, consume_TOKEN: function() {
        var t2 = this._input[this.offset - 1], e2 = this.tokenTerminals[t2];
        return e2 ? e2.apply(this, []) : this.yytext;
      }, tokenTerminals: { $: function() {
        return this.offset++, this.is_LABEL_START() ? (this.offset--, this.consume_LABEL(), this.tok.T_VARIABLE) : (this.offset--, "$");
      }, "-": function() {
        var t2 = this._input[this.offset];
        return ">" === t2 ? (this.begin("ST_LOOKING_FOR_PROPERTY").input(), this.tok.T_OBJECT_OPERATOR) : "-" === t2 ? (this.input(), this.tok.T_DEC) : "=" === t2 ? (this.input(), this.tok.T_MINUS_EQUAL) : "-";
      }, "\\": function() {
        return this.tok.T_NS_SEPARATOR;
      }, "/": function() {
        return "=" === this._input[this.offset] ? (this.input(), this.tok.T_DIV_EQUAL) : "/";
      }, ":": function() {
        return ":" === this._input[this.offset] ? (this.input(), this.tok.T_DOUBLE_COLON) : ":";
      }, "(": function() {
        var t2 = this.offset;
        if (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), this.is_LABEL_START()) {
          var e2 = this.yytext.length;
          this.consume_LABEL();
          var i2 = this.yytext.substring(e2 - 1).toLowerCase(), n2 = this.castKeywords[i2];
          if ("number" == typeof n2 && (this.input(), this.is_TABSPACE() && this.consume_TABSPACE().input(), ")" === this._input[this.offset - 1]))
            return n2;
        }
        return this.unput(this.offset - t2), "(";
      }, "=": function() {
        var t2 = this._input[this.offset];
        return ">" === t2 ? (this.input(), this.tok.T_DOUBLE_ARROW) : "=" === t2 ? "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_IS_IDENTICAL) : (this.input(), this.tok.T_IS_EQUAL) : "=";
      }, "+": function() {
        var t2 = this._input[this.offset];
        return "+" === t2 ? (this.input(), this.tok.T_INC) : "=" === t2 ? (this.input(), this.tok.T_PLUS_EQUAL) : "+";
      }, "!": function() {
        return "=" === this._input[this.offset] ? "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_IS_NOT_IDENTICAL) : (this.input(), this.tok.T_IS_NOT_EQUAL) : "!";
      }, "?": function() {
        return this.version >= 700 && "?" === this._input[this.offset] ? this.version >= 704 && "=" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_COALESCE_EQUAL) : (this.input(), this.tok.T_COALESCE) : this.version >= 800 && "-" === this._input[this.offset] && ">" === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_NULLSAFE_OBJECT_OPERATOR) : "?";
      }, "<": function() {
        var t2 = this._input[this.offset];
        return "<" === t2 ? "=" === (t2 = this._input[this.offset + 1]) ? (this.consume(2), this.tok.T_SL_EQUAL) : "<" === t2 && this.is_HEREDOC() ? this.tok.T_START_HEREDOC : (this.input(), this.tok.T_SL) : "=" === t2 ? (this.input(), this.version >= 700 && ">" === this._input[this.offset] ? (this.input(), this.tok.T_SPACESHIP) : this.tok.T_IS_SMALLER_OR_EQUAL) : ">" === t2 ? (this.input(), this.tok.T_IS_NOT_EQUAL) : "<";
      }, ">": function() {
        var t2 = this._input[this.offset];
        return "=" === t2 ? (this.input(), this.tok.T_IS_GREATER_OR_EQUAL) : ">" === t2 ? "=" === (t2 = this._input[this.offset + 1]) ? (this.consume(2), this.tok.T_SR_EQUAL) : (this.input(), this.tok.T_SR) : ">";
      }, "*": function() {
        var t2 = this._input[this.offset];
        return "=" === t2 ? (this.input(), this.tok.T_MUL_EQUAL) : "*" === t2 ? (this.input(), "=" === this._input[this.offset] ? (this.input(), this.tok.T_POW_EQUAL) : this.tok.T_POW) : "*";
      }, ".": function() {
        var t2 = this._input[this.offset];
        return "=" === t2 ? (this.input(), this.tok.T_CONCAT_EQUAL) : "." === t2 && "." === this._input[this.offset + 1] ? (this.consume(2), this.tok.T_ELLIPSIS) : ".";
      }, "%": function() {
        return "=" === this._input[this.offset] ? (this.input(), this.tok.T_MOD_EQUAL) : "%";
      }, "&": function() {
        var t2 = this._input[this.offset];
        return "=" === t2 ? (this.input(), this.tok.T_AND_EQUAL) : "&" === t2 ? (this.input(), this.tok.T_BOOLEAN_AND) : "&";
      }, "|": function() {
        var t2 = this._input[this.offset];
        return "=" === t2 ? (this.input(), this.tok.T_OR_EQUAL) : "|" === t2 ? (this.input(), this.tok.T_BOOLEAN_OR) : "|";
      }, "^": function() {
        return "=" === this._input[this.offset] ? (this.input(), this.tok.T_XOR_EQUAL) : "^";
      } } };
      p.T_STRING, p.consume_TOKEN, p.tokenTerminals;
      var f = { is_NUM: function() {
        var t2 = this._input.charCodeAt(this.offset - 1);
        return t2 > 47 && t2 < 58 || 95 === t2;
      }, is_NUM_START: function() {
        var t2 = this._input.charCodeAt(this.offset - 1);
        return t2 > 47 && t2 < 58;
      }, is_LABEL: function() {
        var t2 = this._input.charCodeAt(this.offset - 1);
        return t2 > 96 && t2 < 123 || t2 > 64 && t2 < 91 || 95 === t2 || t2 > 47 && t2 < 58 || t2 > 126;
      }, is_LABEL_START: function() {
        var t2 = this._input.charCodeAt(this.offset - 1);
        return t2 > 64 && t2 < 91 || (t2 > 96 && t2 < 123 || (95 === t2 || t2 > 126));
      }, consume_LABEL: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if (!this.is_LABEL()) {
            t2 && this.unput(1);
            break;
          }
        }
        return this;
      }, is_TOKEN: function() {
        var t2 = this._input[this.offset - 1];
        return -1 !== ";:,.\\[]()|^&+-/*=%!~$<>?@".indexOf(t2);
      }, is_WHITESPACE: function() {
        var t2 = this._input[this.offset - 1];
        return " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2;
      }, is_TABSPACE: function() {
        var t2 = this._input[this.offset - 1];
        return " " === t2 || "	" === t2;
      }, consume_TABSPACE: function() {
        for (; this.offset < this.size; ) {
          var t2 = this.input();
          if (!this.is_TABSPACE()) {
            t2 && this.unput(1);
            break;
          }
        }
        return this;
      }, is_HEX: function() {
        var t2 = this._input.charCodeAt(this.offset - 1);
        return t2 > 47 && t2 < 58 || (t2 > 64 && t2 < 71 || (t2 > 96 && t2 < 103 || 95 === t2));
      } };
      f.is_NUM, f.is_NUM_START, f.is_LABEL, f.is_LABEL_START, f.consume_LABEL, f.is_TOKEN, f.is_WHITESPACE, f.is_TABSPACE, f.consume_TABSPACE, f.is_HEX;
      var T = function(t2) {
        this.engine = t2, this.tok = this.engine.tokens.names, this.EOF = 1, this.debug = false, this.all_tokens = true, this.comment_tokens = false, this.mode_eval = false, this.asp_tags = false, this.short_tags = false, this.version = 800, this.yyprevcol = 0, this.keywords = { __class__: this.tok.T_CLASS_C, __trait__: this.tok.T_TRAIT_C, __function__: this.tok.T_FUNC_C, __method__: this.tok.T_METHOD_C, __line__: this.tok.T_LINE, __file__: this.tok.T_FILE, __dir__: this.tok.T_DIR, __namespace__: this.tok.T_NS_C, exit: this.tok.T_EXIT, die: this.tok.T_EXIT, function: this.tok.T_FUNCTION, const: this.tok.T_CONST, return: this.tok.T_RETURN, try: this.tok.T_TRY, catch: this.tok.T_CATCH, finally: this.tok.T_FINALLY, throw: this.tok.T_THROW, if: this.tok.T_IF, elseif: this.tok.T_ELSEIF, endif: this.tok.T_ENDIF, else: this.tok.T_ELSE, while: this.tok.T_WHILE, endwhile: this.tok.T_ENDWHILE, do: this.tok.T_DO, for: this.tok.T_FOR, endfor: this.tok.T_ENDFOR, foreach: this.tok.T_FOREACH, endforeach: this.tok.T_ENDFOREACH, declare: this.tok.T_DECLARE, enddeclare: this.tok.T_ENDDECLARE, instanceof: this.tok.T_INSTANCEOF, as: this.tok.T_AS, switch: this.tok.T_SWITCH, endswitch: this.tok.T_ENDSWITCH, case: this.tok.T_CASE, default: this.tok.T_DEFAULT, break: this.tok.T_BREAK, continue: this.tok.T_CONTINUE, goto: this.tok.T_GOTO, echo: this.tok.T_ECHO, print: this.tok.T_PRINT, class: this.tok.T_CLASS, interface: this.tok.T_INTERFACE, trait: this.tok.T_TRAIT, extends: this.tok.T_EXTENDS, implements: this.tok.T_IMPLEMENTS, new: this.tok.T_NEW, clone: this.tok.T_CLONE, var: this.tok.T_VAR, eval: this.tok.T_EVAL, include: this.tok.T_INCLUDE, include_once: this.tok.T_INCLUDE_ONCE, require: this.tok.T_REQUIRE, require_once: this.tok.T_REQUIRE_ONCE, namespace: this.tok.T_NAMESPACE, use: this.tok.T_USE, insteadof: this.tok.T_INSTEADOF, global: this.tok.T_GLOBAL, isset: this.tok.T_ISSET, empty: this.tok.T_EMPTY, __halt_compiler: this.tok.T_HALT_COMPILER, static: this.tok.T_STATIC, abstract: this.tok.T_ABSTRACT, final: this.tok.T_FINAL, private: this.tok.T_PRIVATE, protected: this.tok.T_PROTECTED, public: this.tok.T_PUBLIC, unset: this.tok.T_UNSET, list: this.tok.T_LIST, array: this.tok.T_ARRAY, callable: this.tok.T_CALLABLE, or: this.tok.T_LOGICAL_OR, and: this.tok.T_LOGICAL_AND, xor: this.tok.T_LOGICAL_XOR, match: this.tok.T_MATCH }, this.castKeywords = { int: this.tok.T_INT_CAST, integer: this.tok.T_INT_CAST, real: this.tok.T_DOUBLE_CAST, double: this.tok.T_DOUBLE_CAST, float: this.tok.T_DOUBLE_CAST, string: this.tok.T_STRING_CAST, binary: this.tok.T_STRING_CAST, array: this.tok.T_ARRAY_CAST, object: this.tok.T_OBJECT_CAST, bool: this.tok.T_BOOL_CAST, boolean: this.tok.T_BOOL_CAST, unset: this.tok.T_UNSET_CAST };
      };
      T.prototype.setInput = function(t2) {
        return this._input = t2, this.size = t2.length, this.yylineno = 1, this.offset = 0, this.yyprevcol = 0, this.yytext = "", this.yylloc = { first_offset: 0, first_line: 1, first_column: 0, prev_offset: 0, prev_line: 1, prev_column: 0, last_line: 1, last_column: 0 }, this.tokens = [], this.version > 703 ? this.keywords.fn = this.tok.T_FN : delete this.keywords.fn, this.done = this.offset >= this.size, !this.all_tokens && this.mode_eval ? (this.conditionStack = ["INITIAL"], this.begin("ST_IN_SCRIPTING")) : (this.conditionStack = [], this.begin("INITIAL")), this.heredoc_label = { label: "", length: 0, indentation: 0, indentation_uses_spaces: false, finished: false, first_encaps_node: false, toString: function() {
          this.label;
        } }, this;
      }, T.prototype.input = function() {
        var t2 = this._input[this.offset];
        return t2 ? (this.yytext += t2, this.offset++, "\r" === t2 && "\n" === this._input[this.offset] && (this.yytext += "\n", this.offset++), "\n" === t2 || "\r" === t2 ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++, t2) : "";
      }, T.prototype.unput = function(t2) {
        if (1 === t2)
          this.offset--, "\n" === this._input[this.offset] && "\r" === this._input[this.offset - 1] && (this.offset--, t2++), "\r" === this._input[this.offset] || "\n" === this._input[this.offset] ? (this.yylloc.last_line--, this.yylineno--, this.yylloc.last_column = this.yyprevcol) : this.yylloc.last_column--, this.yytext = this.yytext.substring(0, this.yytext.length - t2);
        else if (t2 > 0)
          if (this.offset -= t2, t2 < this.yytext.length) {
            this.yytext = this.yytext.substring(0, this.yytext.length - t2), this.yylloc.last_line = this.yylloc.first_line, this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;
            for (var e2 = 0; e2 < this.yytext.length; e2++) {
              var i2 = this.yytext[e2];
              "\r" === i2 ? (i2 = this.yytext[++e2], this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0, "\n" !== i2 && ("\r" === i2 ? this.yylloc.last_line++ : this.yylloc.last_column++)) : "\n" === i2 ? (this.yyprevcol = this.yylloc.last_column, this.yylloc.last_line++, this.yylloc.last_column = 0) : this.yylloc.last_column++;
            }
            this.yylineno = this.yylloc.last_line;
          } else
            this.yytext = "", this.yylloc.last_line = this.yylineno = this.yylloc.first_line, this.yylloc.last_column = this.yylloc.first_column;
        return this;
      }, T.prototype.tryMatch = function(t2) {
        return t2 === this.ahead(t2.length);
      }, T.prototype.tryMatchCaseless = function(t2) {
        return t2 === this.ahead(t2.length).toLowerCase();
      }, T.prototype.ahead = function(t2) {
        var e2 = this._input.substring(this.offset, this.offset + t2);
        return "\r" === e2[e2.length - 1] && "\n" === this._input[this.offset + t2 + 1] && (e2 += "\n"), e2;
      }, T.prototype.consume = function(t2) {
        for (var e2 = 0; e2 < t2; e2++) {
          var i2 = this._input[this.offset];
          if (!i2)
            break;
          this.yytext += i2, this.offset++, "\r" === i2 && "\n" === this._input[this.offset] && (this.yytext += "\n", this.offset++, e2++), "\n" === i2 || "\r" === i2 ? (this.yylloc.last_line = ++this.yylineno, this.yyprevcol = this.yylloc.last_column, this.yylloc.last_column = 0) : this.yylloc.last_column++;
        }
        return this;
      }, T.prototype.getState = function() {
        return { yytext: this.yytext, offset: this.offset, yylineno: this.yylineno, yyprevcol: this.yyprevcol, yylloc: { first_offset: this.yylloc.first_offset, first_line: this.yylloc.first_line, first_column: this.yylloc.first_column, last_line: this.yylloc.last_line, last_column: this.yylloc.last_column }, heredoc_label: this.heredoc_label };
      }, T.prototype.setState = function(t2) {
        return this.yytext = t2.yytext, this.offset = t2.offset, this.yylineno = t2.yylineno, this.yyprevcol = t2.yyprevcol, this.yylloc = t2.yylloc, t2.heredoc_label && (this.heredoc_label = t2.heredoc_label), this;
      }, T.prototype.appendToken = function(t2, e2) {
        return this.tokens.push([t2, e2]), this;
      }, T.prototype.lex = function() {
        this.yylloc.prev_offset = this.offset, this.yylloc.prev_line = this.yylloc.last_line, this.yylloc.prev_column = this.yylloc.last_column;
        var t2 = this.next() || this.lex();
        if (!this.all_tokens) {
          for (; t2 === this.tok.T_WHITESPACE || !this.comment_tokens && (t2 === this.tok.T_COMMENT || t2 === this.tok.T_DOC_COMMENT) || t2 === this.tok.T_OPEN_TAG; )
            t2 = this.next() || this.lex();
          if (t2 == this.tok.T_OPEN_TAG_WITH_ECHO)
            return this.tok.T_ECHO;
          if (t2 === this.tok.T_CLOSE_TAG)
            return ";";
        }
        return this.yylloc.prev_offset || (this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column), t2;
      }, T.prototype.begin = function(t2) {
        if (this.conditionStack.push(t2), this.curCondition = t2, this.stateCb = this["match" + t2], "function" != typeof this.stateCb)
          throw new Error('Undefined condition state "' + t2 + '"');
        return this;
      }, T.prototype.popState = function() {
        var t2 = this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
        if (this.curCondition = this.conditionStack[this.conditionStack.length - 1], this.stateCb = this["match" + this.curCondition], "function" != typeof this.stateCb)
          throw new Error('Undefined condition state "' + this.curCondition + '"');
        return t2;
      }, T.prototype.next = function() {
        var t2;
        if (this._input || (this.done = true), this.yylloc.first_offset = this.offset, this.yylloc.first_line = this.yylloc.last_line, this.yylloc.first_column = this.yylloc.last_column, this.yytext = "", this.done)
          return this.yylloc.prev_offset = this.yylloc.first_offset, this.yylloc.prev_line = this.yylloc.first_line, this.yylloc.prev_column = this.yylloc.first_column, this.EOF;
        if (this.tokens.length > 0 ? ("object" == typeof (t2 = this.tokens.shift())[1] ? this.setState(t2[1]) : this.consume(t2[1]), t2 = t2[0]) : t2 = this.stateCb.apply(this, []), this.offset >= this.size && 0 === this.tokens.length && (this.done = true), this.debug) {
          var e2 = t2;
          e2 = "number" == typeof e2 ? this.engine.tokens.values[e2] : '"' + e2 + '"';
          var i2 = new Error(e2 + "	from " + this.yylloc.first_line + "," + this.yylloc.first_column + "	 - to " + this.yylloc.last_line + "," + this.yylloc.last_column + '	"' + this.yytext + '"');
          console.error(i2.stack);
        }
        return t2;
      }, [s, r, o, a, h, l, d, p, f].forEach(function(t2) {
        for (var e2 in t2)
          T.prototype[e2] = t2[e2];
      });
      var k = T, m = function(t2, e2, i2) {
        this.line = t2, this.column = e2, this.offset = i2;
      }, E = { read_array: function() {
        var t2 = null, e2 = false, i2 = this.node("array");
        this.token === this.tok.T_ARRAY ? (this.next().expect("("), t2 = ")") : (e2 = true, t2 = "]");
        var n2 = [];
        return this.next().token !== t2 && (n2 = this.read_array_pair_list(e2)), this.expect(t2), this.next(), i2(e2, n2);
      }, read_array_pair_list: function(t2) {
        var e2 = this;
        return this.read_list(function() {
          return e2.read_array_pair(t2);
        }, ",", true);
      }, read_array_pair: function(t2) {
        if (!(!t2 && ")" === this.token || t2 && "]" === this.token)) {
          if ("," === this.token)
            return this.node("noop")();
          var e2 = this.node("entry"), i2 = null, n2 = null, s2 = false, r2 = false;
          if ("&" === this.token)
            this.next(), s2 = true, n2 = this.read_variable(true, false);
          else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704)
            this.next(), "&" === this.token && this.error(), r2 = true, n2 = this.read_expr();
          else {
            var o2 = this.read_expr();
            this.token === this.tok.T_DOUBLE_ARROW ? (this.next(), i2 = o2, "&" === this.token ? (this.next(), s2 = true, n2 = this.read_variable(true, false)) : n2 = this.read_expr()) : n2 = o2;
          }
          return e2(i2, n2, s2, r2);
        }
      } };
      function x(t2, e2, i2) {
        return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
      }
      function y(t2, e2) {
        var i2 = Object.keys(t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t2);
          e2 && (n2 = n2.filter(function(e3) {
            return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
          })), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function v(t2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var i2 = null != arguments[e2] ? arguments[e2] : {};
          e2 % 2 ? y(Object(i2), true).forEach(function(e3) {
            x(t2, e3, i2[e3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : y(Object(i2)).forEach(function(e3) {
            Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i2, e3));
          });
        }
        return t2;
      }
      function A(t2, e2) {
        return function(t3) {
          if (Array.isArray(t3))
            return t3;
        }(t2) || function(t3, e3) {
          if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t3)))
            return;
          var i2 = [], n2 = true, s2 = false, r2 = void 0;
          try {
            for (var o2, a2 = t3[Symbol.iterator](); !(n2 = (o2 = a2.next()).done) && (i2.push(o2.value), !e3 || i2.length !== e3); n2 = true)
              ;
          } catch (t4) {
            s2 = true, r2 = t4;
          } finally {
            try {
              n2 || null == a2.return || a2.return();
            } finally {
              if (s2)
                throw r2;
            }
          }
          return i2;
        }(t2, e2) || N(t2, e2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function g(t2) {
        return function(t3) {
          if (Array.isArray(t3))
            return C(t3);
        }(t2) || function(t3) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(t3))
            return Array.from(t3);
        }(t2) || N(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function N(t2, e2) {
        if (t2) {
          if ("string" == typeof t2)
            return C(t2, e2);
          var i2 = Object.prototype.toString.call(t2).slice(8, -1);
          return "Object" === i2 && t2.constructor && (i2 = t2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(i2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? C(t2, e2) : void 0;
        }
      }
      function C(t2, e2) {
        (null == e2 || e2 > t2.length) && (e2 = t2.length);
        for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
          n2[i2] = t2[i2];
        return n2;
      }
      function S(t2) {
        if ("undefined" == typeof Symbol || null == t2[Symbol.iterator]) {
          if (Array.isArray(t2) || (t2 = N(t2))) {
            var e2 = 0, i2 = function() {
            };
            return { s: i2, n: function() {
              return e2 >= t2.length ? { done: true } : { done: false, value: t2[e2++] };
            }, e: function(t3) {
              throw t3;
            }, f: i2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var n2, s2, r2 = true, o2 = false;
        return { s: function() {
          n2 = t2[Symbol.iterator]();
        }, n: function() {
          var t3 = n2.next();
          return r2 = t3.done, t3;
        }, e: function(t3) {
          o2 = true, s2 = t3;
        }, f: function() {
          try {
            r2 || null == n2.return || n2.return();
          } finally {
            if (o2)
              throw s2;
          }
        } };
      }
      E.read_array, E.read_array_pair_list, E.read_array_pair;
      var b = { read_class_declaration_statement: function(t2) {
        var e2 = this.node("class"), i2 = this.read_class_modifiers();
        if (this.token !== this.tok.T_CLASS)
          return this.error(this.tok.T_CLASS), this.next(), null;
        this.next().expect(this.tok.T_STRING);
        var n2 = this.node("identifier"), s2 = this.text();
        this.next(), n2 = n2(s2);
        var r2 = this.read_extends_from(), o2 = this.read_implements_list();
        this.expect("{");
        var a2 = e2(n2, r2, o2, this.next().read_class_body(), i2);
        return t2 && (a2.attrGroups = t2), a2;
      }, read_class_modifiers: function() {
        return [0, 0, this.read_class_modifier()];
      }, read_class_modifier: function() {
        return this.token === this.tok.T_ABSTRACT ? (this.next(), 1) : this.token === this.tok.T_FINAL ? (this.next(), 2) : 0;
      }, read_class_body: function() {
        for (var t2 = [], e2 = []; this.token !== this.EOF && "}" !== this.token; )
          if (this.token !== this.tok.T_COMMENT)
            if (this.token !== this.tok.T_DOC_COMMENT)
              if (this.token !== this.tok.T_USE) {
                this.token === this.tok.T_ATTRIBUTE && (e2 = this.read_attr_list());
                var i2 = this.position(), n2 = this.read_member_flags(false);
                if (this.token !== this.tok.T_CONST)
                  if (this.token === this.tok.T_VAR && (this.next().expect(this.tok.T_VARIABLE), n2[0] = null, n2[1] = 0), this.token === this.tok.T_FUNCTION)
                    t2.push(this.read_function(false, n2, e2, i2)), e2 = [];
                  else if (this.token === this.tok.T_VARIABLE || this.version >= 704 && ("?" === this.token || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_ARRAY || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE)) {
                    var s2 = this.read_variable_list(n2, e2);
                    e2 = [], this.expect(";"), this.next(), t2 = t2.concat(s2);
                  } else
                    this.error([this.tok.T_CONST, this.tok.T_VARIABLE, this.tok.T_FUNCTION]), this.next();
                else {
                  var r2 = this.read_constant_list(n2, e2);
                  this.expect(";") && this.next(), t2 = t2.concat(r2);
                }
              } else
                t2 = t2.concat(this.read_trait_use_statement());
            else
              t2.push(this.read_doc_comment());
          else
            t2.push(this.read_comment());
        return this.expect("}"), this.next(), t2;
      }, read_variable_list: function(t2, e2) {
        var i2 = this.node("propertystatement"), n2 = this.read_list(function() {
          var t3 = this.node("property"), i3 = A(this.read_optional_type(), 2), n3 = i3[0], s2 = i3[1];
          this.expect(this.tok.T_VARIABLE);
          var r2 = this.node("identifier"), o2 = this.text().substring(1);
          return this.next(), r2 = r2(o2), ";" === this.token || "," === this.token ? t3(r2, null, n3, s2, e2 || []) : "=" === this.token ? t3(r2, this.next().read_expr(), n3, s2, e2 || []) : (this.expect([",", ";", "="]), t3(r2, null, n3, s2, e2 || []));
        }, ",");
        return i2(null, n2, t2);
      }, read_constant_list: function(t2, e2) {
        this.expect(this.tok.T_CONST) && this.next();
        var i2 = this.node("classconstant"), n2 = this.read_list(function() {
          var t3 = this.node("constant"), e3 = null, i3 = null;
          if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            e3 = this.node("identifier");
            var n3 = this.text();
            this.next(), e3 = e3(n3);
          } else
            this.expect("IDENTIFIER");
          return this.expect("=") && (i3 = this.next().read_expr()), t3(e3, i3);
        }, ",");
        return i2(null, n2, t2, e2 || []);
      }, read_member_flags: function(t2) {
        var e2 = [-1, -1, -1];
        if (this.is("T_MEMBER_FLAGS")) {
          var i2 = 0, n2 = 0;
          do {
            switch (this.token) {
              case this.tok.T_PUBLIC:
                i2 = 0, n2 = 0;
                break;
              case this.tok.T_PROTECTED:
                i2 = 0, n2 = 1;
                break;
              case this.tok.T_PRIVATE:
                i2 = 0, n2 = 2;
                break;
              case this.tok.T_STATIC:
                i2 = 1, n2 = 1;
                break;
              case this.tok.T_ABSTRACT:
                i2 = 2, n2 = 1;
                break;
              case this.tok.T_FINAL:
                i2 = 2, n2 = 2;
            }
            t2 && (0 == i2 && 2 == n2 ? (this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]), n2 = -1) : 2 == i2 && 1 == n2 && (this.error(), n2 = -1)), -1 !== e2[i2] ? this.error() : -1 !== n2 && (e2[i2] = n2);
          } while (this.next().is("T_MEMBER_FLAGS"));
        }
        return -1 == e2[1] && (e2[1] = 0), -1 == e2[2] && (e2[2] = 0), e2;
      }, read_optional_type: function() {
        var t2 = false;
        "?" === this.token && (t2 = true, this.next());
        var e2 = this.read_types();
        if (t2 && !e2 && this.raiseError("Expecting a type definition combined with nullable operator"), !t2 && !e2)
          return [false, null];
        if ("|" === this.token) {
          e2 = [e2];
          do {
            this.next();
            var i2 = this.read_type();
            if (!i2) {
              this.raiseError("Expecting a type definition");
              break;
            }
            e2.push(i2);
          } while ("|" === this.token);
        }
        return [t2, e2];
      }, read_interface_declaration_statement: function(t2) {
        var e2 = this.node("interface");
        if (this.token !== this.tok.T_INTERFACE)
          return this.error(this.tok.T_INTERFACE), this.next(), null;
        this.next().expect(this.tok.T_STRING);
        var i2 = this.node("identifier"), n2 = this.text();
        this.next(), i2 = i2(n2);
        var s2 = this.read_interface_extends_list();
        return this.expect("{"), e2(i2, s2, this.next().read_interface_body(), t2 || []);
      }, read_interface_body: function() {
        for (var t2 = [], e2 = []; this.token !== this.EOF && "}" !== this.token; )
          if (this.token !== this.tok.T_COMMENT)
            if (this.token !== this.tok.T_DOC_COMMENT) {
              var i2 = this.position();
              e2 = this.read_attr_list();
              var n2 = this.read_member_flags(true);
              if (this.token == this.tok.T_CONST) {
                var s2 = this.read_constant_list(n2, e2);
                this.expect(";") && this.next(), t2 = t2.concat(s2), e2 = [];
              } else if (this.token === this.tok.T_FUNCTION) {
                var r2 = this.read_function_declaration(2, n2, e2, i2);
                r2.parseFlags(n2), t2.push(r2), this.expect(";") && this.next(), e2 = [];
              } else
                this.error([this.tok.T_CONST, this.tok.T_FUNCTION]), this.next();
            } else
              t2.push(this.read_doc_comment());
          else
            t2.push(this.read_comment());
        return this.expect("}") && this.next(), t2;
      }, read_trait_declaration_statement: function() {
        var t2 = this.node("trait");
        if (this.token !== this.tok.T_TRAIT)
          return this.error(this.tok.T_TRAIT), this.next(), null;
        this.next().expect(this.tok.T_STRING);
        var e2 = this.node("identifier"), i2 = this.text();
        return this.next(), e2 = e2(i2), this.expect("{"), t2(e2, this.next().read_class_body());
      }, read_trait_use_statement: function() {
        var t2 = this.node("traituse");
        this.expect(this.tok.T_USE) && this.next();
        for (var e2 = [this.read_namespace_name()], i2 = null; "," === this.token; )
          e2.push(this.next().read_namespace_name());
        if ("{" === this.token) {
          for (i2 = []; this.next().token !== this.EOF && "}" !== this.token; )
            i2.push(this.read_trait_use_alias()), this.expect(";");
          this.expect("}") && this.next();
        } else
          this.expect(";") && this.next();
        return t2(e2, i2);
      }, read_trait_use_alias: function() {
        var t2, e2 = this.node(), i2 = null;
        if (this.is("IDENTIFIER")) {
          t2 = this.node("identifier");
          var n2 = this.text();
          this.next(), t2 = t2(n2);
        } else if (t2 = this.read_namespace_name(), this.token === this.tok.T_DOUBLE_COLON)
          if (this.next(), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            i2 = t2, t2 = this.node("identifier");
            var s2 = this.text();
            this.next(), t2 = t2(s2);
          } else
            this.expect(this.tok.T_STRING);
        else
          t2 = t2.name;
        if (this.token === this.tok.T_INSTEADOF)
          return e2("traitprecedence", i2, t2, this.next().read_name_list());
        if (this.token === this.tok.T_AS) {
          var r2 = null, o2 = null;
          if (this.next().is("T_MEMBER_FLAGS") && (r2 = this.read_member_flags()), this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            o2 = this.node("identifier");
            var a2 = this.text();
            this.next(), o2 = o2(a2);
          } else
            false === r2 && this.expect(this.tok.T_STRING);
          return e2("traitalias", i2, t2, o2, r2);
        }
        return this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]), e2("traitalias", i2, t2, null, null);
      } };
      b.read_class_declaration_statement, b.read_class_modifiers, b.read_class_modifier, b.read_class_body, b.read_variable_list, b.read_constant_list, b.read_member_flags, b.read_optional_type, b.read_interface_declaration_statement, b.read_interface_body, b.read_trait_declaration_statement, b.read_trait_use_statement, b.read_trait_use_alias;
      var L = { read_comment: function() {
        var t2 = this.text(), e2 = this.ast.prepare("/*" === t2.substring(0, 2) ? "commentblock" : "commentline", null, this), i2 = this.lexer.yylloc.first_offset, n2 = this.prev;
        return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (e2 = e2(t2)).offset = i2, this.prev = n2, e2;
      }, read_doc_comment: function() {
        var t2 = this.ast.prepare("commentblock", null, this), e2 = this.lexer.yylloc.first_offset, i2 = this.text(), n2 = this.prev;
        return this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset], this.lex(), (t2 = t2(i2)).offset = e2, this.prev = n2, t2;
      } };
      L.read_comment, L.read_doc_comment;
      var O = { read_expr: function(t2) {
        var e2 = this.node();
        if ("@" === this.token)
          return t2 || (t2 = this.next().read_expr()), e2("silent", t2);
        if (t2 || (t2 = this.read_expr_item()), "|" === this.token)
          return e2("bin", "|", t2, this.next().read_expr());
        if ("&" === this.token)
          return e2("bin", "&", t2, this.next().read_expr());
        if ("^" === this.token)
          return e2("bin", "^", t2, this.next().read_expr());
        if ("." === this.token)
          return e2("bin", ".", t2, this.next().read_expr());
        if ("+" === this.token)
          return e2("bin", "+", t2, this.next().read_expr());
        if ("-" === this.token)
          return e2("bin", "-", t2, this.next().read_expr());
        if ("*" === this.token)
          return e2("bin", "*", t2, this.next().read_expr());
        if ("/" === this.token)
          return e2("bin", "/", t2, this.next().read_expr());
        if ("%" === this.token)
          return e2("bin", "%", t2, this.next().read_expr());
        if (this.token === this.tok.T_POW)
          return e2("bin", "**", t2, this.next().read_expr());
        if (this.token === this.tok.T_SL)
          return e2("bin", "<<", t2, this.next().read_expr());
        if (this.token === this.tok.T_SR)
          return e2("bin", ">>", t2, this.next().read_expr());
        if (this.token === this.tok.T_BOOLEAN_OR)
          return e2("bin", "||", t2, this.next().read_expr());
        if (this.token === this.tok.T_LOGICAL_OR)
          return e2("bin", "or", t2, this.next().read_expr());
        if (this.token === this.tok.T_BOOLEAN_AND)
          return e2("bin", "&&", t2, this.next().read_expr());
        if (this.token === this.tok.T_LOGICAL_AND)
          return e2("bin", "and", t2, this.next().read_expr());
        if (this.token === this.tok.T_LOGICAL_XOR)
          return e2("bin", "xor", t2, this.next().read_expr());
        if (this.token === this.tok.T_IS_IDENTICAL)
          return e2("bin", "===", t2, this.next().read_expr());
        if (this.token === this.tok.T_IS_NOT_IDENTICAL)
          return e2("bin", "!==", t2, this.next().read_expr());
        if (this.token === this.tok.T_IS_EQUAL)
          return e2("bin", "==", t2, this.next().read_expr());
        if (this.token === this.tok.T_IS_NOT_EQUAL)
          return e2("bin", "!=", t2, this.next().read_expr());
        if ("<" === this.token)
          return e2("bin", "<", t2, this.next().read_expr());
        if (">" === this.token)
          return e2("bin", ">", t2, this.next().read_expr());
        if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL)
          return e2("bin", "<=", t2, this.next().read_expr());
        if (this.token === this.tok.T_IS_GREATER_OR_EQUAL)
          return e2("bin", ">=", t2, this.next().read_expr());
        if (this.token === this.tok.T_SPACESHIP)
          return e2("bin", "<=>", t2, this.next().read_expr());
        if (this.token === this.tok.T_INSTANCEOF && (t2 = e2("bin", "instanceof", t2, this.next().read_class_name_reference()), ";" !== this.token && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF && (t2 = this.read_expr(t2))), this.token === this.tok.T_COALESCE)
          return e2("bin", "??", t2, this.next().read_expr());
        if ("?" === this.token) {
          var i2 = null;
          return ":" !== this.next().token && (i2 = this.read_expr()), this.expect(":") && this.next(), e2("retif", t2, i2, this.read_expr());
        }
        return e2.destroy(t2), t2;
      }, read_expr_cast: function(t2) {
        return this.node("cast")(t2, this.text(), this.next().read_expr());
      }, read_isset_variable: function() {
        return this.read_expr();
      }, read_isset_variables: function() {
        return this.read_function_list(this.read_isset_variable, ",");
      }, read_internal_functions_in_yacc: function() {
        var t2 = null;
        switch (this.token) {
          case this.tok.T_ISSET:
            t2 = this.node("isset"), this.next().expect("(") && this.next();
            var e2 = this.read_isset_variables();
            this.expect(")") && this.next(), t2 = t2(e2);
            break;
          case this.tok.T_EMPTY:
            t2 = this.node("empty"), this.next().expect("(") && this.next();
            var i2 = this.read_expr();
            this.expect(")") && this.next(), t2 = t2(i2);
            break;
          case this.tok.T_INCLUDE:
            t2 = this.node("include")(false, false, this.next().read_expr());
            break;
          case this.tok.T_INCLUDE_ONCE:
            t2 = this.node("include")(true, false, this.next().read_expr());
            break;
          case this.tok.T_EVAL:
            t2 = this.node("eval"), this.next().expect("(") && this.next();
            var n2 = this.read_expr();
            this.expect(")") && this.next(), t2 = t2(n2);
            break;
          case this.tok.T_REQUIRE:
            t2 = this.node("include")(false, true, this.next().read_expr());
            break;
          case this.tok.T_REQUIRE_ONCE:
            t2 = this.node("include")(true, true, this.next().read_expr());
        }
        return t2;
      }, read_optional_expr: function(t2) {
        return this.token !== t2 ? this.read_expr() : null;
      }, read_exit_expr: function() {
        var t2 = null;
        return "(" === this.token && (this.next(), t2 = this.read_optional_expr(")"), this.expect(")") && this.next()), t2;
      }, read_expr_item: function() {
        var t2, e2, i2 = [];
        if ("+" === this.token)
          return this.node("unary")("+", this.next().read_expr());
        if ("-" === this.token)
          return this.node("unary")("-", this.next().read_expr());
        if ("!" === this.token)
          return this.node("unary")("!", this.next().read_expr());
        if ("~" === this.token)
          return this.node("unary")("~", this.next().read_expr());
        if ("(" === this.token)
          return (e2 = this.next().read_expr()).parenthesizedExpression = true, this.expect(")") && this.next(), this.handleDereferencable(e2);
        if ("`" === this.token)
          return this.read_encapsed_string("`");
        if (this.token === this.tok.T_LIST) {
          var n2 = null, s2 = this.innerList;
          t2 = this.node("list"), s2 || (n2 = this.node("assign")), this.next().expect("(") && this.next(), this.innerList || (this.innerList = true);
          var r2 = this.read_array_pair_list(false);
          this.expect(")") && this.next();
          for (var o2 = false, a2 = 0; a2 < r2.length; a2++)
            if (null !== r2[a2] && "noop" !== r2[a2].kind) {
              o2 = true;
              break;
            }
          return o2 || this.raiseError("Fatal Error :  Cannot use empty list on line " + this.lexer.yylloc.first_line), s2 ? t2(r2, false) : (this.innerList = false, this.expect("=") ? n2(t2(r2, false), this.next().read_expr(), "=") : t2(r2, false));
        }
        if (this.token === this.tok.T_ATTRIBUTE && (i2 = this.read_attr_list()), this.token === this.tok.T_CLONE)
          return this.node("clone")(this.next().read_expr());
        switch (this.token) {
          case this.tok.T_INC:
            return this.node("pre")("+", this.next().read_variable(false, false));
          case this.tok.T_DEC:
            return this.node("pre")("-", this.next().read_variable(false, false));
          case this.tok.T_NEW:
            return this.read_new_expr();
          case this.tok.T_ISSET:
          case this.tok.T_EMPTY:
          case this.tok.T_INCLUDE:
          case this.tok.T_INCLUDE_ONCE:
          case this.tok.T_EVAL:
          case this.tok.T_REQUIRE:
          case this.tok.T_REQUIRE_ONCE:
            return this.read_internal_functions_in_yacc();
          case this.tok.T_MATCH:
            return this.read_match_expression();
          case this.tok.T_INT_CAST:
            return this.read_expr_cast("int");
          case this.tok.T_DOUBLE_CAST:
            return this.read_expr_cast("float");
          case this.tok.T_STRING_CAST:
            return this.read_expr_cast(-1 !== this.text().indexOf("binary") ? "binary" : "string");
          case this.tok.T_ARRAY_CAST:
            return this.read_expr_cast("array");
          case this.tok.T_OBJECT_CAST:
            return this.read_expr_cast("object");
          case this.tok.T_BOOL_CAST:
            return this.read_expr_cast("bool");
          case this.tok.T_UNSET_CAST:
            return this.read_expr_cast("unset");
          case this.tok.T_THROW:
            return this.version < 800 && this.raiseError("PHP 8+ is required to use throw as an expression"), this.node("throw")(this.next().read_expr());
          case this.tok.T_EXIT:
            var h2 = "die" === this.lexer.yytext.toLowerCase();
            return t2 = this.node("exit"), this.next(), t2(this.read_exit_expr(), h2);
          case this.tok.T_PRINT:
            return this.node("print")(this.next().read_expr());
          case this.tok.T_YIELD:
            var l2 = null, c2 = null;
            return t2 = this.node("yield"), this.next().is("EXPR") && (l2 = this.read_expr(), this.token === this.tok.T_DOUBLE_ARROW && (c2 = l2, l2 = this.next().read_expr())), t2(l2, c2);
          case this.tok.T_YIELD_FROM:
            return (t2 = this.node("yieldfrom"))(e2 = this.next().read_expr());
          case this.tok.T_FN:
          case this.tok.T_FUNCTION:
            return this.read_inline_function(void 0, i2);
          case this.tok.T_STATIC:
            var u2 = [this.token, this.lexer.getState()];
            if (this.next(), this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN)
              return this.read_inline_function([0, 1, 0], i2);
            this.lexer.tokens.push(u2), this.next();
        }
        if (this.is("VARIABLE")) {
          t2 = this.node();
          var _2 = "identifier" === (e2 = this.read_variable(false, false)).kind || "staticlookup" === e2.kind && "identifier" === e2.offset.kind;
          switch (this.token) {
            case "=":
              return _2 && this.error("VARIABLE"), "&" == this.next().token ? this.read_assignref(t2, e2) : t2("assign", e2, this.read_expr(), "=");
            case this.tok.T_PLUS_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "+=");
            case this.tok.T_MINUS_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "-=");
            case this.tok.T_MUL_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "*=");
            case this.tok.T_POW_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "**=");
            case this.tok.T_DIV_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "/=");
            case this.tok.T_CONCAT_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), ".=");
            case this.tok.T_MOD_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "%=");
            case this.tok.T_AND_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "&=");
            case this.tok.T_OR_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "|=");
            case this.tok.T_XOR_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "^=");
            case this.tok.T_SL_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "<<=");
            case this.tok.T_SR_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), ">>=");
            case this.tok.T_COALESCE_EQUAL:
              return _2 && this.error("VARIABLE"), t2("assign", e2, this.next().read_expr(), "??=");
            case this.tok.T_INC:
              return _2 && this.error("VARIABLE"), this.next(), t2("post", "+", e2);
            case this.tok.T_DEC:
              return _2 && this.error("VARIABLE"), this.next(), t2("post", "-", e2);
            default:
              t2.destroy(e2);
          }
        } else {
          if (this.is("SCALAR")) {
            if (t2 = this.node(), "array" === (e2 = this.read_scalar()).kind && e2.shortForm && "=" === this.token) {
              var d2 = this.convertToList(e2);
              return e2.loc && (d2.loc = e2.loc), t2("assign", d2, this.next().read_expr(), "=");
            }
            return t2.destroy(e2), this.handleDereferencable(e2);
          }
          this.error("EXPR"), this.next();
        }
        return e2;
      }, convertToList: function(t2) {
        var e2 = this, i2 = t2.items.map(function(t3) {
          return t3.value && "array" === t3.value.kind && t3.value.shortForm && (t3.value = e2.convertToList(t3.value)), t3;
        }), n2 = this.node("list")(i2, true);
        return t2.loc && (n2.loc = t2.loc), t2.leadingComments && (n2.leadingComments = t2.leadingComments), t2.trailingComments && (n2.trailingComments = t2.trailingComments), n2;
      }, read_assignref: function(t2, e2) {
        var i2;
        return this.next(), this.token === this.tok.T_NEW ? (this.version >= 700 && this.error(), i2 = this.read_new_expr()) : i2 = this.read_variable(false, false), t2("assignref", e2, i2);
      }, read_inline_function: function(t2, e2) {
        if (this.token === this.tok.T_FUNCTION) {
          var i2 = this.read_function(true, t2, e2);
          return i2.attrGroups = e2, i2;
        }
        !this.version >= 704 && this.raiseError("Arrow Functions are not allowed");
        var n2 = this.node("arrowfunc");
        this.expect(this.tok.T_FN) && this.next();
        var s2 = this.is_reference();
        this.expect("(") && this.next();
        var r2 = this.read_parameter_list();
        this.expect(")") && this.next();
        var o2 = false, a2 = null;
        ":" === this.token && ("?" === this.next().token && (o2 = true, this.next()), a2 = this.read_types()), this.expect(this.tok.T_DOUBLE_ARROW) && this.next();
        var h2 = n2(r2, s2, this.read_expr(), a2, o2, !!t2);
        return h2.attrGroups = e2, h2;
      }, read_match_expression: function() {
        var t2 = this.node("match");
        this.expect(this.tok.T_MATCH) && this.next(), this.version < 800 && this.raiseError("Match statements are not allowed before PHP 8");
        var e2, i2;
        return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(")") && this.next(), this.expect("{") && this.next(), i2 = this.read_match_arms(), this.expect("}") && this.next(), t2(e2, i2);
      }, read_match_arms: function() {
        var t2 = this;
        return this.read_list(function() {
          return t2.read_match_arm();
        }, ",", true);
      }, read_match_arm: function() {
        if ("}" !== this.token)
          return this.node("matcharm")(this.read_match_arm_conds(), this.read_expr());
      }, read_match_arm_conds: function() {
        var t2 = [];
        if (this.token === this.tok.T_DEFAULT)
          t2 = null, this.next();
        else
          for (t2.push(this.read_expr()); "," === this.token; ) {
            if (this.next(), this.token === this.tok.T_DOUBLE_ARROW)
              return this.next(), t2;
            t2.push(this.read_expr());
          }
        return this.expect(this.tok.T_DOUBLE_ARROW) && this.next(), t2;
      }, read_attribute() {
        var t2 = this.text(), e2 = [];
        return this.next(), "(" === this.token && (e2 = this.read_argument_list()), this.node("attribute")(t2, e2);
      }, read_attr_list() {
        var t2 = [];
        if (this.token === this.tok.T_ATTRIBUTE)
          do {
            var e2 = this.node("attrgroup")([]);
            for (this.next(), e2.attrs.push(this.read_attribute()); "," === this.token; )
              this.next(), "]" !== this.token && e2.attrs.push(this.read_attribute());
            t2.push(e2), this.expect("]"), this.next();
          } while (this.token === this.tok.T_ATTRIBUTE);
        return t2;
      }, read_new_expr: function() {
        var t2 = this.node("new");
        this.expect(this.tok.T_NEW) && this.next();
        var e2 = [], i2 = this.read_attr_list();
        if (this.token === this.tok.T_CLASS) {
          var n2 = this.node("class");
          "(" === this.next().token && (e2 = this.read_argument_list());
          var s2 = this.read_extends_from(), r2 = this.read_implements_list(), o2 = null;
          this.expect("{") && (o2 = this.next().read_class_body());
          var a2 = n2(null, s2, r2, o2, [0, 0, 0]);
          return a2.attrGroups = i2, t2(a2, e2);
        }
        var h2 = this.read_new_class_name();
        return "(" === this.token && (e2 = this.read_argument_list()), t2(h2, e2);
      }, read_new_class_name: function() {
        if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {
          var t2 = this.read_namespace_name(true);
          return this.token === this.tok.T_DOUBLE_COLON && (t2 = this.read_static_getter(t2)), t2;
        }
        if (this.is("VARIABLE"))
          return this.read_variable(true, false);
        this.expect([this.tok.T_STRING, "VARIABLE"]);
      }, handleDereferencable: function(t2) {
        for (; this.token !== this.EOF; )
          if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON)
            t2 = this.recursive_variable_chain_scan(t2, false, false, true);
          else if (this.token === this.tok.T_CURLY_OPEN || "[" === this.token)
            t2 = this.read_dereferencable(t2);
          else {
            if ("(" !== this.token)
              return t2;
            t2 = this.node("call")(t2, this.read_argument_list());
          }
        return t2;
      } };
      O.read_expr, O.read_expr_cast, O.read_isset_variable, O.read_isset_variables, O.read_internal_functions_in_yacc, O.read_optional_expr, O.read_exit_expr, O.read_expr_item, O.convertToList, O.read_assignref, O.read_inline_function, O.read_match_expression, O.read_match_arms, O.read_match_arm, O.read_match_arm_conds, O.read_attribute, O.read_attr_list, O.read_new_expr, O.read_new_class_name, O.handleDereferencable;
      var I = { is_reference: function() {
        return "&" == this.token && (this.next(), true);
      }, is_variadic: function() {
        return this.token === this.tok.T_ELLIPSIS && (this.next(), true);
      }, read_function: function(t2, e2, i2, n2) {
        var s2 = this.read_function_declaration(t2 ? 1 : e2 ? 2 : 0, e2 && 1 === e2[1], i2 || [], n2);
        return e2 && 1 == e2[2] ? (s2.parseFlags(e2), this.expect(";") && this.next()) : (this.expect("{") && (s2.body = this.read_code_block(false), s2.loc && s2.body.loc && (s2.loc.end = s2.body.loc.end)), !t2 && e2 && s2.parseFlags(e2)), s2;
      }, read_function_declaration: function(t2, e2, i2, n2) {
        var s2 = this, r2 = "function";
        1 === t2 ? r2 = "closure" : 2 === t2 && (r2 = "method");
        var o2 = this.node(r2);
        this.expect(this.tok.T_FUNCTION) && this.next();
        var a2 = this.is_reference(), h2 = false, l2 = [], c2 = null, u2 = false;
        if (1 !== t2) {
          var _2 = this.node("identifier");
          2 === t2 ? this.version >= 700 ? this.token === this.tok.T_STRING || this.is("IDENTIFIER") ? (h2 = this.text(), this.next()) : this.version < 704 && this.error("IDENTIFIER") : this.token === this.tok.T_STRING ? (h2 = this.text(), this.next()) : this.error("IDENTIFIER") : this.version >= 700 ? this.token === this.tok.T_STRING ? (h2 = this.text(), this.next()) : this.version >= 704 ? this.expect("(") || this.next() : (this.error(this.tok.T_STRING), this.next()) : (this.expect(this.tok.T_STRING) && (h2 = this.text()), this.next()), h2 = _2(h2);
        }
        this.expect("(") && this.next();
        var d2 = this.read_parameter_list();
        this.expect(")") && this.next(), 1 === t2 && (l2 = this.read_lexical_vars()), ":" === this.token && ("?" === this.next().token && (u2 = true, this.next()), c2 = this.read_types());
        var p2 = function(t3) {
          return t3.attrGroups = i2 || [], n2 && t3.loc && (t3.loc.start = n2, t3.loc.source && (t3.loc.source = s2.lexer._input.substr(t3.loc.start.offset, t3.loc.end.offset - t3.loc.start.offset))), t3;
        };
        return p2(1 === t2 ? o2(d2, a2, l2, c2, u2, e2) : o2(h2, d2, a2, c2, u2));
      }, read_lexical_vars: function() {
        var t2 = [];
        return this.token === this.tok.T_USE && (this.next(), this.expect("(") && this.next(), t2 = this.read_lexical_var_list(), this.expect(")") && this.next()), t2;
      }, read_list_with_dangling_comma: function(t2) {
        for (var e2 = []; this.token != this.EOF; ) {
          if (e2.push(t2()), "," != this.token) {
            if (")" == this.token)
              break;
            this.error([",", ")"]);
            break;
          }
          if (this.next(), this.version >= 800 && ")" === this.token)
            return e2;
        }
        return e2;
      }, read_lexical_var_list: function() {
        return this.read_list_with_dangling_comma(this.read_lexical_var.bind(this));
      }, read_lexical_var: function() {
        if ("&" === this.token)
          return this.read_byref(this.read_lexical_var.bind(this));
        var t2 = this.node("variable");
        this.expect(this.tok.T_VARIABLE);
        var e2 = this.text().substring(1);
        return this.next(), t2(e2, false);
      }, read_parameter_list: function() {
        return ")" != this.token ? this.read_list_with_dangling_comma(this.read_parameter.bind(this)) : [];
      }, read_parameter: function() {
        var t2, e2 = this.node("parameter"), i2 = null, n2 = null, s2 = false, r2 = [];
        this.token === this.tok.T_ATTRIBUTE && (r2 = this.read_attr_list());
        var o2 = this.read_promoted();
        "?" === this.token && (this.next(), s2 = true), t2 = this.read_types(), s2 && !t2 && this.raiseError("Expecting a type definition combined with nullable operator");
        var a2 = this.is_reference(), h2 = this.is_variadic();
        if (this.expect(this.tok.T_VARIABLE)) {
          i2 = this.node("identifier");
          var l2 = this.text().substring(1);
          this.next(), i2 = i2(l2);
        }
        "=" == this.token && (n2 = this.next().read_expr());
        var c2 = e2(i2, t2, n2, a2, h2, s2, o2);
        return r2 && (c2.attrGroups = r2), c2;
      }, read_types() {
        var t2 = [], e2 = this.node("uniontype"), i2 = this.read_type();
        if (!i2)
          return null;
        for (t2.push(i2); "|" === this.token; )
          this.next(), i2 = this.read_type(), t2.push(i2);
        return 1 === t2.length ? t2[0] : e2(t2);
      }, read_promoted() {
        return this.token === this.tok.T_PUBLIC ? (this.next(), 1) : this.token === this.tok.T_PROTECTED ? (this.next(), 2) : this.token === this.tok.T_PRIVATE ? (this.next(), 4) : 0;
      }, read_argument_list: function() {
        var t2 = [];
        return this.expect("(") && this.next(), ")" !== this.token && (t2 = this.read_non_empty_argument_list()), this.expect(")") && this.next(), t2;
      }, read_non_empty_argument_list: function() {
        var t2 = false;
        return this.read_function_list(function() {
          var e2 = this.read_argument();
          return e2 && (t2 && this.raiseError("Unexpected argument after a variadic argument"), "variadic" === e2.kind && (t2 = true)), e2;
        }.bind(this), ",");
      }, read_argument: function() {
        if (this.token === this.tok.T_ELLIPSIS)
          return this.node("variadic")(this.next().read_expr());
        if (this.token === this.tok.T_STRING || Object.values(this.lexer.keywords).includes(this.token)) {
          var t2 = this.lexer.getState(), e2 = this.lexer.lex();
          if (this.lexer.setState(t2), ":" === e2)
            return this.version < 800 && this.raiseError("PHP 8+ is required to use named arguments"), this.node("namedargument")(this.text(), this.next().next().read_expr());
        }
        return this.read_expr();
      }, read_type: function() {
        var t2 = this.node();
        if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {
          var e2 = this.text();
          return this.next(), t2("typereference", e2.toLowerCase(), e2);
        }
        if (this.token === this.tok.T_STRING || this.token === this.tok.T_STATIC) {
          var i2 = this.text(), n2 = [this.token, this.lexer.getState()];
          return this.next(), this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(i2.toLowerCase()) > -1 ? t2("typereference", i2.toLowerCase(), i2) : (this.lexer.tokens.push(n2), this.next(), t2.destroy(), this.read_namespace_name());
        }
        return this.token === this.tok.T_NAMESPACE || this.token === this.tok.T_NS_SEPARATOR ? (t2.destroy(), this.read_namespace_name()) : (t2.destroy(), null);
      } };
      I.is_reference, I.is_variadic, I.read_function, I.read_function_declaration, I.read_lexical_vars, I.read_list_with_dangling_comma, I.read_lexical_var_list, I.read_lexical_var, I.read_parameter_list, I.read_parameter, I.read_types, I.read_promoted, I.read_argument_list, I.read_non_empty_argument_list, I.read_argument, I.read_type;
      var R = { read_if: function() {
        var t2 = this.node("if"), e2 = this.next().read_if_expr(), i2 = null, n2 = null, s2 = false;
        if (":" === this.token) {
          s2 = true, this.next(), i2 = this.node("block");
          for (var r2 = []; this.token !== this.EOF && this.token !== this.tok.T_ENDIF; ) {
            if (this.token === this.tok.T_ELSEIF) {
              n2 = this.read_elseif_short();
              break;
            }
            if (this.token === this.tok.T_ELSE) {
              n2 = this.read_else_short();
              break;
            }
            r2.push(this.read_inner_statement());
          }
          i2 = i2(null, r2), this.expect(this.tok.T_ENDIF) && this.next(), this.expectEndOfStatement();
        } else
          i2 = this.read_statement(), this.token === this.tok.T_ELSEIF ? n2 = this.read_if() : this.token === this.tok.T_ELSE && (n2 = this.next().read_statement());
        return t2(e2, i2, n2, s2);
      }, read_if_expr: function() {
        this.expect("(") && this.next();
        var t2 = this.read_expr();
        return this.expect(")") && this.next(), t2;
      }, read_elseif_short: function() {
        var t2 = null, e2 = this.node("if"), i2 = this.next().read_if_expr();
        this.expect(":") && this.next();
        for (var n2 = this.node("block"), s2 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; ) {
          if (this.token === this.tok.T_ELSEIF) {
            t2 = this.read_elseif_short();
            break;
          }
          if (this.token === this.tok.T_ELSE) {
            t2 = this.read_else_short();
            break;
          }
          s2.push(this.read_inner_statement());
        }
        return e2(i2, n2(null, s2), t2, true);
      }, read_else_short: function() {
        this.next().expect(":") && this.next();
        for (var t2 = this.node("block"), e2 = []; this.token != this.EOF && this.token !== this.tok.T_ENDIF; )
          e2.push(this.read_inner_statement());
        return t2(null, e2);
      } };
      R.read_if, R.read_if_expr, R.read_elseif_short, R.read_else_short;
      var w = { read_while: function() {
        var t2 = this.node("while");
        this.expect(this.tok.T_WHILE) && this.next();
        var e2, i2 = null, n2 = false;
        return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(")") && this.next(), ":" === this.token ? (n2 = true, i2 = this.read_short_form(this.tok.T_ENDWHILE)) : i2 = this.read_statement(), t2(e2, i2, n2);
      }, read_do: function() {
        var t2 = this.node("do");
        this.expect(this.tok.T_DO) && this.next();
        var e2, i2 = null;
        return e2 = this.read_statement(), this.expect(this.tok.T_WHILE) && (this.next().expect("(") && this.next(), i2 = this.read_expr(), this.expect(")") && this.next(), this.expect(";") && this.next()), t2(i2, e2);
      }, read_for: function() {
        var t2 = this.node("for");
        this.expect(this.tok.T_FOR) && this.next();
        var e2 = [], i2 = [], n2 = [], s2 = null, r2 = false;
        return this.expect("(") && this.next(), ";" !== this.token ? (e2 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), ";" !== this.token ? (i2 = this.read_list(this.read_expr, ","), this.expect(";") && this.next()) : this.next(), ")" !== this.token ? (n2 = this.read_list(this.read_expr, ","), this.expect(")") && this.next()) : this.next(), ":" === this.token ? (r2 = true, s2 = this.read_short_form(this.tok.T_ENDFOR)) : s2 = this.read_statement(), t2(e2, i2, n2, s2, r2);
      }, read_foreach: function() {
        var t2 = this.node("foreach");
        this.expect(this.tok.T_FOREACH) && this.next();
        var e2, i2 = null, n2 = null, s2 = null, r2 = false;
        return this.expect("(") && this.next(), e2 = this.read_expr(), this.expect(this.tok.T_AS) && (this.next(), n2 = this.read_foreach_variable(), this.token === this.tok.T_DOUBLE_ARROW && (i2 = n2, n2 = this.next().read_foreach_variable())), i2 && "list" === i2.kind && this.raiseError("Fatal Error : Cannot use list as key element"), this.expect(")") && this.next(), ":" === this.token ? (r2 = true, s2 = this.read_short_form(this.tok.T_ENDFOREACH)) : s2 = this.read_statement(), t2(e2, i2, n2, s2, r2);
      }, read_foreach_variable: function() {
        if (this.token === this.tok.T_LIST || "[" === this.token) {
          var t2 = "[" === this.token, e2 = this.node("list");
          this.next(), !t2 && this.expect("(") && this.next();
          var i2 = this.read_array_pair_list(t2);
          return this.expect(t2 ? "]" : ")") && this.next(), e2(i2, t2);
        }
        return this.read_variable(false, false);
      } };
      w.read_while, w.read_do, w.read_for, w.read_foreach, w.read_foreach_variable;
      var D = { read_start: function() {
        return this.token == this.tok.T_NAMESPACE ? this.read_namespace() : this.read_top_statement();
      } };
      D.read_start;
      var P = { read_namespace: function() {
        var t2, e2, i2 = this.node("namespace");
        return this.expect(this.tok.T_NAMESPACE) && this.next(), e2 = "{" == this.token ? { name: [""] } : this.read_namespace_name(), this.currentNamespace = e2, ";" == this.token ? (this.currentNamespace = e2, t2 = this.next().read_top_statements(), this.expect(this.EOF), i2(e2.name, t2, false)) : "{" == this.token ? (this.currentNamespace = e2, t2 = this.next().read_top_statements(), this.expect("}") && this.next(), 0 === t2.length && this.extractDoc && this._docs.length > this._docIndex && t2.push(this.node("noop")()), i2(e2.name, t2, true)) : "(" === this.token ? (e2.resolution = this.ast.reference.RELATIVE_NAME, e2.name = e2.name.substring(1), i2.destroy(), this.node("call")(e2, this.read_argument_list())) : (this.error(["{", ";"]), this.currentNamespace = e2, t2 = this.read_top_statements(), this.expect(this.EOF), i2(e2, t2, false));
      }, read_namespace_name: function(t2) {
        var e2 = this.node(), i2 = false;
        this.token === this.tok.T_NAMESPACE && (this.next().expect(this.tok.T_NS_SEPARATOR) && this.next(), i2 = true);
        var n2 = this.read_list(this.tok.T_STRING, this.tok.T_NS_SEPARATOR, true);
        if (!i2 && 1 === n2.length && (t2 || "(" !== this.token)) {
          if ("parent" === n2[0].toLowerCase())
            return e2("parentreference", n2[0]);
          if ("self" === n2[0].toLowerCase())
            return e2("selfreference", n2[0]);
        }
        return e2("name", n2, i2);
      }, read_use_statement: function() {
        var t2 = this.node("usegroup"), e2 = [], i2 = null;
        this.expect(this.tok.T_USE) && this.next();
        var n2 = this.read_use_type();
        return e2.push(this.read_use_declaration(false)), "," === this.token ? e2 = e2.concat(this.next().read_use_declarations(false)) : "{" === this.token && (i2 = e2[0].name, e2 = this.next().read_use_declarations(null === n2), this.expect("}") && this.next()), t2 = t2(i2, n2, e2), this.expect(";") && this.next(), t2;
      }, read_class_name_reference: function() {
        return this.read_variable(true, false);
      }, read_use_declaration: function(t2) {
        var e2 = this.node("useitem"), i2 = null;
        t2 && (i2 = this.read_use_type());
        var n2 = this.read_namespace_name(), s2 = this.read_use_alias();
        return e2(n2.name, s2, i2);
      }, read_use_declarations: function(t2) {
        for (var e2 = [this.read_use_declaration(t2)]; "," === this.token; ) {
          if (this.next(), t2) {
            if (this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING)
              break;
          } else if (this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR)
            break;
          e2.push(this.read_use_declaration(t2));
        }
        return e2;
      }, read_use_alias: function() {
        var t2 = null;
        if (this.token === this.tok.T_AS && this.next().expect(this.tok.T_STRING)) {
          var e2 = this.node("identifier"), i2 = this.text();
          this.next(), t2 = e2(i2);
        }
        return t2;
      }, read_use_type: function() {
        return this.token === this.tok.T_FUNCTION ? (this.next(), this.ast.useitem.TYPE_FUNCTION) : this.token === this.tok.T_CONST ? (this.next(), this.ast.useitem.TYPE_CONST) : null;
      } };
      P.read_namespace, P.read_namespace_name, P.read_use_statement, P.read_class_name_reference, P.read_use_declaration, P.read_use_declarations, P.read_use_alias, P.read_use_type;
      var U = { "\\": "\\", $: "$", n: "\n", r: "\r", t: "	", f: String.fromCharCode(12), v: String.fromCharCode(11), e: String.fromCharCode(27) }, B = { resolve_special_chars: function(t2, e2) {
        return e2 ? t2.replace(/\\"/, '"').replace(/\\([\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, function(t3, e3, i2) {
          return U[e3] ? U[e3] : "x" === e3[0] || "X" === e3[0] ? String.fromCodePoint(parseInt(e3.substr(1), 16)) : "u" === e3[0] ? String.fromCodePoint(parseInt(i2, 16)) : String.fromCodePoint(parseInt(e3, 8));
        }) : t2.replace(/\\\\/g, "\\").replace(/\\'/g, "'");
      }, remove_heredoc_leading_whitespace_chars: function(t2, e2, i2, n2) {
        if (0 === e2)
          return t2;
        this.check_heredoc_indentation_level(t2, e2, i2, n2);
        var s2 = i2 ? " " : "	", r2 = new RegExp("\\n".concat(s2, "{").concat(e2, "}"), "g"), o2 = new RegExp("^".concat(s2, "{").concat(e2, "}"));
        return n2 && (t2 = t2.replace(o2, "")), t2.replace(r2, "\n");
      }, check_heredoc_indentation_level: function(t2, e2, i2, n2) {
        var s2 = t2.length, r2 = 0, o2 = 0, a2 = true, h2 = i2 ? " " : "	", l2 = false;
        if (!n2) {
          if (-1 === (r2 = t2.indexOf("\n")))
            return;
          r2++;
        }
        for (; r2 < s2; )
          a2 ? t2[r2] === h2 ? o2++ : l2 = true : a2 = false, "\n" !== t2[r2] && l2 && o2 < e2 ? this.raiseError("Invalid body indentation level (expecting an indentation at least ".concat(e2, ")")) : l2 = false, "\n" === t2[r2] && (a2 = true, o2 = 0), r2++;
      }, read_dereferencable_scalar: function() {
        var t2 = null;
        switch (this.token) {
          case this.tok.T_CONSTANT_ENCAPSED_STRING:
            var e2 = this.node("string"), i2 = this.text(), n2 = 0;
            "b" !== i2[0] && "B" !== i2[0] || (n2 = 1);
            var s2 = '"' === i2[n2];
            this.next(), e2 = e2(s2, this.resolve_special_chars(i2.substring(n2 + 1, i2.length - 1), s2), 1 === n2, i2), t2 = this.token === this.tok.T_DOUBLE_COLON ? this.read_static_getter(e2) : e2;
            break;
          case this.tok.T_ARRAY:
          case "[":
            t2 = this.read_array();
        }
        return t2;
      }, read_scalar: function() {
        if (this.is("T_MAGIC_CONST"))
          return this.get_magic_constant();
        var t2, e2;
        switch (this.token) {
          case this.tok.T_LNUMBER:
          case this.tok.T_DNUMBER:
            var i2 = this.node("number");
            return t2 = this.text(), this.next(), i2(t2, null);
          case this.tok.T_START_HEREDOC:
            if ("ST_NOWDOC" === this.lexer.curCondition) {
              var n2 = this.lexer.yylloc.first_offset;
              e2 = this.node("nowdoc"), t2 = this.next().text(), this.lexer.heredoc_label.indentation > 0 && (t2 = t2.substring(0, t2.length - this.lexer.heredoc_label.indentation));
              var s2 = t2[t2.length - 1];
              "\n" === s2 ? t2 = "\r" === t2[t2.length - 2] ? t2.substring(0, t2.length - 2) : t2.substring(0, t2.length - 1) : "\r" === s2 && (t2 = t2.substring(0, t2.length - 1)), this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next(), this.expect(this.tok.T_END_HEREDOC) && this.next();
              var r2 = this.lexer._input.substring(n2, this.lexer.yylloc.first_offset);
              return e2 = e2(this.remove_heredoc_leading_whitespace_chars(t2, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), r2, this.lexer.heredoc_label.label);
            }
            return this.read_encapsed_string(this.tok.T_END_HEREDOC);
          case '"':
            return this.read_encapsed_string('"');
          case 'b"':
          case 'B"':
            return this.read_encapsed_string('"', true);
          case this.tok.T_CONSTANT_ENCAPSED_STRING:
          case this.tok.T_ARRAY:
          case "[":
            return this.read_dereferencable_scalar();
          default:
            var o2 = this.error("SCALAR");
            return this.next(), o2;
        }
      }, read_dereferencable: function(t2) {
        var e2, i2, n2 = this.node("offsetlookup");
        return "[" === this.token ? (i2 = this.next().read_expr(), this.expect("]") && this.next(), e2 = n2(t2, i2)) : this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES && (e2 = n2(t2, i2 = this.read_encapsed_string_item(false))), e2;
      }, read_encapsed_string_item: function(t2) {
        var e2, i2, n2, s2 = this.node("encapsedpart"), r2 = null, o2 = false, a2 = this.node();
        if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {
          var h2 = this.text();
          this.next(), a2 = a2("string", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(h2, t2), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : h2, false, h2);
        } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {
          if (r2 = "simple", o2 = true, n2 = null, this.next().token === this.tok.T_STRING_VARNAME) {
            n2 = this.node("variable");
            var l2 = this.text();
            this.next(), "[" === this.token ? (n2 = n2(l2, false), i2 = this.node("offsetlookup"), e2 = this.next().read_expr(), this.expect("]") && this.next(), a2 = i2(n2, e2)) : a2 = n2(l2, false);
          } else
            a2 = a2("variable", this.read_expr(), false);
          this.expect("}") && this.next();
        } else if (this.token === this.tok.T_CURLY_OPEN)
          r2 = "complex", a2.destroy(), a2 = this.next().read_variable(false, false), this.expect("}") && this.next();
        else if (this.token === this.tok.T_VARIABLE) {
          if (r2 = "simple", a2.destroy(), a2 = this.read_simple_variable(), "[" === this.token && (i2 = this.node("offsetlookup"), e2 = this.next().read_encaps_var_offset(), this.expect("]") && this.next(), a2 = i2(a2, e2)), this.token === this.tok.T_OBJECT_OPERATOR) {
            i2 = this.node("propertylookup"), this.next().expect(this.tok.T_STRING);
            var c2 = this.node("identifier");
            n2 = this.text(), this.next(), a2 = i2(a2, c2(n2));
          }
        } else {
          this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);
          var u2 = this.text();
          this.next(), a2.destroy(), a2 = a2("string", false, u2, false, u2);
        }
        return this.lexer.heredoc_label.first_encaps_node = false, s2(a2, r2, o2);
      }, read_encapsed_string: function(t2) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.lexer.yylloc.first_offset, n2 = this.node("encapsed");
        this.next();
        var s2 = this.lexer.yylloc.prev_offset - (e2 ? 1 : 0), r2 = [], o2 = null;
        for (o2 = "`" === t2 ? this.ast.encapsed.TYPE_SHELL : '"' === t2 ? this.ast.encapsed.TYPE_STRING : this.ast.encapsed.TYPE_HEREDOC; this.token !== t2 && this.token !== this.EOF; )
          r2.push(this.read_encapsed_string_item(true));
        if (r2.length > 0 && "encapsedpart" === r2[r2.length - 1].kind && "string" === r2[r2.length - 1].expression.kind) {
          var a2 = r2[r2.length - 1].expression, h2 = a2.value[a2.value.length - 1];
          "\n" === h2 ? "\r" === a2.value[a2.value.length - 2] ? a2.value = a2.value.substring(0, a2.value.length - 2) : a2.value = a2.value.substring(0, a2.value.length - 1) : "\r" === h2 && (a2.value = a2.value.substring(0, a2.value.length - 1));
        }
        this.expect(t2) && this.next();
        var l2 = this.lexer._input.substring("heredoc" === o2 ? i2 : s2 - 1, this.lexer.yylloc.first_offset);
        return n2 = n2(r2, l2, o2), t2 === this.tok.T_END_HEREDOC && (n2.label = this.lexer.heredoc_label.label, this.lexer.heredoc_label.finished = true), n2;
      }, get_magic_constant: function() {
        var t2 = this.node("magic"), e2 = this.text();
        return this.next(), t2(e2.toUpperCase(), e2);
      } };
      B.resolve_special_chars, B.remove_heredoc_leading_whitespace_chars, B.check_heredoc_indentation_level, B.read_dereferencable_scalar, B.read_scalar, B.read_dereferencable, B.read_encapsed_string_item, B.read_encapsed_string, B.get_magic_constant;
      var M = { read_top_statements: function() {
        for (var t2 = []; this.token !== this.EOF && "}" !== this.token; ) {
          var e2 = this.read_top_statement();
          e2 && (Array.isArray(e2) ? t2 = t2.concat(e2) : t2.push(e2));
        }
        return t2;
      }, read_top_statement: function() {
        var t2 = [];
        switch (this.token === this.tok.T_ATTRIBUTE && (t2 = this.read_attr_list()), this.token) {
          case this.tok.T_FUNCTION:
            return this.read_function(false, false, t2);
          case this.tok.T_ABSTRACT:
          case this.tok.T_FINAL:
          case this.tok.T_CLASS:
            return this.read_class_declaration_statement(t2);
          case this.tok.T_INTERFACE:
            return this.read_interface_declaration_statement(t2);
          case this.tok.T_TRAIT:
            return this.read_trait_declaration_statement();
          case this.tok.T_USE:
            return this.read_use_statement();
          case this.tok.T_CONST:
            var e2 = this.node("constantstatement"), i2 = this.next().read_const_list();
            return this.expectEndOfStatement(), e2(null, i2);
          case this.tok.T_NAMESPACE:
            return this.read_namespace();
          case this.tok.T_HALT_COMPILER:
            var n2 = this.node("halt");
            return this.next().expect("(") && this.next(), this.expect(")") && this.next(), this.expect(";"), this.lexer.done = true, n2(this.lexer._input.substring(this.lexer.offset));
          default:
            return this.read_statement();
        }
      }, read_inner_statements: function() {
        for (var t2 = []; this.token != this.EOF && "}" !== this.token; ) {
          var e2 = this.read_inner_statement();
          e2 && (Array.isArray(e2) ? t2 = t2.concat(e2) : t2.push(e2));
        }
        return t2;
      }, read_const_list: function() {
        return this.read_list(function() {
          this.expect(this.tok.T_STRING);
          var t2 = this.node("constant"), e2 = this.node("identifier"), i2 = this.text();
          return this.next(), e2 = e2(i2), this.expect("=") ? t2(e2, this.next().read_expr()) : t2(e2, null);
        }, ",", false);
      }, read_declare_list: function() {
        for (var t2 = []; this.token != this.EOF && ")" !== this.token; ) {
          this.expect(this.tok.T_STRING);
          var e2 = this.node("declaredirective"), i2 = this.node("identifier"), n2 = this.text();
          this.next(), i2 = i2(n2);
          var s2 = null;
          if (this.expect("=") && (s2 = this.next().read_expr()), t2.push(e2(i2, s2)), "," !== this.token)
            break;
          this.next();
        }
        return t2;
      }, read_inner_statement: function() {
        var t2 = [];
        switch (this.token === this.tok.T_ATTRIBUTE && (t2 = this.read_attr_list()), this.token) {
          case this.tok.T_FUNCTION:
            var e2 = this.read_function(false, false);
            return e2.attrGroups = t2, e2;
          case this.tok.T_ABSTRACT:
          case this.tok.T_FINAL:
          case this.tok.T_CLASS:
            return this.read_class_declaration_statement();
          case this.tok.T_INTERFACE:
            return this.read_interface_declaration_statement();
          case this.tok.T_TRAIT:
            return this.read_trait_declaration_statement();
          case this.tok.T_HALT_COMPILER:
            this.raiseError("__HALT_COMPILER() can only be used from the outermost scope");
            var i2 = this.node("halt");
            return this.next().expect("(") && this.next(), this.expect(")") && this.next(), i2 = i2(this.lexer._input.substring(this.lexer.offset)), this.expect(";") && this.next(), i2;
          default:
            return this.read_statement();
        }
      }, read_statement: function() {
        switch (this.token) {
          case "{":
            return this.read_code_block(false);
          case this.tok.T_IF:
            return this.read_if();
          case this.tok.T_SWITCH:
            return this.read_switch();
          case this.tok.T_FOR:
            return this.read_for();
          case this.tok.T_FOREACH:
            return this.read_foreach();
          case this.tok.T_WHILE:
            return this.read_while();
          case this.tok.T_DO:
            return this.read_do();
          case this.tok.T_COMMENT:
            return this.read_comment();
          case this.tok.T_DOC_COMMENT:
            return this.read_doc_comment();
          case this.tok.T_RETURN:
            var t2 = this.node("return");
            this.next();
            var e2 = this.read_optional_expr(";");
            return this.expectEndOfStatement(), t2(e2);
          case this.tok.T_BREAK:
          case this.tok.T_CONTINUE:
            var i2 = this.node(this.token === this.tok.T_CONTINUE ? "continue" : "break");
            this.next();
            var n2 = this.read_optional_expr(";");
            return this.expectEndOfStatement(), i2(n2);
          case this.tok.T_GLOBAL:
            var s2 = this.node("global"), r2 = this.next().read_list(this.read_simple_variable, ",");
            return this.expectEndOfStatement(), s2(r2);
          case this.tok.T_STATIC:
            var o2 = [this.token, this.lexer.getState()], a2 = this.node();
            if (this.next().token === this.tok.T_DOUBLE_COLON) {
              this.lexer.tokens.push(o2);
              var h2 = this.next().read_expr();
              return this.expectEndOfStatement(h2), a2("expressionstatement", h2);
            }
            if (this.token === this.tok.T_FUNCTION)
              return this.read_function(true, [0, 1, 0]);
            var l2 = this.read_variable_declarations();
            return this.expectEndOfStatement(), a2("static", l2);
          case this.tok.T_ECHO:
            var c2 = this.node("echo"), u2 = this.text(), _2 = "<?=" === u2 || "<%=" === u2, d2 = this.next().read_function_list(this.read_expr, ",");
            return this.expectEndOfStatement(), c2(d2, _2);
          case this.tok.T_INLINE_HTML:
            var p2 = this.text(), f2 = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null, T2 = "\r" === f2 || "\n" === f2;
            T2 && "\n" === f2 && this.lexer.yylloc.first_offset > 1 && "\r" === this.lexer._input[this.lexer.yylloc.first_offset - 2] && (f2 = "\r\n");
            var k2 = this.node("inline");
            return this.next(), k2(p2, T2 ? f2 + p2 : p2);
          case this.tok.T_UNSET:
            var m2 = this.node("unset");
            this.next().expect("(") && this.next();
            var E2 = this.read_function_list(this.read_variable, ",");
            return this.expect(")") && this.next(), this.expect(";") && this.next(), m2(E2);
          case this.tok.T_DECLARE:
            var x2, y2 = this.node("declare"), v2 = [];
            this.next().expect("(") && this.next();
            var A2 = this.read_declare_list();
            if (this.expect(")") && this.next(), ":" === this.token) {
              for (this.next(); this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE; )
                v2.push(this.read_top_statement());
              0 === v2.length && this.extractDoc && this._docs.length > this._docIndex && v2.push(this.node("noop")()), this.expect(this.tok.T_ENDDECLARE) && this.next(), this.expectEndOfStatement(), x2 = this.ast.declare.MODE_SHORT;
            } else if ("{" === this.token) {
              for (this.next(); this.token != this.EOF && "}" !== this.token; )
                v2.push(this.read_top_statement());
              0 === v2.length && this.extractDoc && this._docs.length > this._docIndex && v2.push(this.node("noop")()), this.expect("}") && this.next(), x2 = this.ast.declare.MODE_BLOCK;
            } else
              this.expect(";") && this.next(), x2 = this.ast.declare.MODE_NONE;
            return y2(A2, v2, x2);
          case this.tok.T_TRY:
            return this.read_try();
          case this.tok.T_THROW:
            var g2 = this.node("throw"), N2 = this.next().read_expr();
            return this.expectEndOfStatement(), g2(N2);
          case ";":
            return this.next(), null;
          case this.tok.T_STRING:
            var C2 = this.node(), S2 = [this.token, this.lexer.getState()], b2 = this.text(), L2 = this.node("identifier");
            if (":" === this.next().token)
              return L2 = L2(b2), this.next(), C2("label", L2);
            L2.destroy(), C2.destroy(), this.lexer.tokens.push(S2);
            var O2 = this.node("expressionstatement"), I2 = this.next().read_expr();
            return this.expectEndOfStatement(I2), O2(I2);
          case this.tok.T_GOTO:
            var R2 = this.node("goto"), w2 = null;
            if (this.next().expect(this.tok.T_STRING)) {
              w2 = this.node("identifier");
              var D2 = this.text();
              this.next(), w2 = w2(D2), this.expectEndOfStatement();
            }
            return R2(w2);
          default:
            var P2 = this.node("expressionstatement"), U2 = this.read_expr();
            return this.expectEndOfStatement(U2), P2(U2);
        }
      }, read_code_block: function(t2) {
        var e2 = this.node("block");
        this.expect("{") && this.next();
        var i2 = t2 ? this.read_top_statements() : this.read_inner_statements();
        return 0 === i2.length && this.extractDoc && this._docs.length > this._docIndex && i2.push(this.node("noop")()), this.expect("}") && this.next(), e2(null, i2);
      } };
      M.read_top_statements, M.read_top_statement, M.read_inner_statements, M.read_const_list, M.read_declare_list, M.read_inner_statement, M.read_statement, M.read_code_block;
      var F = { read_switch: function() {
        var t2 = this.node("switch");
        this.expect(this.tok.T_SWITCH) && this.next(), this.expect("(") && this.next();
        var e2 = this.read_expr();
        this.expect(")") && this.next();
        var i2 = ":" === this.token;
        return t2(e2, this.read_switch_case_list(), i2);
      }, read_switch_case_list: function() {
        var t2 = null, e2 = this.node("block"), i2 = [];
        for ("{" === this.token ? t2 = "}" : ":" === this.token ? t2 = this.tok.T_ENDSWITCH : this.expect(["{", ":"]), this.next(), ";" === this.token && this.next(); this.token !== this.EOF && this.token !== t2; )
          i2.push(this.read_case_list(t2));
        return 0 === i2.length && this.extractDoc && this._docs.length > this._docIndex && i2.push(this.node("noop")()), this.expect(t2) && this.next(), t2 === this.tok.T_ENDSWITCH && this.expectEndOfStatement(), e2(null, i2);
      }, read_case_list: function(t2) {
        var e2 = this.node("case"), i2 = null;
        this.token === this.tok.T_CASE ? i2 = this.next().read_expr() : this.token === this.tok.T_DEFAULT ? this.next() : this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]), this.expect([":", ";"]) && this.next();
        for (var n2 = this.node("block"), s2 = []; this.token !== this.EOF && this.token !== t2 && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT; )
          s2.push(this.read_inner_statement());
        return e2(i2, n2(null, s2));
      } };
      F.read_switch, F.read_switch_case_list, F.read_case_list;
      var H = { read_try: function() {
        this.expect(this.tok.T_TRY);
        for (var t2 = this.node("try"), e2 = null, i2 = [], n2 = this.next().read_statement(); this.token === this.tok.T_CATCH; ) {
          var s2 = this.node("catch");
          this.next().expect("(") && this.next();
          var r2 = this.read_list(this.read_namespace_name, "|", false), o2 = null;
          this.token === this.tok.T_VARIABLE && (o2 = this.read_variable(true, false)), this.expect(")"), i2.push(s2(this.next().read_statement(), r2, o2));
        }
        return this.token === this.tok.T_FINALLY && (e2 = this.next().read_statement()), t2(n2, i2, e2);
      } };
      H.read_try;
      var G = { read_short_form: function(t2) {
        var e2 = this.node("block"), i2 = [];
        for (this.expect(":") && this.next(); this.token != this.EOF && this.token !== t2; )
          i2.push(this.read_inner_statement());
        return 0 === i2.length && this.extractDoc && this._docs.length > this._docIndex && i2.push(this.node("noop")()), this.expect(t2) && this.next(), this.expectEndOfStatement(), e2(null, i2);
      }, read_function_list: function(t2, e2) {
        var i2 = [];
        do {
          if (this.token == e2 && this.version >= 703 && i2.length > 0) {
            i2.push(this.node("noop")());
            break;
          }
          if (i2.push(t2.apply(this, [])), this.token != e2)
            break;
          if (")" == this.next().token && this.version >= 703)
            break;
        } while (this.token != this.EOF);
        return i2;
      }, read_list: function(t2, e2, i2) {
        var n2 = [];
        if (this.token == e2 && (i2 && n2.push("function" == typeof t2 ? this.node("noop")() : null), this.next()), "function" == typeof t2)
          do {
            var s2 = t2.apply(this, []);
            if (s2 && n2.push(s2), this.token != e2)
              break;
          } while (this.next().token != this.EOF);
        else {
          if (!this.expect(t2))
            return [];
          for (n2.push(this.text()); this.next().token != this.EOF && this.token == e2 && this.next().token == t2; )
            n2.push(this.text());
        }
        return n2;
      }, read_name_list: function() {
        return this.read_list(this.read_namespace_name, ",", false);
      }, read_byref: function(t2) {
        var e2 = this.node("byref");
        this.next(), e2 = e2(null);
        var i2 = t2();
        return i2 && (this.ast.swapLocations(i2, e2, i2, this), i2.byref = true), i2;
      }, read_variable_declarations: function() {
        return this.read_list(function() {
          var t2 = this.node("staticvariable"), e2 = this.node("variable");
          if (this.expect(this.tok.T_VARIABLE)) {
            var i2 = this.text().substring(1);
            this.next(), e2 = e2(i2, false);
          } else
            e2 = e2("#ERR", false);
          return "=" === this.token ? t2(e2, this.next().read_expr()) : e2;
        }, ",");
      }, read_extends_from: function() {
        return this.token === this.tok.T_EXTENDS ? this.next().read_namespace_name() : null;
      }, read_interface_extends_list: function() {
        return this.token === this.tok.T_EXTENDS ? this.next().read_name_list() : null;
      }, read_implements_list: function() {
        return this.token === this.tok.T_IMPLEMENTS ? this.next().read_name_list() : null;
      } };
      G.read_short_form, G.read_function_list, G.read_list, G.read_name_list, G.read_byref, G.read_variable_declarations, G.read_extends_from, G.read_interface_extends_list, G.read_implements_list;
      var V = { read_variable: function(t2, e2) {
        var i2;
        if ("&" === this.token)
          return this.read_byref(this.read_variable.bind(this, t2, e2));
        if (this.is([this.tok.T_VARIABLE, "$"]))
          i2 = this.read_reference_variable(e2);
        else if (this.is([this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE])) {
          i2 = this.node();
          var n2 = this.read_namespace_name();
          if (this.token != this.tok.T_DOUBLE_COLON && "(" != this.token && -1 === ["parentreference", "selfreference"].indexOf(n2.kind)) {
            var s2 = n2.name.toLowerCase();
            "true" === s2 ? i2 = n2.destroy(i2("boolean", true, n2.name)) : "false" === s2 ? i2 = n2.destroy(i2("boolean", false, n2.name)) : "null" === s2 ? i2 = n2.destroy(i2("nullkeyword", n2.name)) : (i2.destroy(n2), i2 = n2);
          } else
            i2.destroy(n2), i2 = n2;
        } else if (this.token === this.tok.T_STATIC) {
          i2 = this.node("staticreference");
          var r2 = this.text();
          this.next(), i2 = i2(r2);
        } else
          this.expect("VARIABLE");
        return this.token === this.tok.T_DOUBLE_COLON && (i2 = this.read_static_getter(i2, e2)), this.recursive_variable_chain_scan(i2, t2, e2);
      }, read_static_getter: function(t2, e2) {
        var i2, n2, s2 = this.node("staticlookup");
        return this.next().is([this.tok.T_VARIABLE, "$"]) ? i2 = this.read_reference_variable(e2) : this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is("IDENTIFIER") ? (i2 = this.node("identifier"), n2 = this.text(), this.next(), i2 = i2(n2)) : "{" === this.token ? (i2 = this.node("literal"), n2 = this.next().read_expr(), this.expect("}") && this.next(), i2 = i2("literal", n2, null), this.expect("(")) : (this.error([this.tok.T_VARIABLE, this.tok.T_STRING]), i2 = this.node("identifier"), n2 = this.text(), this.next(), i2 = i2(n2)), s2(t2, i2);
      }, read_what: function() {
        var t2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e2 = null, i2 = null;
        switch (this.next().token) {
          case this.tok.T_STRING:
            e2 = this.node("identifier"), i2 = this.text(), this.next(), e2 = e2(i2), t2 && this.token === this.tok.T_OBJECT_OPERATOR && this.error();
            break;
          case this.tok.T_VARIABLE:
            e2 = this.node("variable"), i2 = this.text().substring(1), this.next(), e2 = e2(i2, false);
            break;
          case "$":
            e2 = this.node(), this.next().expect(["$", "{", this.tok.T_VARIABLE]), "{" === this.token ? (i2 = this.next().read_expr(), this.expect("}") && this.next(), e2 = e2("variable", i2, true)) : e2 = e2("variable", i2 = this.read_expr(), false);
            break;
          case "{":
            e2 = this.node("encapsedpart"), i2 = this.next().read_expr(), this.expect("}") && this.next(), e2 = e2(i2, "complex", false);
            break;
          default:
            this.error([this.tok.T_STRING, this.tok.T_VARIABLE, "$", "{"]), e2 = this.node("identifier"), i2 = this.text(), this.next(), e2 = e2(i2);
        }
        return e2;
      }, recursive_variable_chain_scan: function(t2, e2, i2) {
        var n2, s2;
        t:
          for (; this.token != this.EOF; )
            switch (this.token) {
              case "(":
                if (e2)
                  return t2;
                t2 = this.node("call")(t2, this.read_argument_list());
                break;
              case "[":
              case "{":
                var r2 = "[" === this.token;
                if (n2 = this.node("offsetlookup"), this.next(), s2 = false, i2)
                  s2 = this.read_encaps_var_offset(), this.expect(r2 ? "]" : "}") && this.next();
                else
                  (r2 ? "]" !== this.token : "}" !== this.token) ? (s2 = this.read_expr(), this.expect(r2 ? "]" : "}") && this.next()) : this.next();
                t2 = n2(t2, s2);
                break;
              case this.tok.T_DOUBLE_COLON:
                "staticlookup" === t2.kind && "identifier" === t2.offset.kind && this.error(), t2 = (n2 = this.node("staticlookup"))(t2, this.read_what(true));
                break;
              case this.tok.T_OBJECT_OPERATOR:
                t2 = (n2 = this.node("propertylookup"))(t2, this.read_what());
                break;
              case this.tok.T_NULLSAFE_OBJECT_OPERATOR:
                t2 = (n2 = this.node("nullsafepropertylookup"))(t2, this.read_what());
                break;
              default:
                break t;
            }
        return t2;
      }, read_encaps_var_offset: function() {
        var t2 = this.node();
        if (this.token === this.tok.T_STRING) {
          var e2 = this.text();
          this.next(), t2 = t2("identifier", e2);
        } else if (this.token === this.tok.T_NUM_STRING) {
          var i2 = this.text();
          this.next(), t2 = t2("number", i2, null);
        } else if ("-" === this.token) {
          this.next();
          var n2 = -1 * this.text();
          this.expect(this.tok.T_NUM_STRING) && this.next(), t2 = t2("number", n2, null);
        } else if (this.token === this.tok.T_VARIABLE) {
          var s2 = this.text().substring(1);
          this.next(), t2 = t2("variable", s2, false);
        } else {
          this.expect([this.tok.T_STRING, this.tok.T_NUM_STRING, "-", this.tok.T_VARIABLE]);
          var r2 = this.text();
          this.next(), t2 = t2("identifier", r2);
        }
        return t2;
      }, read_reference_variable: function(t2) {
        for (var e2, i2 = this.read_simple_variable(); this.token != this.EOF; ) {
          var n2 = this.node();
          if ("{" != this.token || t2) {
            n2.destroy();
            break;
          }
          e2 = this.next().read_expr(), this.expect("}") && this.next(), i2 = n2("offsetlookup", i2, e2);
        }
        return i2;
      }, read_simple_variable: function() {
        var t2, e2 = this.node("variable");
        if (this.expect([this.tok.T_VARIABLE, "$"]) && this.token === this.tok.T_VARIABLE)
          t2 = this.text().substring(1), this.next(), e2 = e2(t2, false);
        else
          switch ("$" === this.token && this.next(), this.token) {
            case "{":
              var i2 = this.next().read_expr();
              this.expect("}") && this.next(), e2 = e2(i2, true);
              break;
            case "$":
              e2 = e2(this.read_simple_variable(), false);
              break;
            case this.tok.T_VARIABLE:
              t2 = this.text().substring(1);
              var n2 = this.node("variable");
              this.next(), e2 = e2(n2(t2, false), false);
              break;
            default:
              this.error(["{", "$", this.tok.T_VARIABLE]), t2 = this.text(), this.next(), e2 = e2(t2, false);
          }
        return e2;
      } };
      function W(t2) {
        return "." != t2 && "," != t2 && !isNaN(parseFloat(t2)) && isFinite(t2);
      }
      V.read_variable, V.read_static_getter, V.read_what, V.recursive_variable_chain_scan, V.read_encaps_var_offset, V.read_reference_variable, V.read_simple_variable;
      var Q = function(t2, e2) {
        this.lexer = t2, this.ast = e2, this.tok = t2.tok, this.EOF = t2.EOF, this.token = null, this.prev = null, this.debug = false, this.version = 800, this.extractDoc = false, this.extractTokens = false, this.suppressErrors = false;
        var i2 = function(t3) {
          return [t3, null];
        };
        this.entries = { IDENTIFIER: new Map([this.tok.T_ABSTRACT, this.tok.T_ARRAY, this.tok.T_AS, this.tok.T_BREAK, this.tok.T_CALLABLE, this.tok.T_CASE, this.tok.T_CATCH, this.tok.T_CLASS, this.tok.T_CLASS_C, this.tok.T_CLONE, this.tok.T_CONST, this.tok.T_CONTINUE, this.tok.T_DECLARE, this.tok.T_DEFAULT, this.tok.T_DIR, this.tok.T_DO, this.tok.T_ECHO, this.tok.T_ELSE, this.tok.T_ELSEIF, this.tok.T_EMPTY, this.tok.T_ENDDECLARE, this.tok.T_ENDFOR, this.tok.T_ENDFOREACH, this.tok.T_ENDIF, this.tok.T_ENDSWITCH, this.tok.T_ENDWHILE, this.tok.T_EVAL, this.tok.T_EXIT, this.tok.T_EXTENDS, this.tok.T_FILE, this.tok.T_FINAL, this.tok.T_FINALLY, this.tok.T_FN, this.tok.T_FOR, this.tok.T_FOREACH, this.tok.T_FUNC_C, this.tok.T_FUNCTION, this.tok.T_GLOBAL, this.tok.T_GOTO, this.tok.T_IF, this.tok.T_IMPLEMENTS, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_INSTANCEOF, this.tok.T_INSTEADOF, this.tok.T_INTERFACE, this.tok.T_ISSET, this.tok.T_LINE, this.tok.T_LIST, this.tok.T_LOGICAL_AND, this.tok.T_LOGICAL_OR, this.tok.T_LOGICAL_XOR, this.tok.T_MATCH, this.tok.T_METHOD_C, this.tok.T_NAMESPACE, this.tok.T_NEW, this.tok.T_NS_C, this.tok.T_PRINT, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_PUBLIC, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_RETURN, this.tok.T_STATIC, this.tok.T_SWITCH, this.tok.T_THROW, this.tok.T_TRAIT, this.tok.T_TRY, this.tok.T_UNSET, this.tok.T_USE, this.tok.T_VAR, this.tok.T_WHILE, this.tok.T_YIELD].map(i2)), VARIABLE: new Map([this.tok.T_VARIABLE, "$", "&", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE, this.tok.T_STATIC].map(i2)), SCALAR: new Map([this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i2)), T_MAGIC_CONST: new Map([this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(i2)), T_MEMBER_FLAGS: new Map([this.tok.T_PUBLIC, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_STATIC, this.tok.T_ABSTRACT, this.tok.T_FINAL].map(i2)), EOS: new Map([";", this.EOF, this.tok.T_INLINE_HTML].map(i2)), EXPR: new Map(["@", "-", "+", "!", "~", "(", "`", this.tok.T_LIST, this.tok.T_CLONE, this.tok.T_INC, this.tok.T_DEC, this.tok.T_NEW, this.tok.T_ISSET, this.tok.T_EMPTY, this.tok.T_MATCH, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_EVAL, this.tok.T_INT_CAST, this.tok.T_DOUBLE_CAST, this.tok.T_STRING_CAST, this.tok.T_ARRAY_CAST, this.tok.T_OBJECT_CAST, this.tok.T_BOOL_CAST, this.tok.T_UNSET_CAST, this.tok.T_EXIT, this.tok.T_PRINT, this.tok.T_YIELD, this.tok.T_STATIC, this.tok.T_FUNCTION, this.tok.T_FN, this.tok.T_VARIABLE, "$", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_STRING, this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, "[", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '"', 'b"', 'B"', "-", this.tok.T_NS_SEPARATOR].map(i2)) };
      };
      Q.prototype.getTokenName = function(t2) {
        return W(t2) ? t2 == this.EOF ? "the end of file (EOF)" : this.lexer.engine.tokens.values[t2] : "'" + t2 + "'";
      }, Q.prototype.parse = function(t2, e2) {
        this._errors = [], this.filename = e2 || "eval", this.currentNamespace = [""], this.extractDoc ? this._docs = [] : this._docs = null, this.extractTokens ? this._tokens = [] : this._tokens = null, this._docIndex = 0, this._lastNode = null, this.lexer.setInput(t2), this.lexer.all_tokens = this.extractTokens, this.lexer.comment_tokens = this.extractDoc, this.length = this.lexer._input.length, this.innerList = false, this.innerListForm = false;
        var i2 = this.node("program"), n2 = [];
        for (this.next(); this.token != this.EOF; )
          n2.push(this.read_start());
        0 === n2.length && this.extractDoc && this._docs.length > this._docIndex && n2.push(this.node("noop")()), this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];
        var s2 = i2(n2, this._errors, this._docs, this._tokens);
        if (this.debug) {
          var r2 = this.ast.checkNodes();
          if (r2.length > 0)
            throw r2.forEach(function(t3) {
              t3.position && console.log("Node at line " + t3.position.line + ", column " + t3.position.column), console.log(t3.stack.join("\n"));
            }), new Error("Some nodes are not closed");
        }
        return s2;
      }, Q.prototype.raiseError = function(t2, e2, i2, n2) {
        if (t2 += " on line " + this.lexer.yylloc.first_line, !this.suppressErrors) {
          var s2 = new SyntaxError(t2, this.filename, this.lexer.yylloc.first_line);
          throw s2.lineNumber = this.lexer.yylloc.first_line, s2.fileName = this.filename, s2.columnNumber = this.lexer.yylloc.first_column, s2;
        }
        var r2 = this.ast.prepare("error", null, this)(t2, n2, this.lexer.yylloc.first_line, i2);
        return this._errors.push(r2), r2;
      }, Q.prototype.error = function(t2) {
        var e2 = "Parse Error : syntax error", i2 = this.getTokenName(this.token), n2 = "";
        if (this.token !== this.EOF) {
          if (W(this.token)) {
            var s2 = this.text();
            s2.length > 10 && (s2 = s2.substring(0, 7) + "..."), i2 = "'" + s2 + "' (" + i2 + ")";
          }
          e2 += ", unexpected " + i2;
        }
        return t2 && !Array.isArray(t2) && ((W(t2) || 1 === t2.length) && (n2 = ", expecting " + this.getTokenName(t2)), e2 += n2), this.raiseError(e2, n2, t2, i2);
      }, Q.prototype.position = function() {
        return new m(this.lexer.yylloc.first_line, this.lexer.yylloc.first_column, this.lexer.yylloc.first_offset);
      }, Q.prototype.node = function(t2) {
        if (this.extractDoc) {
          var e2 = null;
          this._docIndex < this._docs.length && (e2 = this._docs.slice(this._docIndex), this._docIndex = this._docs.length, this.debug && (console.log(new Error("Append docs on " + t2)), console.log(e2)));
          var i2 = this.ast.prepare(t2, e2, this);
          return i2.postBuild = function(t3) {
            if (this._docIndex < this._docs.length)
              if (this._lastNode) {
                for (var e3 = this.prev[2], i3 = this._docIndex; i3 < this._docs.length && !(this._docs[i3].offset > e3); i3++)
                  ;
                i3 > this._docIndex && (this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, i3)), this._docIndex = i3);
              } else
                this.token === this.EOF && (t3.setTrailingComments(this._docs.slice(this._docIndex)), this._docIndex = this._docs.length);
            this._lastNode = t3;
          }.bind(this), i2;
        }
        return this.ast.prepare(t2, null, this);
      }, Q.prototype.expectEndOfStatement = function(t2) {
        if (";" === this.token)
          t2 && ";" === this.lexer.yytext && t2.includeToken(this);
        else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF)
          return this.error(";"), false;
        return this.next(), true;
      };
      var Y = ["parser.next", "parser.node", "parser.showlog"];
      Q.prototype.showlog = function() {
        for (var t2, e2 = new Error().stack.split("\n"), i2 = 2; i2 < e2.length; i2++) {
          t2 = e2[i2].trim();
          for (var n2 = false, s2 = 0; s2 < Y.length; s2++)
            if (t2.substring(3, 3 + Y[s2].length) === Y[s2]) {
              n2 = true;
              break;
            }
          if (!n2)
            break;
        }
        return console.log("Line " + this.lexer.yylloc.first_line + " : " + this.getTokenName(this.token) + ">" + this.lexer.yytext + "< @-->" + t2), this;
      }, Q.prototype.expect = function(t2) {
        if (Array.isArray(t2)) {
          if (-1 === t2.indexOf(this.token))
            return this.error(t2), false;
        } else if (this.token != t2)
          return this.error(t2), false;
        return true;
      }, Q.prototype.text = function() {
        return this.lexer.yytext;
      }, Q.prototype.next = function() {
        if (";" === this.token && ";" !== this.lexer.yytext || (this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset]), this.lex(), this.debug && this.showlog(), this.extractDoc)
          for (; this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT; )
            this.token === this.tok.T_COMMENT ? this._docs.push(this.read_comment()) : this._docs.push(this.read_doc_comment());
        return this;
      }, Q.prototype.lex = function() {
        if (this.extractTokens)
          do {
            if (this.token = this.lexer.lex() || this.EOF, this.token === this.EOF)
              return this;
            var t2 = this.lexer.yytext;
            if (t2 = this.lexer.engine.tokens.values.hasOwnProperty(this.token) ? [this.lexer.engine.tokens.values[this.token], t2, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset] : [null, t2, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset], this._tokens.push(t2), this.token === this.tok.T_CLOSE_TAG)
              return this.token = ";", this;
            if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO)
              return this.token = this.tok.T_ECHO, this;
          } while (this.token === this.tok.T_WHITESPACE || !this.extractDoc && (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) || this.token === this.tok.T_OPEN_TAG);
        else
          this.token = this.lexer.lex() || this.EOF;
        return this;
      }, Q.prototype.is = function(t2) {
        return Array.isArray(t2) ? -1 !== t2.indexOf(this.token) : this.entries[t2].has(this.token);
      }, [E, b, L, O, I, R, w, D, P, B, M, F, H, G, V].forEach(function(t2) {
        for (var e2 in t2) {
          if (Q.prototype.hasOwnProperty(e2))
            throw new Error("Function " + e2 + " is already defined - collision");
          Q.prototype[e2] = t2[e2];
        }
      });
      var j = Q, $ = { values: { 101: "T_HALT_COMPILER", 102: "T_USE", 103: "T_ENCAPSED_AND_WHITESPACE", 104: "T_OBJECT_OPERATOR", 105: "T_STRING", 106: "T_DOLLAR_OPEN_CURLY_BRACES", 107: "T_STRING_VARNAME", 108: "T_CURLY_OPEN", 109: "T_NUM_STRING", 110: "T_ISSET", 111: "T_EMPTY", 112: "T_INCLUDE", 113: "T_INCLUDE_ONCE", 114: "T_EVAL", 115: "T_REQUIRE", 116: "T_REQUIRE_ONCE", 117: "T_NAMESPACE", 118: "T_NS_SEPARATOR", 119: "T_AS", 120: "T_IF", 121: "T_ENDIF", 122: "T_WHILE", 123: "T_DO", 124: "T_FOR", 125: "T_SWITCH", 126: "T_BREAK", 127: "T_CONTINUE", 128: "T_RETURN", 129: "T_GLOBAL", 130: "T_STATIC", 131: "T_ECHO", 132: "T_INLINE_HTML", 133: "T_UNSET", 134: "T_FOREACH", 135: "T_DECLARE", 136: "T_TRY", 137: "T_THROW", 138: "T_GOTO", 139: "T_FINALLY", 140: "T_CATCH", 141: "T_ENDDECLARE", 142: "T_LIST", 143: "T_CLONE", 144: "T_PLUS_EQUAL", 145: "T_MINUS_EQUAL", 146: "T_MUL_EQUAL", 147: "T_DIV_EQUAL", 148: "T_CONCAT_EQUAL", 149: "T_MOD_EQUAL", 150: "T_AND_EQUAL", 151: "T_OR_EQUAL", 152: "T_XOR_EQUAL", 153: "T_SL_EQUAL", 154: "T_SR_EQUAL", 155: "T_INC", 156: "T_DEC", 157: "T_BOOLEAN_OR", 158: "T_BOOLEAN_AND", 159: "T_LOGICAL_OR", 160: "T_LOGICAL_AND", 161: "T_LOGICAL_XOR", 162: "T_SL", 163: "T_SR", 164: "T_IS_IDENTICAL", 165: "T_IS_NOT_IDENTICAL", 166: "T_IS_EQUAL", 167: "T_IS_NOT_EQUAL", 168: "T_IS_SMALLER_OR_EQUAL", 169: "T_IS_GREATER_OR_EQUAL", 170: "T_INSTANCEOF", 171: "T_INT_CAST", 172: "T_DOUBLE_CAST", 173: "T_STRING_CAST", 174: "T_ARRAY_CAST", 175: "T_OBJECT_CAST", 176: "T_BOOL_CAST", 177: "T_UNSET_CAST", 178: "T_EXIT", 179: "T_PRINT", 180: "T_YIELD", 181: "T_YIELD_FROM", 182: "T_FUNCTION", 183: "T_DOUBLE_ARROW", 184: "T_DOUBLE_COLON", 185: "T_ARRAY", 186: "T_CALLABLE", 187: "T_CLASS", 188: "T_ABSTRACT", 189: "T_TRAIT", 190: "T_FINAL", 191: "T_EXTENDS", 192: "T_INTERFACE", 193: "T_IMPLEMENTS", 194: "T_VAR", 195: "T_PUBLIC", 196: "T_PROTECTED", 197: "T_PRIVATE", 198: "T_CONST", 199: "T_NEW", 200: "T_INSTEADOF", 201: "T_ELSEIF", 202: "T_ELSE", 203: "T_ENDSWITCH", 204: "T_CASE", 205: "T_DEFAULT", 206: "T_ENDFOR", 207: "T_ENDFOREACH", 208: "T_ENDWHILE", 209: "T_CONSTANT_ENCAPSED_STRING", 210: "T_LNUMBER", 211: "T_DNUMBER", 212: "T_LINE", 213: "T_FILE", 214: "T_DIR", 215: "T_TRAIT_C", 216: "T_METHOD_C", 217: "T_FUNC_C", 218: "T_NS_C", 219: "T_START_HEREDOC", 220: "T_END_HEREDOC", 221: "T_CLASS_C", 222: "T_VARIABLE", 223: "T_OPEN_TAG", 224: "T_OPEN_TAG_WITH_ECHO", 225: "T_CLOSE_TAG", 226: "T_WHITESPACE", 227: "T_COMMENT", 228: "T_DOC_COMMENT", 229: "T_ELLIPSIS", 230: "T_COALESCE", 231: "T_POW", 232: "T_POW_EQUAL", 233: "T_SPACESHIP", 234: "T_COALESCE_EQUAL", 235: "T_FN", 236: "T_NULLSAFE_OBJECT_OPERATOR", 237: "T_MATCH", 238: "T_ATTRIBUTE" }, names: { T_HALT_COMPILER: 101, T_USE: 102, T_ENCAPSED_AND_WHITESPACE: 103, T_OBJECT_OPERATOR: 104, T_STRING: 105, T_DOLLAR_OPEN_CURLY_BRACES: 106, T_STRING_VARNAME: 107, T_CURLY_OPEN: 108, T_NUM_STRING: 109, T_ISSET: 110, T_EMPTY: 111, T_INCLUDE: 112, T_INCLUDE_ONCE: 113, T_EVAL: 114, T_REQUIRE: 115, T_REQUIRE_ONCE: 116, T_NAMESPACE: 117, T_NS_SEPARATOR: 118, T_AS: 119, T_IF: 120, T_ENDIF: 121, T_WHILE: 122, T_DO: 123, T_FOR: 124, T_SWITCH: 125, T_BREAK: 126, T_CONTINUE: 127, T_RETURN: 128, T_GLOBAL: 129, T_STATIC: 130, T_ECHO: 131, T_INLINE_HTML: 132, T_UNSET: 133, T_FOREACH: 134, T_DECLARE: 135, T_TRY: 136, T_THROW: 137, T_GOTO: 138, T_FINALLY: 139, T_CATCH: 140, T_ENDDECLARE: 141, T_LIST: 142, T_CLONE: 143, T_PLUS_EQUAL: 144, T_MINUS_EQUAL: 145, T_MUL_EQUAL: 146, T_DIV_EQUAL: 147, T_CONCAT_EQUAL: 148, T_MOD_EQUAL: 149, T_AND_EQUAL: 150, T_OR_EQUAL: 151, T_XOR_EQUAL: 152, T_SL_EQUAL: 153, T_SR_EQUAL: 154, T_INC: 155, T_DEC: 156, T_BOOLEAN_OR: 157, T_BOOLEAN_AND: 158, T_LOGICAL_OR: 159, T_LOGICAL_AND: 160, T_LOGICAL_XOR: 161, T_SL: 162, T_SR: 163, T_IS_IDENTICAL: 164, T_IS_NOT_IDENTICAL: 165, T_IS_EQUAL: 166, T_IS_NOT_EQUAL: 167, T_IS_SMALLER_OR_EQUAL: 168, T_IS_GREATER_OR_EQUAL: 169, T_INSTANCEOF: 170, T_INT_CAST: 171, T_DOUBLE_CAST: 172, T_STRING_CAST: 173, T_ARRAY_CAST: 174, T_OBJECT_CAST: 175, T_BOOL_CAST: 176, T_UNSET_CAST: 177, T_EXIT: 178, T_PRINT: 179, T_YIELD: 180, T_YIELD_FROM: 181, T_FUNCTION: 182, T_DOUBLE_ARROW: 183, T_DOUBLE_COLON: 184, T_ARRAY: 185, T_CALLABLE: 186, T_CLASS: 187, T_ABSTRACT: 188, T_TRAIT: 189, T_FINAL: 190, T_EXTENDS: 191, T_INTERFACE: 192, T_IMPLEMENTS: 193, T_VAR: 194, T_PUBLIC: 195, T_PROTECTED: 196, T_PRIVATE: 197, T_CONST: 198, T_NEW: 199, T_INSTEADOF: 200, T_ELSEIF: 201, T_ELSE: 202, T_ENDSWITCH: 203, T_CASE: 204, T_DEFAULT: 205, T_ENDFOR: 206, T_ENDFOREACH: 207, T_ENDWHILE: 208, T_CONSTANT_ENCAPSED_STRING: 209, T_LNUMBER: 210, T_DNUMBER: 211, T_LINE: 212, T_FILE: 213, T_DIR: 214, T_TRAIT_C: 215, T_METHOD_C: 216, T_FUNC_C: 217, T_NS_C: 218, T_START_HEREDOC: 219, T_END_HEREDOC: 220, T_CLASS_C: 221, T_VARIABLE: 222, T_OPEN_TAG: 223, T_OPEN_TAG_WITH_ECHO: 224, T_CLOSE_TAG: 225, T_WHITESPACE: 226, T_COMMENT: 227, T_DOC_COMMENT: 228, T_ELLIPSIS: 229, T_COALESCE: 230, T_POW: 231, T_POW_EQUAL: 232, T_SPACESHIP: 233, T_COALESCE_EQUAL: 234, T_FN: 235, T_NULLSAFE_OBJECT_OPERATOR: 236, T_MATCH: 237, T_ATTRIBUTE: 238 } }, z = function(t2, e2, i2) {
        this.source = t2, this.start = e2, this.end = i2;
      }, K = function(t2, e2, i2) {
        this.kind = t2, e2 && (this.leadingComments = e2), i2 && (this.loc = i2);
      };
      K.prototype.setTrailingComments = function(t2) {
        this.trailingComments = t2;
      }, K.prototype.destroy = function(t2) {
        if (!t2)
          throw new Error("Node already initialized, you must swap with another node");
        return this.leadingComments && (t2.leadingComments ? t2.leadingComments = Array.concat(this.leadingComments, t2.leadingComments) : t2.leadingComments = this.leadingComments), this.trailingComments && (t2.trailingComments ? t2.trailingComments = Array.concat(this.trailingComments, t2.trailingComments) : t2.trailingComments = this.trailingComments), t2;
      }, K.prototype.includeToken = function(t2) {
        return this.loc && (this.loc.end && (this.loc.end.line = t2.lexer.yylloc.last_line, this.loc.end.column = t2.lexer.yylloc.last_column, this.loc.end.offset = t2.lexer.offset), t2.ast.withSource && (this.loc.source = t2.lexer._input.substring(this.loc.start.offset, t2.lexer.offset))), this;
      }, K.extends = function(t2, e2) {
        return e2.prototype = Object.create(this.prototype), e2.extends = this.extends, e2.prototype.constructor = e2, e2.kind = t2, e2;
      };
      var X = K, J = "expression", q = X.extends(J, function(t2, e2, i2) {
        X.apply(this, [t2 || J, e2, i2]);
      }), Z = "array", tt = q.extends(Z, function(t2, e2, i2, n2) {
        q.apply(this, [Z, i2, n2]), this.items = e2, this.shortForm = t2;
      }), et = "arrowfunc", it = q.extends(et, function(t2, e2, i2, n2, s2, r2, o2, a2) {
        q.apply(this, [et, o2, a2]), this.arguments = t2, this.byref = e2, this.body = i2, this.type = n2, this.nullable = s2, this.isStatic = r2 || false;
      }), nt = "assign", st = q.extends(nt, function(t2, e2, i2, n2, s2) {
        q.apply(this, [nt, n2, s2]), this.left = t2, this.right = e2, this.operator = i2;
      }), rt = "assignref", ot = q.extends(rt, function(t2, e2, i2, n2) {
        q.apply(this, [rt, i2, n2]), this.left = t2, this.right = e2;
      }), at = "attribute", ht = X.extends(at, function(t2, e2, i2, n2) {
        X.apply(this, [at, i2, n2]), this.name = t2, this.args = e2;
      }), lt = "attrgroup", ct = X.extends(lt, function(t2, e2, i2) {
        X.apply(this, [lt, e2, i2]), this.attrs = t2 || [];
      }), ut = "operation", _t = q.extends(ut, function(t2, e2, i2) {
        q.apply(this, [t2 || ut, e2, i2]);
      }), dt = _t.extends("bin", function(t2, e2, i2, n2, s2) {
        _t.apply(this, ["bin", n2, s2]), this.type = t2, this.left = e2, this.right = i2;
      }), pt = "statement", ft = X.extends(pt, function(t2, e2, i2) {
        X.apply(this, [t2 || pt, e2, i2]);
      }), Tt = "block", kt = ft.extends(Tt, function(t2, e2, i2, n2) {
        ft.apply(this, [t2 || Tt, i2, n2]), this.children = e2.filter(Boolean);
      }), mt = "literal", Et = q.extends(mt, function(t2, e2, i2, n2, s2) {
        q.apply(this, [t2 || mt, n2, s2]), this.value = e2, i2 && (this.raw = i2);
      }), xt = "boolean", yt = Et.extends(xt, function(t2, e2, i2, n2) {
        Et.apply(this, [xt, t2, e2, i2, n2]);
      }), vt = "break", At = ft.extends(vt, function(t2, e2, i2) {
        ft.apply(this, [vt, e2, i2]), this.level = t2;
      }), gt = "byref", Nt = q.extends(gt, function(t2, e2, i2) {
        q.apply(this, [gt, e2, i2]), this.what = t2;
      }), Ct = "call", St = q.extends(Ct, function(t2, e2, i2, n2) {
        q.apply(this, [Ct, i2, n2]), this.what = t2, this.arguments = e2;
      }), bt = "case", Lt = ft.extends(bt, function(t2, e2, i2, n2) {
        ft.apply(this, [bt, i2, n2]), this.test = t2, this.body = e2;
      }), Ot = "cast", It = _t.extends(Ot, function(t2, e2, i2, n2, s2) {
        _t.apply(this, [Ot, n2, s2]), this.type = t2, this.raw = e2, this.expr = i2;
      }), Rt = "catch", wt = ft.extends(Rt, function(t2, e2, i2, n2, s2) {
        ft.apply(this, [Rt, n2, s2]), this.body = t2, this.what = e2, this.variable = i2;
      }), Dt = "declaration", Pt = ft.extends(Dt, function(t2, e2, i2, n2) {
        ft.apply(this, [t2 || Dt, i2, n2]), this.name = e2;
      });
      Pt.prototype.parseFlags = function(t2) {
        this.isAbstract = 1 === t2[2], this.isFinal = 2 === t2[2], "class" !== this.kind && (-1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private"), this.isStatic = 1 === t2[1]);
      };
      var Ut = Pt, Bt = "class", Mt = Ut.extends(Bt, function(t2, e2, i2, n2, s2, r2, o2) {
        Ut.apply(this, [Bt, t2, r2, o2]), this.isAnonymous = !t2, this.extends = e2, this.implements = i2, this.body = n2, this.attrGroups = [], this.parseFlags(s2);
      }), Ft = "constantstatement", Ht = ft.extends(Ft, function(t2, e2, i2, n2) {
        ft.apply(this, [t2 || Ft, i2, n2]), this.constants = e2;
      }), Gt = "classconstant", Vt = Ht.extends(Gt, function(t2, e2, i2, n2, s2, r2) {
        Ht.apply(this, [t2 || Gt, e2, s2, r2]), this.parseFlags(i2), this.attrGroups = n2;
      });
      Vt.prototype.parseFlags = function(t2) {
        -1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private");
      };
      var Wt = Vt, Qt = "clone", Yt = q.extends(Qt, function(t2, e2, i2) {
        q.apply(this, [Qt, e2, i2]), this.what = t2;
      }), jt = "closure", $t = q.extends(jt, function(t2, e2, i2, n2, s2, r2, o2, a2) {
        q.apply(this, [jt, o2, a2]), this.uses = i2, this.arguments = t2, this.byref = e2, this.type = n2, this.nullable = s2, this.isStatic = r2 || false, this.body = null, this.attrGroups = [];
      }), zt = X.extends("comment", function(t2, e2, i2, n2) {
        X.apply(this, [t2, i2, n2]), this.value = e2;
      }), Kt = "commentblock", Xt = zt.extends(Kt, function(t2, e2, i2) {
        zt.apply(this, [Kt, t2, e2, i2]);
      }), Jt = "commentline", qt = zt.extends(Jt, function(t2, e2, i2) {
        zt.apply(this, [Jt, t2, e2, i2]);
      }), Zt = "constant", te = X.extends(Zt, function(t2, e2, i2, n2) {
        X.apply(this, [Zt, i2, n2]), this.name = t2, this.value = e2;
      }), ee = "continue", ie = ft.extends(ee, function(t2, e2, i2) {
        ft.apply(this, [ee, e2, i2]), this.level = t2;
      }), ne = "declare", se = kt.extends(ne, function(t2, e2, i2, n2, s2) {
        kt.apply(this, [ne, e2, n2, s2]), this.directives = t2, this.mode = i2;
      });
      se.MODE_SHORT = "short", se.MODE_BLOCK = "block", se.MODE_NONE = "none";
      var re = se, oe = "declaredirective", ae = X.extends(oe, function(t2, e2, i2, n2) {
        X.apply(this, [oe, i2, n2]), this.key = t2, this.value = e2;
      }), he = ft.extends("do", function(t2, e2, i2, n2) {
        ft.apply(this, ["do", i2, n2]), this.test = t2, this.body = e2;
      }), le = "echo", ce = ft.extends(le, function(t2, e2, i2, n2) {
        ft.apply(this, [le, i2, n2]), this.shortForm = e2, this.expressions = t2;
      }), ue = "empty", _e = q.extends(ue, function(t2, e2, i2) {
        q.apply(this, [ue, e2, i2]), this.expression = t2;
      }), de = "encapsed", pe = Et.extends(de, function(t2, e2, i2, n2, s2) {
        Et.apply(this, [de, t2, e2, n2, s2]), this.type = i2;
      });
      pe.TYPE_STRING = "string", pe.TYPE_SHELL = "shell", pe.TYPE_HEREDOC = "heredoc", pe.TYPE_OFFSET = "offset";
      var fe = pe, Te = "encapsedpart", ke = q.extends(Te, function(t2, e2, i2, n2, s2) {
        q.apply(this, [Te, n2, s2]), this.expression = t2, this.syntax = e2, this.curly = i2;
      }), me = "entry", Ee = q.extends(me, function(t2, e2, i2, n2, s2, r2) {
        q.apply(this, [me, s2, r2]), this.key = t2, this.value = e2, this.byRef = i2, this.unpack = n2;
      }), xe = "error", ye = X.extends(xe, function(t2, e2, i2, n2, s2, r2) {
        X.apply(this, [xe, s2, r2]), this.message = t2, this.token = e2, this.line = i2, this.expected = n2;
      }), ve = "eval", Ae = q.extends(ve, function(t2, e2, i2) {
        q.apply(this, [ve, e2, i2]), this.source = t2;
      }), ge = "exit", Ne = q.extends(ge, function(t2, e2, i2, n2) {
        q.apply(this, [ge, i2, n2]), this.expression = t2, this.useDie = e2;
      }), Ce = "expressionstatement", Se = ft.extends(Ce, function(t2, e2, i2) {
        ft.apply(this, [Ce, e2, i2]), this.expression = t2;
      }), be = ft.extends("for", function(t2, e2, i2, n2, s2, r2, o2) {
        ft.apply(this, ["for", r2, o2]), this.init = t2, this.test = e2, this.increment = i2, this.shortForm = s2, this.body = n2;
      }), Le = "foreach", Oe = ft.extends(Le, function(t2, e2, i2, n2, s2, r2, o2) {
        ft.apply(this, [Le, r2, o2]), this.source = t2, this.key = e2, this.value = i2, this.shortForm = s2, this.body = n2;
      }), Ie = "function", Re = Ut.extends(Ie, function(t2, e2, i2, n2, s2, r2, o2) {
        Ut.apply(this, [Ie, t2, r2, o2]), this.arguments = e2, this.byref = i2, this.type = n2, this.nullable = s2, this.body = null, this.attrGroups = [];
      }), we = "global", De = ft.extends(we, function(t2, e2, i2) {
        ft.apply(this, [we, e2, i2]), this.items = t2;
      }), Pe = "goto", Ue = ft.extends(Pe, function(t2, e2, i2) {
        ft.apply(this, [Pe, e2, i2]), this.label = t2;
      }), Be = "halt", Me = ft.extends(Be, function(t2, e2, i2) {
        ft.apply(this, [Be, e2, i2]), this.after = t2;
      }), Fe = "identifier", He = X.extends(Fe, function(t2, e2, i2) {
        X.apply(this, [Fe, e2, i2]), this.name = t2;
      }), Ge = ft.extends("if", function(t2, e2, i2, n2, s2, r2) {
        ft.apply(this, ["if", s2, r2]), this.test = t2, this.body = e2, this.alternate = i2, this.shortForm = n2;
      }), Ve = "include", We = q.extends(Ve, function(t2, e2, i2, n2, s2) {
        q.apply(this, [Ve, n2, s2]), this.once = t2, this.require = e2, this.target = i2;
      }), Qe = "inline", Ye = Et.extends(Qe, function(t2, e2, i2, n2) {
        Et.apply(this, [Qe, t2, e2, i2, n2]);
      }), je = "interface", $e = Ut.extends(je, function(t2, e2, i2, n2, s2, r2) {
        Ut.apply(this, [je, t2, s2, r2]), this.extends = e2, this.body = i2, this.attrGroups = n2;
      }), ze = "isset", Ke = q.extends(ze, function(t2, e2, i2) {
        q.apply(this, [ze, e2, i2]), this.variables = t2;
      }), Xe = "label", Je = ft.extends(Xe, function(t2, e2, i2) {
        ft.apply(this, [Xe, e2, i2]), this.name = t2;
      }), qe = "list", Ze = q.extends(qe, function(t2, e2, i2, n2) {
        q.apply(this, [qe, i2, n2]), this.items = t2, this.shortForm = e2;
      }), ti = "lookup", ei = q.extends(ti, function(t2, e2, i2, n2, s2) {
        q.apply(this, [t2 || ti, n2, s2]), this.what = e2, this.offset = i2;
      }), ii = "magic", ni = Et.extends(ii, function(t2, e2, i2, n2) {
        Et.apply(this, [ii, t2, e2, i2, n2]);
      }), si = "match", ri = q.extends(si, function(t2, e2, i2, n2) {
        q.apply(this, [si, i2, n2]), this.cond = t2, this.arms = e2;
      }), oi = "matcharm", ai = q.extends(oi, function(t2, e2, i2, n2) {
        q.apply(this, [oi, i2, n2]), this.conds = t2, this.body = e2;
      }), hi = "method", li = Re.extends(hi, function() {
        Re.apply(this, arguments), this.kind = hi;
      }), ci = "reference", ui = X.extends(ci, function(t2, e2, i2) {
        X.apply(this, [t2 || ci, e2, i2]);
      }), _i = "name", di = ui.extends(_i, function t2(e2, i2, n2, s2) {
        ui.apply(this, [_i, n2, s2]), i2 ? this.resolution = t2.RELATIVE_NAME : 1 === e2.length ? this.resolution = t2.UNQUALIFIED_NAME : e2[0] ? this.resolution = t2.QUALIFIED_NAME : this.resolution = t2.FULL_QUALIFIED_NAME, this.name = e2.join("\\");
      });
      di.UNQUALIFIED_NAME = "uqn", di.QUALIFIED_NAME = "qn", di.FULL_QUALIFIED_NAME = "fqn", di.RELATIVE_NAME = "rn";
      var pi = di, fi = "namespace", Ti = kt.extends(fi, function(t2, e2, i2, n2, s2) {
        kt.apply(this, [fi, e2, n2, s2]), this.name = t2, this.withBrackets = i2 || false;
      }), ki = "namedargument", mi = q.extends(ki, function(t2, e2, i2, n2) {
        q.apply(this, [ki, i2, n2]), this.name = t2, this.value = e2;
      }), Ei = q.extends("new", function(t2, e2, i2, n2) {
        q.apply(this, ["new", i2, n2]), this.what = t2, this.arguments = e2;
      }), xi = "noop", yi = X.extends(xi, function(t2, e2) {
        X.apply(this, [xi, t2, e2]);
      }), vi = "nowdoc", Ai = Et.extends(vi, function(t2, e2, i2, n2, s2) {
        Et.apply(this, [vi, t2, e2, n2, s2]), this.label = i2;
      }), gi = "nullkeyword", Ni = X.extends(gi, function(t2, e2, i2) {
        X.apply(this, [gi, e2, i2]), this.raw = t2;
      }), Ci = "nullsafepropertylookup", Si = ei.extends(Ci, function(t2, e2, i2, n2) {
        ei.apply(this, [Ci, t2, e2, i2, n2]);
      }), bi = "number", Li = Et.extends(bi, function(t2, e2, i2, n2) {
        Et.apply(this, [bi, t2, e2, i2, n2]);
      }), Oi = "offsetlookup", Ii = ei.extends(Oi, function(t2, e2, i2, n2) {
        ei.apply(this, [Oi, t2, e2, i2, n2]);
      }), Ri = "parameter", wi = Ut.extends(Ri, function(t2, e2, i2, n2, s2, r2, o2, a2, h2) {
        Ut.apply(this, [Ri, t2, a2, h2]), this.value = i2, this.type = e2, this.byref = n2, this.variadic = s2, this.nullable = r2, this.flags = o2 || 0, this.attrGroups = [];
      }), Di = "parentreference", Pi = ui.extends(Di, function(t2, e2, i2) {
        ui.apply(this, [Di, e2, i2]), this.raw = t2;
      }), Ui = "post", Bi = _t.extends(Ui, function(t2, e2, i2, n2) {
        _t.apply(this, [Ui, i2, n2]), this.type = t2, this.what = e2;
      }), Mi = _t.extends("pre", function(t2, e2, i2, n2) {
        _t.apply(this, ["pre", i2, n2]), this.type = t2, this.what = e2;
      }), Fi = "print", Hi = q.extends(Fi, function(t2, e2, i2) {
        q.apply(this, [Fi, e2, i2]), this.expression = t2;
      }), Gi = "program", Vi = kt.extends(Gi, function(t2, e2, i2, n2, s2, r2) {
        kt.apply(this, [Gi, t2, s2, r2]), this.errors = e2, i2 && (this.comments = i2), n2 && (this.tokens = n2);
      }), Wi = "property", Qi = ft.extends(Wi, function(t2, e2, i2, n2, s2, r2, o2) {
        ft.apply(this, [Wi, r2, o2]), this.name = t2, this.value = e2, this.nullable = i2, this.type = n2, this.attrGroups = s2;
      }), Yi = "propertylookup", ji = ei.extends(Yi, function(t2, e2, i2, n2) {
        ei.apply(this, [Yi, t2, e2, i2, n2]);
      }), $i = "propertystatement", zi = ft.extends($i, function(t2, e2, i2, n2, s2) {
        ft.apply(this, [$i, n2, s2]), this.properties = e2, this.parseFlags(i2);
      });
      zi.prototype.parseFlags = function(t2) {
        -1 === t2[0] ? this.visibility = "" : null === t2[0] ? this.visibility = null : 0 === t2[0] ? this.visibility = "public" : 1 === t2[0] ? this.visibility = "protected" : 2 === t2[0] && (this.visibility = "private"), this.isStatic = 1 === t2[1];
      };
      var Ki = zi, Xi = "retif", Ji = q.extends(Xi, function(t2, e2, i2, n2, s2) {
        q.apply(this, [Xi, n2, s2]), this.test = t2, this.trueExpr = e2, this.falseExpr = i2;
      }), qi = "return", Zi = ft.extends(qi, function(t2, e2, i2) {
        ft.apply(this, [qi, e2, i2]), this.expr = t2;
      }), tn = "selfreference", en = ui.extends(tn, function(t2, e2, i2) {
        ui.apply(this, [tn, e2, i2]), this.raw = t2;
      }), nn = "silent", sn = q.extends(nn, function(t2, e2, i2) {
        q.apply(this, [nn, e2, i2]), this.expr = t2;
      }), rn = "static", on = ft.extends(rn, function(t2, e2, i2) {
        ft.apply(this, [rn, e2, i2]), this.variables = t2;
      }), an = "staticvariable", hn = X.extends(an, function(t2, e2, i2, n2) {
        X.apply(this, [an, i2, n2]), this.variable = t2, this.defaultValue = e2;
      }), ln = "staticlookup", cn = ei.extends(ln, function(t2, e2, i2, n2) {
        ei.apply(this, [ln, t2, e2, i2, n2]);
      }), un = "staticreference", _n = ui.extends(un, function(t2, e2, i2) {
        ui.apply(this, [un, e2, i2]), this.raw = t2;
      }), dn = "string", pn = Et.extends(dn, function(t2, e2, i2, n2, s2, r2) {
        Et.apply(this, [dn, e2, n2, s2, r2]), this.unicode = i2, this.isDoubleQuote = t2;
      }), fn = "switch", Tn = ft.extends(fn, function(t2, e2, i2, n2, s2) {
        ft.apply(this, [fn, n2, s2]), this.test = t2, this.body = e2, this.shortForm = i2;
      }), kn = "throw", mn = ft.extends(kn, function(t2, e2, i2) {
        ft.apply(this, [kn, e2, i2]), this.what = t2;
      }), En = "trait", xn = Ut.extends(En, function(t2, e2, i2, n2) {
        Ut.apply(this, [En, t2, i2, n2]), this.body = e2;
      }), yn = "traitalias", vn = X.extends(yn, function(t2, e2, i2, n2, s2, r2) {
        X.apply(this, [yn, s2, r2]), this.trait = t2, this.method = e2, this.as = i2, this.visibility = "", n2 && (0 === n2[0] ? this.visibility = "public" : 1 === n2[0] ? this.visibility = "protected" : 2 === n2[0] && (this.visibility = "private"));
      }), An = "traitprecedence", gn = X.extends(An, function(t2, e2, i2, n2, s2) {
        X.apply(this, [An, n2, s2]), this.trait = t2, this.method = e2, this.instead = i2;
      }), Nn = "traituse", Cn = X.extends(Nn, function(t2, e2, i2, n2) {
        X.apply(this, [Nn, i2, n2]), this.traits = t2, this.adaptations = e2;
      }), Sn = ft.extends("try", function(t2, e2, i2, n2, s2) {
        ft.apply(this, ["try", n2, s2]), this.body = t2, this.catches = e2, this.always = i2;
      }), bn = "typereference", Ln = ui.extends(bn, function(t2, e2, i2, n2) {
        ui.apply(this, [bn, i2, n2]), this.name = t2, this.raw = e2;
      });
      Ln.types = ["int", "float", "string", "bool", "object", "array", "callable", "iterable", "void", "static"];
      var On = Ln, In2 = "unary", Rn = _t.extends(In2, function(t2, e2, i2, n2) {
        _t.apply(this, [In2, i2, n2]), this.type = t2, this.what = e2;
      }), wn = "uniontype", Dn = Ut.extends(wn, function(t2, e2, i2) {
        Ut.apply(this, [wn, null, e2, i2]), this.types = t2;
      }), Pn = "unset", Un = ft.extends(Pn, function(t2, e2, i2) {
        ft.apply(this, [Pn, e2, i2]), this.variables = t2;
      }), Bn = "usegroup", Mn = ft.extends(Bn, function(t2, e2, i2, n2, s2) {
        ft.apply(this, [Bn, n2, s2]), this.name = t2, this.type = e2, this.items = i2;
      }), Fn = "useitem", Hn = ft.extends(Fn, function(t2, e2, i2, n2, s2) {
        ft.apply(this, [Fn, n2, s2]), this.name = t2, this.alias = e2, this.type = i2;
      });
      Hn.TYPE_CONST = "const", Hn.TYPE_FUNCTION = "function";
      var Gn = Hn, Vn = "variable", Wn = q.extends(Vn, function(t2, e2, i2, n2) {
        q.apply(this, [Vn, i2, n2]), this.name = t2, this.curly = e2 || false;
      }), Qn = "variadic", Yn = q.extends(Qn, function(t2, e2, i2) {
        q.apply(this, [Qn, e2, i2]), this.what = t2;
      }), jn = "while", $n = ft.extends(jn, function(t2, e2, i2, n2, s2) {
        ft.apply(this, [jn, n2, s2]), this.test = t2, this.body = e2, this.shortForm = i2;
      }), zn = "yield", Kn = q.extends(zn, function(t2, e2, i2, n2) {
        q.apply(this, [zn, i2, n2]), this.value = t2, this.key = e2;
      }), Xn = "yieldfrom", Jn = q.extends(Xn, function(t2, e2, i2) {
        q.apply(this, [Xn, e2, i2]), this.value = t2;
      }), qn = function(t2, e2) {
        this.withPositions = t2, this.withSource = e2;
      };
      qn.precedence = {}, [["or"], ["xor"], ["and"], ["="], ["?"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "!=", "===", "!==", "<=>"], ["<", "<=", ">", ">="], ["<<", ">>"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["cast", "silent"], ["**"]].forEach(function(t2, e2) {
        t2.forEach(function(t3) {
          qn.precedence[t3] = e2 + 1;
        });
      }), qn.prototype.isRightAssociative = function(t2) {
        return "**" === t2 || "??" === t2;
      }, qn.prototype.swapLocations = function(t2, e2, i2, n2) {
        this.withPositions && (t2.loc.start = e2.loc.start, t2.loc.end = i2.loc.end, this.withSource && (t2.loc.source = n2.lexer._input.substring(t2.loc.start.offset, t2.loc.end.offset)));
      }, qn.prototype.resolveLocations = function(t2, e2, i2, n2) {
        this.withPositions && (t2.loc.start.offset > e2.loc.start.offset && (t2.loc.start = e2.loc.start), t2.loc.end.offset < i2.loc.end.offset && (t2.loc.end = i2.loc.end), this.withSource && (t2.loc.source = n2.lexer._input.substring(t2.loc.start.offset, t2.loc.end.offset)));
      }, qn.prototype.resolvePrecedence = function(t2, e2) {
        var i2, n2, s2;
        return "call" === t2.kind ? this.resolveLocations(t2, t2.what, t2, e2) : "propertylookup" === t2.kind || "staticlookup" === t2.kind || "offsetlookup" === t2.kind && t2.offset ? this.resolveLocations(t2, t2.what, t2.offset, e2) : "bin" === t2.kind ? t2.right && !t2.right.parenthesizedExpression && ("bin" === t2.right.kind ? (n2 = qn.precedence[t2.type], s2 = qn.precedence[t2.right.type], n2 && s2 && s2 <= n2 && (t2.type !== t2.right.type || !this.isRightAssociative(t2.type)) && (i2 = t2.right, t2.right = t2.right.left, this.swapLocations(t2, t2.left, t2.right, e2), i2.left = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.left, i2.right, e2), t2 = i2)) : "retif" === t2.right.kind && (n2 = qn.precedence[t2.type], s2 = qn.precedence["?"], n2 && s2 && s2 <= n2 && (i2 = t2.right, t2.right = t2.right.test, this.swapLocations(t2, t2.left, t2.right, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2))) : "silent" !== t2.kind && "cast" !== t2.kind || !t2.expr || t2.expr.parenthesizedExpression ? "unary" === t2.kind ? t2.what && !t2.what.parenthesizedExpression && ("bin" === t2.what.kind ? (i2 = t2.what, t2.what = t2.what.left, this.swapLocations(t2, t2, t2.what, e2), i2.left = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.left, i2.right, e2), t2 = i2) : "retif" === t2.what.kind && (i2 = t2.what, t2.what = t2.what.test, this.swapLocations(t2, t2, t2.what, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2)) : "retif" === t2.kind ? t2.falseExpr && "retif" === t2.falseExpr.kind && !t2.falseExpr.parenthesizedExpression && (i2 = t2.falseExpr, t2.falseExpr = i2.test, this.swapLocations(t2, t2.test, t2.falseExpr, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2) : "assign" === t2.kind ? t2.right && "bin" === t2.right.kind && !t2.right.parenthesizedExpression && (n2 = qn.precedence["="], s2 = qn.precedence[t2.right.type], n2 && s2 && s2 < n2 && (i2 = t2.right, t2.right = t2.right.left, i2.left = t2, this.swapLocations(i2, i2.left, t2.right, e2), t2 = i2)) : "expressionstatement" === t2.kind && this.swapLocations(t2, t2.expression, t2, e2) : "bin" === t2.expr.kind ? (i2 = t2.expr, t2.expr = t2.expr.left, this.swapLocations(t2, t2, t2.expr, e2), i2.left = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.left, i2.right, e2), t2 = i2) : "retif" === t2.expr.kind && (i2 = t2.expr, t2.expr = t2.expr.test, this.swapLocations(t2, t2, t2.expr, e2), i2.test = this.resolvePrecedence(t2, e2), this.swapLocations(i2, i2.test, i2.falseExpr, e2), t2 = i2), t2;
      }, qn.prototype.prepare = function(t2, e2, i2) {
        var n2 = null;
        (this.withPositions || this.withSource) && (n2 = i2.position());
        var s2 = this, r2 = function r3() {
          var o2 = null, a2 = Array.prototype.slice.call(arguments);
          if (a2.push(e2), s2.withPositions || s2.withSource) {
            var h2 = null;
            s2.withSource && (h2 = i2.lexer._input.substring(n2.offset, i2.prev[2])), o2 = new z(h2, n2, new m(i2.prev[0], i2.prev[1], i2.prev[2])), a2.push(o2);
          }
          t2 || (t2 = a2.shift());
          var l2 = s2[t2];
          if ("function" != typeof l2)
            throw new Error('Undefined node "' + t2 + '"');
          var c2 = Object.create(l2.prototype);
          return l2.apply(c2, a2), r3.instance = c2, r3.trailingComments && (c2.trailingComments = r3.trailingComments), "function" == typeof r3.postBuild && r3.postBuild(c2), i2.debug && delete qn.stack[r3.stackUid], s2.resolvePrecedence(c2, i2);
        };
        return i2.debug && (qn.stack || (qn.stack = {}, qn.stackUid = 1), qn.stack[++qn.stackUid] = { position: n2, stack: new Error().stack.split("\n").slice(3, 5) }, r2.stackUid = qn.stackUid), r2.setTrailingComments = function(t3) {
          r2.instance ? r2.instance.setTrailingComments(t3) : r2.trailingComments = t3;
        }, r2.destroy = function(t3) {
          e2 && (t3 ? t3.leadingComments ? t3.leadingComments = e2.concat(t3.leadingComments) : t3.leadingComments = e2 : i2._docIndex = i2._docs.length - e2.length), i2.debug && delete qn.stack[r2.stackUid];
        }, r2;
      }, qn.prototype.checkNodes = function() {
        var t2 = [];
        for (var e2 in qn.stack)
          qn.stack.hasOwnProperty(e2) && t2.push(qn.stack[e2]);
        return qn.stack = {}, t2;
      }, [tt, it, st, ot, ht, ct, dt, kt, yt, At, Nt, St, Lt, It, wt, Mt, Wt, Yt, $t, zt, Xt, qt, te, Ht, ie, Ut, re, ae, he, ce, _e, fe, ke, Ee, ye, Ae, Ne, q, Se, be, Oe, Re, De, Ue, Me, He, Ge, We, Ye, $e, Ke, Je, Ze, Et, ei, ni, ri, ai, li, pi, Ti, mi, Ei, X, yi, Ai, Ni, Si, Li, Ii, _t, wi, Pi, Bi, Mi, Hi, Vi, Qi, ji, Ki, ui, Ji, Zi, en, sn, ft, on, hn, cn, _n, pn, Tn, mn, xn, vn, gn, Cn, Sn, On, Rn, Dn, Un, Mn, Gn, Wn, Yn, $n, Kn, Jn].forEach(function(t2) {
        qn.prototype[t2.kind] = t2;
      });
      var Zn = qn;
      function ts(t2, e2) {
        for (var i2 = Object.keys(t2), n2 = i2.length; n2--; ) {
          var s2 = i2[n2], r2 = t2[s2];
          null === r2 ? delete e2[s2] : "function" == typeof r2 ? e2[s2] = r2.bind(e2) : Array.isArray(r2) ? e2[s2] = Array.isArray(e2[s2]) ? e2[s2].concat(r2) : r2 : e2[s2] = "object" == typeof r2 && "object" == typeof e2[s2] ? ts(r2, e2[s2]) : r2;
        }
        return e2;
      }
      var es = function(t2) {
        if ("function" == typeof this)
          return new this(t2);
        if (this.tokens = $, this.lexer = new k(this), this.ast = new Zn(), this.parser = new j(this.lexer, this.ast), t2 && "object" == typeof t2) {
          if (t2.parser && (t2.lexer || (t2.lexer = {}), t2.parser.version)) {
            if ("string" == typeof t2.parser.version) {
              var e2 = t2.parser.version.split(".");
              if (e2 = 100 * parseInt(e2[0]) + parseInt(e2[1]), isNaN(e2))
                throw new Error("Bad version number : " + t2.parser.version);
              t2.parser.version = e2;
            } else if ("number" != typeof t2.parser.version)
              throw new Error("Expecting a number for version");
            if (t2.parser.version < 500 || t2.parser.version > 900)
              throw new Error("Can only handle versions between 5.x to 8.x");
          }
          ts(t2, this), this.lexer.version = this.parser.version;
        }
      }, is = function(t2) {
        return "function" == typeof t2.write ? t2.toString() : t2;
      };
      es.create = function(t2) {
        return new es(t2);
      }, es.parseEval = function(t2, e2) {
        return new es(e2).parseEval(t2);
      }, es.prototype.parseEval = function(t2) {
        return this.lexer.mode_eval = true, this.lexer.all_tokens = false, t2 = is(t2), this.parser.parse(t2, "eval");
      }, es.parseCode = function(t2, e2, i2) {
        return "object" != typeof e2 || i2 || (i2 = e2, e2 = "unknown"), new es(i2).parseCode(t2, e2);
      }, es.prototype.parseCode = function(t2, e2) {
        return this.lexer.mode_eval = false, this.lexer.all_tokens = false, t2 = is(t2), this.parser.parse(t2, e2);
      }, es.tokenGetAll = function(t2, e2) {
        return new es(e2).tokenGetAll(t2);
      }, es.prototype.tokenGetAll = function(t2) {
        this.lexer.mode_eval = false, this.lexer.all_tokens = true, t2 = is(t2);
        var e2 = this.lexer.EOF, i2 = this.tokens.values;
        this.lexer.setInput(t2);
        for (var n2 = this.lexer.lex() || e2, s2 = []; n2 != e2; ) {
          var r2 = this.lexer.yytext;
          i2.hasOwnProperty(n2) && (r2 = [i2[n2], r2, this.lexer.yylloc.first_line]), s2.push(r2), n2 = this.lexer.lex() || e2;
        }
        return s2;
      };
      var ns = es, ss = $, rs = k, os = Zn, as = j, hs = ts, ls = es;
      ns.tokens = ss, ns.lexer = rs, ns.AST = os, ns.parser = as, ns.combine = hs, ns.default = ls;
      var cs = function(t2, e2, i2) {
        var n2 = i2 && "markdown" === i2.parentParser;
        if (!t2 && n2)
          return "";
        t2 = t2.replace(/\?>\r?\n<\?/g, "?>\n___PSEUDO_INLINE_PLACEHOLDER___<?");
        var s2, r2 = new ns({ parser: { extractDoc: true }, ast: { withPositions: true, withSource: true } }), o2 = -1 !== t2.indexOf("<?php"), a2 = n2 && !o2;
        try {
          s2 = a2 ? r2.parseEval(t2) : r2.parseCode(t2);
        } catch (t3) {
          throw t3 instanceof SyntaxError && "lineNumber" in t3 && (t3.loc = { start: { line: t3.lineNumber, column: t3.columnNumber } }, delete t3.lineNumber, delete t3.columnNumber), t3;
        }
        return s2.extra = { parseAsEval: a2 }, s2.comments.forEach(function(t3) {
          "\r" === t3.value[t3.value.length - 1] && (t3.value = t3.value.slice(0, -1), t3.loc.end.offset = t3.loc.end.offset - 1), "\n" === t3.value[t3.value.length - 1] && (t3.value = t3.value.slice(0, -1), t3.loc.end.offset = t3.loc.end.offset - 1);
        }), s2;
      }, us = n.default.util, _s = us.hasNewline, ds = us.skipEverythingButNewLine, ps = us.skipNewline, fs = us.isNextLineEmpty, Ts = us.isPreviousLineEmpty, ks = us.getNextNonSpaceNonCommentCharacterIndex, ms = n.default.version;
      function Es(t2, e2) {
        return parseInt(ms[0]) > 1 ? t2[e2] : t2;
      }
      var xs = {};
      function ys(t2) {
        return xs[t2];
      }
      [["or"], ["xor"], ["and"], ["=", "+=", "-=", "*=", "**=", "/=", ".=", "%=", "&=", "|=", "^=", "<<=", ">>="], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!==", "<>", "<=>"], ["<", ">", "<=", ">="], [">>", "<<"], ["+", "-", "."], ["*", "/", "%"], ["!"], ["instanceof"], ["++", "--", "~"], ["**"]].forEach(function(t2, e2) {
        t2.forEach(function(t3) {
          xs[t3] = e2;
        });
      });
      var vs = ["==", "!=", "===", "!==", "<>", "<=>"], As = ["*", "/", "%"], gs = [">>", "<<"];
      function Ns(t2) {
        return ["block", "program", "namespace", "class", "interface", "trait", "traituse", "declare"].includes(t2.kind);
      }
      function Cs(t2) {
        var e2 = t2.body;
        return e2 ? ("block" === e2.kind && (e2 = e2.children), e2[0]) : null;
      }
      function Ss(t2) {
        var e2 = t2.children || t2.body || t2.adaptations;
        return Array.isArray(e2) ? e2 : null;
      }
      function bs(t2) {
        var e2 = t2.getParentNode();
        return e2 ? Ss(e2) : null;
      }
      function Ls(t2) {
        return t2.length > 0 ? t2[t2.length - 1] : null;
      }
      function Os(t2) {
        var e2 = t2.getValue();
        if ("program" === e2.kind) {
          var i2 = Ss(e2);
          return !(!i2 || 0 === i2.length) && "inline" === i2[0].kind;
        }
        if ("switch" === e2.kind) {
          if (!e2.body)
            return false;
          var n2 = Ss(e2.body);
          if (0 === n2.length)
            return false;
          var s2 = A(n2, 1)[0];
          if (!s2.body)
            return false;
          var r2 = Ss(s2.body);
          return 0 !== r2.length && "inline" === r2[0].kind;
        }
        var o2 = Cs(e2);
        return !!o2 && "inline" === o2.kind;
      }
      var Is2 = ["__construct", "__destruct", "__call", "__callStatic", "__get", "__set", "__isset", "__unset", "__sleep", "__wakeup", "__toString", "__invoke", "__set_state", "__clone", "__debugInfo"].reduce(function(t2, e2) {
        return t2[e2.toLowerCase()] = e2, t2;
      }, {});
      var Rs = { printNumber: function(t2) {
        return t2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e)/, "");
      }, getPrecedence: ys, isBitwiseOperator: function(t2) {
        return !!gs[t2] || "|" === t2 || "^" === t2 || "&" === t2;
      }, shouldFlatten: function(t2, e2) {
        return ys(e2) === ys(t2) && ("**" !== t2 && ((!vs.includes(t2) || !vs.includes(e2)) && (!("%" === e2 && As.includes(t2) || "%" === t2 && As.includes(e2)) && ((e2 === t2 || !As.includes(e2) || !As.includes(t2)) && (!gs.includes(t2) || !gs.includes(e2))))));
      }, nodeHasStatement: Ns, getNodeListProperty: Ss, getParentNodeListProperty: bs, getLast: Ls, getPenultimate: function(t2) {
        return t2.length > 1 ? t2[t2.length - 2] : null;
      }, isLastStatement: function(t2) {
        var e2 = bs(t2);
        if (!e2)
          return true;
        var i2 = t2.getValue();
        return e2[e2.length - 1] === i2;
      }, getBodyFirstChild: Cs, lineShouldEndWithSemicolon: function(t2) {
        var e2 = t2.getValue(), i2 = t2.getParentNode();
        if (!i2)
          return false;
        if (["for", "foreach", "while", "do", "if", "switch"].includes(i2.kind) && "block" !== e2.kind && "if" !== e2.kind && (i2.body === e2 || i2.alternate === e2))
          return true;
        if (!Ns(i2))
          return false;
        if ("echo" === e2.kind && e2.shortForm)
          return false;
        if ("traituse" === e2.kind)
          return !e2.adaptations;
        if ("method" === e2.kind && e2.isAbstract)
          return true;
        if ("method" === e2.kind) {
          var n2 = t2.getParentNode();
          if (n2 && "interface" === n2.kind)
            return true;
        }
        return ["expressionstatement", "do", "usegroup", "classconstant", "propertystatement", "traitprecedence", "traitalias", "goto", "constantstatement", "global", "static", "echo", "unset", "return", "break", "continue", "throw"].includes(e2.kind);
      }, fileShouldEndWithHardline: function(t2) {
        var e2 = t2.getValue(), i2 = "program" === e2.kind, n2 = e2.children && Ls(e2.children);
        if (!i2)
          return false;
        if (n2 && ["halt", "inline"].includes(n2.kind))
          return false;
        if (n2 && ("declare" === n2.kind || "namespace" === n2.kind)) {
          var s2 = n2.children.length > 0 && Ls(n2.children);
          if (s2 && ["halt", "inline"].includes(s2.kind))
            return false;
        }
        return true;
      }, maybeStripLeadingSlashFromUse: function(t2) {
        var e2 = t2.replace(/^\\/, "");
        return -1 !== e2.indexOf("\\") ? e2 : t2;
      }, hasDanglingComments: function(t2) {
        return t2.comments && t2.comments.some(function(t3) {
          return !t3.leading && !t3.trailing;
        });
      }, hasLeadingComment: function(t2) {
        return t2.comments && t2.comments.some(function(t3) {
          return t3.leading;
        });
      }, hasTrailingComment: function(t2) {
        return t2.comments && t2.comments.some(function(t3) {
          return t3.trailing;
        });
      }, docShouldHaveTrailingNewline: function t2(e2) {
        var i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = e2.getNode(i2), s2 = e2.getNode(i2 + 1), r2 = e2.getNode(i2 + 2);
        if (!s2)
          return false;
        if (r2 && ["call", "new", "echo"].includes(r2.kind) && !["call", "array"].includes(s2.kind) || "parameter" === s2.kind) {
          var o2 = r2.arguments.length - 1, a2 = r2.arguments.indexOf(s2);
          return a2 !== o2;
        }
        if (r2 && "for" === r2.kind) {
          var h2 = r2.init.indexOf(s2);
          if (-1 !== h2)
            return h2 !== r2.init.length - 1;
          var l2 = r2.test.indexOf(s2);
          if (-1 !== l2)
            return l2 !== r2.test.length - 1;
          var c2 = r2.increment.indexOf(s2);
          if (-1 !== c2)
            return c2 !== r2.increment.length - 1;
        }
        if ("bin" === s2.kind)
          return s2.left === n2 || t2(e2, i2 + 1);
        if ("case" === s2.kind && s2.test === n2)
          return true;
        if ("staticvariable" === s2.kind) {
          var u2 = r2.variables.length - 1, _2 = r2.variables.indexOf(s2);
          return _2 !== u2;
        }
        if ("entry" === s2.kind) {
          if (s2.key === n2)
            return true;
          var d2 = r2.items.length - 1, p2 = r2.items.indexOf(s2);
          return p2 !== d2;
        }
        if (["call", "new"].includes(s2.kind)) {
          var f2 = s2.arguments.length - 1, T2 = s2.arguments.indexOf(n2);
          return T2 !== f2;
        }
        if ("echo" === s2.kind) {
          var k2 = s2.expressions.length - 1, m2 = s2.expressions.indexOf(n2);
          return m2 !== k2;
        }
        if ("array" === s2.kind) {
          var E2 = s2.items.length - 1, x2 = s2.items.indexOf(n2);
          return x2 !== E2;
        }
        return "retif" === s2.kind && t2(e2, i2 + 1);
      }, isLookupNode: function(t2) {
        return "propertylookup" === t2.kind || "staticlookup" === t2.kind || "offsetlookup" === t2.kind;
      }, isFirstChildrenInlineNode: Os, shouldPrintHardLineAfterStartInControlStructure: function(t2) {
        var e2 = t2.getValue();
        return !["try", "catch"].includes(e2.kind) && Os(t2);
      }, shouldPrintHardLineBeforeEndInControlStructure: function(t2) {
        var e2 = t2.getValue();
        if (["try", "catch"].includes(e2.kind))
          return true;
        if ("switch" === e2.kind) {
          var i2 = Ss(e2.body);
          if (0 === i2.length)
            return true;
          var n2 = Ls(i2);
          if (!n2.body)
            return true;
          var s2 = Ss(n2.body);
          return 0 === s2.length || "inline" !== s2[0].kind;
        }
        return !Os(t2);
      }, getAlignment: function(t2) {
        var e2 = t2.split("\n").pop();
        return e2.length - e2.trimLeft().length + 1;
      }, isProgramLikeNode: function(t2) {
        return ["program", "declare", "namespace"].includes(t2.kind);
      }, isReferenceLikeNode: function(t2) {
        return ["name", "parentreference", "selfreference", "staticreference"].includes(t2.kind);
      }, getNodeKindIncludingLogical: function(t2) {
        return "bin" === t2.kind && ["||", "&&"].includes(t2.type) ? "logical" : t2.kind;
      }, useDoubleQuote: function(t2, e2) {
        if (t2.isDoubleQuote === e2.singleQuote) {
          var i2 = t2.raw.slice("b" === t2.raw[0] ? 2 : 1, -1).match(/\\([$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})|\r?\n|'|"|\$/);
          return t2.isDoubleQuote ? i2 : !i2;
        }
        return t2.isDoubleQuote;
      }, hasEmptyBody: function(t2) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body", i2 = t2.getValue();
        return i2[e2] && i2[e2].children && 0 === i2[e2].children.length && (!i2[e2].comments || 0 === i2[e2].comments.length);
      }, isNextLineEmptyAfterNamespace: function(t2, e2, i2) {
        var n2 = i2(e2);
        return n2 = ds(t2, n2), n2 = ps(t2, n2), _s(t2, n2);
      }, shouldPrintHardlineBeforeTrailingComma: function(t2) {
        return "nowdoc" === t2.kind || "encapsed" === t2.kind && "heredoc" === t2.type || "entry" === t2.kind && ("nowdoc" === t2.value.kind || "encapsed" === t2.value.kind && "heredoc" === t2.value.type);
      }, isDocNode: function(t2) {
        return "nowdoc" === t2.kind || "encapsed" === t2.kind && "heredoc" === t2.type;
      }, getAncestorNode: function(t2, e2) {
        var i2 = function(t3, e3) {
          for (var i3, n2 = [].concat(e3), s2 = -1; i3 = t3.getParentNode(++s2); )
            if (-1 !== n2.indexOf(i3.kind))
              return s2;
          return -1;
        }(t2, e2);
        return -1 === i2 ? null : t2.getParentNode(i2);
      }, getNextNode: function(t2, e2) {
        var i2 = t2.getParentNode(), n2 = Ss(i2);
        if (!n2)
          return null;
        var s2 = n2.indexOf(e2);
        return -1 === s2 ? null : i2.children[s2 + 1];
      }, normalizeMagicMethodName: function(t2) {
        var e2 = t2.toLowerCase();
        return Is2[e2] ? Is2[e2] : t2;
      }, isPreviousLineEmpty: function(t2, e2, i2) {
        return Ts(t2, e2, Es(i2, "locStart"));
      }, isNextLineEmpty: function(t2, e2, i2) {
        return fs(t2, e2, Es(i2, "locEnd"));
      }, getNextNonSpaceNonCommentCharacterIndex: function(t2, e2, i2) {
        return ks(t2, e2, Es(i2, "locEnd"));
      } }, ws = n.default.util, Ds = ws.addLeadingComment, Ps = ws.addDanglingComment, Us = ws.addTrailingComment, Bs = ws.skipNewline, Ms = ws.hasNewline, Fs = ws.hasNewlineInRange, Hs = n.default.doc.builders, Gs = Hs.concat, Vs = Hs.join, Ws = Hs.indent, Qs = Hs.hardline, Ys = Hs.cursor, js = Hs.lineSuffix, $s = Hs.breakParent, zs = Rs.getNextNonSpaceNonCommentCharacterIndex, Ks = Rs.isNextLineEmpty, Xs = Rs.isPreviousLineEmpty, Js = Rs.isLookupNode;
      function qs(t2, e2) {
        var i2 = t2.children;
        0 === i2.length ? Ps(t2, e2) : Ds(i2[0], e2);
      }
      function Zs(t2, e2) {
        "block" === t2.kind ? qs(t2, e2) : Ds(t2, e2);
      }
      function tr(t2, e2, i2, n2, s2, r2) {
        var o2 = zs(t2, s2, r2), a2 = t2.charAt(o2);
        return e2 && "identifier" === e2.kind && i2 && ("function" === i2.kind || "method" === i2.kind) && ")" === a2 ? (Us(i2, s2), true) : !(!i2 || "function" !== i2.kind && "method" !== i2.kind || !n2 || "block" !== n2.kind) && (qs(n2, s2), true);
      }
      function er(t2, e2, i2, n2, s2, r2) {
        if (!i2 || "if" !== i2.kind || !n2)
          return false;
        var o2 = zs(t2, s2, r2);
        return ")" === t2.charAt(o2) ? (Us(e2, s2), true) : e2 === i2.body && n2 === i2.alternate ? (Ps(i2, s2), true) : "if" === n2.kind ? (Zs(n2.body, s2), true) : i2.body === n2 && (Ds(n2, s2), true);
      }
      function ir(t2, e2, i2) {
        if (t2 && ["class", "interface", "trait"].includes(t2.kind)) {
          if (e2 && t2.extends) {
            if (Array.isArray(t2.extends)) {
              if (t2.extends.some(function(t3) {
                if (e2 && e2 === t3)
                  return Ps(e2, i2), true;
              }))
                return true;
            } else if (e2 === t2.extends)
              return Ps(e2, i2), true;
          }
          if (e2 && t2.implements && t2.implements.some(function(t3) {
            if (e2 && e2 === t3)
              return Ps(e2, i2), true;
          }))
            return true;
          if (!(t2.body && t2.body.length > 0))
            return Ps(t2, i2), true;
        }
        return !!(e2 && "class" === e2.kind && e2.isAnonymous && e2.leadingComments && "commentblock" === i2.kind);
      }
      function nr(t2, e2, i2, n2, s2) {
        if (e2 && ("function" === e2.kind || "method" === e2.kind)) {
          for (var r2 = 0, o2 = 0; o2 < e2.arguments.length; o2++)
            r2 = s2.locEnd(e2.arguments[o2]) > r2 ? s2.locEnd(e2.arguments[o2]) : r2;
          var a2 = e2.body && s2.locStart(n2) > r2 && s2.locEnd(n2) < s2.locStart(e2.body), h2 = zs(t2, n2, s2);
          if (e2.type && a2 && ")" !== t2.charAt(h2))
            return s2.locEnd(n2) < s2.locStart(e2.type) ? (Ps(e2.type, n2), true) : (Us(e2.type, n2), true);
        }
        return false;
      }
      function sr(t2, e2, i2, n2, s2) {
        return !(!i2 || !["function", "method", "parameter"].includes(i2.kind)) && ("typereference" === e2.kind && "identifier" === n2.kind && (Us(e2, s2), true));
      }
      function rr(t2, e2) {
        return !(!t2 || !["label", "goto"].includes(t2.kind)) && (Us(t2, e2), true);
      }
      function or(t2, e2, i2, n2) {
        return i2 && "inline" === i2.kind ? (i2.leadingComments || (i2.leadingComments = []), i2.leadingComments.includes(n2) || i2.leadingComments.push(n2), true) : !(t2 || i2 || !e2 || "inline" !== e2.kind) && (Ps(e2, n2), true);
      }
      function ar(t2, e2, i2) {
        return !(!t2 || "try" !== t2.kind || !e2) && ("block" === e2.kind ? (qs(e2, i2), true) : "try" === e2.kind ? (Zs(e2.always, i2), true) : "catch" === e2.kind && (Zs(e2.body, i2), true));
      }
      function hr(t2, e2, i2, n2) {
        return i2 || e2 || !t2 || "namespace" !== t2.kind || t2.withBrackets ? !(e2 || !t2 || "namespace" !== t2.kind || t2.withBrackets) && (Ps(t2, n2), true) : (Us(t2, n2), true);
      }
      function lr(t2, e2, i2, n2) {
        return !(!t2 || "declare" !== t2.kind) && ((!e2 || "noop" !== e2.kind) && (i2 && t2.directives[0] !== i2 ? !(!i2 || !e2) && (Ds(i2, n2), true) : ("none" === t2.mode ? Us(t2, n2) : Ps(t2, n2), true)));
      }
      function cr(t2, e2, i2, n2, s2, r2) {
        if (!i2 || "while" !== i2.kind || !n2)
          return false;
        var o2 = zs(t2, s2, r2);
        return ")" === t2.charAt(o2) ? (Us(e2, s2), true) : "block" === n2.kind && (qs(n2, s2), true);
      }
      function ur(t2, e2) {
        return t2.getValue().printed = true, e2.printer.printComment(t2, e2);
      }
      function _r(t2, e2, i2) {
        return t2.getNode() === e2.cursorNode && t2.getValue() ? Gs([Ys, i2, Ys]) : i2;
      }
      var dr = { handleOwnLineComment: function(t2, e2, i2) {
        var n2 = t2.precedingNode, s2 = t2.enclosingNode, r2 = t2.followingNode;
        return tr(e2, n2, s2, r2, t2, i2) || function(t3, e3, i3) {
          if (t3 && Js(t3) && e3 && ["identifier", "variable", "encapsed"].includes(e3.kind))
            return Ds(t3, i3), true;
          return false;
        }(s2, r2, t2) || er(e2, n2, s2, r2, t2, i2) || cr(e2, n2, s2, r2, t2, i2) || ar(s2, r2, t2) || ir(s2, r2, t2) || sr(e2, n2, s2, r2, t2) || nr(e2, s2, r2, t2, i2) || function(t3, e3, i3, n3) {
          if (!i3 && t3 && ("for" === t3.kind || "foreach" === t3.kind))
            return t3.body && "block" !== t3.body.kind ? Ds(i3, n3) : Ds(t3, n3), true;
          return false;
        }(s2, 0, r2, t2) || or(s2, n2, r2, t2) || lr(s2, n2, r2, t2);
      }, handleEndOfLineComment: function(t2, e2, i2) {
        var n2 = t2.precedingNode, s2 = t2.enclosingNode, r2 = t2.followingNode;
        return function(t3, e3, i3, n3, s3) {
          if (!e3 && !n3 && i3 && "array" === i3.kind)
            return Us(i3, s3), true;
          return false;
        }(0, n2, s2, r2, t2) || function(t3, e3, i3, n3, s3) {
          if (i3 && "return" === i3.kind && !i3.expr)
            return Us(i3, s3), true;
          return false;
        }(0, 0, s2, 0, t2) || tr(e2, n2, s2, r2, t2, i2) || function(t3, e3, i3, n3, s3, r3) {
          var o2 = e3 && !Fs(s3, r3.locEnd(e3), r3.locStart(n3));
          if ((!e3 || !o2) && t3 && "retif" === t3.kind && i3)
            return Ds(i3, n3), true;
          return false;
        }(s2, n2, r2, t2, e2, i2) || er(e2, n2, s2, r2, t2, i2) || cr(e2, n2, s2, r2, t2, i2) || ar(s2, r2, t2) || ir(s2, r2, t2) || sr(e2, n2, s2, r2, t2) || nr(e2, s2, r2, t2, i2) || function(t3, e3) {
          if (t3 && "entry" === t3.kind)
            return Ds(t3, e3), true;
          return false;
        }(s2, t2) || function(t3, e3, i3) {
          if (e3 && "call" === e3.kind && t3 && e3.what === t3 && e3.arguments.length > 0)
            return Ds(e3.arguments[0], i3), true;
          return false;
        }(n2, s2, t2) || function(t3, e3, i3) {
          if (t3 && "assign" === t3.kind && e3) {
            var n3 = t3.loc.start.offset + t3.loc.source.indexOf("=");
            if (i3.loc.start.offset > n3)
              return Ds(e3, i3), true;
          }
          return false;
        }(s2, r2, t2) || or(s2, n2, r2, t2) || hr(s2, n2, r2, t2) || lr(s2, n2, r2, t2) || rr(s2, t2);
      }, handleRemainingComment: function(t2, e2, i2) {
        var n2 = t2.precedingNode, s2 = t2.enclosingNode, r2 = t2.followingNode;
        return er(e2, n2, s2, r2, t2, i2) || cr(e2, n2, s2, r2, t2, i2) || function(t3, e3, i3, n3) {
          var s3 = zs(t3, i3, n3);
          if (")" !== t3.charAt(s3))
            return false;
          if (e3 && ("function" === e3.kind || "closure" === e3.kind || "method" === e3.kind || "call" === e3.kind || "new" === e3.kind) && 0 === e3.arguments.length)
            return Ps(e3, i3), true;
          return false;
        }(e2, s2, t2, i2) || ir(s2, r2, t2) || function(t3, e3, i3) {
          if (t3 && "traituse" === t3.kind && t3.adaptations && !t3.adaptations.length)
            return Ps(t3, i3), true;
          return false;
        }(s2, 0, t2) || sr(e2, n2, s2, r2, t2) || nr(e2, s2, r2, t2, i2) || rr(s2, t2) || function(t3, e3, i3, n3) {
          if (e3 && "halt" === e3.kind)
            return Ps(e3, n3), true;
          if (t3 && "halt" === t3.kind)
            return Ps(t3, n3), true;
          return false;
        }(n2, s2, 0, t2) || function(t3, e3) {
          if (t3 && ("continue" === t3.kind || "break" === t3.kind) && !t3.label)
            return Us(t3, e3), true;
          return false;
        }(s2, t2) || or(s2, n2, r2, t2) || hr(s2, n2, r2, t2);
      }, getCommentChildNodes: function(t2) {
        return "object" != typeof t2 ? [] : function(t3) {
          return Object.keys(t3).filter(function(t4) {
            return "kind" !== t4 && "loc" !== t4 && "errors" !== t4 && "extra" !== t4 && "comments" !== t4 && "leadingComments" !== t4 && "enclosingNode" !== t4 && "precedingNode" !== t4 && "followingNode" !== t4;
          }).map(function(e2) {
            return t3[e2];
          });
        }(t2);
      }, canAttachComment: function(t2) {
        return t2.kind && "commentblock" !== t2.kind && "commentline" !== t2.kind;
      }, isBlockComment: function(t2) {
        return "commentblock" === t2.kind;
      }, printDanglingComments: function(t2, e2, i2, n2) {
        var s2 = [], r2 = t2.getValue();
        return r2 && r2.comments ? (t2.each(function(t3) {
          var i3 = t3.getValue();
          !i3 || i3.leading || i3.trailing || n2 && !n2(i3) || s2.push(ur(t3, e2));
        }, "comments"), 0 === s2.length ? "" : i2 ? Vs(Qs, s2) : Ws(Gs([Qs, Vs(Qs, s2)]))) : "";
      }, hasLeadingComment: function(t2) {
        return t2.comments && t2.comments.some(function(t3) {
          return t3.leading;
        });
      }, hasTrailingComment: function(t2) {
        return t2.comments && t2.comments.some(function(t3) {
          return t3.trailing;
        });
      }, hasLeadingOwnLineComment: function(t2, e2, i2) {
        return e2.comments && e2.comments.some(function(e3) {
          return e3.leading && Ms(t2, i2.locEnd(e3));
        });
      }, printComments: function(t2, e2) {
        var i2 = [];
        return t2.forEach(function(t3, n2, s2) {
          t3.printed = true;
          var r2 = s2.length === n2 + 1;
          i2.push(t3.value), r2 || i2.push(Qs), Ks(e2.originalText, t3, e2) && !r2 && i2.push(Qs);
        }), Gs(i2);
      }, printAllComments: function(t2, e2, i2, n2) {
        var s2 = t2.getValue(), r2 = e2(t2), o2 = s2 && s2.comments;
        if (!o2 || 0 === o2.length)
          return _r(t2, i2, r2);
        var a2 = [], h2 = [n2 ? ";" : "", r2];
        return t2.each(function(t3) {
          var e3 = t3.getValue(), n3 = e3.leading, s3 = e3.trailing;
          if (n3) {
            var r3 = function(t4, e4, i3) {
              var n4 = t4.getValue(), s4 = ur(t4, i3);
              if (!s4)
                return "";
              var r4 = i3.printer.isBlockComment && i3.printer.isBlockComment(n4);
              return Gs(r4 ? [s4, Ms(i3.originalText, i3.locEnd(n4)) ? Qs : " "] : [s4, Qs]);
            }(t3, 0, i2);
            if (!r3)
              return;
            a2.push(r3);
            var o3 = i2.originalText;
            Ms(o3, Bs(o3, i2.locEnd(e3))) && a2.push(Qs);
          } else
            s3 && h2.push(function(t4, e4, i3) {
              var n4 = t4.getValue(), s4 = ur(t4, i3);
              if (!s4)
                return "";
              var r4 = i3.printer.isBlockComment && i3.printer.isBlockComment(n4);
              if (Ms(i3.originalText, i3.locStart(n4), { backwards: true })) {
                var o4 = Xs(i3.originalText, n4, i3);
                return js(Gs([Qs, o4 ? Qs : "", s4]));
              }
              return Gs(r4 ? [" ", s4] : [js(Gs([" ", s4])), r4 ? "" : $s]);
            }(t3, 0, i2));
        }, "comments"), _r(t2, i2, Gs(a2.concat(h2)));
      } };
      function pr() {
      }
      pr.strictEqual = function() {
      };
      var fr = pr, Tr = Rs.getPrecedence, kr = Rs.shouldFlatten, mr = Rs.isBitwiseOperator;
      var Er = function(t2) {
        var e2 = t2.getParentNode();
        if (!e2)
          return false;
        var i2 = t2.getName(), n2 = t2.getNode();
        if (["program", "expressionstatement", "namespace", "declare", "block", "include", "print", "return", "echo"].includes(e2.kind))
          return false;
        switch (n2.kind) {
          case "pre":
          case "post":
            if ("unary" === e2.kind)
              return "pre" === n2.kind && ("+" === n2.type && "+" === e2.type || "-" === n2.type && "-" === e2.type);
          case "unary":
            switch (e2.kind) {
              case "unary":
                return n2.type === e2.type && ("+" === n2.type || "-" === n2.type);
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return "what" === i2 && e2.what === n2;
              case "bin":
                return "**" === e2.type && "left" === i2;
              default:
                return false;
            }
          case "bin":
            switch (e2.kind) {
              case "assign":
              case "retif":
                return ["and", "xor", "or"].includes(n2.type);
              case "silent":
              case "cast":
                return n2.parenthesizedExpression;
              case "pre":
              case "post":
              case "unary":
                return true;
              case "call":
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
                return "what" === i2 && e2.what === n2;
              case "bin":
                var s2 = e2.type, r2 = Tr(s2), o2 = n2.type, a2 = Tr(o2);
                return r2 > a2 || ("||" === s2 && "&&" === o2 || (r2 === a2 && "right" === i2 ? (fr.strictEqual(e2.right, n2), true) : r2 === a2 && !kr(s2, o2) || (r2 < a2 && "%" === o2 ? "+" === s2 || "-" === s2 : !!mr(s2))));
              default:
                return false;
            }
          case "propertylookup":
          case "staticlookup":
            switch (e2.kind) {
              case "call":
                return "what" === i2 && e2.what === n2 && n2.parenthesizedExpression;
              default:
                return false;
            }
          case "clone":
          case "new":
            switch (e2.kind) {
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return "what" === i2 && e2.what === n2;
              default:
                return false;
            }
          case "yield":
            switch (e2.kind) {
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return "what" === i2 && e2.what === n2;
              case "retif":
                return e2.test === n2;
              default:
                return !(!n2.key && !n2.value);
            }
          case "assign":
            return ("for" !== e2.kind || !e2.init.includes(n2) && !e2.increment.includes(n2)) && ("assign" !== e2.kind && ("static" !== e2.kind && (!["if", "do", "while", "foreach", "switch"].includes(e2.kind) && ("silent" !== e2.kind && "call" !== e2.kind))));
          case "retif":
            switch (e2.kind) {
              case "cast":
                return true;
              case "unary":
              case "bin":
              case "retif":
                return !("test" === i2 && !e2.trueExpr);
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return "what" === i2 && e2.what === n2;
              default:
                return false;
            }
          case "closure":
            switch (e2.kind) {
              case "call":
                return "what" === i2 && e2.what === n2;
              case "propertylookup":
                return true;
              default:
                return false;
            }
          case "silence":
          case "cast":
            return n2.parenthesizedExpression;
          case "string":
          case "array":
            switch (e2.kind) {
              case "propertylookup":
              case "staticlookup":
              case "offsetlookup":
              case "call":
                return (!["string", "array"].includes(n2.kind) || "offsetlookup" !== e2.kind) && ("what" === i2 && e2.what === n2);
              default:
                return false;
            }
          case "print":
          case "include":
            return "bin" === e2.kind;
        }
        return false;
      }, xr = n.default.doc.builders, yr = xr.breakParent, vr = xr.concat, Ar = xr.join, gr = xr.line, Nr = xr.lineSuffix, Cr = xr.group, Sr = xr.conditionalGroup, br = xr.indent, Lr = xr.dedent, Or = xr.ifBreak, Ir = xr.hardline, Rr = xr.softline, wr = xr.literalline, Dr = xr.align, Pr = xr.dedentToRoot, Ur = n.default.doc.utils.willBreak, Br = n.default.util, Mr = Br.isNextLineEmptyAfterIndex, Fr = Br.hasNewline, Hr = Br.hasNewlineInRange, Gr = Rs.getLast, Vr = Rs.getPenultimate, Wr = Rs.isLastStatement, Qr = Rs.lineShouldEndWithSemicolon, Yr = Rs.printNumber, jr = Rs.shouldFlatten, $r = Rs.maybeStripLeadingSlashFromUse, zr = Rs.fileShouldEndWithHardline, Kr = Rs.hasDanglingComments, Xr = Rs.hasLeadingComment, Jr = Rs.hasTrailingComment, qr = Rs.docShouldHaveTrailingNewline, Zr = Rs.isLookupNode, to = Rs.isFirstChildrenInlineNode, eo = Rs.shouldPrintHardLineAfterStartInControlStructure, io = Rs.shouldPrintHardLineBeforeEndInControlStructure, no = Rs.getAlignment, so = Rs.isProgramLikeNode, ro = Rs.getNodeKindIncludingLogical, oo = Rs.useDoubleQuote, ao = Rs.hasEmptyBody, ho = Rs.isNextLineEmptyAfterNamespace, lo = Rs.shouldPrintHardlineBeforeTrailingComma, co = Rs.isDocNode, uo = Rs.getAncestorNode, _o = Rs.isReferenceLikeNode, po = Rs.getNextNode, fo = Rs.normalizeMagicMethodName, To = Rs.getNextNonSpaceNonCommentCharacterIndex, ko = Rs.isNextLineEmpty;
      function mo(t2, e2) {
        return parseFloat(t2) >= parseFloat(e2);
      }
      function Eo(t2, e2) {
        return !!t2.trailingCommaPHP && mo(t2.phpVersion, e2);
      }
      function xo(t2) {
        switch (t2.braceStyle) {
          case "1tbs":
            return false;
          case "psr-2":
          default:
            return true;
        }
      }
      function yo(t2, e2, i2) {
        var n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        return vr([n2 ? "?" : "", "->", t2.call(i2, "offset")]);
      }
      function vo(t2, e2, i2) {
        return yo(t2, e2, i2, true);
      }
      function Ao(t2, e2, i2) {
        var n2 = t2.getValue(), s2 = !["variable", "identifier"].includes(n2.offset.kind);
        return vr(["::", s2 ? "{" : "", t2.call(i2, "offset"), s2 ? "}" : ""]);
      }
      function go(t2, e2, i2) {
        var n2 = t2.getValue(), s2 = n2.offset && "number" === n2.offset.kind || uo(t2, "encapsed");
        return vr(["[", n2.offset ? Cr(vr([br(vr([s2 ? "" : Rr, t2.call(i2, "offset")])), s2 ? "" : Rr])) : "", "]"]);
      }
      function No(t2) {
        return "array" === t2.kind && (t2.items.length > 0 || t2.comments) || "function" === t2.kind || "method" === t2.kind || "closure" === t2.kind;
      }
      function Co(t2) {
        var e2 = Gr(t2), i2 = Vr(t2);
        return !Xr(e2) && !Jr(e2) && No(e2) && (!i2 || i2.kind !== e2.kind);
      }
      function So(t2) {
        if (2 !== t2.length)
          return false;
        var e2 = A(t2, 2), i2 = e2[0], n2 = e2[1];
        return !(i2.comments && i2.comments.length || "function" !== i2.kind && "method" !== i2.kind && "closure" !== i2.kind || "retif" === n2.kind || No(n2));
      }
      function bo(t2, e2, i2) {
        var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "arguments", s2 = t2.getValue()[n2];
        if (0 === s2.length)
          return vr(["(", dr.printDanglingComments(t2, e2, true), ")"]);
        var r2 = false, o2 = false, a2 = s2.length - 1, h2 = t2.map(function(t3, n3) {
          var s3 = t3.getNode(), h3 = [i2(t3)];
          return n3 === a2 || (ko(e2.originalText, s3, e2) ? (0 === n3 && (o2 = true), r2 = true, h3.push(",", Ir, Ir)) : h3.push(",", gr)), vr(h3);
        }, n2), l2 = t2.getValue(), c2 = Gr(s2), u2 = Eo(e2, "7.3") && ["call", "new", "unset", "isset"].includes(l2.kind) || Eo(e2, "8.0") && ["function", "closure", "method", "arrowfunc"].includes(l2.kind) ? br(vr([c2 && lo(c2) ? Ir : "", ","])) : "";
        function _2() {
          return Cr(vr(["(", br(vr([gr, vr(h2)])), u2, gr, ")"]), { shouldBreak: true });
        }
        var d2 = So(s2), p2 = Co(s2);
        if (d2 || p2) {
          var f2, T2 = (d2 ? h2.slice(1).some(Ur) : h2.slice(0, -1).some(Ur)) || r2, k2 = 0;
          t2.each(function(t3) {
            d2 && 0 === k2 && (f2 = [vr([t3.call(function(t4) {
              return i2(t4, { expandFirstArg: true });
            }), h2.length > 1 ? "," : "", o2 ? Ir : gr, o2 ? Ir : ""])].concat(h2.slice(1))), p2 && k2 === s2.length - 1 && (f2 = h2.slice(0, -1).concat(t3.call(function(t4) {
              return i2(t4, { expandLastArg: true });
            }))), k2++;
          }, n2);
          var m2 = h2.some(Ur), E2 = vr(["(", vr(f2), ")"]);
          return vr([m2 ? yr : "", Sr([m2 ? Or(_2(), E2) : E2, vr(d2 ? ["(", Cr(f2[0], { shouldBreak: true }), vr(f2.slice(1)), ")"] : ["(", vr(h2.slice(0, -1)), Cr(Gr(f2), { shouldBreak: true }), ")"]), Cr(vr(["(", br(vr([gr, vr(h2)])), Or(u2), gr, ")"]), { shouldBreak: true })], { shouldBreak: T2 })]);
        }
        return Cr(vr(["(", br(vr([Rr, vr(h2)])), Or(u2), Rr, ")"]), { shouldBreak: h2.some(Ur) || r2 });
      }
      function Lo(t2) {
        return "array" === t2.kind && 0 !== t2.items.length;
      }
      function Oo(t2) {
        return "array" === t2.right.kind && 0 !== t2.right.items.length;
      }
      function Io(t2, e2, i2) {
        var n2 = t2.getValue();
        switch (n2.kind) {
          case "propertylookup":
            return yo(t2, e2, i2);
          case "nullsafepropertylookup":
            return vo(t2, e2, i2);
          case "staticlookup":
            return Ao(t2, 0, i2);
          case "offsetlookup":
            return go(t2, 0, i2);
          default:
            return "Have not implemented lookup kind ".concat(n2.kind, " yet.");
        }
      }
      function Ro(t2) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = e2.opening, n2 = void 0 === i2 || i2;
        if ("heredoc" === t2.type)
          return n2 ? "<<<".concat(t2.label) : t2.label;
        var s2 = { string: '"', shell: "`" };
        return s2[t2.type] ? s2[t2.type] : "Unimplemented encapsed type ".concat(t2.type);
      }
      function wo(t2, e2, i2) {
        var n2 = [], s2 = [];
        return t2.each(function(t3) {
          n2.push(vr(s2)), n2.push(Cr(i2(t3))), s2 = [",", gr], t3.getValue() && ko(e2.originalText, t3.getValue(), e2) && s2.push(Rr);
        }, "items"), vr(n2);
      }
      function Do(t2, e2) {
        if (0 === e2.length)
          return t2;
        var i2 = 0;
        return e2.reduce(function(e3, n2) {
          var s2 = n2.start, r2 = n2.end, o2 = n2.alignment, a2 = n2.before, h2 = n2.after, l2 = vr([a2 || "", vr(t2.slice(s2, r2)), h2 || ""]), c2 = e3.concat(t2.slice(i2, s2), o2 ? Pr(Cr(vr([Dr(new Array(o2).join(" "), l2)]))) : Cr(l2), r2 === t2.length - 1 ? t2.slice(r2) : "");
          return i2 = r2, c2;
        }, []);
      }
      function Po(t2, e2, i2) {
        var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "children", s2 = t2.getValue(), r2 = t2.getParentNode(), o2 = -1, a2 = [], h2 = [];
        t2.map(function(l3, c3) {
          var u3 = l3.getValue(), _3 = "inline" === u3.kind, d3 = i2(l3), p3 = s2[n2], f3 = p3[c3 + 1], T3 = !Wr(l3) && !_3 && (f3 && "case" === f3.kind ? !to(t2) : f3 && "inline" !== f3.kind), k3 = vr([d3, T3 ? Ir : "", T3 && ko(e2.originalText, u3, e2) ? Ir : ""]), m3 = 0 === c3, E3 = p3.length - 1 === c3, x2 = "block" === s2.kind && r2 && ["function", "closure", "method", "try", "catch"].includes(r2.kind), y2 = x2 && m3 ? "" : " ";
          if (_3 || !_3 && E3 && o2 >= 0) {
            var v2 = o2;
            if (_3 && (o2 = c3), _3 && !m3 || !_3 && E3) {
              var A2 = (_3 ? v2 : o2) + 1, g2 = E3 && !_3 ? c3 + 1 : c3, N2 = p3[_3 ? v2 : o2], C2 = N2 ? no(N2.raw) : "", S2 = g2 - A2 > 1, b2 = S2 ? x2 && !N2 || so(s2) && 0 === A2 ? "" : Ir : "", L2 = S2 && "halt" !== u3.kind ? x2 && E3 ? "" : Ir : "";
              S2 && (y2 = ""), h2.push({ start: A2, end: g2, alignment: C2, before: b2, after: L2 });
            }
          }
          if (_3) {
            var O2 = f3 && "echo" === f3.kind && f3.shortForm ? "<?=" : "<?php", I2 = u3.leadingComments && u3.leadingComments.length ? vr([m3 && "namespace" !== s2.kind && !x2 ? "<?php" : "", "namespace" !== s2.kind && x2 ? "" : Ir, dr.printComments(u3.leadingComments, e2), Ir, "?>"]) : so(s2) && m3 && "namespace" !== s2.kind ? "" : vr([y2, "?>"]), R2 = t2.getNode(c3 + 1), w2 = R2 && R2.children && R2.children.length, D2 = u3.comments && u3.comments.length ? vr([O2, Ir, w2 ? dr.printComments(u3.comments, e2) : "", Ir, w2 ? "?>" : ""]) : so(s2) && E3 ? "" : vr([O2, " "]);
            k3 = vr([I2, k3, D2]);
          }
          a2.push(k3);
        }, n2);
        var l2 = Do(a2, h2);
        if ("program" === s2.kind && !s2.extra.parseAsEval) {
          var c2 = [], u2 = A(s2.children, 1), _2 = u2[0], d2 = !_2 || "inline" !== _2.kind;
          if (d2) {
            var p2 = e2.originalText.trim().match(/^<\?(php|=)(\s+)?\S/), f2 = vr([p2 && p2[2] && p2[2].includes("\n") ? vr([Ir, p2[2].split("\n").length > 2 ? Ir : ""]) : " ", s2.comments ? dr.printComments(s2.comments, e2) : ""]), T2 = _2 && "echo" === _2.kind && _2.shortForm;
            c2.push(vr([T2 ? "<?=" : "<?php", f2]));
          }
          c2.push(vr(l2));
          var k2 = e2.originalText.trim().endsWith("?>");
          if (k2) {
            var m2 = Gr(s2.children), E2 = m2 ? vr([Hr(e2.originalText.trimEnd(), e2.locEnd(m2), e2.locEnd(s2)) ? Ir : " ", ko(e2.originalText, m2, e2) ? Ir : ""]) : s2.comments ? Ir : "";
            c2.push(Nr(vr([E2, "?>"])));
          }
          return vr(c2);
        }
        return vr(l2);
      }
      function Uo(t2, e2, i2, n2) {
        return vr(t2.map(function(t3) {
          var n3 = [];
          return n3.push(i2(t3)), Wr(t3) || (n3.push(Ir), ko(e2.originalText, t3.getValue(), e2) && n3.push(Ir)), vr(n3);
        }, n2));
      }
      function Bo(t2, e2, i2) {
        var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "extends", s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : " ", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : " ", o2 = t2.getValue(), a2 = Kr(o2[n2]) ? vr([Ir, t2.call(function(t3) {
          return dr.printDanglingComments(t3, e2, true);
        }, n2), Ir]) : s2, h2 = Array.isArray(o2[n2]) ? Cr(vr([Ar(",", t2.map(function(t3) {
          var n3 = i2(t3);
          return Kr(t3.getValue()) ? vr([Ir, dr.printDanglingComments(t3, e2, true), Ir, n3]) : vr([r2, n3]);
        }, n2))])) : vr([r2, t2.call(i2, n2)]);
        return br(vr([a2, n2, Ur(a2) ? br(h2) : h2]));
      }
      function Mo(t2, e2, i2) {
        var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, s2 = n2.inline, r2 = void 0 !== s2 && s2, o2 = [];
        return t2.getValue().attrGroups ? (t2.each(function(t3) {
          var n3 = ["#["];
          o2.length > 0 && o2.push(r2 ? " " : Ir), n3.push(Or(Rr)), t3.each(function(t4) {
            var s3 = t4.getValue();
            n3.length > 2 && n3.push(",", Or(Rr, " "));
            var r3 = [s3.name];
            s3.args.length > 0 && r3.push(bo(t4, e2, i2, "args")), n3.push(Cr(vr(r3)));
          }, "attrs"), o2.push(Cr(vr([br(vr(n3)), Or(Rr), "]", Rr, r2 ? " " : ""])));
        }, "attrGroups"), 0 === o2.length ? [] : [vr([].concat(o2, [r2 ? "" : Ir]))]) : [];
      }
      function Fo(t2, e2, i2) {
        var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "body", s2 = t2.getValue();
        if (!s2[n2])
          return ";";
        var r2 = t2.call(i2, n2);
        return vr([s2.shortForm ? ":" : " {", br(vr(["block" !== s2[n2].kind || s2[n2].children && s2[n2].children.length > 0 || s2[n2].comments && s2[n2].comments.length > 0 ? vr([eo(t2) ? "switch" === s2.kind ? " " : "" : Ir, r2]) : ""])), "if" === s2.kind && "body" === n2 ? "" : vr([io(t2) ? Ir : "", s2.shortForm ? vr(["end", s2.kind, ";"]) : "}"])]);
      }
      function Ho(t2, e2, i2, n2, s2, r2, o2) {
        if (!n2)
          return e2;
        var a2 = Go(t2, n2, s2, r2, o2);
        return Cr(vr([e2, i2, a2]));
      }
      function Go(t2, e2, i2, n2, s2) {
        var r2 = n2 ? "&" : "";
        if (dr.hasLeadingOwnLineComment(s2.originalText, e2, s2))
          return br(vr([Ir, r2, i2]));
        var o2 = "cast" === e2.kind ? e2.expr : e2;
        return "bin" === o2.kind && !Oo(o2) || "retif" === o2.kind && (!o2.trueExpr && !Lo(o2.falseExpr) || "bin" === o2.test.kind && !Oo(o2.test)) || ("variable" === t2.kind || "string" === t2.kind || Zr(t2)) && ("string" === o2.kind && !Vo(o2) || function t3(e3) {
          return !!Zr(e3) && (!("variable" !== e3.what.kind && !_o(e3.what)) || t3(e3.what));
        }(o2)) ? Cr(br(vr([gr, r2, i2]))) : vr([" ", r2, i2]);
      }
      function Vo(t2) {
        return t2.raw.includes("\n");
      }
      function Wo(t2, e2, i2) {
        return ("string" === t2.kind || "encapsed" === t2.kind && ("string" === t2.type || "shell" === t2.type)) && Vo(t2) && !Fr(e2, i2.locStart(t2), { backwards: true });
      }
      var Qo = function(t2, e2, i2) {
        var n2 = t2.getValue();
        if (!n2)
          return "";
        if ("string" == typeof n2)
          return n2;
        var s2 = function(t3, e3, i3) {
          var n3 = t3.getValue();
          switch (n3.kind) {
            case "program":
              return Cr(vr([Po(t3, e3, i3), dr.printDanglingComments(t3, e3, true, function(t4) {
                return !t4.printed;
              })]));
            case "expressionstatement":
              return t3.call(i3, "expression");
            case "block":
              return vr([Po(t3, e3, i3), dr.printDanglingComments(t3, e3, true)]);
            case "declare":
              var s3 = function(t4) {
                return Ar(", ", t4.map(function(t5) {
                  return vr([i3(t5)]);
                }, "directives"));
              };
              if (["block", "short"].includes(n3.mode))
                return vr(["declare(", s3(t3), ")", "block" === n3.mode ? " {" : ":", n3.children.length > 0 ? br(vr([Ir, Po(t3, e3, i3)])) : "", dr.printDanglingComments(t3, e3), Ir, "block" === n3.mode ? "}" : "enddeclare;"]);
              var r3 = po(t3, n3);
              return vr(["declare(", s3(t3), ")", r3 && "inline" === r3.kind ? "" : ";"]);
            case "declaredirective":
              return vr([t3.call(i3, "key"), "=", t3.call(i3, "value")]);
            case "namespace":
              return vr(["namespace ", n3.name && "string" == typeof n3.name ? vr([n3.name, n3.withBrackets ? " " : ""]) : "", n3.withBrackets ? "{" : ";", Kr(n3) ? vr([" ", dr.printDanglingComments(t3, e3, true)]) : "", n3.children.length > 0 ? n3.withBrackets ? br(vr([Ir, Po(t3, e3, i3)])) : vr(["inline" === n3.children[0].kind ? "" : vr([Ir, ho(e3.originalText, n3, e3.locStart) ? Ir : ""]), Po(t3, e3, i3)]) : "", n3.withBrackets ? vr([Ir, "}"]) : ""]);
            case "usegroup":
              return Cr(vr(["use ", n3.type ? vr([n3.type, " "]) : "", br(vr([n3.name ? vr([$r(n3.name), "\\{", Rr]) : "", Ar(vr([",", gr]), t3.map(function(t4) {
                return vr([i3(t4)]);
              }, "items"))])), n3.name ? vr([Or(Eo(e3, "7.2") ? "," : ""), Rr, "}"]) : ""]));
            case "useitem":
              return vr([n3.type ? vr([n3.type, " "]) : "", $r(n3.name), Kr(n3) ? vr([" ", dr.printDanglingComments(t3, e3, true)]) : "", n3.alias ? vr([" as ", t3.call(i3, "alias")]) : ""]);
            case "class":
            case "interface":
            case "trait":
              return function(t4, e4, i4) {
                var n4 = t4.getValue(), s4 = "class" === n4.kind && n4.isAnonymous, r4 = Mo(t4, e4, i4, { inline: s4 }), o4 = s4 ? [] : g(r4);
                n4.isFinal && o4.push("final ");
                n4.isAbstract && o4.push("abstract ");
                o4.push(s4 ? "" : n4.kind), n4.name && o4.push(" ", t4.call(i4, "name"));
                n4.extends && n4.implements ? o4.push(Sr([vr([Bo(t4, e4, i4, "extends"), Bo(t4, e4, i4, "implements")]), vr([Bo(t4, e4, i4, "extends"), Bo(t4, e4, i4, "implements", " ", Ir)]), vr([Bo(t4, e4, i4, "extends", Ir, " "), Bo(t4, e4, i4, "implements", Ir, n4.implements.length > 1 ? Ir : " ")])], { shouldBreak: Kr(n4.extends) })) : (n4.extends && o4.push(Sr([Bo(t4, e4, i4, "extends"), Bo(t4, e4, i4, "extends", " ", Ir), Bo(t4, e4, i4, "extends", Ir, n4.extends.length > 1 ? Ir : " ")])), n4.implements && o4.push(Sr([Bo(t4, e4, i4, "implements"), Bo(t4, e4, i4, "implements", " ", Ir), Bo(t4, e4, i4, "implements", Ir, n4.implements.length > 1 ? Ir : " ")])));
                var a3 = Cr(vr([Cr(vr(o4)), xo(e4) ? s4 ? gr : Ir : " "])), h3 = n4.body && 0 === n4.body.length && !Kr(n4), l3 = vr(["{", br(vr([h3 ? "" : Ir, Uo(t4, e4, i4, "body")])), dr.printDanglingComments(t4, e4, true), s4 && h3 ? Rr : Ir, "}"]);
                return vr([a3, l3]);
              }(t3, e3, i3);
            case "traitprecedence":
              return vr([t3.call(i3, "trait"), "::", t3.call(i3, "method"), " insteadof ", Ar(", ", t3.map(i3, "instead"))]);
            case "traitalias":
              return vr([n3.trait ? vr([t3.call(i3, "trait"), "::"]) : "", n3.method ? t3.call(i3, "method") : "", " as ", Ar(" ", [].concat(g(n3.visibility ? [n3.visibility] : []), g(n3.as ? [t3.call(i3, "as")] : [])))]);
            case "traituse":
              return Cr(vr(["use ", br(Cr(Ar(vr([",", gr]), t3.map(i3, "traits")))), n3.adaptations ? vr([" {", n3.adaptations.length > 0 ? vr([br(vr([Ir, Uo(t3, e3, i3, "adaptations")])), Ir]) : Kr(n3) ? vr([gr, dr.printDanglingComments(t3, e3, true), gr]) : "", "}"]) : ""]));
            case "function":
            case "closure":
            case "method":
              return function(t4, e4, i4) {
                var n4 = t4.getValue(), s4 = g(Mo(t4, e4, i4, { inline: "closure" === n4.kind }));
                n4.isFinal && s4.push("final ");
                n4.isAbstract && s4.push("abstract ");
                n4.visibility && s4.push(n4.visibility, " ");
                n4.isStatic && s4.push("static ");
                s4.push("function "), n4.byref && s4.push("&");
                n4.name && s4.push(t4.call(i4, "name"));
                s4.push(bo(t4, e4, i4)), n4.uses && n4.uses.length > 0 && s4.push(Cr(vr([" use ", bo(t4, e4, i4, "uses")])));
                n4.type && s4.push(vr([": ", Kr(n4.type) ? vr([t4.call(function(t5) {
                  return dr.printDanglingComments(t5, e4, true);
                }, "type"), " "]) : "", n4.nullable ? "?" : "", t4.call(i4, "type")]));
                var r4 = vr(s4);
                if (!n4.body)
                  return r4;
                var o4 = "closure" === n4.kind, a3 = vr(["{", br(vr([ao(t4) ? "" : Ir, t4.call(i4, "body")])), o4 && ao(t4) ? "" : Ir, "}"]);
                if (o4)
                  return vr([r4, " ", a3]);
                if (0 === n4.arguments.length)
                  return vr([r4, xo(e4) ? Ir : " ", a3]);
                if (s4.some(Ur))
                  return vr([r4, " ", a3]);
                return Sr([vr([r4, xo(e4) ? Ir : " ", a3]), vr([r4, " ", a3])]);
              }(t3, e3, i3);
            case "arrowfunc":
              return vr([].concat(g(Mo(t3, e3, i3, { inline: true })), [n3.isStatic ? "static " : "", "fn", bo(t3, e3, i3), n3.type ? vr([": ", n3.nullable ? "?" : "", t3.call(i3, "type")]) : "", " => ", t3.call(i3, "body")]));
            case "parameter":
              var o3 = "";
              1 === n3.flags ? o3 = "public " : 2 === n3.flags ? o3 = "protected " : 4 === n3.flags && (o3 = "private ");
              var a2 = vr([].concat(g(Mo(t3, e3, i3, { inline: true })), [o3, n3.nullable ? "?" : "", n3.type ? vr([t3.call(i3, "type"), " "]) : "", n3.byref ? "&" : "", n3.variadic ? "..." : "", "$", t3.call(i3, "name")]));
              return n3.value ? Cr(vr([a2, Kr(n3) ? " " : "", dr.printDanglingComments(t3, e3, true), vr([" =", Go(n3.name, n3.value, t3.call(i3, "value"), false, e3)])])) : a2;
            case "variadic":
              return vr(["...", t3.call(i3, "what")]);
            case "property":
              return Cr(vr([n3.type ? vr([n3.nullable ? "?" : "", t3.call(i3, "type"), " "]) : "", "$", t3.call(i3, "name"), n3.value ? vr([" =", Go(n3.name, n3.value, t3.call(i3, "value"), false, e3)]) : ""]));
            case "propertystatement":
              var h2 = [];
              t3.map(function(t4) {
                return h2.push.apply(h2, g(Mo(t4, e3, i3)));
              }, "properties");
              var l2, c2 = t3.map(function(t4) {
                return i3(t4);
              }, "properties"), u2 = n3.properties.some(function(t4) {
                return t4.value;
              });
              if (1 !== c2.length || n3.properties[0].comments)
                c2.length > 0 && (l2 = br(c2[0]));
              else
                l2 = A(c2, 1)[0];
              var _2 = n3.visibility || null === n3.visibility;
              return Cr(vr([].concat(h2, [_2 ? vr([null === n3.visibility ? "var" : n3.visibility, ""]) : "", n3.isStatic ? vr([_2 ? " " : "", "static"]) : "", l2 ? vr([" ", l2]) : "", br(vr(c2.slice(1).map(function(t4) {
                return vr([",", u2 ? Ir : gr, t4]);
              })))])));
            case "if":
              var d2 = [], p2 = Fo(t3, e3, i3, "body"), f2 = Cr(vr(["if (", Cr(vr([br(vr([Rr, t3.call(i3, "test")])), Rr])), ")", p2]));
              if (d2.push(f2, to(t3) || !n3.body ? "" : Ir), n3.alternate) {
                d2.push(n3.shortForm ? "" : "} ");
                var T2 = Jr(n3.body) && n3.body.comments.some(function(t4) {
                  return t4.trailing && !dr.isBlockComment(t4);
                }) || function(t4) {
                  if (!t4.comments)
                    return false;
                  var e4 = Gr(t4.comments.filter(function(t5) {
                    return !t5.leading && !t5.trailing;
                  }));
                  return e4 && !dr.isBlockComment(e4);
                }(n3), k2 = !T2;
                d2.push(k2 ? "" : Ir), Kr(n3) && d2.push(ko(e3.originalText, n3.body, e3) ? Ir : "", dr.printDanglingComments(t3, e3, true), T2 ? Ir : " "), d2.push("else", Cr("if" === n3.alternate.kind ? t3.call(i3, "alternate") : Fo(t3, e3, i3, "alternate")));
              } else
                d2.push(n3.body ? n3.shortForm ? "endif;" : "}" : "");
              return vr(d2);
            case "do":
              return vr(["do", Fo(t3, e3, i3, "body"), " while (", Cr(vr([br(vr([Rr, t3.call(i3, "test")])), Rr])), ")"]);
            case "while":
            case "switch":
              return Cr(vr([n3.kind, " (", Cr(vr([br(vr([Rr, t3.call(i3, "test")])), Rr])), ")", Fo(t3, e3, i3, "body")]));
            case "for":
              var m2 = Fo(t3, e3, i3, "body"), E2 = dr.printDanglingComments(t3, e3, true), x2 = E2 ? vr([E2, Rr]) : "";
              return n3.init.length || n3.test.length || n3.increment.length ? vr([x2, Cr(vr(["for (", Cr(vr([br(vr([Rr, Cr(vr([Ar(vr([",", gr]), t3.map(i3, "init"))])), ";", gr, Cr(vr([Ar(vr([",", gr]), t3.map(i3, "test"))])), ";", gr, Cr(Ar(vr([",", gr]), t3.map(i3, "increment")))])), Rr])), ")", m2]))]) : vr([x2, Cr(vr(["for (;;)", m2]))]);
            case "foreach":
              var y2 = Fo(t3, e3, i3, "body"), v2 = dr.printDanglingComments(t3, e3, true), N2 = v2 ? vr([v2, Rr]) : "";
              return vr([N2, Cr(vr(["foreach (", Cr(vr([br(vr([Rr, t3.call(i3, "source"), gr, "as ", Cr(n3.key ? br(Ar(vr([" =>", gr]), [t3.call(i3, "key"), t3.call(i3, "value")])) : t3.call(i3, "value"))])), Rr])), ")", y2]))]);
            case "try":
              var C2 = [];
              return C2.push("try", Fo(t3, e3, i3, "body")), n3.catches && C2.push(vr(t3.map(i3, "catches"))), n3.always && C2.push(" finally", Fo(t3, e3, i3, "always")), vr(C2);
            case "catch":
              return vr([" catch", n3.what ? vr([" (", Ar(" | ", t3.map(i3, "what")), n3.variable ? vr([" ", t3.call(i3, "variable")]) : "", ")"]) : "", Fo(t3, e3, i3, "body")]);
            case "case":
              return vr([n3.test ? vr(["case ", n3.test.comments ? br(t3.call(i3, "test")) : t3.call(i3, "test"), ":"]) : "default:", n3.body && n3.body.children && n3.body.children.length ? br(vr([to(t3) ? "" : Ir, t3.call(i3, "body")])) : ""]);
            case "break":
            case "continue":
              return n3.level && ("number" === n3.level.kind && "1" !== n3.level.value) ? vr(["".concat(n3.kind, " "), t3.call(i3, "level")]) : n3.kind;
            case "call":
              return 1 === n3.arguments.length && Wo(n3.arguments[0], e3.originalText, e3) ? vr([t3.call(i3, "what"), vr(["(", Ar(", ", t3.map(i3, "arguments")), ")"])]) : Zr(n3.what) ? function(t4, e4, i4) {
                var n4 = [];
                function s4(t5) {
                  var i5 = e4.originalText, n5 = To(i5, t5, e4);
                  return ")" === i5.charAt(n5) ? Mr(i5, n5 + 1, e4) : ko(i5, t5, e4);
                }
                function r4(t5) {
                  var o5 = t5.getValue();
                  if ("call" !== o5.kind || !Zr(o5.what) && "call" !== o5.what.kind)
                    if (Zr(o5)) {
                      var a4 = null;
                      a4 = "propertylookup" === o5.kind ? yo(t5, e4, i4) : "nullsafepropertylookup" === o5.kind ? vo(t5, e4, i4) : "staticlookup" === o5.kind ? Ao(t5, e4, i4) : go(t5, e4, i4), n4.unshift({ node: o5, needsParens: Er(t5), printed: dr.printAllComments(t5, function() {
                        return a4;
                      }, e4) }), t5.call(function(t6) {
                        return r4(t6);
                      }, "what");
                    } else
                      n4.unshift({ node: o5, printed: t5.call(i4) });
                  else
                    n4.unshift({ node: o5, printed: vr([dr.printAllComments(t5, function() {
                      return vr([bo(t5, e4, i4)]);
                    }, e4), s4(o5) ? Ir : ""]) }), t5.call(function(t6) {
                      return r4(t6);
                    }, "what");
                }
                var o4 = t4.getValue();
                n4.unshift({ node: o4, printed: bo(t4, e4, i4) }), t4.call(function(t5) {
                  return r4(t5);
                }, "what");
                for (var a3 = 0; a3 < n4.length; ++a3)
                  "call" === n4[a3].node.kind && n4[a3 - 1] && ["propertylookup", "staticlookup"].includes(n4[a3 - 1].node.kind) && n4[a3 - 1].needsParens && (n4[0].printed = vr(["(", n4[0].printed]), n4[a3 - 1].printed = vr([n4[a3 - 1].printed, ")"]));
                for (var h3 = [], l3 = [n4[0]], c3 = 1; c3 < n4.length && ("call" === n4[c3].node.kind || Zr(n4[c3].node) && n4[c3].node.offset && "number" === n4[c3].node.offset.kind); ++c3)
                  l3.push(n4[c3]);
                if ("call" !== n4[0].node.kind)
                  for (; c3 + 1 < n4.length && (Zr(n4[c3].node) && Zr(n4[c3 + 1].node)); ++c3)
                    l3.push(n4[c3]);
                h3.push(l3), l3 = [];
                for (var u3 = false; c3 < n4.length; ++c3) {
                  if (u3 && Zr(n4[c3].node)) {
                    if ("offsetlookup" === n4[c3].node.kind && n4[c3].node.offset && "number" === n4[c3].node.offset.kind) {
                      l3.push(n4[c3]);
                      continue;
                    }
                    h3.push(l3), l3 = [], u3 = false;
                  }
                  "call" === n4[c3].node.kind && (u3 = true), l3.push(n4[c3]), n4[c3].node.comments && dr.hasTrailingComment(n4[c3].node) && (h3.push(l3), l3 = [], u3 = false);
                }
                l3.length > 0 && h3.push(l3);
                function _3(t5) {
                  var i5 = t5[1].length && "offsetlookup" === t5[1][0].node.kind;
                  if (1 === t5[0].length) {
                    var n5 = t5[0][0].node;
                    return "variable" === n5.kind && ("this" === n5.name || d3 && s5(n5.name)) || _o(n5);
                  }
                  function s5(t6) {
                    return t6.length < e4.tabWidth;
                  }
                  var r5 = Gr(t5[0]).node;
                  return Zr(r5) && ("identifier" === r5.offset.kind || "variable" === r5.offset.kind) && i5;
                }
                var d3 = "expressionstatement" === t4.getParentNode().kind, p3 = h3.length >= 2 && !h3[1][0].node.comments && _3(h3);
                function f3(t5) {
                  for (var e5 = [], i5 = 0; i5 < t5.length; i5++)
                    t5[i5 + 1] && t5[i5 + 1].needsParens ? (e5.push("(", t5[i5].printed, t5[i5 + 1].printed, ")"), i5++) : e5.push(t5[i5].printed);
                  return vr(e5);
                }
                function T3(t5) {
                  return 0 === t5.length ? "" : br(Cr(vr([Ir, Ar(Ir, t5.map(f3))])));
                }
                var k3 = h3.map(f3), m3 = vr(k3), E3 = p3 ? 3 : 2, x3 = h3.slice(0, E3).reduce(function(t5, e5) {
                  return t5.concat(e5);
                }, []), y3 = x3.slice(1, -1).some(function(t5) {
                  return dr.hasLeadingComment(t5.node);
                }) || x3.slice(0, -1).some(function(t5) {
                  return dr.hasTrailingComment(t5.node);
                }) || h3[E3] && dr.hasLeadingComment(h3[E3][0].node), v3 = uo(t4, "encapsed");
                if (h3.length <= E3 && !y3 || v3)
                  return Cr(m3);
                var A2 = Gr(p3 ? h3.slice(1, 2)[0] : h3[0]).node, g2 = "call" !== A2.kind && s4(A2), N3 = vr([f3(h3[0]), p3 ? vr(h3.slice(1, 2).map(f3)) : "", g2 ? Ir : "", T3(h3.slice(p3 ? 2 : 1))]), C3 = n4.filter(function(t5) {
                  return "call" === t5.node.kind;
                }).length;
                if (y3 || C3 >= 3 || k3.slice(0, -1).some(Ur))
                  return Cr(N3);
                return vr([Ur(m3) || g2 ? yr : "", Sr([m3, N3])]);
              }(t3, e3, i3) : vr([t3.call(i3, "what"), bo(t3, e3, i3)]);
            case "new":
              var S2 = n3.what && "class" === n3.what.kind && n3.what.isAnonymous;
              if (!S2 && 1 === n3.arguments.length && Wo(n3.arguments[0], e3.originalText, e3))
                return vr(["new "].concat(g(t3.call(Mo, "what")), [t3.call(i3, "what"), "(", Ar(", ", t3.map(i3, "arguments")), ")"]));
              var b2 = [];
              if (b2.push("new "), S2)
                b2.push.apply(b2, [n3.what.leadingComments && "commentblock" === n3.what.leadingComments[0].kind ? vr([dr.printComments(n3.what.leadingComments, e3), " "]) : ""].concat(g(t3.call(function(t4, e4, i4) {
                  return Mo(t4, e4, i4, { inline: true });
                }, "what")), ["class", n3.arguments.length > 0 ? vr([" ", bo(t3, e3, i3)]) : "", Cr(t3.call(i3, "what"))]));
              else {
                var L2 = vr([t3.call(i3, "what"), bo(t3, e3, i3)]);
                b2.push(Xr(n3.what) ? br(L2) : L2);
              }
              return vr(b2);
            case "clone":
              return vr(["clone ", n3.what.comments ? br(t3.call(i3, "what")) : t3.call(i3, "what")]);
            case "propertylookup":
            case "nullsafepropertylookup":
            case "staticlookup":
            case "offsetlookup":
              var O2, I2 = t3.getParentNode(), R2 = 0;
              do {
                O2 = t3.getParentNode(R2), R2++;
              } while (O2 && Zr(O2));
              var w2 = uo(t3, "encapsed") || O2 && ("new" === O2.kind || "assign" === O2.kind && "variable" !== O2.left.kind) || "offsetlookup" === n3.kind || (_o(n3.what) || "variable" === n3.what.kind) && ["identifier", "variable", "encapsedpart"].includes(n3.offset.kind) && I2 && !Zr(I2);
              return vr([t3.call(i3, "what"), w2 ? Io(t3, e3, i3) : Cr(br(vr([Rr, Io(t3, e3, i3)])))]);
            case "exit":
              return Cr(vr([n3.useDie ? "die" : "exit", "(", n3.expression ? Wo(n3.expression, e3.originalText, e3) ? t3.call(i3, "expression") : vr([br(vr([Rr, t3.call(i3, "expression")])), Rr]) : dr.printDanglingComments(t3, e3), ")"]));
            case "global":
              return Cr(vr(["global ", br(vr([Ar(vr([",", gr]), t3.map(i3, "items"))]))]));
            case "include":
              return vr([n3.require ? "require" : "include", n3.once ? "_once" : "", " ", n3.target.comments ? br(t3.call(i3, "target")) : t3.call(i3, "target")]);
            case "label":
              return vr([t3.call(i3, "name"), ":"]);
            case "goto":
              return vr(["goto ", t3.call(i3, "label")]);
            case "throw":
              return vr(["throw ", n3.what.comments ? br(t3.call(i3, "what")) : t3.call(i3, "what")]);
            case "silent":
              return vr(["@", t3.call(i3, "expr")]);
            case "halt":
              return vr([Kr(n3) ? vr([dr.printDanglingComments(t3, e3, true), Ir]) : "", "__halt_compiler();", n3.after]);
            case "eval":
              return Cr(vr(["eval(", Wo(n3.source, e3.originalText, e3) ? t3.call(i3, "source") : vr([br(vr([Rr, t3.call(i3, "source")])), Rr]), ")"]));
            case "echo":
              var D2, P2 = t3.map(function(t4) {
                return i3(t4);
              }, "expressions");
              if (1 !== P2.length || n3.expressions[0].comments)
                P2.length > 0 && (D2 = co(n3.expressions[0]) || n3.expressions[0].comments ? br(P2[0]) : Lr(P2[0]));
              else
                D2 = A(P2, 1)[0];
              return Cr(vr([n3.shortForm ? "" : "echo ", D2 || "", br(vr(P2.slice(1).map(function(t4) {
                return vr([",", gr, t4]);
              })))]));
            case "print":
              return vr(["print ", n3.expression.comments ? br(t3.call(i3, "expression")) : t3.call(i3, "expression")]);
            case "return":
              var U2 = [];
              if (U2.push("return"), n3.expr) {
                var B2 = t3.call(i3, "expr");
                U2.push(" ", n3.expr.comments ? br(B2) : B2);
              }
              return Kr(n3) && U2.push(" ", dr.printDanglingComments(t3, e3, true)), vr(U2);
            case "isset":
            case "unset":
              return Cr(vr([n3.kind, bo(t3, e3, i3, "variables")]));
            case "empty":
              return Cr(vr(["empty(", br(vr([Rr, t3.call(i3, "expression")])), Rr, ")"]));
            case "variable":
              var M2 = t3.getParentNode(), F2 = t3.getParentNode(1), H2 = "assign" === M2.kind ? "" : n3.byref ? "&" : "", G2 = "encapsedpart" === M2.kind && "simple" === M2.syntax && M2.curly || F2 && "offsetlookup" === M2.kind && "encapsedpart" === F2.kind && "simple" === F2.syntax && F2.curly ? "" : "$", V2 = n3.curly ? "{" : "", W2 = n3.curly ? "}" : "";
              return vr([H2, G2, V2, t3.call(i3, "name"), W2]);
            case "constantstatement":
            case "classconstant":
              var Q2, Y2 = Mo(t3, e3, i3), j2 = t3.map(function(t4) {
                return i3(t4);
              }, "constants");
              if (1 !== j2.length || n3.constants[0].comments)
                j2.length > 0 && (Q2 = br(j2[0]));
              else
                Q2 = A(j2, 1)[0];
              return Cr(vr([].concat(g(Y2), [n3.visibility ? vr([n3.visibility, " "]) : "", "const", Q2 ? vr([" ", Q2]) : "", br(vr(j2.slice(1).map(function(t4) {
                return vr([",", Ir, t4]);
              })))])));
            case "constant":
              return Ho(n3.name, t3.call(i3, "name"), " =", n3.value, t3.call(i3, "value"), false, e3);
            case "static":
              var $2, z2 = t3.map(function(t4) {
                return i3(t4);
              }, "variables"), K2 = n3.variables.some(function(t4) {
                return t4.defaultValue;
              });
              if (1 !== z2.length || n3.variables[0].comments)
                z2.length > 0 && ($2 = br(z2[0]));
              else
                $2 = A(z2, 1)[0];
              return Cr(vr(["static", $2 ? vr([" ", $2]) : "", br(vr(z2.slice(1).map(function(t4) {
                return vr([",", K2 ? Ir : gr, t4]);
              })))]));
            case "staticvariable":
              return Ho(n3.variable, t3.call(i3, "variable"), " =", n3.defaultValue, t3.call(i3, "defaultValue"), false, e3);
            case "list":
            case "array":
              var X2 = "array" === n3.kind && mo(e3.phpVersion, "5.4") || "list" === n3.kind && (n3.shortForm || mo(e3.phpVersion, "7.1")), J2 = X2 ? "[" : vr([n3.kind, "("]), q2 = X2 ? "]" : ")";
              if (0 === n3.items.length)
                return Kr(n3) ? Cr(vr([J2, dr.printDanglingComments(t3, e3), Rr, q2])) : vr([J2, q2]);
              var Z2 = Gr(n3.items), tt2 = Z2 && "noop" === Z2.kind, et2 = A(n3.items.filter(function(t4) {
                return "noop" !== t4.kind;
              }).sort(function(t4, i4) {
                return e3.locStart(t4) - e3.locStart(i4);
              }), 1)[0], it2 = !(!et2 || !et2.key) && et2 && Hr(e3.originalText, e3.locStart(n3), e3.locStart(et2));
              return Cr(vr([J2, br(vr([Rr, wo(t3, e3, i3)])), tt2 ? "," : "", Or(!tt2 && Eo(e3, "5.0") ? vr([Z2 && lo(Z2) ? Ir : "", ","]) : ""), dr.printDanglingComments(t3, e3, true), Rr, q2]), { shouldBreak: it2 });
            case "entry":
              var nt2 = n3.byRef ? "&" : "", st2 = n3.unpack ? "..." : "";
              return n3.key ? Ho(n3.key, t3.call(i3, "key"), " =>", n3.value, t3.call(i3, "value"), nt2, e3) : vr([nt2, st2, t3.call(i3, "value")]);
            case "yield":
              var rt2 = vr([n3.key ? vr([t3.call(i3, "key"), " => "]) : "", t3.call(i3, "value")]);
              return vr(["yield", n3.key || n3.value ? " " : "", n3.value && n3.value.comments ? br(rt2) : rt2]);
            case "yieldfrom":
              return vr(["yield from ", n3.value.comments ? br(t3.call(i3, "value")) : t3.call(i3, "value")]);
            case "unary":
              return vr([n3.type, t3.call(i3, "what")]);
            case "pre":
              return vr([n3.type + n3.type, t3.call(i3, "what")]);
            case "post":
              return vr([t3.call(i3, "what"), n3.type + n3.type]);
            case "cast":
              return vr(["(", n3.type, ") ", n3.expr.comments ? br(t3.call(i3, "expr")) : t3.call(i3, "expr")]);
            case "assignref":
            case "assign":
              var ot2 = "assignref" === n3.kind;
              return Ho(n3.left, t3.call(i3, "left"), vr([" ", ot2 ? "=" : n3.operator]), n3.right, t3.call(i3, "right"), ot2, e3);
            case "bin":
              var at2 = t3.getParentNode(), ht2 = t3.getParentNode(1), lt2 = n3 !== at2.body && ("if" === at2.kind || "while" === at2.kind || "switch" === at2.kind || "do" === at2.kind), ct2 = function t4(e4, i4, n4, s4, r4) {
                var o4 = [], a3 = e4.getValue();
                if ("bin" === a3.kind) {
                  jr(a3.type, a3.left.type) ? o4 = o4.concat(e4.call(function(e5) {
                    return t4(e5, i4, n4, true, r4);
                  }, "left")) : o4.push(e4.call(i4, "left"));
                  var h3 = Oo(a3), l3 = vr(h3 ? [a3.type, " ", e4.call(i4, "right")] : [a3.type, gr, e4.call(i4, "right")]), c3 = e4.getParentNode(), u3 = !(r4 && ["||", "&&"].includes(a3.type)) && ro(c3) !== ro(a3) && ro(a3.left) !== ro(a3) && ro(a3.right) !== ro(a3), _3 = co(a3.left) || "bin" === a3.left.kind && co(a3.left.right);
                  o4.push(_3 ? "" : " ", u3 ? Cr(l3) : l3), s4 && a3.comments && (o4 = dr.printAllComments(e4, function() {
                    return vr(o4);
                  }, n4));
                } else
                  o4.push(e4.call(i4));
                return o4;
              }(t3, i3, e3, false, lt2);
              if (lt2)
                return vr(ct2);
              if ("unary" === at2.kind || Zr(at2) && "offsetlookup" !== at2.kind)
                return Cr(vr([br(vr([Rr, vr(ct2)])), Rr]));
              var ut2 = n3 !== at2.body && "for" === at2.kind || "retif" === at2.kind && ht2 && "return" !== ht2.kind, _t2 = ["assign", "property", "constant", "staticvariable", "entry"].includes(at2.kind), dt2 = "bin" === n3.left.kind && jr(n3.type, n3.left.type);
              if (ut2 || Oo(n3) && !dt2 || !Oo(n3) && _t2)
                return Cr(vr(ct2));
              var pt2 = vr(ct2.slice(1));
              return Cr(vr([ct2.length > 0 ? ct2[0] : "", br(pt2)]));
            case "retif":
              var ft2, Tt2 = [], kt2 = t3.getParentNode(), mt2 = 0;
              do {
                ft2 = t3.getParentNode(mt2), mt2++;
              } while (ft2 && "retif" === ft2.kind);
              var Et2 = ft2 || kt2, xt2 = "bin" === n3.falseExpr.kind ? br(t3.call(i3, "falseExpr")) : t3.call(i3, "falseExpr"), yt2 = vr([n3.trueExpr ? gr : " ", "?", n3.trueExpr ? vr([" ", "bin" === n3.trueExpr.kind ? br(t3.call(i3, "trueExpr")) : t3.call(i3, "trueExpr"), gr]) : "", ":", n3.trueExpr ? vr([" ", xt2]) : vr([Lo(n3.falseExpr) ? " " : gr, xt2])]);
              Tt2.push(yt2);
              var vt2 = function(t4) {
                return kt2 === Et2 ? Cr(t4) : t4;
              }, At2 = t3.getParentNode(1), gt2 = "cast" === kt2.kind && At2 ? At2 : kt2, Nt2 = ["propertylookup", "staticlookup"].includes(gt2.kind), Ct2 = t3.call(i3, "test");
              if (!n3.trueExpr) {
                var St2 = vr([Ct2, "bin" === gt2.kind || ["print", "echo", "return", "include"].includes(Et2.kind) ? br(vr(Tt2)) : vr(Tt2)]);
                return "call" === gt2.kind && gt2.what === n3 || "unary" === gt2.kind || Zr(gt2) && "offsetlookup" !== gt2.kind ? Cr(vr([br(vr([Rr, St2])), Rr])) : vt2(St2);
              }
              return vt2(vr(["retif" === n3.test.kind ? br(Ct2) : Ct2, br(vr(Tt2)), Nt2 ? Rr : ""]));
            case "boolean":
              return n3.value ? "true" : "false";
            case "number":
              return Yr(n3.value);
            case "string":
              if ("encapsedpart" === t3.getParentNode().kind) {
                var bt2 = t3.getParentNode(1), Lt2 = 0, Ot2 = mo(e3.phpVersion, "7.3"), It2 = wr;
                if ("heredoc" === bt2.type) {
                  It2 = Ot2 ? Ir : wr;
                  var Rt2 = bt2.raw.split(/\r?\n/g);
                  -1 === (Lt2 = Rt2[Rt2.length - 1].search(/\S/)) && (Lt2 = Rt2[Rt2.length - 2].search(/\S/));
                }
                return Ar(It2, n3.raw.split(/\r?\n/g).map(function(t4, e4) {
                  return e4 > 0 || 0 === n3.loc.start.column ? t4.substring(Lt2) : t4;
                }));
              }
              var wt2 = oo(n3, e3) ? '"' : "'", Dt2 = n3.raw;
              return "b" === n3.raw[0] && (Dt2 = Dt2.slice(1)), ['"', "'"].includes(Dt2[0]) && (Dt2 = Dt2.substr(1)), ['"', "'"].includes(Dt2[Dt2.length - 1]) && (Dt2 = Dt2.substr(0, Dt2.length - 1)), vr(["b" === n3.raw[0] ? "b" : "", wt2, Ar(wr, Dt2.split(/\r?\n/g)), wt2]);
            case "uniontype":
              return Cr(vr(t3.map(function(e4, n4) {
                return vr(0 === n4 ? [t3.call(i3)] : ["|", t3.call(i3)]);
              }, "types")));
            case "encapsedpart":
              var Pt2 = "simple" === n3.syntax && n3.curly || "complex" === n3.syntax ? vr([n3.curly ? "$" : "", "{"]) : "", Ut2 = "simple" === n3.syntax && n3.curly || "complex" === n3.syntax ? "}" : "";
              return vr([Pt2, t3.call(i3, "expression"), Ut2]);
            case "encapsed":
              switch (n3.type) {
                case "string":
                case "shell":
                case "heredoc":
                  var Bt2 = mo(e3.phpVersion, "7.3") ? Ir : wr;
                  return vr([Ro(n3), "heredoc" === n3.type ? Bt2 : "", vr(t3.map(i3, "value")), Ro(n3, { opening: false }), "heredoc" === n3.type && qr(t3) ? Ir : ""]);
                default:
                  return "Have not implemented kind ".concat(n3.type, " yet.");
              }
            case "inline":
              return Ar(wr, n3.raw.replace("___PSEUDO_INLINE_PLACEHOLDER___", "").split(/\r?\n/g));
            case "magic":
              return n3.value;
            case "nowdoc":
              var Mt2 = mo(e3.phpVersion, "7.3") ? Ir : wr;
              return vr(["<<<'", n3.label, "'", Mt2, Ar(Mt2, n3.value.split(/\r?\n/g)), Mt2, n3.label, qr(t3) ? Ir : ""]);
            case "name":
              return vr(["rn" === n3.resolution ? "namespace\\" : "", n3.name]);
            case "literal":
              return t3.call(i3, "value");
            case "parentreference":
              return "parent";
            case "selfreference":
              return "self";
            case "staticreference":
              return "static";
            case "typereference":
              return n3.name;
            case "nullkeyword":
              return "null";
            case "identifier":
              return "method" === t3.getParentNode().kind && (n3.name = fo(n3.name)), t3.call(i3, "name");
            case "match":
              var Ft2 = t3.map(function(t4, e4) {
                var n4 = null === t4.getValue().conds ? "default" : vr(t4.map(function(t5, e5) {
                  return Cr(vr(e5 > 0 ? [",", gr, i3(t5)] : [i3(t5)]));
                }, "conds")), s4 = t4.call(i3, "body");
                return vr(e4 > 0 ? [", ", gr, n4, " => ", s4] : [gr, n4, " => ", s4]);
              }, "arms");
              return Cr(vr(["match (", Cr(vr([Rr, br(vr([t3.call(i3, "cond")])), Rr])), ") {", br(vr(Ft2)), " ", Rr, "}"]));
            case "noop":
              return n3.comments ? dr.printComments(t3.getValue().comments, e3) : "";
            case "namedargument":
              return vr([n3.name, ": ", t3.call(i3, "value")]);
            case "error":
            default:
              return "Have not implemented kind ".concat(n3.kind, " yet.");
          }
        }(t2, e2, i2), r2 = [], o2 = Er(t2);
        return o2 && r2.unshift("("), r2.push(s2), o2 && r2.push(")"), Qr(t2) && r2.push(";"), zr(t2) && r2.push(Ir), vr(r2);
      };
      var Yo = function(t2, e2) {
        if (["loc", "range", "raw", "comments", "leadingComments", "trailingComments", "parenthesizedExpression", "parent", "prev", "start", "end", "tokens", "errors", "extra"].forEach(function(t3) {
          delete e2[t3];
        }), "string" === t2.kind && delete e2.isDoubleQuote, ["array", "list"].includes(t2.kind) && delete e2.shortForm, "inline" === t2.kind) {
          if (t2.value.includes("___PSEUDO_INLINE_PLACEHOLDER___"))
            return null;
          e2.value = e2.value.replace(/\r\n?|\n/g, "");
        }
        if (("continue" === t2.kind || "break" === t2.kind) && t2.level) {
          var i2 = e2.level;
          "number" === i2.kind && (e2.level = "1" === i2.value ? null : i2);
        }
        if ("block" === t2.kind && 1 === t2.children.length && "block" === t2.children[0].kind)
          for (; "block" === e2.children[0].kind; )
            e2.children = e2.children[0].children;
        if ("number" === t2.kind && (e2.value = Rs.printNumber(t2.value)), ["foreach", "for", "if", "while", "do"].includes(t2.kind) && (t2.body && "block" !== t2.body.kind ? e2.body = { kind: "block", children: [e2.body] } : e2.body = e2.body ? e2.body : null, t2.alternate && "block" !== t2.alternate.kind ? e2.alternate = { kind: "block", children: [e2.alternate] } : e2.alternate = e2.alternate ? e2.alternate : null), "usegroup" === t2.kind && "string" == typeof t2.name && (e2.name = e2.name.replace(/^\\/, "")), "useitem" === t2.kind && (e2.name = e2.name.replace(/^\\/, "")), "method" === t2.kind && "identifier" === t2.name.kind && (e2.name.name = Rs.normalizeMagicMethodName(e2.name.name)), "noop" === t2.kind)
          return null;
      }, jo = "PHP", $o = { phpVersion: { since: "0.13.0", category: jo, type: "choice", default: "7.0", description: "Minimum target PHP version.", choices: [{ value: "5.0" }, { value: "5.1" }, { value: "5.2" }, { value: "5.3" }, { value: "5.4" }, { value: "5.5" }, { value: "5.6" }, { value: "7.0" }, { value: "7.1" }, { value: "7.2" }, { value: "7.3" }, { value: "7.4" }, { value: "8.0" }] }, trailingCommaPHP: { since: "0.0.0", category: jo, type: "boolean", default: true, description: "Print trailing commas wherever possible when multi-line." }, braceStyle: { since: "0.10.0", category: jo, type: "choice", default: "psr-2", description: "Print one space or newline for code blocks (classes and functions).", choices: [{ value: "psr-2", description: "Use PSR-2 brace style." }, { value: "1tbs", description: "Use 1tbs brace style." }] } }, zo = function(t2, e2, i2, n2) {
        if ("length" !== i2 && "prototype" !== i2 && "arguments" !== i2 && "caller" !== i2) {
          var s2 = Object.getOwnPropertyDescriptor(t2, i2), r2 = Object.getOwnPropertyDescriptor(e2, i2);
          !Ko(s2, r2) && n2 || Object.defineProperty(t2, i2, r2);
        }
      }, Ko = function(t2, e2) {
        return void 0 === t2 || t2.configurable || t2.writable === e2.writable && t2.enumerable === e2.enumerable && t2.configurable === e2.configurable && (t2.writable || t2.value === e2.value);
      }, Xo = function(t2, e2) {
        var i2 = Object.getPrototypeOf(e2);
        i2 !== Object.getPrototypeOf(t2) && Object.setPrototypeOf(t2, i2);
      }, Jo = function(t2, e2) {
        return "/* Wrapped ".concat(t2, "*/\n").concat(e2);
      }, qo = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), Zo = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), ta = function(t2, e2, i2) {
        var n2 = "" === i2 ? "" : "with ".concat(i2.trim(), "() "), s2 = Jo.bind(null, n2, e2.toString());
        Object.defineProperty(s2, "name", Zo), Object.defineProperty(t2, "toString", v(v({}, qo), {}, { value: s2 }));
      }, ea = function(t2, e2) {
        var i2, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, s2 = n2.ignoreNonConfigurable, r2 = void 0 !== s2 && s2, o2 = t2.name, a2 = S(Reflect.ownKeys(e2));
        try {
          for (a2.s(); !(i2 = a2.n()).done; ) {
            var h2 = i2.value;
            zo(t2, e2, h2, r2);
          }
        } catch (t3) {
          a2.e(t3);
        } finally {
          a2.f();
        }
        return Xo(t2, e2), ta(t2, e2, o2), t2;
      }, ia = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function na(t2) {
        return t2 && t2.default || t2;
      }
      var sa, ra = function() {
        var t2 = {};
        return t2.promise = new Promise(function(e2, i2) {
          t2.resolve = e2, t2.reject = i2;
        }), t2;
      }, oa = function(t2, e2) {
        return t2(e2 = { exports: {} }, e2.exports), e2.exports;
      }(function(t2, e2) {
        var i2 = ia && ia.__awaiter || function(t3, e3, i3, n3) {
          return new (i3 || (i3 = Promise))(function(s3, r3) {
            function o2(t4) {
              try {
                h2(n3.next(t4));
              } catch (t5) {
                r3(t5);
              }
            }
            function a2(t4) {
              try {
                h2(n3.throw(t4));
              } catch (t5) {
                r3(t5);
              }
            }
            function h2(t4) {
              t4.done ? s3(t4.value) : new i3(function(e4) {
                e4(t4.value);
              }).then(o2, a2);
            }
            h2((n3 = n3.apply(t3, e3 || [])).next());
          });
        }, n2 = ia && ia.__importDefault || function(t3) {
          return t3 && t3.__esModule ? t3 : { default: t3 };
        };
        Object.defineProperty(e2, "__esModule", { value: true });
        var s2 = n2(ra);
        function r2(t3) {
          var e3, n3, r3, o2 = this, a2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "maxAge", h2 = function() {
            return i2(o2, void 0, void 0, regeneratorRuntime.mark(function o3() {
              var h3, l3, c3, u2, _2 = this;
              return regeneratorRuntime.wrap(function(o4) {
                for (; ; )
                  switch (o4.prev = o4.next) {
                    case 0:
                      if (void 0 === e3) {
                        o4.next = 2;
                        break;
                      }
                      return o4.abrupt("return");
                    case 2:
                      h3 = function(o5) {
                        return i2(_2, void 0, void 0, regeneratorRuntime.mark(function i3() {
                          var h4;
                          return regeneratorRuntime.wrap(function(i4) {
                            for (; ; )
                              switch (i4.prev = i4.next) {
                                case 0:
                                  if (r3 = s2.default(), !((h4 = o5[1][a2] - Date.now()) <= 0)) {
                                    i4.next = 6;
                                    break;
                                  }
                                  return t3.delete(o5[0]), r3.resolve(), i4.abrupt("return");
                                case 6:
                                  return e3 = o5[0], "function" == typeof (n3 = setTimeout(function() {
                                    t3.delete(o5[0]), r3 && r3.resolve();
                                  }, h4)).unref && n3.unref(), i4.abrupt("return", r3.promise);
                                case 10:
                                case "end":
                                  return i4.stop();
                              }
                          }, i3);
                        }));
                      }, o4.prev = 3, l3 = S(t3), o4.prev = 5, l3.s();
                    case 7:
                      if ((c3 = l3.n()).done) {
                        o4.next = 13;
                        break;
                      }
                      return u2 = c3.value, o4.next = 11, h3(u2);
                    case 11:
                      o4.next = 7;
                      break;
                    case 13:
                      o4.next = 18;
                      break;
                    case 15:
                      o4.prev = 15, o4.t0 = o4.catch(5), l3.e(o4.t0);
                    case 18:
                      return o4.prev = 18, l3.f(), o4.finish(18);
                    case 21:
                      o4.next = 25;
                      break;
                    case 23:
                      o4.prev = 23, o4.t1 = o4.catch(3);
                    case 25:
                      e3 = void 0;
                    case 26:
                    case "end":
                      return o4.stop();
                  }
              }, o3, null, [[3, 23], [5, 15, 18, 21]]);
            }));
          }, l2 = function() {
            e3 = void 0, void 0 !== n3 && (clearTimeout(n3), n3 = void 0), void 0 !== r3 && (r3.reject(void 0), r3 = void 0);
          }, c2 = t3.set.bind(t3);
          return t3.set = function(i3, n4) {
            t3.has(i3) && t3.delete(i3);
            var s3 = c2(i3, n4);
            return e3 && e3 === i3 && l2(), h2(), s3;
          }, h2(), t3;
        }
        e2.default = r2, t2.exports = r2, t2.exports.default = r2;
      });
      (sa = oa) && sa.__esModule && Object.prototype.hasOwnProperty.call(sa, "default") && sa.default;
      var aa = oa, ha = /* @__PURE__ */ new WeakMap(), la = /* @__PURE__ */ new WeakMap(), ca = function(t2) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = e2.cacheKey, n2 = e2.cache, s2 = void 0 === n2 ? /* @__PURE__ */ new Map() : n2, r2 = e2.maxAge;
        "number" == typeof r2 && aa(s2);
        var o2 = function() {
          for (var e3 = arguments.length, n3 = new Array(e3), o3 = 0; o3 < e3; o3++)
            n3[o3] = arguments[o3];
          var a2 = i2 ? i2(n3) : n3[0], h2 = s2.get(a2);
          if (h2)
            return h2.data;
          var l2 = t2.apply(this, n3);
          return s2.set(a2, { data: l2, maxAge: r2 ? Date.now() + r2 : Number.POSITIVE_INFINITY }), l2;
        };
        return ea(o2, t2, { ignoreNonConfigurable: true }), la.set(o2, s2), o2;
      };
      ca.decorator = function() {
        var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return function(e2, i2, n2) {
          var s2 = e2[i2];
          if ("function" != typeof s2)
            throw new TypeError("The decorated value must be a function");
          delete n2.value, delete n2.writable, n2.get = function() {
            if (!ha.has(this)) {
              var e3 = ca(s2, t2);
              return ha.set(this, e3), e3;
            }
            return ha.get(this);
          };
        };
      }, ca.clear = function(t2) {
        var e2 = la.get(t2);
        if (!e2)
          throw new TypeError("Can't clear a function that was not memoized!");
        if ("function" != typeof e2.clear)
          throw new TypeError("The cache Map can't be cleared!");
        e2.clear();
      };
      var ua = /@prettier|@format/, _a = ca(function(t2) {
        var e2 = cs(t2), i2 = A(e2.children, 1)[0], n2 = A(e2.comments.filter(function(t3) {
          return "commentblock" === t3.kind;
        }), 1)[0];
        if (i2 && n2 && n2.loc.start.line < i2.loc.start.line)
          return n2;
      });
      var da = function(t2) {
        if (!ua.test(t2))
          return false;
        var e2 = _a(t2);
        if (e2) {
          var i2 = e2.value;
          return ua.test(i2);
        }
        return false;
      }, pa = function(t2) {
        var e2 = _a(t2);
        if (e2) {
          var i2 = e2.loc, n2 = i2.start.offset, s2 = i2.end.offset, r2 = t2.substring(0, n2), o2 = t2.substring(s2);
          return "".concat(r2).concat(function(t3, e3) {
            var i3 = t3.split(/\r?\n/g);
            if (1 === i3.length) {
              var n3 = A(/\/*\*\*(.*)\*\//.exec(i3[0]), 2)[1];
              i3 = ["/**", " * ".concat(n3.trim()), " */"];
            }
            var s3 = i3.findIndex(function(t4) {
              return /@\S/.test(t4);
            }) || 1;
            return i3.splice(s3, 0, " * @format"), i3.join(function(t4) {
              var e4 = t4.indexOf("\n");
              return e4 >= 0 && "\r" === t4.charAt(e4 - 1) ? "\r\n" : "\n";
            }(e3));
          }(e2.value, t2)).concat(o2);
        }
        var a2 = "<?php";
        if (!t2.startsWith(a2))
          return t2;
        var h2 = a2.length, l2 = t2.substring(0, h2), c2 = t2.substring(h2);
        return "".concat(l2, "\n/** \n * @format \n */\n").concat(c2);
      }, fa = "programming", Ta = "text.html.php", ka = "application/x-httpd-php", ma = "#4F5D95", Ea = [".php", ".aw", ".ctp", ".fcgi", ".inc", ".php3", ".php4", ".php5", ".phps", ".phpt"], xa = [".php", ".php_cs", ".php_cs.dist", "Phakefile"], ya = ["php"], va = ["inc"], Aa = { name: "PHP", type: fa, tmScope: Ta, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: ka, color: ma, extensions: Ea, filenames: xa, interpreters: ya, aliases: va, languageId: 272 }, ga = Object.freeze({ __proto__: null, name: "PHP", type: fa, tmScope: Ta, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: ka, color: ma, extensions: Ea, filenames: xa, interpreters: ya, aliases: va, languageId: 272, default: Aa }), Na = "HTML+PHP", Ca = "markup", Sa = "text.html.php", ba = "HTML", La = [".phtml"], Oa = "application/x-httpd-php", Ia = { name: Na, type: Ca, tmScope: Sa, group: ba, extensions: La, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: Oa, languageId: 151 }, Ra = Object.freeze({ __proto__: null, name: Na, type: Ca, tmScope: Sa, group: ba, extensions: La, aceMode: "php", codemirrorMode: "php", codemirrorMimeType: Oa, languageId: 151, default: Ia }), wa = na(ga), Da = na(Ra), Pa = n.default.doc.builders, Ua = Pa.join, Ba = Pa.hardline, Ma = da, Fa = pa;
      function Ha(t2, e2) {
        var i2 = e2.extend, n2 = e2.override, s2 = {};
        for (var r2 in t2) {
          s2["languageId" === r2 ? "linguistLanguageId" : r2] = t2[r2];
        }
        if (i2)
          for (var o2 in i2)
            s2[o2] = (s2[o2] || []).concat(i2[o2]);
        for (var a2 in n2)
          s2[a2] = n2[a2];
        return s2;
      }
      var Ga = [Ha(wa, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } }), Ha(Da, { override: { parsers: ["php"], vscodeLanguageIds: ["php"] } })], Va = function(t2) {
        return function(e2) {
          return e2.loc && e2.loc[t2] && e2.loc[t2].offset;
        };
      }, Wa = { php: { parse: cs, astFormat: "php", locStart: Va("start"), locEnd: Va("end"), hasPragma: Ma } }, Qa = { languages: Ga, printers: { php: { print: Qo, insertPragma: Fa, massageAstNode: Yo, getCommentChildNodes: dr.getCommentChildNodes, canAttachComment: dr.canAttachComment, isBlockComment: dr.isBlockComment, handleComments: { ownLine: dr.handleOwnLineComment, endOfLine: dr.handleEndOfLineComment, remaining: dr.handleRemainingComment }, willPrintOwnComments(t2) {
        var e2 = t2.getValue();
        return e2 && "noop" === e2.kind;
      }, printComment(t2) {
        var e2 = t2.getValue();
        switch (e2.kind) {
          case "commentblock":
            if (!e2.value.includes("\n"))
              return e2.value;
            var i2 = e2.value.split(/\r?\n/g);
            return i2.slice(1, i2.length - 1).every(function(t3) {
              return "*" === t3.trim()[0];
            }) ? Ua(Ba, i2.map(function(t3, e3) {
              return (e3 > 0 ? " " : "") + (e3 < i2.length - 1 ? t3.trim() : t3.trimLeft());
            })) : e2.value;
          case "commentline":
            return e2.value.trimRight();
          default:
            throw new Error("Not a comment: ".concat(JSON.stringify(e2)));
        }
      }, hasPrettierIgnore(t2) {
        var e2 = function(t3) {
          return t3.value.includes("prettier-ignore") && !t3.value.includes("prettier-ignore-start") && !t3.value.includes("prettier-ignore-end");
        }, i2 = t2.getParentNode(), n2 = t2.getNode();
        return n2 && "classconstant" !== n2.kind && n2.comments && n2.comments.length > 0 && n2.comments.some(e2) || n2 && "constant" === n2.kind && i2 && "classconstant" === i2.kind && i2.comments && i2.comments.length > 0 && i2.comments.some(e2);
      } } }, parsers: Wa, options: $o, defaultOptions: { tabWidth: 4 } }, Ya = Qa.languages, ja = Qa.printers, $a = Qa.parsers, za = Qa.options, Ka = Qa.defaultOptions;
      t.default = Qa, t.defaultOptions = Ka, t.languages = Ya, t.options = za, t.parsers = $a, t.printers = ja, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// server/src/formatting/prettier/utils.ts
function cleanOptions(options) {
  [
    "cursorOffset",
    "rangeEnd",
    "rangeStart",
    "locEnd",
    "locStat",
    "printer",
    "originalText",
    "astFormat"
  ].forEach((p) => {
    delete options[p];
  });
  return options;
}
function setOptions(options) {
  htmlOptions = cleanOptions(
    Object.assign(
      {},
      options,
      { htmlWhitespaceSensitivity: "ignore", parser: "html", plugins: options.plugins }
    )
  );
  phpOptions = cleanOptions(
    Object.assign({}, options, {
      parser: "php",
      plugins: [import_standalone.default]
    })
  );
}
function formatPhp(text) {
  let result = prettier.format("<?php " + text, phpOptions).trim();
  result = result.substring(5);
  if (text.endsWith(";") == false && result.endsWith(";")) {
    result = result.substring(0, result.length - 1);
  }
  return result.trim();
}
function formatAsHtml(text) {
  return prettier.format(text, htmlOptions);
}
var prettier, plugin, import_standalone, phpOptions, htmlOptions;
var init_utils6 = __esm({
  "server/src/formatting/prettier/utils.ts"() {
    "use strict";
    prettier = __toESM(require("prettier"));
    plugin = __toESM(require_plugin());
    import_standalone = __toESM(require_standalone());
  }
});

// server/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var isNothing_1, isObject_1, toArray_1, repeat_1, isNegativeZero_1, extend_1, common, exception, snippet, TYPE_CONSTRUCTOR_OPTIONS, YAML_NODE_KINDS, type, schema, str, seq, map, failsafe, _null, bool, int, YAML_FLOAT_PATTERN, SCIENTIFIC_WITHOUT_DOT, float, json, core, YAML_DATE_REGEXP, YAML_TIMESTAMP_REGEXP, timestamp, merge, BASE64_MAP, binary, _hasOwnProperty$3, _toString$2, omap, _toString$1, pairs, _hasOwnProperty$2, set, _default, _hasOwnProperty$1, CONTEXT_FLOW_IN, CONTEXT_FLOW_OUT, CONTEXT_BLOCK_IN, CONTEXT_BLOCK_OUT, CHOMPING_CLIP, CHOMPING_STRIP, CHOMPING_KEEP, PATTERN_NON_PRINTABLE, PATTERN_NON_ASCII_LINE_BREAKS, PATTERN_FLOW_INDICATORS, PATTERN_TAG_HANDLE, PATTERN_TAG_URI, simpleEscapeCheck, simpleEscapeMap, i, directiveHandlers, loadAll_1, load_1, loader, _toString, _hasOwnProperty, CHAR_BOM, CHAR_TAB, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_SPACE, CHAR_EXCLAMATION, CHAR_DOUBLE_QUOTE, CHAR_SHARP, CHAR_PERCENT, CHAR_AMPERSAND, CHAR_SINGLE_QUOTE, CHAR_ASTERISK, CHAR_COMMA, CHAR_MINUS, CHAR_COLON, CHAR_EQUALS, CHAR_GREATER_THAN, CHAR_QUESTION, CHAR_COMMERCIAL_AT, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_GRAVE_ACCENT, CHAR_LEFT_CURLY_BRACKET, CHAR_VERTICAL_LINE, CHAR_RIGHT_CURLY_BRACKET, ESCAPE_SEQUENCES, DEPRECATED_BOOLEANS_SYNTAX, DEPRECATED_BASE60_SYNTAX, QUOTING_TYPE_SINGLE, QUOTING_TYPE_DOUBLE, STYLE_PLAIN, STYLE_SINGLE, STYLE_LITERAL, STYLE_FOLDED, STYLE_DOUBLE, dump_1, dumper, load, loadAll, dump, safeLoad, safeLoadAll, safeDump;
var init_js_yaml = __esm({
  "server/node_modules/js-yaml/dist/js-yaml.mjs"() {
    isNothing_1 = isNothing;
    isObject_1 = isObject;
    toArray_1 = toArray;
    repeat_1 = repeat;
    isNegativeZero_1 = isNegativeZero;
    extend_1 = extend;
    common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    YAMLException$1.prototype = Object.create(Error.prototype);
    YAMLException$1.prototype.constructor = YAMLException$1;
    YAMLException$1.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    exception = YAMLException$1;
    snippet = makeSnippet;
    TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    type = Type$1;
    Schema$1.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema$1.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    schema = Schema$1;
    str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
    seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
    map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
    failsafe = new schema({
      explicit: [
        str,
        seq,
        map
      ]
    });
    _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    YAML_FLOAT_PATTERN = new RegExp(
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    json = failsafe.extend({
      implicit: [
        _null,
        bool,
        int,
        float
      ]
    });
    core = json;
    YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    _toString$2 = Object.prototype.toString;
    omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    _toString$1 = Object.prototype.toString;
    pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    _default = core.extend({
      implicit: [
        timestamp,
        merge
      ],
      explicit: [
        binary,
        omap,
        pairs,
        set
      ]
    });
    _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    CONTEXT_FLOW_IN = 1;
    CONTEXT_FLOW_OUT = 2;
    CONTEXT_BLOCK_IN = 3;
    CONTEXT_BLOCK_OUT = 4;
    CHOMPING_CLIP = 1;
    CHOMPING_STRIP = 2;
    CHOMPING_KEEP = 3;
    PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    simpleEscapeCheck = new Array(256);
    simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$1.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    loadAll_1 = loadAll$1;
    load_1 = load$1;
    loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    _toString = Object.prototype.toString;
    _hasOwnProperty = Object.prototype.hasOwnProperty;
    CHAR_BOM = 65279;
    CHAR_TAB = 9;
    CHAR_LINE_FEED = 10;
    CHAR_CARRIAGE_RETURN = 13;
    CHAR_SPACE = 32;
    CHAR_EXCLAMATION = 33;
    CHAR_DOUBLE_QUOTE = 34;
    CHAR_SHARP = 35;
    CHAR_PERCENT = 37;
    CHAR_AMPERSAND = 38;
    CHAR_SINGLE_QUOTE = 39;
    CHAR_ASTERISK = 42;
    CHAR_COMMA = 44;
    CHAR_MINUS = 45;
    CHAR_COLON = 58;
    CHAR_EQUALS = 61;
    CHAR_GREATER_THAN = 62;
    CHAR_QUESTION = 63;
    CHAR_COMMERCIAL_AT = 64;
    CHAR_LEFT_SQUARE_BRACKET = 91;
    CHAR_RIGHT_SQUARE_BRACKET = 93;
    CHAR_GRAVE_ACCENT = 96;
    CHAR_LEFT_CURLY_BRACKET = 123;
    CHAR_VERTICAL_LINE = 124;
    CHAR_RIGHT_CURLY_BRACKET = 125;
    ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    QUOTING_TYPE_SINGLE = 1;
    QUOTING_TYPE_DOUBLE = 2;
    STYLE_PLAIN = 1;
    STYLE_SINGLE = 2;
    STYLE_LITERAL = 3;
    STYLE_FOLDED = 4;
    STYLE_DOUBLE = 5;
    dump_1 = dump$1;
    dumper = {
      dump: dump_1
    };
    load = loader.load;
    loadAll = loader.loadAll;
    dump = dumper.dump;
    safeLoad = renamed("safeLoad", "load");
    safeLoadAll = renamed("safeLoadAll", "loadAll");
    safeDump = renamed("safeDump", "dump");
  }
});

// server/src/formatting/frontMatterFormatter.ts
var FrontMatterFormatter;
var init_frontMatterFormatter = __esm({
  "server/src/formatting/frontMatterFormatter.ts"() {
    "use strict";
    init_js_yaml();
    FrontMatterFormatter = class {
      static formatFrontMatter(contents) {
        try {
          const docFrontMatter = load(contents, {});
          let temp = dump(docFrontMatter, {
            indent: 2,
            noArrayIndent: false,
            condenseFlow: false,
            forceQuotes: true,
            noRefs: true,
            skipInvalid: true
          });
          if (temp.endsWith("\n")) {
            temp = temp.trimEnd();
          }
          return temp;
        } catch (err) {
          return contents;
        }
      }
    };
  }
});

// server/src/runtime/document/printers/errorPrinter.ts
var ErrorPrinter;
var init_errorPrinter = __esm({
  "server/src/runtime/document/printers/errorPrinter.ts"() {
    "use strict";
    ErrorPrinter = class {
      static printError(error, lines) {
        var _a, _b;
        let result = `[${error.errorCode}] ${error.message}

`, line = (_b = (_a = error.node) == null ? void 0 : _a.startPosition) == null ? void 0 : _b.line;
        let maxLine = line;
        lines.forEach((text, lineNumber) => {
          maxLine = lineNumber;
        });
        let maxLineLen = maxLine.toString().length;
        lines.forEach((lineText, lineNumber) => {
          let curLineString = lineNumber.toString(), prefix = "", linePaddingLen = 0;
          linePaddingLen = maxLineLen - curLineString.length;
          if (line == lineNumber) {
            prefix = " >" + "0".repeat(linePaddingLen) + curLineString + "| ";
          } else {
            prefix = "  " + "0".repeat(linePaddingLen) + curLineString + "| ";
          }
          result += prefix + lineText + "\n";
        });
        return result;
      }
    };
  }
});

// server/src/formatting/prettier/prettierDocumentFormatter.ts
var PrettierDocumentFormatter;
var init_prettierDocumentFormatter = __esm({
  "server/src/formatting/prettier/prettierDocumentFormatter.ts"() {
    "use strict";
    init_documentFormatter();
    init_utils6();
    init_frontMatterFormatter();
    init_errorPrinter();
    PrettierDocumentFormatter = class extends DocumentFormatter {
      constructor(options) {
        super();
        this.createExtraVirtualStructures = true;
        setOptions(options);
        this.withHtmlFormatter(formatAsHtml).withYamlFormatter(FrontMatterFormatter.formatFrontMatter).withTransformOptions({
          endNewline: true,
          maxAntlersStatementsPerLine: 3,
          newlinesAfterFrontMatter: 1,
          tabSize: options.tabWidth
        }).withPhpFormatter(formatPhp).withPreFormatter((document) => {
          var _a, _b, _c;
          if (document.errors.hasStructureErrors()) {
            const firstError = document.errors.getFirstStructureError(), lines = document.getLinesAround((_c = (_b = (_a = firstError.node) == null ? void 0 : _a.startPosition) == null ? void 0 : _b.line) != null ? _c : 1);
            throw new SyntaxError(ErrorPrinter.printError(firstError, lines));
          }
          return null;
        });
      }
    };
  }
});

// server/src/formatting/prettier/plugin.ts
var require_plugin = __commonJS({
  "server/src/formatting/prettier/plugin.ts"(exports, module2) {
    init_antlersDocument();
    init_prettierDocumentFormatter();
    init_utils6();
    var formatterOptions;
    var defaultAntlersSettings = {
      formatFrontMatter: false,
      showGeneralSnippetCompletions: true,
      diagnostics: {
        warnOnDynamicCssClassNames: true,
        validateTagParameters: true,
        reportDiagnostics: true
      },
      trace: { server: "off" },
      formatterIgnoreExtensions: ["xml"],
      languageVersion: "runtime"
    };
    var plugin2 = {
      languages: [
        {
          name: "Antlers",
          parsers: ["antlers"],
          extensions: [".antlers.html", ".antlers.php"],
          vscodeLanguageIds: ["html", "antlers"]
        }
      ],
      parsers: {
        antlers: {
          parse: function(text, _, options) {
            formatterOptions = options;
            setOptions(options);
            const document = new AntlersDocument();
            return document.loadString(text);
          },
          locStart: () => 0,
          locEnd: () => 0,
          astFormat: "antlers"
        }
      },
      printers: {
        antlers: {
          print(path) {
            const doc = path.stack[0];
            return new PrettierDocumentFormatter(formatterOptions).formatDocument(doc, defaultAntlersSettings);
          }
        }
      },
      defaultOptions: {
        tabWidth: 4
      }
    };
    module2.exports = plugin2;
  }
});
module.exports = require_plugin();
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */

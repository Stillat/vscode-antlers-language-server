var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate2(uuid2) {
      return typeof uuid2 === "string" && _regex.default.test(uuid2);
    }
    var _default2 = validate2;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify2(arr, offset = 0) {
      const uuid2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid2;
    }
    var _default2 = stringify2;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default2 = v12;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default2 = parse2;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default2;
    exports.URL = exports.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str2) {
      str2 = unescape(encodeURIComponent(str2));
      const bytes = [];
      for (let i = 0; i < str2.length; ++i) {
        bytes.push(str2.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL;
    function _default2(name, version2, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default2 = md5;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v32 = (0, _v.default)("v3", 48, _md.default);
    var _default2 = v32;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v42(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default2 = v42;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default2 = sha1;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v52 = (0, _v.default)("v5", 80, _sha.default);
    var _default2 = v52;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default2 = "00000000-0000-0000-0000-000000000000";
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid2.substr(14, 1), 16);
    }
    var _default2 = version2;
    exports.default = _default2;
  }
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "node_modules/uuid/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// server/node_modules/locutus/php/info/getenv.js
var require_getenv = __commonJS({
  "server/node_modules/locutus/php/info/getenv.js"(exports, module2) {
    "use strict";
    module2.exports = function getenv(varname) {
      if (typeof process !== "undefined" || !process.env || !process.env[varname]) {
        return false;
      }
      return process.env[varname];
    };
  }
});

// server/node_modules/locutus/php/strings/setlocale.js
var require_setlocale = __commonJS({
  "server/node_modules/locutus/php/strings/setlocale.js"(exports, module2) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    module2.exports = function setlocale(category, locale) {
      var getenv = require_getenv();
      var categ = "";
      var cats = [];
      var i = 0;
      var _copy = function _copy2(orig) {
        if (orig instanceof RegExp) {
          return new RegExp(orig);
        } else if (orig instanceof Date) {
          return new Date(orig);
        }
        var newObj = {};
        for (var _i in orig) {
          if (_typeof(orig[_i]) === "object") {
            newObj[_i] = _copy2(orig[_i]);
          } else {
            newObj[_i] = orig[_i];
          }
        }
        return newObj;
      };
      var _nplurals2a = function _nplurals2a2(n) {
        return n !== 1 ? 1 : 0;
      };
      var _nplurals2b = function _nplurals2b2(n) {
        return n > 1 ? 1 : 0;
      };
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      $locutus.php = $locutus.php || {};
      if (!$locutus.php.locales || !$locutus.php.locales.fr_CA || !$locutus.php.locales.fr_CA.LC_TIME || !$locutus.php.locales.fr_CA.LC_TIME.x) {
        $locutus.php.locales = {};
        $locutus.php.locales.en = {
          LC_COLLATE: function LC_COLLATE(str1, str2) {
            return str1 === str2 ? 0 : str1 > str2 ? 1 : -1;
          },
          LC_CTYPE: {
            an: /^[A-Za-z\d]+$/g,
            al: /^[A-Za-z]+$/g,
            ct: /^[\u0000-\u001F\u007F]+$/g,
            dg: /^[\d]+$/g,
            gr: /^[\u0021-\u007E]+$/g,
            lw: /^[a-z]+$/g,
            pr: /^[\u0020-\u007E]+$/g,
            pu: /^[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]+$/g,
            sp: /^[\f\n\r\t\v ]+$/g,
            up: /^[A-Z]+$/g,
            xd: /^[A-Fa-f\d]+$/g,
            CODESET: "UTF-8",
            lower: "abcdefghijklmnopqrstuvwxyz",
            upper: "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
          },
          LC_TIME: {
            a: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            A: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            b: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            B: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            c: "%a %d %b %Y %r %Z",
            p: ["AM", "PM"],
            P: ["am", "pm"],
            r: "%I:%M:%S %p",
            x: "%m/%d/%Y",
            X: "%r",
            alt_digits: "",
            ERA: "",
            ERA_YEAR: "",
            ERA_D_T_FMT: "",
            ERA_D_FMT: "",
            ERA_T_FMT: ""
          },
          LC_MONETARY: {
            int_curr_symbol: "USD",
            currency_symbol: "$",
            mon_decimal_point: ".",
            mon_thousands_sep: ",",
            mon_grouping: [3],
            positive_sign: "",
            negative_sign: "-",
            int_frac_digits: 2,
            frac_digits: 2,
            p_cs_precedes: 1,
            p_sep_by_space: 0,
            n_cs_precedes: 1,
            n_sep_by_space: 0,
            p_sign_posn: 3,
            n_sign_posn: 0
          },
          LC_NUMERIC: {
            decimal_point: ".",
            thousands_sep: ",",
            grouping: [3]
          },
          LC_MESSAGES: {
            YESEXPR: "^[yY].*",
            NOEXPR: "^[nN].*",
            YESSTR: "",
            NOSTR: ""
          },
          nplurals: _nplurals2a
        };
        $locutus.php.locales.en_US = _copy($locutus.php.locales.en);
        $locutus.php.locales.en_US.LC_TIME.c = "%a %d %b %Y %r %Z";
        $locutus.php.locales.en_US.LC_TIME.x = "%D";
        $locutus.php.locales.en_US.LC_TIME.X = "%r";
        $locutus.php.locales.en_US.LC_MONETARY.int_curr_symbol = "USD ";
        $locutus.php.locales.en_US.LC_MONETARY.p_sign_posn = 1;
        $locutus.php.locales.en_US.LC_MONETARY.n_sign_posn = 1;
        $locutus.php.locales.en_US.LC_MONETARY.mon_grouping = [3, 3];
        $locutus.php.locales.en_US.LC_NUMERIC.thousands_sep = "";
        $locutus.php.locales.en_US.LC_NUMERIC.grouping = [];
        $locutus.php.locales.en_GB = _copy($locutus.php.locales.en);
        $locutus.php.locales.en_GB.LC_TIME.r = "%l:%M:%S %P %Z";
        $locutus.php.locales.en_AU = _copy($locutus.php.locales.en_GB);
        $locutus.php.locales.C = _copy($locutus.php.locales.en);
        $locutus.php.locales.C.LC_CTYPE.CODESET = "ANSI_X3.4-1968";
        $locutus.php.locales.C.LC_MONETARY = {
          int_curr_symbol: "",
          currency_symbol: "",
          mon_decimal_point: "",
          mon_thousands_sep: "",
          mon_grouping: [],
          p_cs_precedes: 127,
          p_sep_by_space: 127,
          n_cs_precedes: 127,
          n_sep_by_space: 127,
          p_sign_posn: 127,
          n_sign_posn: 127,
          positive_sign: "",
          negative_sign: "",
          int_frac_digits: 127,
          frac_digits: 127
        };
        $locutus.php.locales.C.LC_NUMERIC = {
          decimal_point: ".",
          thousands_sep: "",
          grouping: []
        };
        $locutus.php.locales.C.LC_TIME.c = "%a %b %e %H:%M:%S %Y";
        $locutus.php.locales.C.LC_TIME.x = "%m/%d/%y";
        $locutus.php.locales.C.LC_TIME.X = "%H:%M:%S";
        $locutus.php.locales.C.LC_MESSAGES.YESEXPR = "^[yY]";
        $locutus.php.locales.C.LC_MESSAGES.NOEXPR = "^[nN]";
        $locutus.php.locales.fr = _copy($locutus.php.locales.en);
        $locutus.php.locales.fr.nplurals = _nplurals2b;
        $locutus.php.locales.fr.LC_TIME.a = ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"];
        $locutus.php.locales.fr.LC_TIME.A = ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"];
        $locutus.php.locales.fr.LC_TIME.b = ["jan", "f\xE9v", "mar", "avr", "mai", "jun", "jui", "ao\xFB", "sep", "oct", "nov", "d\xE9c"];
        $locutus.php.locales.fr.LC_TIME.B = ["janvier", "f\xE9vrier", "mars", "avril", "mai", "juin", "juillet", "ao\xFBt", "septembre", "octobre", "novembre", "d\xE9cembre"];
        $locutus.php.locales.fr.LC_TIME.c = "%a %d %b %Y %T %Z";
        $locutus.php.locales.fr.LC_TIME.p = ["", ""];
        $locutus.php.locales.fr.LC_TIME.P = ["", ""];
        $locutus.php.locales.fr.LC_TIME.x = "%d.%m.%Y";
        $locutus.php.locales.fr.LC_TIME.X = "%T";
        $locutus.php.locales.fr_CA = _copy($locutus.php.locales.fr);
        $locutus.php.locales.fr_CA.LC_TIME.x = "%Y-%m-%d";
      }
      if (!$locutus.php.locale) {
        $locutus.php.locale = "en_US";
        if (typeof window !== "undefined" && window.document) {
          var d = window.document;
          var NS_XHTML = "https://www.w3.org/1999/xhtml";
          var NS_XML = "https://www.w3.org/XML/1998/namespace";
          if (d.getElementsByTagNameNS && d.getElementsByTagNameNS(NS_XHTML, "html")[0]) {
            if (d.getElementsByTagNameNS(NS_XHTML, "html")[0].getAttributeNS && d.getElementsByTagNameNS(NS_XHTML, "html")[0].getAttributeNS(NS_XML, "lang")) {
              $locutus.php.locale = d.getElementsByTagName(NS_XHTML, "html")[0].getAttributeNS(NS_XML, "lang");
            } else if (d.getElementsByTagNameNS(NS_XHTML, "html")[0].lang) {
              $locutus.php.locale = d.getElementsByTagNameNS(NS_XHTML, "html")[0].lang;
            }
          } else if (d.getElementsByTagName("html")[0] && d.getElementsByTagName("html")[0].lang) {
            $locutus.php.locale = d.getElementsByTagName("html")[0].lang;
          }
        }
      }
      $locutus.php.locale = $locutus.php.locale.replace("-", "_");
      if (!($locutus.php.locale in $locutus.php.locales)) {
        if ($locutus.php.locale.replace(/_[a-zA-Z]+$/, "") in $locutus.php.locales) {
          $locutus.php.locale = $locutus.php.locale.replace(/_[a-zA-Z]+$/, "");
        }
      }
      if (!$locutus.php.localeCategories) {
        $locutus.php.localeCategories = {
          LC_COLLATE: $locutus.php.locale,
          LC_CTYPE: $locutus.php.locale,
          LC_MONETARY: $locutus.php.locale,
          LC_NUMERIC: $locutus.php.locale,
          LC_TIME: $locutus.php.locale,
          LC_MESSAGES: $locutus.php.locale
        };
      }
      if (locale === null || locale === "") {
        locale = getenv(category) || getenv("LANG");
      } else if (Object.prototype.toString.call(locale) === "[object Array]") {
        for (i = 0; i < locale.length; i++) {
          if (!(locale[i] in $locutus.php.locales)) {
            if (i === locale.length - 1) {
              return false;
            }
            continue;
          }
          locale = locale[i];
          break;
        }
      }
      if (locale === "0" || locale === 0) {
        if (category === "LC_ALL") {
          for (categ in $locutus.php.localeCategories) {
            cats.push(categ + "=" + $locutus.php.localeCategories[categ]);
          }
          return cats.join(";");
        }
        return $locutus.php.localeCategories[category];
      }
      if (!(locale in $locutus.php.locales)) {
        return false;
      }
      if (category === "LC_ALL") {
        for (categ in $locutus.php.localeCategories) {
          $locutus.php.localeCategories[categ] = locale;
        }
      } else {
        $locutus.php.localeCategories[category] = locale;
      }
      return locale;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_alnum.js
var require_ctype_alnum = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_alnum.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_alnum(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.an) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_alpha.js
var require_ctype_alpha = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_alpha.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_alpha(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.al) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_cntrl.js
var require_ctype_cntrl = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_cntrl.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_cntrl(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.ct) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_digit.js
var require_ctype_digit = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_digit.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_digit(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.dg) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_graph.js
var require_ctype_graph = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_graph.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_graph(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.gr) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_lower.js
var require_ctype_lower = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_lower.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_lower(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.lw) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_print.js
var require_ctype_print = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_print.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_print(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.pr) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_punct.js
var require_ctype_punct = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_punct.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_punct(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.pu) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_space.js
var require_ctype_space = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_space.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_space(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.sp) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_upper.js
var require_ctype_upper = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_upper.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_upper(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.up) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/ctype_xdigit.js
var require_ctype_xdigit = __commonJS({
  "server/node_modules/locutus/php/ctype/ctype_xdigit.js"(exports, module2) {
    "use strict";
    module2.exports = function ctype_xdigit(text) {
      var setlocale = require_setlocale();
      if (typeof text !== "string") {
        return false;
      }
      setlocale("LC_ALL", 0);
      var $global = typeof window !== "undefined" ? window : global;
      $global.$locutus = $global.$locutus || {};
      var $locutus = $global.$locutus;
      var p = $locutus.php;
      return text.search(p.locales[p.localeCategories.LC_CTYPE].LC_CTYPE.xd) !== -1;
    };
  }
});

// server/node_modules/locutus/php/ctype/index.js
var require_ctype = __commonJS({
  "server/node_modules/locutus/php/ctype/index.js"(exports, module2) {
    "use strict";
    module2.exports.ctype_alnum = require_ctype_alnum();
    module2.exports.ctype_alpha = require_ctype_alpha();
    module2.exports.ctype_cntrl = require_ctype_cntrl();
    module2.exports.ctype_digit = require_ctype_digit();
    module2.exports.ctype_graph = require_ctype_graph();
    module2.exports.ctype_lower = require_ctype_lower();
    module2.exports.ctype_print = require_ctype_print();
    module2.exports.ctype_punct = require_ctype_punct();
    module2.exports.ctype_space = require_ctype_space();
    module2.exports.ctype_upper = require_ctype_upper();
    module2.exports.ctype_xdigit = require_ctype_xdigit();
  }
});

// server/node_modules/locutus/php/var/is_numeric.js
var require_is_numeric = __commonJS({
  "server/node_modules/locutus/php/var/is_numeric.js"(exports, module2) {
    "use strict";
    module2.exports = function is_numeric2(mixedVar) {
      var whitespace = [" ", "\n", "\r", "	", "\f", "\v", "\xA0", "\u2000", "\u2001", "\u2002", "\u2003", "\u2004", "\u2005", "\u2006", "\u2007", "\u2008", "\u2009", "\u200A", "\u200B", "\u2028", "\u2029", "\u3000"].join("");
      return (typeof mixedVar === "number" || typeof mixedVar === "string" && whitespace.indexOf(mixedVar.slice(-1)) === -1) && mixedVar !== "" && !isNaN(mixedVar);
    };
  }
});

// server/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports.Disposable || (exports.Disposable = {}));
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// server/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
          clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
          return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
          clearImmediate(handle);
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
    })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      const candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports.isResponseMessage = isResponseMessage;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports.Event || (exports.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            ral_1.default().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        ral_1.default().timer.clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options !== null && options !== void 0 ? options : "utf-8";
        } else {
          charset = (_a = options.charset) !== null && _a !== void 0 ? _a : "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = ral_1.default().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          ral_1.default().timer.clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        var _a, _b;
        if (options === void 0 || typeof options === "string") {
          return { charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder };
        } else {
          return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[Symbol.toStringTag] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a;
        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
      }
      get last() {
        var _a;
        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map2 = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map2._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Verbose"] = 2] = "Verbose";
    })(Trace = exports.Trace || (exports.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString2(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString2;
    })(Trace = exports.Trace || (exports.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ Object.create(null);
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            const key = createRequestQueueKey(message.params.id);
            const toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type2;
        let requestHandler;
        if (element) {
          type2 = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = String(requestMessage.id);
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type2 !== void 0 && type2.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type2.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = String(responseMessage.id);
          const responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type2 = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            const id = params.id;
            const source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          const element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type2 = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type2 !== void 0) {
                  if (type2.numberOfParams !== 0 && type2.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type2.numberOfParams} params but recevied none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                if (type2 !== void 0) {
                  if (type2.parameterStructures === messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                  }
                  if (type2.numberOfParams !== message.params.length) {
                    logger.error(`Notification ${message.method} defines ${type2.numberOfParams} params but received ${message.params.length} argumennts`);
                  }
                }
                notificationHandler(...message.params);
              } else {
                if (type2 !== void 0 && type2.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = String(responseMessage.id);
          const responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type2, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type: type2,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
            break;
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Recevied parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type2, params) {
        let result;
        const numberOfParams = type2.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type2.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type2, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type2)) {
            method = type2;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type2.method;
            messageParams = computeMessageParams(type2, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type2, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type2)) {
            starNotificationHandler = type2;
          } else if (handler) {
            if (Is2.string(type2)) {
              method = type2;
              notificationHandlers[type2] = { type: void 0, handler };
            } else {
              method = type2.method;
              notificationHandlers[type2.method] = { type: type2, handler };
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                delete notificationHandlers[method];
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type2, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type2)) {
            method = type2;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type2.method;
            messageParams = computeMessageParams(type2, params);
            const numberOfParams = type2.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              cancellationStrategy.sender.sendCancellation(connection, id);
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version2,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          return result;
        },
        onRequest: (type2, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type2)) {
            method = void 0;
            starRequestHandler = type2;
          } else if (Is2.string(type2)) {
            method = null;
            if (handler !== void 0) {
              method = type2;
              requestHandlers[type2] = { handler, type: void 0 };
            }
          } else {
            if (handler !== void 0) {
              method = type2.method;
              requestHandlers[type2.method] = { type: type2, handler };
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                delete requestHandlers[method];
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is2.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          ral_1.default().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// server/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
    exports.CancellationStrategy = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// server/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "server/node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return api_1.createMessageConnection(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// server/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "server/node_modules/vscode-jsonrpc/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// server/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "server/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocument = exports2.EOL = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = void 0;
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
      })(integer = exports2.integer || (exports2.integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
      })(uinteger = exports2.uinteger || (exports2.uinteger = {}));
      var Position3;
      (function(Position4) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.line) && Is2.uinteger(candidate.character);
        }
        Position4.is = is;
      })(Position3 = exports2.Position || (exports2.Position = {}));
      var Range3;
      (function(Range4) {
        function create(one, two, three, four) {
          if (Is2.uinteger(one) && Is2.uinteger(two) && Is2.uinteger(three) && Is2.uinteger(four)) {
            return { start: Position3.create(one, two), end: Position3.create(three, four) };
          } else if (Position3.is(one) && Position3.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
          }
        }
        Range4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Position3.is(candidate.start) && Position3.is(candidate.end);
        }
        Range4.is = is;
      })(Range3 = exports2.Range || (exports2.Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && (Is2.string(candidate.uri) || Is2.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports2.Location || (exports2.Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.targetRange) && Is2.string(candidate.targetUri) && (Range3.is(candidate.targetSelectionRange) || Is2.undefined(candidate.targetSelectionRange)) && (Range3.is(candidate.originSelectionRange) || Is2.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink = exports2.LocationLink || (exports2.LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.numberRange(candidate.red, 0, 1) && Is2.numberRange(candidate.green, 0, 1) && Is2.numberRange(candidate.blue, 0, 1) && Is2.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color = exports2.Color || (exports2.Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Range3.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation = exports2.ColorInformation || (exports2.ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.string(candidate.label) && (Is2.undefined(candidate.textEdit) || TextEdit7.is(candidate)) && (Is2.undefined(candidate.additionalTextEdits) || Is2.typedArray(candidate.additionalTextEdits, TextEdit7.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation = exports2.ColorPresentation || (exports2.ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2["Comment"] = "comment";
        FoldingRangeKind2["Imports"] = "imports";
        FoldingRangeKind2["Region"] = "region";
      })(FoldingRangeKind = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind) {
          var result = {
            startLine,
            endLine
          };
          if (Is2.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is2.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is2.defined(kind)) {
            result.kind = kind;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.uinteger(candidate.startLine) && Is2.uinteger(candidate.startLine) && (Is2.undefined(candidate.startCharacter) || Is2.uinteger(candidate.startCharacter)) && (Is2.undefined(candidate.endCharacter) || Is2.uinteger(candidate.endCharacter)) && (Is2.undefined(candidate.kind) || Is2.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange = exports2.FoldingRange || (exports2.FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Location.is(candidate.location) && Is2.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation = exports2.DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity2;
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 = exports2.DiagnosticSeverity || (exports2.DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag = exports2.DiagnosticTag || (exports2.DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Is2.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription = exports2.CodeDescription || (exports2.CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is2.defined(severity)) {
            result.severity = severity;
          }
          if (Is2.defined(code)) {
            result.code = code;
          }
          if (Is2.defined(source)) {
            result.source = source;
          }
          if (Is2.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && Is2.string(candidate.message) && (Is2.number(candidate.severity) || Is2.undefined(candidate.severity)) && (Is2.integer(candidate.code) || Is2.string(candidate.code) || Is2.undefined(candidate.code)) && (Is2.undefined(candidate.codeDescription) || Is2.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is2.string(candidate.source) || Is2.undefined(candidate.source)) && (Is2.undefined(candidate.relatedInformation) || Is2.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports2.Diagnostic || (exports2.Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is2.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.title) && Is2.string(candidate.command);
        }
        Command2.is = is;
      })(Command = exports2.Command || (exports2.Command = {}));
      var TextEdit7;
      (function(TextEdit8) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit8.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit8.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit8.del = del;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.newText) && Range3.is(candidate.range);
        }
        TextEdit8.is = is;
      })(TextEdit7 = exports2.TextEdit || (exports2.TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation = exports2.ChangeAnnotation || (exports2.ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return typeof candidate === "string";
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier = exports2.ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit7.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit = exports2.AnnotatedTextEdit || (exports2.AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports2.TextDocumentEdit || (exports2.TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile = exports2.CreateFile || (exports2.CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is2.string(candidate.oldUri) && Is2.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile = exports2.RenameFile || (exports2.RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is2.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is2.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile = exports2.DeleteFile || (exports2.DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is2.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit = exports2.WorkspaceEdit || (exports2.WorkspaceEdit = {}));
      var TextEditChangeImpl = function() {
        function TextEditChangeImpl2(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit7.insert(position, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit7.replace(range, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.delete = function(range, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit7.del(range);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.add = function(edit) {
          this.edits.push(edit);
        };
        TextEditChangeImpl2.prototype.all = function() {
          return this.edits;
        };
        TextEditChangeImpl2.prototype.clear = function() {
          this.edits.splice(0, this.edits.length);
        };
        TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
          if (value === void 0) {
            throw new Error("Text edit change is not configured to manage change annotations.");
          }
        };
        return TextEditChangeImpl2;
      }();
      var ChangeAnnotations = function() {
        function ChangeAnnotations2(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        ChangeAnnotations2.prototype.all = function() {
          return this._annotations;
        };
        Object.defineProperty(ChangeAnnotations2.prototype, "size", {
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
          var id;
          if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error("Id " + id + " is already in use.");
          }
          if (annotation === void 0) {
            throw new Error("No annotation provided for id " + id);
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        };
        ChangeAnnotations2.prototype.nextId = function() {
          this._counter++;
          return this._counter.toString();
        };
        return ChangeAnnotations2;
      }();
      var WorkspaceChange = function() {
        function WorkspaceChange2(workspaceEdit) {
          var _this = this;
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach(function(change) {
                if (TextDocumentEdit.is(change)) {
                  var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                  _this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach(function(key) {
                var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                _this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        Object.defineProperty(WorkspaceChange2.prototype, "edit", {
          get: function() {
            this.initDocumentChanges();
            if (this._changeAnnotations !== void 0) {
              if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = void 0;
              } else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            }
            return this._workspaceEdit;
          },
          enumerable: false,
          configurable: true
        });
        WorkspaceChange2.prototype.getTextEditChange = function(key) {
          if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
              var edits = [];
              var textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            var result = this._textEditChanges[key];
            if (!result) {
              var edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        };
        WorkspaceChange2.prototype.initDocumentChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        };
        WorkspaceChange2.prototype.initChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        };
        WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = CreateFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = RenameFile.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = DeleteFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        return WorkspaceChange2;
      }();
      exports2.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports2.TextDocumentIdentifier || (exports2.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (candidate.version === null || Is2.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier = exports2.OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version2, text) {
          return { uri, languageId, version: version2, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.string(candidate.languageId) && Is2.integer(candidate.version) && Is2.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports2.TextDocumentItem || (exports2.TextDocumentItem = {}));
      var MarkupKind5;
      (function(MarkupKind6) {
        MarkupKind6.PlainText = "plaintext";
        MarkupKind6.Markdown = "markdown";
      })(MarkupKind5 = exports2.MarkupKind || (exports2.MarkupKind = {}));
      (function(MarkupKind6) {
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind6.PlainText || candidate === MarkupKind6.Markdown;
        }
        MarkupKind6.is = is;
      })(MarkupKind5 = exports2.MarkupKind || (exports2.MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(value) && MarkupKind5.is(candidate.kind) && Is2.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent = exports2.MarkupContent || (exports2.MarkupContent = {}));
      var CompletionItemKind31;
      (function(CompletionItemKind32) {
        CompletionItemKind32.Text = 1;
        CompletionItemKind32.Method = 2;
        CompletionItemKind32.Function = 3;
        CompletionItemKind32.Constructor = 4;
        CompletionItemKind32.Field = 5;
        CompletionItemKind32.Variable = 6;
        CompletionItemKind32.Class = 7;
        CompletionItemKind32.Interface = 8;
        CompletionItemKind32.Module = 9;
        CompletionItemKind32.Property = 10;
        CompletionItemKind32.Unit = 11;
        CompletionItemKind32.Value = 12;
        CompletionItemKind32.Enum = 13;
        CompletionItemKind32.Keyword = 14;
        CompletionItemKind32.Snippet = 15;
        CompletionItemKind32.Color = 16;
        CompletionItemKind32.File = 17;
        CompletionItemKind32.Reference = 18;
        CompletionItemKind32.Folder = 19;
        CompletionItemKind32.EnumMember = 20;
        CompletionItemKind32.Constant = 21;
        CompletionItemKind32.Struct = 22;
        CompletionItemKind32.Event = 23;
        CompletionItemKind32.Operator = 24;
        CompletionItemKind32.TypeParameter = 25;
      })(CompletionItemKind31 = exports2.CompletionItemKind || (exports2.CompletionItemKind = {}));
      var InsertTextFormat7;
      (function(InsertTextFormat8) {
        InsertTextFormat8.PlainText = 1;
        InsertTextFormat8.Snippet = 2;
      })(InsertTextFormat7 = exports2.InsertTextFormat || (exports2.InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag = exports2.CompletionItemTag || (exports2.CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.newText) && Range3.is(candidate.insert) && Range3.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit = exports2.InsertReplaceEdit || (exports2.InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode = exports2.InsertTextMode || (exports2.InsertTextMode = {}));
      var CompletionItem29;
      (function(CompletionItem30) {
        function create(label) {
          return { label };
        }
        CompletionItem30.create = create;
      })(CompletionItem29 = exports2.CompletionItem || (exports2.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList = exports2.CompletionList || (exports2.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is2.string(candidate) || Is2.objectLiteral(candidate) && Is2.string(candidate.language) && Is2.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString = exports2.MarkedString || (exports2.MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is2.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is2.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range3.is(value.range));
        }
        Hover2.is = is;
      })(Hover = exports2.Hover || (exports2.Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation = exports2.ParameterInformation || (exports2.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is2.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is2.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation = exports2.SignatureInformation || (exports2.SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind = exports2.DocumentHighlightKind || (exports2.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is2.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight = exports2.DocumentHighlight || (exports2.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind = exports2.SymbolKind || (exports2.SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag = exports2.SymbolTag || (exports2.SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation = exports2.SymbolInformation || (exports2.SymbolInformation = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.name) && Is2.number(candidate.kind) && Range3.is(candidate.range) && Range3.is(candidate.selectionRange) && (candidate.detail === void 0 || Is2.string(candidate.detail)) && (candidate.deprecated === void 0 || Is2.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol = exports2.DocumentSymbol || (exports2.DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind = exports2.CodeActionKind || (exports2.CodeActionKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is2.typedArray(candidate.only, Is2.string));
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports2.CodeActionContext || (exports2.CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.title) && (candidate.diagnostics === void 0 || Is2.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is2.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is2.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction = exports2.CodeAction || (exports2.CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is2.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && (Is2.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports2.CodeLens || (exports2.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.uinteger(candidate.tabSize) && Is2.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports2.FormattingOptions || (exports2.FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range3.is(candidate.range) && (Is2.undefined(candidate.target) || Is2.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports2.DocumentLink || (exports2.DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && Range3.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange = exports2.SelectionRange || (exports2.SelectionRange = {}));
      exports2.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version2, content) {
          return new FullTextDocument(uri, languageId, version2, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (Is2.undefined(candidate.languageId) || Is2.string(candidate.languageId)) && Is2.uinteger(candidate.lineCount) && Is2.func(candidate.getText) && Is2.func(candidate.positionAt) && Is2.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument = exports2.TextDocument || (exports2.TextDocument = {}));
      var FullTextDocument = function() {
        function FullTextDocument2(uri, languageId, version2, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version2;
          this._content = content;
          this._lineOffsets = void 0;
        }
        Object.defineProperty(FullTextDocument2.prototype, "uri", {
          get: function() {
            return this._uri;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "languageId", {
          get: function() {
            return this._languageId;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "version", {
          get: function() {
            return this._version;
          },
          enumerable: false,
          configurable: true
        });
        FullTextDocument2.prototype.getText = function(range) {
          if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        };
        FullTextDocument2.prototype.update = function(event, version2) {
          this._content = event.text;
          this._version = version2;
          this._lineOffsets = void 0;
        };
        FullTextDocument2.prototype.getLineOffsets = function() {
          if (this._lineOffsets === void 0) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              var ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        };
        FullTextDocument2.prototype.positionAt = function(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          var lineOffsets = this.getLineOffsets();
          var low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position3.create(0, offset);
          }
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          var line = low - 1;
          return Position3.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument2.prototype.offsetAt = function(position) {
          var lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          var lineOffset = lineOffsets[position.line];
          var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
          get: function() {
            return this.getLineOffsets().length;
          },
          enumerable: false,
          configurable: true
        });
        return FullTextDocument2;
      }();
      var Is2;
      (function(Is3) {
        var toString2 = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is3.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is3.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is3.boolean = boolean;
        function string(value) {
          return toString2.call(value) === "[object String]";
        }
        Is3.string = string;
        function number(value) {
          return toString2.call(value) === "[object Number]";
        }
        Is3.number = number;
        function numberRange(value, min, max) {
          return toString2.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is3.numberRange = numberRange;
        function integer2(value) {
          return toString2.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is3.integer = integer2;
        function uinteger2(value) {
          return toString2.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is3.uinteger = uinteger2;
        function func(value) {
          return toString2.call(value) === "[object Function]";
        }
        Is3.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is3.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is3.typedArray = typedArray;
      })(Is2 || (Is2 = {}));
    });
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeKind;
    (function(FoldingRangeKind2) {
      FoldingRangeKind2["Comment"] = "comment";
      FoldingRangeKind2["Imports"] = "imports";
      FoldingRangeKind2["Region"] = "region";
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
    var messages_1 = require_messages2();
    var SemanticTokenTypes;
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
    })(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
    var SemanticTokenModifiers;
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
    var SemanticTokens;
    (function(SemanticTokens2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    })(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2["document"] = "document";
      UniquenessLevel2["project"] = "project";
      UniquenessLevel2["group"] = "group";
      UniquenessLevel2["scheme"] = "scheme";
      UniquenessLevel2["global"] = "global";
    })(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2["import"] = "import";
      MonikerKind2["export"] = "export";
      MonikerKind2["local"] = "local";
    })(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
    var Is2 = require_is3();
    var messages_1 = require_messages2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "SemanticTokenTypes", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenTypes;
    } });
    Object.defineProperty(exports, "SemanticTokenModifiers", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenModifiers;
    } });
    Object.defineProperty(exports, "SemanticTokens", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokens;
    } });
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !DocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
    var InitializeError;
    (function(InitializeError2) {
      InitializeError2.unknownProtocolVersion = 1;
    })(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar(require_main2(), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
  }
});

// server/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    __exportStar(require_api2(), exports);
    function createProtocolConnection(input, output, logger, options) {
      return node_1.createMessageConnection(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// server/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v42() {
      return new V4UUID();
    }
    exports.v4 = v42;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    function parse2(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports.parse = parse2;
    function generateUuid() {
      return v42().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// server/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection, token);
    }
    exports.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          var _a;
          if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = uuid_1.generateUuid();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection, token);
    }
    exports.attachPartialResult = attachPartialResult;
  }
});

// server/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is2 = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is2.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            return Array.isArray(arg) ? result : result[0];
          });
        }
      };
    };
    exports.ConfigurationFeature = ConfigurationFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/workspaceFolders.js
var require_workspaceFolders = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/workspaceFolders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        initialize(capabilities) {
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type2 = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type2 = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensBuilder = exports.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onDelta: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            },
            onRange: (handler) => {
              const type2 = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          const prevDataLength = this._prevData.length;
          const dataLength = this._data.length;
          let startIndex = 0;
          while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
            startIndex++;
          }
          if (startIndex < dataLength && startIndex < prevDataLength) {
            let endIndex = 0;
            while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
              endIndex++;
            }
            const newData = this._data.slice(startIndex, dataLength - endIndex);
            const result = {
              resultId: this.id,
              edits: [
                { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
              ]
            };
            return result;
          } else if (startIndex < dataLength) {
            return { resultId: this.id, edits: [
              { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
            ] };
          } else if (startIndex < prevDataLength) {
            return { resultId: this.id, edits: [
              { start: startIndex, deleteCount: prevDataLength - startIndex }
            ] };
          } else {
            return { resultId: this.id, edits: [] };
          }
        } else {
          return this.build();
        }
      }
    };
    exports.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// server/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports.FileOperationsFeature = FileOperationsFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type2 = vscode_languageserver_protocol_1.MonikerRequest.type;
              this.connection.onRequest(type2, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type2, params));
              });
            }
          };
        }
      };
    };
    exports.MonikerFeature = MonikerFeature;
  }
});

// server/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.combineFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = exports.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is2 = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolders_1 = require_workspaceFolders();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var TextDocuments = class {
      constructor(configuration) {
        this._documents = /* @__PURE__ */ Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onWillSave() {
        return this._onWillSave.event;
      }
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      get(uri) {
        return this._documents[uri];
      }
      all() {
        return Object.keys(this._documents).map((key) => this._documents[key]);
      }
      keys() {
        return Object.keys(this._documents);
      }
      listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
          let td = event.textDocument;
          let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._documents[td.uri] = document;
          let toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
          let td = event.textDocument;
          let changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          let document = this._documents[td.uri];
          const { version: version2 } = td;
          if (version2 === null || version2 === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          document = this._configuration.update(document, changes, version2);
          this._documents[td.uri] = document;
          this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            delete this._documents[event.textDocument.uri];
            this._onDidClose.fire(Object.freeze({ document }));
          }
        });
        connection.onWillSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
          }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
          let document = this._documents[event.textDocument.uri];
          if (document && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
          } else {
            return [];
          }
        });
        connection.onDidSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onDidSave.fire(Object.freeze({ document }));
          }
        });
      }
    };
    exports.TextDocuments = TextDocuments;
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      sendErrors(connection) {
        Object.keys(this._messages).forEach((message) => {
          connection.window.showErrorMessage(message);
        });
      }
    };
    exports.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection) {
        this._rawConnection = connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type2, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type: type2, message });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = showDocument_1.ShowDocumentFeature(progress_1.ProgressFeature(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type2, registerOptions) {
        const method = Is2.string(type2) ? type2 : type2.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is2.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type2, registerOptions) {
        const method = Is2.string(type2) ? type2 : type2.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type2, registerOptions) {
        const method = Is2.string(type2) ? type2 : type2.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method);
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = fileOperations_1.FileOperationsFeature(workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
      }
    };
    exports._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = moniker_1.MonikerFeature(linkedEditingRange_1.LinkedEditingRangeFeature(semanticTokens_1.SemanticTokensFeature(callHierarchy_1.CallHierarchyFeature(_LanguagesImpl))));
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
      };
      return result;
    }
    exports.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection = connectionFactory(logger);
      logger.rawAttach(connection);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is2.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type2, ...params) => connection.sendRequest(Is2.string(type2) ? type2 : type2.method, ...params),
        onRequest: (type2, handler) => connection.onRequest(type2, handler),
        sendNotification: (type2, param) => {
          const method = Is2.string(type2) ? type2 : type2.method;
          if (arguments.length === 1) {
            connection.sendNotification(method);
          } else {
            connection.sendNotification(method, param);
          }
        },
        onNotification: (type2, handler) => connection.onNotification(type2, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        dispose: () => connection.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is2.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is2.number(capabilities.textDocumentSync) && !Is2.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports.createConnection = createConnection;
  }
});

// server/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "server/node_modules/vscode-languageserver/lib/node/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
    var url = require("url");
    var path = require("path");
    var fs2 = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path.normalize(segments.join("/"));
    }
    exports.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs2.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = child_process_1.fork("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = child_process_1.spawnSync(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path.join(prefix, "node_modules");
          } else {
            return path.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = child_process_1.spawnSync(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs2.existsSync(__filename.toUpperCase()) || !fs2.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        } else {
          return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
          nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports.resolveModulePath = resolveModulePath;
  }
});

// server/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "server/node_modules/vscode-languageserver-protocol/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// server/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProposedFeatures = exports.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    __exportStar(require_main3(), exports);
    __exportStar(require_server(), exports);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features"
      };
    })(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
  }
});

// server/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "server/node_modules/vscode-languageserver/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConnection = exports.Files = void 0;
    var Is2 = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports);
    __exportStar(require_api3(), exports);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files = exports.Files || (exports.Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is2.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv2 = process.argv.slice(2);
        for (let i = 0; i < argv2.length; i++) {
          let arg = argv2[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv2[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv2[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = node_1.createServerSocketTransport(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = node_1.createServerPipeTransport(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is2.func(input.read) && Is2.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = node_1.createProtocolConnection(input, output, logger, options);
        return result;
      };
      return server_1.createConnection(connectionFactory, watchDog, factories);
    }
  }
});

// server/node_modules/ts-md5/dist/md5.js
var require_md52 = __commonJS({
  "server/node_modules/ts-md5/dist/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Md54 = function() {
      function Md55() {
        this._state = new Int32Array(4);
        this._buffer = new ArrayBuffer(68);
        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
        this.start();
      }
      Md55.hashStr = function(str2, raw) {
        if (raw === void 0) {
          raw = false;
        }
        return this.onePassHasher.start().appendStr(str2).end(raw);
      };
      Md55.hashAsciiStr = function(str2, raw) {
        if (raw === void 0) {
          raw = false;
        }
        return this.onePassHasher.start().appendAsciiStr(str2).end(raw);
      };
      Md55._hex = function(x) {
        var hc = Md55.hexChars;
        var ho = Md55.hexOut;
        var n;
        var offset;
        var j;
        var i;
        for (i = 0; i < 4; i += 1) {
          offset = i * 8;
          n = x[i];
          for (j = 0; j < 8; j += 2) {
            ho[offset + 1 + j] = hc.charAt(n & 15);
            n >>>= 4;
            ho[offset + 0 + j] = hc.charAt(n & 15);
            n >>>= 4;
          }
        }
        return ho.join("");
      };
      Md55._md5cycle = function(x, k) {
        var a = x[0];
        var b = x[1];
        var c = x[2];
        var d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      };
      Md55.prototype.start = function() {
        this._dataLength = 0;
        this._bufferLength = 0;
        this._state.set(Md55.stateIdentity);
        return this;
      };
      Md55.prototype.appendStr = function(str2) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var code;
        var i;
        for (i = 0; i < str2.length; i += 1) {
          code = str2.charCodeAt(i);
          if (code < 128) {
            buf8[bufLen++] = code;
          } else if (code < 2048) {
            buf8[bufLen++] = (code >>> 6) + 192;
            buf8[bufLen++] = code & 63 | 128;
          } else if (code < 55296 || code > 56319) {
            buf8[bufLen++] = (code >>> 12) + 224;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          } else {
            code = (code - 55296) * 1024 + (str2.charCodeAt(++i) - 56320) + 65536;
            if (code > 1114111) {
              throw new Error("Unicode standard supports code points up to U+10FFFF");
            }
            buf8[bufLen++] = (code >>> 18) + 240;
            buf8[bufLen++] = code >>> 12 & 63 | 128;
            buf8[bufLen++] = code >>> 6 & 63 | 128;
            buf8[bufLen++] = code & 63 | 128;
          }
          if (bufLen >= 64) {
            this._dataLength += 64;
            Md55._md5cycle(this._state, buf32);
            bufLen -= 64;
            buf32[0] = buf32[16];
          }
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.appendAsciiStr = function(str2) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var i;
        var j = 0;
        for (; ; ) {
          i = Math.min(str2.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = str2.charCodeAt(j++);
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md55._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.appendByteArray = function(input) {
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var bufLen = this._bufferLength;
        var i;
        var j = 0;
        for (; ; ) {
          i = Math.min(input.length - j, 64 - bufLen);
          while (i--) {
            buf8[bufLen++] = input[j++];
          }
          if (bufLen < 64) {
            break;
          }
          this._dataLength += 64;
          Md55._md5cycle(this._state, buf32);
          bufLen = 0;
        }
        this._bufferLength = bufLen;
        return this;
      };
      Md55.prototype.getState = function() {
        var self = this;
        var s = self._state;
        return {
          buffer: String.fromCharCode.apply(null, self._buffer8),
          buflen: self._bufferLength,
          length: self._dataLength,
          state: [s[0], s[1], s[2], s[3]]
        };
      };
      Md55.prototype.setState = function(state) {
        var buf = state.buffer;
        var x = state.state;
        var s = this._state;
        var i;
        this._dataLength = state.length;
        this._bufferLength = state.buflen;
        s[0] = x[0];
        s[1] = x[1];
        s[2] = x[2];
        s[3] = x[3];
        for (i = 0; i < buf.length; i += 1) {
          this._buffer8[i] = buf.charCodeAt(i);
        }
      };
      Md55.prototype.end = function(raw) {
        if (raw === void 0) {
          raw = false;
        }
        var bufLen = this._bufferLength;
        var buf8 = this._buffer8;
        var buf32 = this._buffer32;
        var i = (bufLen >> 2) + 1;
        var dataBitsLen;
        this._dataLength += bufLen;
        buf8[bufLen] = 128;
        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
        buf32.set(Md55.buffer32Identity.subarray(i), i);
        if (bufLen > 55) {
          Md55._md5cycle(this._state, buf32);
          buf32.set(Md55.buffer32Identity);
        }
        dataBitsLen = this._dataLength * 8;
        if (dataBitsLen <= 4294967295) {
          buf32[14] = dataBitsLen;
        } else {
          var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
          if (matches === null) {
            return;
          }
          var lo = parseInt(matches[2], 16);
          var hi = parseInt(matches[1], 16) || 0;
          buf32[14] = lo;
          buf32[15] = hi;
        }
        Md55._md5cycle(this._state, buf32);
        return raw ? this._state : Md55._hex(this._state);
      };
      Md55.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
      Md55.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Md55.hexChars = "0123456789abcdef";
      Md55.hexOut = [];
      Md55.onePassHasher = new Md55();
      return Md55;
    }();
    exports.Md5 = Md54;
    if (Md54.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
      console.error("Md5 self test failed.");
    }
  }
});

// server/node_modules/yaml/dist/PlainValue-ec8e588e.js
var require_PlainValue_ec8e588e = __commonJS({
  "server/node_modules/yaml/dist/PlainValue-ec8e588e.js"(exports) {
    "use strict";
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src) {
      const ls = [0];
      let offset = src.indexOf("\n");
      while (offset !== -1) {
        offset += 1;
        ls.push(offset);
        offset = src.indexOf("\n", offset);
      }
      return ls;
    }
    function getSrcInfo(cst) {
      let lineStarts, src;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src = cst;
      } else {
        if (Array.isArray(cst))
          cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts)
            cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src = cst.context.src;
        }
      }
      return {
        lineStarts,
        src
      };
    }
    function getLinePos(offset, cst) {
      if (typeof offset !== "number" || offset < 0)
        return null;
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !src || offset > src.length)
        return null;
      for (let i = 0; i < lineStarts.length; ++i) {
        const start = lineStarts[i];
        if (offset < start) {
          return {
            line: i,
            col: offset - lineStarts[i - 1] + 1
          };
        }
        if (offset === start)
          return {
            line: i + 1,
            col: 1
          };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset - lineStarts[line - 1] + 1
      };
    }
    function getLine2(line, cst) {
      const {
        lineStarts,
        src
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length)
        return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src[end - 1] === "\n")
        --end;
      return src.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src = getLine2(start.line, cst);
      if (!src)
        return null;
      let {
        col
      } = start;
      if (src.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src = src.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src.length > col + halfWidth)
            src = src.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src.length - maxWidth;
          src = "\u2026" + src.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src}
${offset}${err}${errEnd}`;
    }
    var Range3 = class {
      static copy(orig) {
        return new Range3(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      setOrigRange(cr, offset) {
        const {
          start,
          end
        } = this;
        if (cr.length === 0 || end <= cr[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset;
        }
        let i = offset;
        while (i < cr.length) {
          if (cr[i] > start)
            break;
          else
            ++i;
        }
        this.origStart = start + i;
        const nextOffset = i;
        while (i < cr.length) {
          if (cr[i] >= end)
            break;
          else
            ++i;
        }
        this.origEnd = end + i;
        return nextOffset;
      }
    };
    var Node3 = class {
      static addStringTerminator(src, offset, str2) {
        if (str2[str2.length - 1] === "\n")
          return str2;
        const next = Node3.endOfWhiteSpace(src, offset);
        return next >= src.length || src[next] === "\n" ? str2 + "\n" : str2;
      }
      static atDocumentBoundary(src, offset, sep) {
        const ch0 = src[offset];
        if (!ch0)
          return true;
        const prev = src[offset - 1];
        if (prev && prev !== "\n")
          return false;
        if (sep) {
          if (ch0 !== sep)
            return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
            return false;
        }
        const ch1 = src[offset + 1];
        const ch2 = src[offset + 2];
        if (ch1 !== ch0 || ch2 !== ch0)
          return false;
        const ch3 = src[offset + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src, offset) {
        let ch = src[offset];
        const isVerbatim = ch === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch && notOk.indexOf(ch) === -1)
          ch = src[offset += 1];
        if (isVerbatim && ch === ">")
          offset += 1;
        return offset;
      }
      static endOfIndent(src, offset) {
        let ch = src[offset];
        while (ch === " ")
          ch = src[offset += 1];
        return offset;
      }
      static endOfLine(src, offset) {
        let ch = src[offset];
        while (ch && ch !== "\n")
          ch = src[offset += 1];
        return offset;
      }
      static endOfWhiteSpace(src, offset) {
        let ch = src[offset];
        while (ch === "	" || ch === " ")
          ch = src[offset += 1];
        return offset;
      }
      static startOfLine(src, offset) {
        let ch = src[offset - 1];
        if (ch === "\n")
          return offset;
        while (ch && ch !== "\n")
          ch = src[offset -= 1];
        return offset + 1;
      }
      static endOfBlockIndent(src, indent, lineStart) {
        const inEnd = Node3.endOfIndent(src, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = Node3.endOfWhiteSpace(src, inEnd);
          const ch = src[wsEnd];
          if (!ch || ch === "\n")
            return wsEnd;
        }
        return null;
      }
      static atBlank(src, offset, endAsBlank) {
        const ch = src[offset];
        return ch === "\n" || ch === "	" || ch === " " || endAsBlank && !ch;
      }
      static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
        if (!ch || indentDiff < 0)
          return false;
        if (indentDiff > 0)
          return true;
        return indicatorAsIndent && ch === "-";
      }
      static normalizeOffset(src, offset) {
        const ch = src[offset];
        return !ch ? offset : ch !== "\n" && src[offset - 1] === "\n" ? offset - 1 : Node3.endOfWhiteSpace(src, offset);
      }
      static foldNewline(src, offset, indent) {
        let inCount = 0;
        let error = false;
        let fold = "";
        let ch = src[offset + 1];
        while (ch === " " || ch === "	" || ch === "\n") {
          switch (ch) {
            case "\n":
              inCount = 0;
              offset += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent)
                error = true;
              offset = Node3.endOfWhiteSpace(src, offset + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset += 1;
              break;
          }
          ch = src[offset + 1];
        }
        if (!fold)
          fold = " ";
        if (ch && inCount <= indent)
          error = true;
        return {
          fold,
          offset,
          error
        };
      }
      constructor(type2, props, context) {
        Object.defineProperty(this, "context", {
          value: context || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type2;
        this.value = null;
      }
      getPropValue(idx, key, skipKey) {
        if (!this.context)
          return null;
        const {
          src
        } = this.context;
        const prop = this.props[idx];
        return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i = 0; i < this.props.length; ++i) {
          const anchor = this.getPropValue(i, Char.ANCHOR, true);
          if (anchor != null)
            return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i = 0; i < this.props.length; ++i) {
          const comment = this.getPropValue(i, Char.COMMENT, true);
          if (comment != null)
            comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src
        } = this.context;
        if (this.header && start === this.header.end)
          return false;
        if (!this.valueRange)
          return false;
        const {
          end
        } = this.valueRange;
        return start !== end || Node3.atBlank(src, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] === Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src
          } = this.context;
          for (let i = 0; i < this.props.length; ++i) {
            if (src[this.props[i].start] !== Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context)
          return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start)
          return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context)
          return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i = 0; i < this.props.length; ++i) {
          const tag = this.getPropValue(i, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context)
          return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        for (let i = start; i < end; ++i) {
          if (src[i] === "\n")
            return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src
        } = this.context;
        if (src[start] === Char.COMMENT) {
          const end = Node3.endOfLine(src, start + 1);
          const commentRange = new Range3(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      setOrigRanges(cr, offset) {
        if (this.range)
          offset = this.range.setOrigRange(cr, offset);
        if (this.valueRange)
          this.valueRange.setOrigRange(cr, offset);
        this.props.forEach((prop) => prop.setOrigRange(cr, offset));
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          range,
          value
        } = this;
        if (value != null)
          return value;
        const str2 = src.slice(range.start, range.end);
        return Node3.addStringTerminator(src, range.end, str2);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source, message) {
        if (!message || !(source instanceof Node3))
          throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source;
      }
      makePretty() {
        if (!this.source)
          return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range3(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx)
            this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLReferenceError", source, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSemanticError", source, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source, message) {
        super("YAMLSyntaxError", source, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source, message) {
        super("YAMLWarning", source, message);
      }
    };
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var PlainValue = class extends Node3 {
      static endOfLine(src, start, inFlow) {
        let ch = src[start];
        let offset = start;
        while (ch && ch !== "\n") {
          if (inFlow && (ch === "[" || ch === "]" || ch === "{" || ch === "}" || ch === ","))
            break;
          const next = src[offset + 1];
          if (ch === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
            break;
          if ((ch === " " || ch === "	") && next === "#")
            break;
          offset += 1;
          ch = next;
        }
        return offset;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src
        } = this.context;
        let ch = src[end - 1];
        while (start < end && (ch === "\n" || ch === "	" || ch === " "))
          ch = src[--end - 1];
        let str2 = "";
        for (let i = start; i < end; ++i) {
          const ch2 = src[i];
          if (ch2 === "\n") {
            const {
              fold,
              offset
            } = Node3.foldNewline(src, i, -1);
            str2 += fold;
            i = offset;
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (i < end && (next === " " || next === "	")) {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
          } else {
            str2 += ch2;
          }
        }
        const ch0 = src[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str: str2
            };
          }
          default:
            return str2;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src
        } = this.context;
        let offset = start;
        let valueEnd = start;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          if (Node3.atDocumentBoundary(src, offset + 1))
            break;
          const end = Node3.endOfBlockIndent(src, indent, offset + 1);
          if (end === null || src[end] === "#")
            break;
          if (src[end] === "\n") {
            offset = end;
          } else {
            valueEnd = PlainValue.endOfLine(src, end, inFlow);
            offset = valueEnd;
          }
        }
        if (this.valueRange.isEmpty())
          this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      parse(context, start) {
        this.context = context;
        const {
          inFlow,
          src
        } = context;
        let offset = start;
        const ch = src[offset];
        if (ch && ch !== "#" && ch !== "\n") {
          offset = PlainValue.endOfLine(src, start, inFlow);
        }
        this.valueRange = new Range3(start, offset);
        offset = Node3.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset = this.parseBlockValue(offset);
        }
        return offset;
      }
    };
    exports.Char = Char;
    exports.Node = Node3;
    exports.PlainValue = PlainValue;
    exports.Range = Range3;
    exports.Type = Type;
    exports.YAMLError = YAMLError;
    exports.YAMLReferenceError = YAMLReferenceError;
    exports.YAMLSemanticError = YAMLSemanticError;
    exports.YAMLSyntaxError = YAMLSyntaxError;
    exports.YAMLWarning = YAMLWarning;
    exports._defineProperty = _defineProperty;
    exports.defaultTagPrefix = defaultTagPrefix;
    exports.defaultTags = defaultTags;
  }
});

// server/node_modules/yaml/dist/parse-cst.js
var require_parse_cst = __commonJS({
  "server/node_modules/yaml/dist/parse-cst.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var BlankLine = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.BLANK_LINE);
      }
      get includesTrailingLines() {
        return true;
      }
      parse(context, start) {
        this.context = context;
        this.range = new PlainValue.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          atLineStart,
          lineStart
        } = context;
        if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM)
          this.error = new PlainValue.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context.indent;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        let ch = src[offset];
        const inlineComment = ch === "#";
        const comments = [];
        let blankLine = null;
        while (ch === "\n" || ch === "#") {
          if (ch === "#") {
            const end2 = PlainValue.Node.endOfLine(src, offset + 1);
            comments.push(new PlainValue.Range(offset, end2));
            offset = end2;
          } else {
            atLineStart = true;
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
            if (src[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
            }
            offset = PlainValue.Node.endOfIndent(src, lineStart);
          }
          ch = src[offset];
        }
        if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset);
        } else if (ch && lineStart > start + 1) {
          offset = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context.parent.items || context.parent.contents;
            if (items)
              items.push(blankLine);
          }
          if (comments.length)
            Array.prototype.push.apply(this.props, comments);
          offset = this.node.range.end;
        } else {
          if (inlineComment) {
            const c = comments[0];
            this.props.push(c);
            offset = c.end;
          } else {
            offset = PlainValue.Node.endOfLine(src, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset;
        this.valueRange = new PlainValue.Range(start, end);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.node ? this.node.setOrigRanges(cr, offset) : offset;
      }
      toString() {
        const {
          context: {
            src
          },
          node,
          range,
          value
        } = this;
        if (value != null)
          return value;
        const str2 = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Comment = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.COMMENT);
      }
      parse(context, start) {
        this.context = context;
        const offset = this.parseComment(start);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    function grabCollectionEndComments(node) {
      let cnode = node;
      while (cnode instanceof CollectionItem)
        cnode = cnode.node;
      if (!(cnode instanceof Collection3))
        return null;
      const len = cnode.items.length;
      let ci = -1;
      for (let i = len - 1; i >= 0; --i) {
        const n = cnode.items[i];
        if (n.type === PlainValue.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n.context;
          if (indent > 0 && n.range.start >= lineStart + indent)
            break;
          ci = i;
        } else if (n.type === PlainValue.Type.BLANK_LINE)
          ci = i;
        else
          break;
      }
      if (ci === -1)
        return null;
      const ca = cnode.items.splice(ci, len - ci);
      const prevEnd = ca[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd)
          cnode.valueRange.end = prevEnd;
        if (cnode === node)
          break;
        cnode = cnode.context.parent;
      }
      return ca;
    }
    var Collection3 = class extends PlainValue.Node {
      static nextContentHasIndent(src, offset, indent) {
        const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
        offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
        const ch = src[offset];
        if (!ch)
          return false;
        if (offset >= lineStart + indent)
          return true;
        if (ch !== "#" && ch !== "\n")
          return false;
        return Collection3.nextContentHasIndent(src, offset, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);
        for (let i = firstItem.props.length - 1; i >= 0; --i) {
          if (firstItem.props[i].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i + 1);
            firstItem.props = firstItem.props.slice(i + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let lineStart = PlainValue.Node.startOfLine(src, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset = start;
        offset = PlainValue.Node.normalizeOffset(src, offset);
        let ch = src[offset];
        let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
        let prevIncludesTrailingLines = false;
        while (ch) {
          while (ch === "\n" || ch === "#") {
            if (atLineStart && ch === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset = blankLine.parse({
                src
              }, offset);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
              this.items.push(blankLine);
              offset -= 1;
            } else if (ch === "#") {
              if (offset < lineStart + indent && !Collection3.nextContentHasIndent(src, offset, indent)) {
                return offset;
              }
              const comment = new Comment();
              offset = comment.parse({
                indent,
                lineStart,
                src
              }, offset);
              this.items.push(comment);
              this.valueRange.end = offset;
              if (offset >= src.length) {
                ch = null;
                break;
              }
            }
            lineStart = offset + 1;
            offset = PlainValue.Node.endOfIndent(src, lineStart);
            if (PlainValue.Node.atBlank(src, offset)) {
              const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
              const next = src[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset = wsEnd;
              }
            }
            ch = src[offset];
            atLineStart = true;
          }
          if (!ch) {
            break;
          }
          if (offset !== lineStart + indent && (atLineStart || ch !== ":")) {
            if (offset < lineStart + indent) {
              if (lineStart > start)
                offset = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
            if (ch !== "-") {
              if (lineStart > start)
                offset = lineStart;
              break;
            }
          } else if (ch === "-" && !this.error) {
            const next = src[offset + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue.YAMLSyntaxError(this, msg);
            }
          }
          const node = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset);
          if (!node)
            return offset;
          this.items.push(node);
          this.valueRange.end = node.valueRange.end;
          offset = PlainValue.Node.normalizeOffset(src, node.range.end);
          ch = src[offset];
          atLineStart = false;
          prevIncludesTrailingLines = node.includesTrailingLines;
          if (ch) {
            let ls = offset - 1;
            let prev = src[ls];
            while (prev === " " || prev === "	")
              prev = src[--ls];
            if (prev === "\n") {
              lineStart = ls + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node);
          if (ec)
            Array.prototype.push.apply(this.items, ec);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null)
          return value;
        let str2 = src.slice(range.start, items[0].range.start) + String(items[0]);
        for (let i = 1; i < items.length; ++i) {
          const item = items[i];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart)
            for (let i2 = 0; i2 < indent; ++i2)
              str2 += " ";
          str2 += String(item);
        }
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var Directive = class extends PlainValue.Node {
      constructor() {
        super(PlainValue.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "	" && ch !== " ")
          ch = src[offset += 1];
        this.name = src.slice(start, offset);
        return offset;
      }
      parseParameters(start) {
        const {
          src
        } = this.context;
        let offset = start;
        let ch = src[offset];
        while (ch && ch !== "\n" && ch !== "#")
          ch = src[offset += 1];
        this.valueRange = new PlainValue.Range(start, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        let offset = this.parseName(start + 1);
        offset = this.parseParameters(offset);
        offset = this.parseComment(offset);
        this.range = new PlainValue.Range(start, offset);
        return offset;
      }
    };
    var Document = class extends PlainValue.Node {
      static startCommentOrEndBlankLine(src, start) {
        const offset = PlainValue.Node.endOfWhiteSpace(src, start);
        const ch = src[offset];
        return ch === "#" || ch === "\n" ? offset : start;
      }
      constructor() {
        super(PlainValue.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset = start;
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
          offset = Document.startCommentOrEndBlankLine(src, offset);
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset = directive.parse({
                  parent: this,
                  src
                }, offset);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset;
          }
        }
        if (src[offset]) {
          this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
          return offset + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset;
      }
      parseContents(start) {
        const {
          parseNode,
          src
        } = this.context;
        if (!this.contents)
          this.contents = [];
        let lineStart = start;
        while (src[lineStart - 1] === "-")
          lineStart -= 1;
        let offset = PlainValue.Node.endOfWhiteSpace(src, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue.Range(offset);
        while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
          switch (src[offset]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset = blankLine.parse({
                  src
                }, offset);
                if (offset < src.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset += 1;
                atLineStart = true;
              }
              lineStart = offset;
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue.Node.endOfIndent(src, offset);
              const context = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node = parseNode(context, iEnd);
              if (!node)
                return this.valueRange.end = iEnd;
              this.contents.push(node);
              offset = node.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node);
              if (ec)
                Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset = Document.startCommentOrEndBlankLine(src, offset);
        }
        this.valueRange.end = offset;
        if (src[offset]) {
          this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
          offset += 3;
          if (src[offset]) {
            offset = PlainValue.Node.endOfWhiteSpace(src, offset);
            if (src[offset] === "#") {
              const comment = new Comment();
              offset = comment.parse({
                src
              }, offset);
              this.contents.push(comment);
            }
            switch (src[offset]) {
              case "\n":
                offset += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset;
      }
      parse(context, start) {
        context.root = this;
        this.context = context;
        const {
          src
        } = context;
        let offset = src.charCodeAt(start) === 65279 ? start + 1 : start;
        offset = this.parseDirectives(offset);
        offset = this.parseContents(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.directives.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.directivesEndMarker)
          offset = this.directivesEndMarker.setOrigRange(cr, offset);
        this.contents.forEach((node) => {
          offset = node.setOrigRanges(cr, offset);
        });
        if (this.documentEndMarker)
          offset = this.documentEndMarker.setOrigRange(cr, offset);
        return offset;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null)
          return value;
        let str2 = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT)
            str2 += "---\n";
          str2 += contents.join("");
        }
        if (str2[str2.length - 1] !== "\n")
          str2 += "\n";
        return str2;
      }
    };
    var Alias2 = class extends PlainValue.Node {
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
        this.valueRange = new PlainValue.Range(start + 1, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (this.valueRange.isEmpty())
          return "";
        let lastNewLine = null;
        let ch = src[end - 1];
        while (ch === "\n" || ch === "	" || ch === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP)
              break;
            else
              return "";
          }
          if (ch === "\n")
            lastNewLine = end;
          ch = src[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi = indent + this.blockIndent;
        const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
        let atStart = true;
        let str2 = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i = start; i < end; ++i) {
          for (let j = 0; j < bi; ++j) {
            if (src[i] !== " ")
              break;
            i += 1;
          }
          const ch2 = src[i];
          if (ch2 === "\n") {
            if (sep === "\n")
              str2 += "\n";
            else
              sep = "\n";
          } else {
            const lineEnd = PlainValue.Node.endOfLine(src, i);
            const line = src.slice(i, lineEnd);
            i = lineEnd;
            if (folded && (ch2 === " " || ch2 === "	") && i < keepStart) {
              if (sep === " ")
                sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n")
                sep = "\n\n";
              str2 += sep + line;
              sep = lineEnd < end && src[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str2 += sep + line;
              sep = folded && i < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "")
              atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str2 : str2 + "\n";
      }
      parseBlockHeader(start) {
        const {
          src
        } = this.context;
        let offset = start + 1;
        let bi = "";
        while (true) {
          const ch = src[offset];
          switch (ch) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi += ch;
              break;
            default:
              this.blockIndent = Number(bi) || null;
              this.header = new PlainValue.Range(start, offset);
              return offset;
          }
          offset += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch = src[offset]; ch === "\n"; ch = src[offset]) {
          offset += 1;
          if (PlainValue.Node.atDocumentBoundary(src, offset))
            break;
          const end = PlainValue.Node.endOfBlockIndent(src, indent, offset);
          if (end === null)
            break;
          const ch2 = src[end];
          const lineIndent = end - (offset + indent);
          if (!this.blockIndent) {
            if (src[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch2 && ch2 !== "\n" && lineIndent < this.blockIndent) {
            if (src[end] === "#")
              break;
            if (!this.error) {
              const src2 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src2}`;
              this.error = new PlainValue.YAMLSemanticError(this, msg);
            }
          }
          if (src[end] === "\n") {
            offset = end;
          } else {
            offset = valueEnd = PlainValue.Node.endOfLine(src, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue.Range(start + 1, offset);
        return offset;
      }
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = this.parseBlockHeader(start);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        offset = this.parseBlockValue(offset);
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        return this.header ? this.header.setOrigRange(cr, offset) : offset;
      }
    };
    var FlowCollection = class extends PlainValue.Node {
      constructor(type2, props) {
        super(type2, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node = this.items[idx - 1];
        return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      parse(context, start) {
        this.context = context;
        const {
          parseNode,
          src
        } = context;
        let {
          indent,
          lineStart
        } = context;
        let char = src[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
        char = src[offset];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset + 1;
                const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);
                if (src[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset = PlainValue.Node.endOfIndent(src, lineStart);
                if (offset <= lineStart + indent) {
                  char = src[offset];
                  if (offset < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset = comment.parse({
                  src
                }, offset);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              const next = src[offset + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset
                });
                offset += 1;
                break;
              }
            }
            default: {
              const node = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset);
              if (!node) {
                this.valueRange = new PlainValue.Range(start, offset);
                return offset;
              }
              this.items.push(node);
              offset = PlainValue.Node.normalizeOffset(src, node.range.end);
            }
          }
          offset = PlainValue.Node.endOfWhiteSpace(src, offset);
          char = src[offset];
        }
        this.valueRange = new PlainValue.Range(start, offset + 1);
        if (char) {
          this.items.push({
            char,
            offset
          });
          offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
          offset = this.parseComment(offset);
        }
        return offset;
      }
      setOrigRanges(cr, offset) {
        offset = super.setOrigRanges(cr, offset);
        this.items.forEach((node) => {
          if (node instanceof PlainValue.Node) {
            offset = node.setOrigRanges(cr, offset);
          } else if (cr.length === 0) {
            node.origOffset = node.offset;
          } else {
            let i = offset;
            while (i < cr.length) {
              if (cr[i] > node.offset)
                break;
              else
                ++i;
            }
            node.origOffset = node.offset + i;
            offset = i;
          }
        });
        return offset;
      }
      toString() {
        const {
          context: {
            src
          },
          items,
          range,
          value
        } = this;
        if (value != null)
          return value;
        const nodes = items.filter((item) => item instanceof PlainValue.Node);
        let str2 = "";
        let prevEnd = range.start;
        nodes.forEach((node) => {
          const prefix = src.slice(prevEnd, node.range.start);
          prevEnd = node.range.end;
          str2 += prefix + String(node);
          if (str2[str2.length - 1] === "\n" && src[prevEnd - 1] !== "\n" && src[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str2 += src.slice(prevEnd, range.end);
        return PlainValue.Node.addStringTerminator(src, range.end, str2);
      }
    };
    var QuoteDouble = class extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch && ch !== '"') {
          offset += ch === "\\" ? 2 : 1;
          ch = src[offset];
        }
        return offset + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== '"')
          errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1))
              errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error)
              errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch === "\\") {
            i += 1;
            switch (src[i]) {
              case "0":
                str2 += "\0";
                break;
              case "a":
                str2 += "\x07";
                break;
              case "b":
                str2 += "\b";
                break;
              case "e":
                str2 += "\x1B";
                break;
              case "f":
                str2 += "\f";
                break;
              case "n":
                str2 += "\n";
                break;
              case "r":
                str2 += "\r";
                break;
              case "t":
                str2 += "	";
                break;
              case "v":
                str2 += "\v";
                break;
              case "N":
                str2 += "\x85";
                break;
              case "_":
                str2 += "\xA0";
                break;
              case "L":
                str2 += "\u2028";
                break;
              case "P":
                str2 += "\u2029";
                break;
              case " ":
                str2 += " ";
                break;
              case '"':
                str2 += '"';
                break;
              case "/":
                str2 += "/";
                break;
              case "\\":
                str2 += "\\";
                break;
              case "	":
                str2 += "	";
                break;
              case "x":
                str2 += this.parseCharCode(i + 1, 2, errors);
                i += 2;
                break;
              case "u":
                str2 += this.parseCharCode(i + 1, 4, errors);
                i += 4;
                break;
              case "U":
                str2 += this.parseCharCode(i + 1, 8, errors);
                i += 8;
                break;
              case "\n":
                while (src[i + 1] === " " || src[i + 1] === "	")
                  i += 1;
                break;
              default:
                errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
                str2 += "\\" + src[i];
            }
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      parseCharCode(offset, length, errors) {
        const {
          src
        } = this.context;
        const cc = src.substr(offset, length);
        const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
          return src.substr(offset - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = QuoteDouble.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    var QuoteSingle = class extends PlainValue.Node {
      static endOfQuote(src, offset) {
        let ch = src[offset];
        while (ch) {
          if (ch === "'") {
            if (src[offset + 1] !== "'")
              break;
            ch = src[offset += 2];
          } else {
            ch = src[offset += 1];
          }
        }
        return offset + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src
        } = this.context;
        if (src[end - 1] !== "'")
          errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str2 = "";
        for (let i = start + 1; i < end - 1; ++i) {
          const ch = src[i];
          if (ch === "\n") {
            if (PlainValue.Node.atDocumentBoundary(src, i + 1))
              errors.push(new PlainValue.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset,
              error
            } = PlainValue.Node.foldNewline(src, i, indent);
            str2 += fold;
            i = offset;
            if (error)
              errors.push(new PlainValue.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch === "'") {
            str2 += ch;
            i += 1;
            if (src[i] !== "'")
              errors.push(new PlainValue.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch === " " || ch === "	") {
            const wsStart = i;
            let next = src[i + 1];
            while (next === " " || next === "	") {
              i += 1;
              next = src[i + 1];
            }
            if (next !== "\n")
              str2 += i > wsStart ? src.slice(wsStart, i + 1) : ch;
          } else {
            str2 += ch;
          }
        }
        return errors.length > 0 ? {
          errors,
          str: str2
        } : str2;
      }
      parse(context, start) {
        this.context = context;
        const {
          src
        } = context;
        let offset = QuoteSingle.endOfQuote(src, start + 1);
        this.valueRange = new PlainValue.Range(start, offset);
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        offset = this.parseComment(offset);
        return offset;
      }
    };
    function createNewNode(type2, props) {
      switch (type2) {
        case PlainValue.Type.ALIAS:
          return new Alias2(type2, props);
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
          return new BlockValue(type2, props);
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.FLOW_SEQ:
          return new FlowCollection(type2, props);
        case PlainValue.Type.MAP_KEY:
        case PlainValue.Type.MAP_VALUE:
        case PlainValue.Type.SEQ_ITEM:
          return new CollectionItem(type2, props);
        case PlainValue.Type.COMMENT:
        case PlainValue.Type.PLAIN:
          return new PlainValue.PlainValue(type2, props);
        case PlainValue.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type2, props);
        case PlainValue.Type.QUOTE_SINGLE:
          return new QuoteSingle(type2, props);
        default:
          return null;
      }
    }
    var ParseContext = class {
      static parseType(src, offset, inFlow) {
        switch (src[offset]) {
          case "*":
            return PlainValue.Type.ALIAS;
          case ">":
            return PlainValue.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue.Type.FLOW_MAP;
          case "[":
            return PlainValue.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;
          case '"':
            return PlainValue.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue.Type.QUOTE_SINGLE;
          default:
            return PlainValue.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue.Node.atDocumentBoundary(this.src, start))
            return null;
          const context = new ParseContext(this, overlay);
          const {
            props,
            type: type2,
            valueStart
          } = context.parseProps(start);
          const node = createNewNode(type2, props);
          let offset = node.parse(context, valueStart);
          node.range = new PlainValue.Range(start, offset);
          if (offset <= start) {
            node.error = new Error(`Node#parse consumed no characters`);
            node.error.parseEnd = offset;
            node.error.source = node;
            node.range.end = start + 1;
          }
          if (context.nodeStartsCollection(node)) {
            if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
              node.error = new PlainValue.YAMLSyntaxError(node, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection3(node);
            offset = collection.parse(new ParseContext(context), offset);
            collection.range = new PlainValue.Range(start, offset);
            return collection;
          }
          return node;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node) {
        const {
          inCollection,
          inFlow,
          src
        } = this;
        if (inCollection || inFlow)
          return false;
        if (node instanceof CollectionItem)
          return true;
        let offset = node.range.end;
        if (src[offset] === "\n" || src[offset - 1] === "\n")
          return false;
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);
        return src[offset] === ":";
      }
      parseProps(offset) {
        const {
          inFlow,
          parent,
          src
        } = this;
        const props = [];
        let lineHasProps = false;
        offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
        let ch = src[offset];
        while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === "\n") {
          if (ch === "\n") {
            let inEnd = offset;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue.Node.endOfIndent(src, lineStart);
            } while (src[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src[inEnd] !== "#" && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent))
              break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset = inEnd;
          } else if (ch === PlainValue.Char.COMMENT) {
            const end = PlainValue.Node.endOfLine(src, offset + 1);
            props.push(new PlainValue.Range(offset, end));
            offset = end;
          } else {
            let end = PlainValue.Node.endOfIdentifier(src, offset + 1);
            if (ch === PlainValue.Char.TAG && src[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
              end = PlainValue.Node.endOfIdentifier(src, end + 5);
            }
            props.push(new PlainValue.Range(offset, end));
            lineHasProps = true;
            offset = PlainValue.Node.endOfWhiteSpace(src, end);
          }
          ch = src[offset];
        }
        if (lineHasProps && ch === ":" && PlainValue.Node.atBlank(src, offset + 1, true))
          offset -= 1;
        const type2 = ParseContext.parseType(src, offset, inFlow);
        return {
          props,
          type: type2,
          valueStart: offset
        };
      }
    };
    function parse2(src) {
      const cr = [];
      if (src.indexOf("\r") !== -1) {
        src = src.replace(/\r\n?/g, (match, offset2) => {
          if (match.length > 1)
            cr.push(offset2);
          return "\n";
        });
      }
      const documents = [];
      let offset = 0;
      do {
        const doc = new Document();
        const context = new ParseContext({
          src
        });
        offset = doc.parse(context, offset);
        documents.push(doc);
      } while (offset < src.length);
      documents.setOrigRanges = () => {
        if (cr.length === 0)
          return false;
        for (let i = 1; i < cr.length; ++i)
          cr[i] -= i;
        let crOffset = 0;
        for (let i = 0; i < documents.length; ++i) {
          crOffset = documents[i].setOrigRanges(cr, crOffset);
        }
        cr.splice(0, cr.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    exports.parse = parse2;
  }
});

// server/node_modules/yaml/dist/resolveSeq-d03cb037.js
var require_resolveSeq_d03cb037 = __commonJS({
  "server/node_modules/yaml/dist/resolveSeq-d03cb037.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    function addCommentBefore(str2, indent, comment) {
      if (!comment)
        return str2;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str2}`;
    }
    function addComment(str2, indent, comment) {
      return !comment ? str2 : comment.indexOf("\n") === -1 ? `${str2} #${comment}` : `${str2}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node3 = class {
    };
    function toJSON(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJSON(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor)
          ctx.onCreate = (res2) => {
            anchor.res = res2;
            delete ctx.onCreate;
          };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint")
        return Number(value);
      return value;
    }
    var Scalar3 = class extends Node3 {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema2, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          const o = {};
          Object.defineProperty(o, k, {
            value: v,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v = o;
        }
      }
      return schema2.createNode(v, false);
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && path[Symbol.iterator]().next().done;
    var Collection3 = class extends Node3 {
      constructor(schema2) {
        super();
        PlainValue._defineProperty(this, "items", []);
        this.schema = schema2;
      }
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (node instanceof Collection3)
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (node instanceof Collection3)
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && node instanceof Scalar3 ? node.value : node;
        else
          return node instanceof Collection3 ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node) => {
          if (!node || node.type !== "PAIR")
            return false;
          const n = node.value;
          return n == null || n instanceof Scalar3 && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return node instanceof Collection3 ? node.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (node instanceof Collection3)
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify: stringify2
        } = ctx;
        const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow)
          itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore)
              nodes2.push({
                type: "comment",
                str: ""
              });
            if (item.commentBefore)
              item.commentBefore.match(/^.*$/gm).forEach((line) => {
                nodes2.push({
                  type: "comment",
                  str: `#${line}`
                });
              });
            if (item.comment)
              comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
              hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str3 = stringify2(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str3.includes("\n"))
            hasItemWithNewLine = true;
          if (inFlow && i < this.items.length - 1)
            str3 += ",";
          str3 = addComment(str3, itemIndent, comment);
          if (chompKeep && (comment || inFlow))
            chompKeep = false;
          nodes2.push({
            type: "item",
            str: str3
          });
          return nodes2;
        }, []);
        let str2;
        if (nodes.length === 0) {
          str2 = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n) => n.str);
          if (hasItemWithNewLine || strings.reduce((sum, str3) => sum + str3.length + 2, 2) > Collection3.maxFlowStringSingleLineLength) {
            str2 = start;
            for (const s of strings) {
              str2 += s ? `
${indentStep}${indent}${s}` : "\n";
            }
            str2 += `
${indent}${end}`;
          } else {
            str2 = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str2 = strings.shift();
          for (const s of strings)
            str2 += s ? `
${indent}${s}` : "\n";
        }
        if (this.comment) {
          str2 += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment)
            onComment();
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str2;
      }
    };
    PlainValue._defineProperty(Collection3, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key) {
      let idx = key instanceof Scalar3 ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq2 = class extends Collection3 {
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && it instanceof Scalar3 ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items)
          seq2.push(toJSON(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n) => n.type === "comment" ? n.str : `- ${n.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key, jsKey, ctx) => {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (key instanceof Node3 && ctx && ctx.doc)
        return key.toString({
          anchors: /* @__PURE__ */ Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    var Pair3 = class extends Node3 {
      constructor(key, value = null) {
        super();
        this.key = key;
        this.value = value;
        this.type = Pair3.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node3 ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null)
          this.key = new Scalar3(null);
        if (this.key instanceof Node3)
          this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map2) {
        const key = toJSON(this.key, "", ctx);
        if (map2 instanceof Map) {
          const value = toJSON(this.value, key, ctx);
          map2.set(key, value);
        } else if (map2 instanceof Set) {
          map2.add(key);
        } else {
          const stringKey = stringifyKey(this.key, key, ctx);
          const value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map2)
            Object.defineProperty(map2, stringKey, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map2[stringKey] = value;
        }
        return map2;
      }
      toJSON(_, ctx) {
        const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc)
          return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key,
          value
        } = this;
        let keyComment = key instanceof Node3 && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection3) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node3 ? key instanceof Collection3 || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify: stringify2
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str2 = stringify2(key, ctx, () => keyComment = null, () => chompKeep = true);
        str2 = addComment(str2, ctx.indent, keyComment);
        if (!explicitKey && str2.length > 1024) {
          if (simpleKeys)
            throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str2 = addComment(str2, ctx.indent, this.comment);
            if (onComment)
              onComment();
          } else if (chompKeep && !keyComment && onChompKeep)
            onChompKeep();
          return ctx.inFlow && !explicitKey ? str2 : `? ${str2}`;
        }
        str2 = explicitKey ? `? ${str2}
${indent}:` : `${str2}:`;
        if (this.comment) {
          str2 = addComment(str2, ctx.indent, this.comment);
          if (onComment)
            onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node3) {
          if (value.spaceBefore)
            vcb = "\n";
          if (value.commentBefore) {
            const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar3)
          ctx.indentAtStart = str2.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq2 && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify2(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws = " ";
        if (vcb || this.comment) {
          ws = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection3) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n"))
            ws = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n")
          ws = "";
        if (chompKeep && !valueComment && onChompKeep)
          onChompKeep();
        return addComment(str2 + ws + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue._defineProperty(Pair3, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node, anchors) => {
      if (node instanceof Alias2) {
        const anchor = anchors.get(node.source);
        return anchor.count * anchor.aliasCount;
      } else if (node instanceof Collection3) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(item, anchors);
          if (c > count)
            count = c;
        }
        return count;
      } else if (node instanceof Pair3) {
        const kc = getAliasCount(node.key, anchors);
        const vc = getAliasCount(node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias2 = class extends Node3 {
      static stringify({
        range,
        source
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
        if (!anchor && inStringifyKey)
          anchor = doc.anchors.getName(source) || doc.anchors.newName();
        if (anchor)
          return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range}]`);
      }
      constructor(source) {
        super();
        this.source = source;
        this.type = PlainValue.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx)
          return toJSON(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode)
            throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
          else
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0)
            anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode)
              throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      toString(ctx) {
        return Alias2.stringify(this, ctx);
      }
    };
    PlainValue._defineProperty(Alias2, "default", true);
    function findPair(items, key) {
      const k = key instanceof Scalar3 ? key.value : key;
      for (const it of items) {
        if (it instanceof Pair3) {
          if (it.key === key || it.key === k)
            return it;
          if (it.key && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap2 = class extends Collection3 {
      add(pair, overwrite) {
        if (!pair)
          pair = new Pair3(pair);
        else if (!(pair instanceof Pair3))
          pair = new Pair3(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite)
            prev.value = pair.value;
          else
            throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i === -1)
            this.items.push(pair);
          else
            this.items.splice(i, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it && it.value;
        return !keepScalar && node instanceof Scalar3 ? node.value : node;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair3(key, value), true);
      }
      toJSON(_, ctx, Type) {
        const map2 = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          item.addToJSMap(ctx, map2);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair3))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n) => n.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge2 = class extends Pair3 {
      constructor(pair) {
        if (pair instanceof Pair3) {
          let seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq2)) {
            seq2 = new YAMLSeq2();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          super(pair.key, seq2);
          this.range = pair.range;
        } else {
          super(new Scalar3(MERGE_KEY), new YAMLSeq2());
        }
        this.type = Pair3.Type.MERGE_PAIR;
      }
      addToJSMap(ctx, map2) {
        for (const {
          source
        } of this.value.items) {
          if (!(source instanceof YAMLMap2))
            throw new Error("Merge sources must be maps");
          const srcMap = source.toJSON(null, ctx, Map);
          for (const [key, value] of srcMap) {
            if (map2 instanceof Map) {
              if (!map2.has(key))
                map2.set(key, value);
            } else if (map2 instanceof Set) {
              map2.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
              Object.defineProperty(map2, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map2;
      }
      toString(ctx, onComment) {
        const seq2 = this.value;
        if (seq2.items.length > 1)
          return super.toString(ctx, onComment);
        this.value = seq2.items[0];
        const str2 = super.toString(ctx, onComment);
        this.value = seq2;
        return str2;
      }
    };
    var binaryOptions2 = {
      defaultType: PlainValue.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions2 = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions2 = {
      asBigInt: false
    };
    var nullOptions2 = {
      nullStr: "null"
    };
    var strOptions2 = {
      defaultType: PlainValue.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str2, tags, scalarFallback) {
      for (const {
        format,
        test,
        resolve
      } of tags) {
        if (test) {
          const match = str2.match(test);
          if (match) {
            let res = resolve.apply(null, match);
            if (!(res instanceof Scalar3))
              res = new Scalar3(res);
            if (format)
              res.format = format;
            return res;
          }
        }
      }
      if (scalarFallback)
        str2 = scalarFallback(str2);
      return new Scalar3(str2);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i) => {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    };
    function foldFlowLines(text, indent, mode, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions2.fold) : strOptions2.fold;
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions2.doubleQuoted;
      const json2 = JSON.stringify(value);
      if (jsonEncoding)
        return json2;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
        if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
          str2 += json2.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json2[i + 1]) {
            case "u":
              {
                str2 += json2.slice(start, i);
                const code = json2.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str2 += "\\0";
                    break;
                  case "0007":
                    str2 += "\\a";
                    break;
                  case "000b":
                    str2 += "\\v";
                    break;
                  case "001b":
                    str2 += "\\e";
                    break;
                  case "0085":
                    str2 += "\\N";
                    break;
                  case "00a0":
                    str2 += "\\_";
                    break;
                  case "2028":
                    str2 += "\\L";
                    break;
                  case "2029":
                    str2 += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str2 += "\\x" + code.substr(2);
                    else
                      str2 += json2.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
                i += 1;
              } else {
                str2 += json2.slice(start, i) + "\n\n";
                while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
                  str2 += "\n";
                  i += 2;
                }
                str2 += indent;
                if (json2[i + 2] === " ")
                  str2 += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str2 = start ? str2 + json2.slice(start) : json2;
      return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value))
          return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value))
          return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type: type2,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal = type2 === PlainValue.Type.BLOCK_FOLDED ? false : type2 === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions2.fold.lineWidth, indent.length);
      let header = literal ? "|" : ">";
      if (!value)
        return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws) => {
        const n = ws.indexOf("\n");
        if (n === -1) {
          header += "-";
        } else if (value === ws || n !== ws.length - 1) {
          header += "+";
          if (onChompKeep)
            onChompKeep();
        }
        wsEnd = ws.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws) => {
        if (ws.indexOf(" ") !== -1)
          header += indentSize;
        const m = ws.match(/ +$/);
        if (m) {
          wsStart = ws.slice(0, -m[0].length);
          return m[0];
        } else {
          wsStart = ws;
          return "";
        }
      });
      if (wsEnd)
        wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart)
        wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment)
          onComment();
      }
      if (!value)
        return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions2.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type: type2,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type2 !== PlainValue.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str2 = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags
        } = ctx.doc.schema;
        const resolved = resolveScalar(str2, tags, tags.scalarFallback).value;
        if (typeof resolved !== "string")
          return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment)
          onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions2;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type: type2,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue.Type.BLOCK_FOLDED:
          case PlainValue.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type2 !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type2 === PlainValue.Type.BLOCK_FOLDED || type2 === PlainValue.Type.BLOCK_LITERAL)) {
        type2 = PlainValue.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type2);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null)
          throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint")
        return String(value);
      if (!isFinite(value))
        return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i = cst.items.length - 1; i >= 0; --i) {
        const item = cst.items[i];
        if (!item || item.type !== PlainValue.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end)
            err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source, key) {
      const sk = String(key);
      const k = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment)
              collection.comment += "\n" + comment;
            else
              collection.comment = comment;
          }
        } else {
          if (afterKey && item.value)
            item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore)
              item.spaceBefore = true;
          } else {
            if (item.commentBefore)
              item.commentBefore += "\n" + comment;
            else
              item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node) {
      const res = node.strValue;
      if (!res)
        return "";
      if (typeof res === "string")
        return res;
      res.errors.forEach((error) => {
        if (!error.source)
          error.source = node;
        doc.errors.push(error);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node) {
      const {
        handle,
        suffix
      } = node.tag;
      let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp)
          prefix = dtp.find((p) => p.handle === handle);
        if (!prefix)
          throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix)
        throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue.YAMLWarning(node, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node) {
      const {
        tag,
        type: type2
      } = node;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!")
            return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node);
          } catch (error) {
            doc.errors.push(error);
          }
        }
      }
      switch (type2) {
        case PlainValue.Type.BLOCK_FOLDED:
        case PlainValue.Type.BLOCK_LITERAL:
        case PlainValue.Type.QUOTE_DOUBLE:
        case PlainValue.Type.QUOTE_SINGLE:
          return PlainValue.defaultTags.STR;
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        case PlainValue.Type.PLAIN:
          return nonSpecific ? PlainValue.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node, tagName) {
      const {
        tags
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags) {
        if (tag.tag === tagName) {
          if (tag.test)
            matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node);
            return res instanceof Collection3 ? res : new Scalar3(res);
          }
        }
      }
      const str2 = resolveString(doc, node);
      if (typeof str2 === "string" && matchWithTest.length > 0)
        return resolveScalar(str2, matchWithTest, tags.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type: type2
    }) {
      switch (type2) {
        case PlainValue.Type.FLOW_MAP:
        case PlainValue.Type.MAP:
          return PlainValue.defaultTags.MAP;
        case PlainValue.Type.FLOW_SEQ:
        case PlainValue.Type.SEQ:
          return PlainValue.defaultTags.SEQ;
        default:
          return PlainValue.defaultTags.STR;
      }
    }
    function resolveTag(doc, node, tagName) {
      try {
        const res = resolveByTagName(doc, node, tagName);
        if (res) {
          if (tagName && node.tag)
            res.tag = tagName;
          return res;
        }
      } catch (error) {
        if (!error.source)
          error.source = node;
        doc.errors.push(error);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node);
        if (!fallback)
          throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
        const res = resolveByTagName(doc, node, fallback);
        res.tag = tagName;
        return res;
      } catch (error) {
        const refError = new PlainValue.YAMLReferenceError(node, error.message);
        refError.stack = error.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node) => {
      if (!node)
        return false;
      const {
        type: type2
      } = node;
      return type2 === PlainValue.Type.MAP_KEY || type2 === PlainValue.Type.MAP_VALUE || type2 === PlainValue.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;
      for (const {
        start,
        end
      } of props) {
        switch (node.context.src[start]) {
          case PlainValue.Char.COMMENT: {
            if (!node.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            const {
              header,
              valueRange
            } = node;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node) {
      const {
        anchors,
        errors,
        schema: schema2
      } = doc;
      if (node.type === PlainValue.Type.ALIAS) {
        const name = node.rawValue;
        const src = anchors.getNode(name);
        if (!src) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
        const res = new Alias2(src);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node);
      if (tagName)
        return resolveTag(doc, node, tagName);
      if (node.type !== PlainValue.Type.PLAIN) {
        const msg = `Failed to resolve ${node.type} node here`;
        errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        return null;
      }
      try {
        const str2 = resolveString(doc, node);
        return resolveScalar(str2, schema2.tags, schema2.tags.scalarFallback);
      } catch (error) {
        if (!error.source)
          error.source = node;
        errors.push(error);
        return null;
      }
    }
    function resolveNode(doc, node) {
      if (!node)
        return null;
      if (node.error)
        doc.errors.push(node.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node.anchor;
        const prev = anchors.getNode(name);
        if (prev)
          anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node;
      }
      if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
      }
      const res = resolveNodeValue(doc, node);
      if (res) {
        res.range = [node.range.start, node.range.end];
        if (doc.options.keepCstNodes)
          res.cstNode = node;
        if (doc.options.keepNodeTypes)
          res.type = node.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca = comments.after.join("\n");
        if (ca)
          res.comment = res.comment ? `${res.comment}
${ca}` : ca;
      }
      return node.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map2 = new YAMLMap2();
      map2.items = items;
      resolveComments(map2, comments);
      let hasCollectionKey = false;
      for (let i = 0; i < items.length; ++i) {
        const {
          key: iKey
        } = items[i];
        if (iKey instanceof Collection3)
          hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i] = new Merge2(items[i]);
          const sources = items[i].value.items;
          let error = null;
          sources.some((node) => {
            if (node instanceof Alias2) {
              const {
                type: type2
              } = node.source;
              if (type2 === PlainValue.Type.MAP || type2 === PlainValue.Type.FLOW_MAP)
                return false;
              return error = "Merge nodes aliases can only point to maps";
            }
            return error = "Merge nodes can only have Alias nodes as values";
          });
          if (error)
            doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
        } else {
          for (let j = i + 1; j < items.length; ++j) {
            const {
              key: jKey
            } = items[j];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = map2;
      return map2;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node,
        src
      },
      props
    }) => {
      if (props.length === 0)
        return false;
      const {
        start
      } = props[0];
      if (node && start > node.valueRange.start)
        return false;
      if (src[start] !== PlainValue.Char.COMMENT)
        return false;
      for (let i = lineStart; i < start; ++i)
        if (src[i] === "\n")
          return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item))
        return;
      const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found)
        pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let keyStart = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key,
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              afterKey: !!key,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue.Type.MAP_KEY:
            if (key !== void 0)
              items.push(new Pair3(key));
            if (item.error)
              doc.errors.push(item.error);
            key = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue.Type.MAP_VALUE:
            {
              if (key === void 0)
                key = null;
              if (item.error)
                doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair3(key, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
              }
              key = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key !== void 0)
              items.push(new Pair3(key));
            key = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error)
              doc.errors.push(item.error);
            next:
              for (let j = i + 1; ; ++j) {
                const nextItem = cst.items[j];
                switch (nextItem && nextItem.type) {
                  case PlainValue.Type.BLANK_LINE:
                  case PlainValue.Type.COMMENT:
                    continue next;
                  case PlainValue.Type.MAP_VALUE:
                    break next;
                  default: {
                    const msg = "Implicit map keys need to be followed by map values";
                    doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                    break next;
                  }
                }
              }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key !== void 0)
        items.push(new Pair3(key));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char === "?" && key === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key === void 0)
              key = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key === void 0 && char !== ",")
                key = null;
              explicitKey = false;
            }
            if (key !== void 0) {
              items.push(new Pair3(key));
              key = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i === cst.items.length - 1)
              continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue.YAMLSyntaxError(cst, msg);
          err.offset = offset;
          doc.errors.push(err);
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key,
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
        } else if (key === void 0) {
          if (next === ",")
            doc.errors.push(new PlainValue.YAMLSemanticError(item, "Separator , missing in flow map"));
          key = resolveNode(doc, item);
        } else {
          if (next !== ",")
            doc.errors.push(new PlainValue.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair3(key, resolveNode(doc, item)));
          key = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair3(key));
      return {
        comments,
        items
      };
    }
    function resolveSeq(doc, cst) {
      if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq2 = new YAMLSeq2();
      seq2.items = items;
      resolveComments(seq2, comments);
      if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair3 && it.key instanceof Collection3)) {
        const warn = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
      }
      cst.resolved = seq2;
      return seq2;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        switch (item.type) {
          case PlainValue.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue.Type.SEQ_ITEM:
            if (item.error)
              doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error)
              doc.errors.push(item.error);
            doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i = 0; i < cst.items.length; ++i) {
        const item = cst.items[i];
        if (typeof item.char === "string") {
          const {
            char,
            offset
          } = item;
          if (char !== ":" && (explicitKey || key !== void 0)) {
            if (explicitKey && key === void 0)
              key = next ? items.pop() : null;
            items.push(new Pair3(key));
            explicitKey = false;
            key = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key === void 0) {
            if (next === ",") {
              key = items.pop();
              if (key instanceof Pair3) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
                const {
                  src
                } = prevItem.context;
                for (let i2 = keyStart; i2 < keyEnd; ++i2)
                  if (src[i2] === "\n") {
                    const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                    doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                    break;
                  }
              }
            } else {
              key = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue.YAMLSyntaxError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair3(key, value));
            key = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair3(key));
      return {
        comments,
        items
      };
    }
    exports.Alias = Alias2;
    exports.Collection = Collection3;
    exports.Merge = Merge2;
    exports.Node = Node3;
    exports.Pair = Pair3;
    exports.Scalar = Scalar3;
    exports.YAMLMap = YAMLMap2;
    exports.YAMLSeq = YAMLSeq2;
    exports.addComment = addComment;
    exports.binaryOptions = binaryOptions2;
    exports.boolOptions = boolOptions2;
    exports.findPair = findPair;
    exports.intOptions = intOptions2;
    exports.isEmptyPath = isEmptyPath;
    exports.nullOptions = nullOptions2;
    exports.resolveMap = resolveMap;
    exports.resolveNode = resolveNode;
    exports.resolveSeq = resolveSeq;
    exports.resolveString = resolveString;
    exports.strOptions = strOptions2;
    exports.stringifyNumber = stringifyNumber;
    exports.stringifyString = stringifyString;
    exports.toJSON = toJSON;
  }
});

// server/node_modules/yaml/dist/warnings-1000a372.js
var require_warnings_1000a372 = __commonJS({
  "server/node_modules/yaml/dist/warnings-1000a372.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var binary2 = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve: (doc, node) => {
        const src = resolveSeq.resolveString(doc, node);
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
          return null;
        }
      },
      options: resolveSeq.binaryOptions,
      stringify: ({
        comment,
        type: type2,
        value
      }, ctx, onComment, onChompKeep) => {
        let src;
        if (typeof Buffer === "function") {
          src = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < value.length; ++i)
            s += String.fromCharCode(value[i]);
          src = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type2)
          type2 = resolveSeq.binaryOptions.defaultType;
        if (type2 === PlainValue.Type.QUOTE_DOUBLE) {
          value = src;
        } else {
          const {
            lineWidth
          } = resolveSeq.binaryOptions;
          const n = Math.ceil(src.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = src.substr(o, lineWidth);
          }
          value = lines.join(type2 === PlainValue.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq.stringifyString({
          comment,
          type: type2,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq2 = resolveSeq.resolveSeq(doc, cst);
      for (let i = 0; i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (item instanceof resolveSeq.Pair)
          continue;
        else if (item instanceof resolveSeq.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq.Pair();
          if (item.commentBefore)
            pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment)
            pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq2.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
      }
      return seq2;
    }
    function createPairs(schema2, iterable, ctx) {
      const pairs3 = new resolveSeq.YAMLSeq(schema2);
      pairs3.tag = "tag:yaml.org,2002:pairs";
      for (const it of iterable) {
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else
            throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key = it;
        }
        const pair = schema2.createPair(key, value, ctx);
        pairs3.items.push(pair);
      }
      return pairs3;
    }
    var pairs2 = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class extends resolveSeq.YAMLSeq {
      constructor() {
        super();
        PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));
        PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));
        PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));
        PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));
        PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));
        this.tag = YAMLOMap.tag;
      }
      toJSON(_, ctx) {
        const map2 = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (pair instanceof resolveSeq.Pair) {
            key = resolveSeq.toJSON(pair.key, "", ctx);
            value = resolveSeq.toJSON(pair.value, key, ctx);
          } else {
            key = resolveSeq.toJSON(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
    };
    PlainValue._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs3 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key
      } of pairs3.items) {
        if (key instanceof resolveSeq.Scalar) {
          if (seenKeys.includes(key.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs3);
    }
    function createOMap(schema2, iterable, ctx) {
      const pairs3 = createPairs(schema2, iterable, ctx);
      const omap3 = new YAMLOMap();
      omap3.items = pairs3.items;
      return omap3;
    }
    var omap2 = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class extends resolveSeq.YAMLMap {
      constructor() {
        super();
        this.tag = YAMLSet.tag;
      }
      add(key) {
        const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
        const prev = resolveSeq.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = resolveSeq.findPair(this.items, key);
        return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues())
          return super.toString(ctx, onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    PlainValue._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map2 = resolveSeq.resolveMap(doc, cst);
      if (!map2.hasAllNullValues())
        throw new PlainValue.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map2);
    }
    function createSet(schema2, iterable, ctx) {
      const set3 = new YAMLSet();
      for (const value of iterable)
        set3.items.push(schema2.createPair(value, null, ctx));
      return set3;
    }
    var set2 = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n = parts.split(":").reduce((n2, p) => n2 * 60 + Number(p), 0);
      return sign === "-" ? -n : n;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value))
        return resolveSeq.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str2, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp2 = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str2, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
          return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined")
        return !YAML_SILENCE_WARNINGS;
      return !env.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type2) {
      if (shouldWarn(false)) {
        const emit = typeof process !== "undefined" && process.emitWarning;
        if (emit)
          emit(warning, type2);
        else {
          console.warn(type2 ? `${type2}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename) {
      if (shouldWarn(true)) {
        const path = filename.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    exports.binary = binary2;
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.omap = omap2;
    exports.pairs = pairs2;
    exports.set = set2;
    exports.timestamp = timestamp2;
    exports.warn = warn;
    exports.warnFileDeprecation = warnFileDeprecation;
    exports.warnOptionDeprecation = warnOptionDeprecation;
  }
});

// server/node_modules/yaml/dist/Schema-88e323a7.js
var require_Schema_88e323a7 = __commonJS({
  "server/node_modules/yaml/dist/Schema-88e323a7.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var warnings = require_warnings_1000a372();
    function createMap(schema2, obj, ctx) {
      const map3 = new resolveSeq.YAMLMap(schema2);
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          map3.items.push(schema2.createPair(key, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          map3.items.push(schema2.createPair(key, obj[key], ctx));
      }
      if (typeof schema2.sortMapEntries === "function") {
        map3.items.sort(schema2.sortMapEntries);
      }
      return map3;
    }
    var map2 = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq.resolveMap
    };
    function createSeq(schema2, obj, ctx) {
      const seq3 = new resolveSeq.YAMLSeq(schema2);
      if (obj && obj[Symbol.iterator]) {
        for (const it of obj) {
          const v = schema2.createNode(it, ctx.wrapScalars, null, ctx);
          seq3.items.push(v);
        }
      }
      return seq3;
    }
    var seq2 = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq.strOptions
    };
    var failsafe2 = [map2, seq2, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
    function intStringify$1(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
      return resolveSeq.stringifyNumber(node);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => str2[0] === "t" || str2[0] === "T",
      options: resolveSeq.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str2, oct) => intResolve$1(str2, oct, 8),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2) => intResolve$1(str2, str2, 10),
      options: resolveSeq.intOptions,
      stringify: resolveSeq.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str2, hex) => intResolve$1(str2, hex, 16),
      options: resolveSeq.intOptions,
      stringify: (node) => intStringify$1(node, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str2, frac1, frac2) {
        const frac = frac1 || frac2;
        const node = new resolveSeq.Scalar(parseFloat(str2));
        if (frac && frac[frac.length - 1] === "0")
          node.minFractionDigits = frac.length;
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    };
    var core2 = failsafe2.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json2 = [map2, seq2, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str2) => str2 === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str2) => resolveSeq.intOptions.asBigInt ? BigInt(str2) : parseInt(str2, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str2) => parseFloat(str2),
      stringify: stringifyJSON
    }];
    json2.scalarFallback = (str2) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src, radix) {
      let str2 = src.replace(/_/g, "");
      if (resolveSeq.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const {
        value
      } = node;
      if (intIdentify(value)) {
        const str2 = value.toString(radix);
        return value < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
      }
      return resolveSeq.stringifyNumber(node);
    }
    var yaml11 = failsafe2.concat([{
      identify: (value) => value == null,
      createNode: (schema2, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq.nullOptions,
      stringify: () => resolveSeq.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str2, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node) => intStringify(node, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str2, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node) => intStringify(node, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str2, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str2, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node) => intStringify(node, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str2, nan) => nan ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str2, frac) {
        const node = new resolveSeq.Scalar(parseFloat(str2.replace(/_/g, "")));
        if (frac) {
          const f = frac.replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: resolveSeq.stringifyNumber
    }], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);
    var schemas = {
      core: core2,
      failsafe: failsafe2,
      json: json2,
      yaml11
    };
    var tags = {
      binary: warnings.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings.intTime,
      map: map2,
      null: nullObj,
      omap: warnings.omap,
      pairs: warnings.pairs,
      seq: seq2,
      set: warnings.set,
      timestamp: warnings.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match = tags2.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) || match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (value instanceof resolveSeq.Node)
        return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema: schema2,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema2.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object")
          return wrapScalars ? new resolveSeq.Scalar(value) : value;
        tagObj = value instanceof Map ? map2 : value[Symbol.iterator] ? seq2 : map2;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias = new resolveSeq.Alias(prev);
          ctx.aliasNodes.push(alias);
          return alias;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq.Node)
        obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i = 0; i < tags2.length; ++i) {
        const tag = tags2[i];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema2 = class {
      constructor({
        customTags,
        merge: merge2,
        schema: schema2,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge2;
        this.name = schema2;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnings.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema2);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: Schema2.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode(value, tagName, createCtx);
      }
      createPair(key, value, ctx) {
        if (!ctx)
          ctx = {
            wrapScalars: true
          };
        const k = this.createNode(key, ctx.wrapScalars, null, ctx);
        const v = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq.Pair(k, v);
      }
    };
    PlainValue._defineProperty(Schema2, "defaultPrefix", PlainValue.defaultTagPrefix);
    PlainValue._defineProperty(Schema2, "defaultTags", PlainValue.defaultTags);
    exports.Schema = Schema2;
  }
});

// server/node_modules/yaml/dist/Document-9b4560a1.js
var require_Document_9b4560a1 = __commonJS({
  "server/node_modules/yaml/dist/Document-9b4560a1.js"(exports) {
    "use strict";
    var PlainValue = require_PlainValue_ec8e588e();
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema2 = require_Schema_88e323a7();
    var defaultOptions = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc, tag) {
      if ((doc.version || doc.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv)
          return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p = doc.tagPrefixes.find((p2) => tag.indexOf(p2.prefix) === 0);
      if (!p) {
        const dtp = doc.getDefaults().tagPrefixes;
        p = dtp && dtp.find((p2) => tag.indexOf(p2.prefix) === 0);
      }
      if (!p)
        return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, (ch) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch]);
      return p.handle + suffix;
    }
    function getTagObject(tags, item) {
      if (item instanceof resolveSeq.Alias)
        return resolveSeq.Alias;
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) || match[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match = tags.filter((t) => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
        tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, {
      anchors,
      doc
    }) {
      const props = [];
      const anchor = doc.anchors.getName(node);
      if (anchor) {
        anchors[anchor] = node;
        props.push(`&${anchor}`);
      }
      if (node.tag) {
        props.push(stringifyTag(doc, node.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify2(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema: schema2
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o) => tagObj = o,
          prevObjects: /* @__PURE__ */ new Map()
        };
        item = schema2.createNode(item, true, null, createCtx);
        for (const alias of createCtx.aliasNodes) {
          alias.source = alias.source.node;
          let name = anchors.getName(alias.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair)
        return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj)
        tagObj = getTagObject(schema2.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str2;
      return item instanceof resolveSeq.Scalar || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    var Anchors = class {
      static validAnchorNode(node) {
        return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue._defineProperty(this, "map", /* @__PURE__ */ Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node, name) {
        this.setAnchor(node, name);
        return new resolveSeq.Alias(node);
      }
      createMergePair(...sources) {
        const merge2 = new resolveSeq.Merge();
        merge2.value.items = sources.map((s) => {
          if (s instanceof resolveSeq.Alias) {
            if (s.source instanceof resolveSeq.YAMLMap)
              return s;
          } else if (s instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge2;
      }
      getName(node) {
        const {
          map: map2
        } = this;
        return Object.keys(map2).find((a) => map2[a] === node);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name) {
        return this.map[name];
      }
      newName(prefix) {
        if (!prefix)
          prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i = 1; true; ++i) {
          const name = `${prefix}${i}`;
          if (!names.includes(name))
            return name;
        }
      }
      resolveNodes() {
        const {
          map: map2,
          _cstAliases
        } = this;
        Object.keys(map2).forEach((a) => {
          map2[a] = map2[a].resolved;
        });
        _cstAliases.forEach((a) => {
          a.source = a.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node, name) {
        if (node != null && !Anchors.validAnchorNode(node)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map: map2
        } = this;
        const prev = node && Object.keys(map2).find((a) => map2[a] === node);
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node;
          }
        } else {
          if (!name) {
            if (!node)
              return null;
            name = this.newName();
          }
          map2[name] = node;
        }
        return name;
      }
    };
    var visit = (node, tags) => {
      if (node && typeof node === "object") {
        const {
          tag
        } = node;
        if (node instanceof resolveSeq.Collection) {
          if (tag)
            tags[tag] = true;
          node.items.forEach((n) => visit(n, tags));
        } else if (node instanceof resolveSeq.Pair) {
          visit(node.key, tags);
          visit(node.value, tags);
        } else if (node instanceof resolveSeq.Scalar) {
          if (tag)
            tags[tag] = true;
        }
      }
      return tags;
    };
    var listTagNames = (node) => Object.keys(visit(node, {}));
    function parseContents(doc, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node of contents) {
        if (node.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc, node);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node.comment);
        } else if (node.type === PlainValue.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc.contents = body || null;
      if (!body) {
        doc.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p) => p.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc, directive) {
      let [version2] = directive.parameters;
      if (directive.name === "YAML:1.0")
        version2 = "1.0";
      if (!version2) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version2]) {
        const v0 = doc.version || doc.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version2}`;
        doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
      }
      return version2;
    }
    function parseDirectives(doc, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment,
          name
        } = directive;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error) {
              doc.errors.push(error);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
              doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
            }
        }
        if (comment)
          directiveComments.push(comment);
      }
      if (prevDoc && !hasDirectives && (doc.version || prevDoc.version || doc.options.version) === "1.1") {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc.version = prevDoc.version;
      }
      doc.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection)
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document = class {
      constructor(options) {
        this.anchors = new Anchors(options.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path, value) {
        assertCollection(this.contents);
        this.contents.addIn(path, value);
      }
      delete(key) {
        assertCollection(this.contents);
        return this.contents.delete(key);
      }
      deleteIn(path) {
        if (resolveSeq.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path);
      }
      getDefaults() {
        return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
      }
      get(key, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (resolveSeq.isEmptyPath(path))
          return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
      }
      hasIn(path) {
        if (resolveSeq.isEmptyPath(path))
          return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
      }
      set(key, value) {
        assertCollection(this.contents);
        this.contents.set(key, value);
      }
      setIn(path, value) {
        if (resolveSeq.isEmptyPath(path))
          this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema)
          return;
        if (typeof id === "number")
          id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version)
            this.version = id;
          else
            this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags))
          this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema2.Schema(opt);
      }
      parse(node, prevDoc) {
        if (this.options.keepCstNodes)
          this.cstNode = node;
        if (this.options.keepNodeTypes)
          this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error,
          valueRange
        } = node;
        if (error) {
          if (!error.source)
            error.source = this;
          this.errors.push(error);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker)
          this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error2 of this.errors)
            if (error2 instanceof PlainValue.YAMLError)
              error2.makePretty();
          for (const warn of this.warnings)
            if (warn instanceof PlainValue.YAMLError)
              warn.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t) => t.indexOf(Schema2.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
          throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p) => p.handle === handle);
          if (prev)
            prev.prefix = prefix;
          else
            this.tagPrefixes.push({
              handle,
              prefix
            });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p) => p.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify: stringify2
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0)
          ctx.anchors = new Map(anchorNames.map((name) => [this.anchors.map[name], {
            alias: [],
            aliasCount: 0,
            count: 1
          }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors)
          for (const {
            count,
            res: res2
          } of ctx.anchors.values())
            onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0")
              vd = "%YAML:1.0";
            else if (this.version === "1.1")
              vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker)
          lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker)
            lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: /* @__PURE__ */ Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify: stringify2
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
              lines.push("");
            if (this.contents.commentBefore)
              lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify2(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify2(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue._defineProperty(Document, "defaults", documentOptions);
    exports.Document = Document;
    exports.defaultOptions = defaultOptions;
    exports.scalarOptions = scalarOptions;
  }
});

// server/node_modules/yaml/dist/index.js
var require_dist2 = __commonJS({
  "server/node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var parseCst = require_parse_cst();
    var Document$1 = require_Document_9b4560a1();
    var Schema2 = require_Schema_88e323a7();
    var PlainValue = require_PlainValue_ec8e588e();
    var warnings = require_warnings_1000a372();
    require_resolveSeq_d03cb037();
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema2 = new Schema2.Schema(options);
      return schema2.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options) {
        super(Object.assign({}, Document$1.defaultOptions, options));
      }
    };
    function parseAllDocuments(src, options) {
      const stream = [];
      let prev;
      for (const cstDoc of parseCst.parse(src)) {
        const doc = new Document(options);
        doc.parse(cstDoc, prev);
        stream.push(doc);
        prev = doc;
      }
      return stream;
    }
    function parseDocument3(src, options) {
      const cst = parseCst.parse(src);
      const doc = new Document(options).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc;
    }
    function parse2(src, options) {
      const doc = parseDocument3(src, options);
      doc.warnings.forEach((warning) => warnings.warn(warning));
      if (doc.errors.length > 0)
        throw doc.errors[0];
      return doc.toJSON();
    }
    function stringify2(value, options) {
      const doc = new Document(options);
      doc.contents = value;
      return String(doc);
    }
    var YAML3 = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse: parse2,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument: parseDocument3,
      scalarOptions: Document$1.scalarOptions,
      stringify: stringify2
    };
    exports.YAML = YAML3;
  }
});

// server/node_modules/yaml/index.js
var require_yaml = __commonJS({
  "server/node_modules/yaml/index.js"(exports, module2) {
    module2.exports = require_dist2().YAML;
  }
});

// server/node_modules/yaml/dist/types.js
var require_types = __commonJS({
  "server/node_modules/yaml/dist/types.js"(exports) {
    "use strict";
    var resolveSeq = require_resolveSeq_d03cb037();
    var Schema2 = require_Schema_88e323a7();
    require_PlainValue_ec8e588e();
    require_warnings_1000a372();
    exports.Alias = resolveSeq.Alias;
    exports.Collection = resolveSeq.Collection;
    exports.Merge = resolveSeq.Merge;
    exports.Node = resolveSeq.Node;
    exports.Pair = resolveSeq.Pair;
    exports.Scalar = resolveSeq.Scalar;
    exports.YAMLMap = resolveSeq.YAMLMap;
    exports.YAMLSeq = resolveSeq.YAMLSeq;
    exports.binaryOptions = resolveSeq.binaryOptions;
    exports.boolOptions = resolveSeq.boolOptions;
    exports.intOptions = resolveSeq.intOptions;
    exports.nullOptions = resolveSeq.nullOptions;
    exports.strOptions = resolveSeq.strOptions;
    exports.Schema = Schema2.Schema;
  }
});

// server/node_modules/js-beautify/js/src/core/output.js
var require_output = __commonJS({
  "server/node_modules/js-beautify/js/src/core/output.js"(exports, module2) {
    "use strict";
    function OutputLine(parent) {
      this.__parent = parent;
      this.__character_count = 0;
      this.__indent_count = -1;
      this.__alignment_count = 0;
      this.__wrap_point_index = 0;
      this.__wrap_point_character_count = 0;
      this.__wrap_point_indent_count = -1;
      this.__wrap_point_alignment_count = 0;
      this.__items = [];
    }
    OutputLine.prototype.clone_empty = function() {
      var line = new OutputLine(this.__parent);
      line.set_indent(this.__indent_count, this.__alignment_count);
      return line;
    };
    OutputLine.prototype.item = function(index) {
      if (index < 0) {
        return this.__items[this.__items.length + index];
      } else {
        return this.__items[index];
      }
    };
    OutputLine.prototype.has_match = function(pattern) {
      for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
        if (this.__items[lastCheckedOutput].match(pattern)) {
          return true;
        }
      }
      return false;
    };
    OutputLine.prototype.set_indent = function(indent, alignment) {
      if (this.is_empty()) {
        this.__indent_count = indent || 0;
        this.__alignment_count = alignment || 0;
        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
      }
    };
    OutputLine.prototype._set_wrap_point = function() {
      if (this.__parent.wrap_line_length) {
        this.__wrap_point_index = this.__items.length;
        this.__wrap_point_character_count = this.__character_count;
        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
      }
    };
    OutputLine.prototype._should_wrap = function() {
      return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
    };
    OutputLine.prototype._allow_wrap = function() {
      if (this._should_wrap()) {
        this.__parent.add_new_line();
        var next = this.__parent.current_line;
        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
        next.__items = this.__items.slice(this.__wrap_point_index);
        this.__items = this.__items.slice(0, this.__wrap_point_index);
        next.__character_count += this.__character_count - this.__wrap_point_character_count;
        this.__character_count = this.__wrap_point_character_count;
        if (next.__items[0] === " ") {
          next.__items.splice(0, 1);
          next.__character_count -= 1;
        }
        return true;
      }
      return false;
    };
    OutputLine.prototype.is_empty = function() {
      return this.__items.length === 0;
    };
    OutputLine.prototype.last = function() {
      if (!this.is_empty()) {
        return this.__items[this.__items.length - 1];
      } else {
        return null;
      }
    };
    OutputLine.prototype.push = function(item) {
      this.__items.push(item);
      var last_newline_index = item.lastIndexOf("\n");
      if (last_newline_index !== -1) {
        this.__character_count = item.length - last_newline_index;
      } else {
        this.__character_count += item.length;
      }
    };
    OutputLine.prototype.pop = function() {
      var item = null;
      if (!this.is_empty()) {
        item = this.__items.pop();
        this.__character_count -= item.length;
      }
      return item;
    };
    OutputLine.prototype._remove_indent = function() {
      if (this.__indent_count > 0) {
        this.__indent_count -= 1;
        this.__character_count -= this.__parent.indent_size;
      }
    };
    OutputLine.prototype._remove_wrap_indent = function() {
      if (this.__wrap_point_indent_count > 0) {
        this.__wrap_point_indent_count -= 1;
      }
    };
    OutputLine.prototype.trim = function() {
      while (this.last() === " ") {
        this.__items.pop();
        this.__character_count -= 1;
      }
    };
    OutputLine.prototype.toString = function() {
      var result = "";
      if (this.is_empty()) {
        if (this.__parent.indent_empty_lines) {
          result = this.__parent.get_indent_string(this.__indent_count);
        }
      } else {
        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
        result += this.__items.join("");
      }
      return result;
    };
    function IndentStringCache(options, baseIndentString) {
      this.__cache = [""];
      this.__indent_size = options.indent_size;
      this.__indent_string = options.indent_char;
      if (!options.indent_with_tabs) {
        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
      }
      baseIndentString = baseIndentString || "";
      if (options.indent_level > 0) {
        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
      }
      this.__base_string = baseIndentString;
      this.__base_string_length = baseIndentString.length;
    }
    IndentStringCache.prototype.get_indent_size = function(indent, column) {
      var result = this.__base_string_length;
      column = column || 0;
      if (indent < 0) {
        result = 0;
      }
      result += indent * this.__indent_size;
      result += column;
      return result;
    };
    IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
      var result = this.__base_string;
      column = column || 0;
      if (indent_level < 0) {
        indent_level = 0;
        result = "";
      }
      column += indent_level * this.__indent_size;
      this.__ensure_cache(column);
      result += this.__cache[column];
      return result;
    };
    IndentStringCache.prototype.__ensure_cache = function(column) {
      while (column >= this.__cache.length) {
        this.__add_column();
      }
    };
    IndentStringCache.prototype.__add_column = function() {
      var column = this.__cache.length;
      var indent = 0;
      var result = "";
      if (this.__indent_size && column >= this.__indent_size) {
        indent = Math.floor(column / this.__indent_size);
        column -= indent * this.__indent_size;
        result = new Array(indent + 1).join(this.__indent_string);
      }
      if (column) {
        result += new Array(column + 1).join(" ");
      }
      this.__cache.push(result);
    };
    function Output(options, baseIndentString) {
      this.__indent_cache = new IndentStringCache(options, baseIndentString);
      this.raw = false;
      this._end_with_newline = options.end_with_newline;
      this.indent_size = options.indent_size;
      this.wrap_line_length = options.wrap_line_length;
      this.indent_empty_lines = options.indent_empty_lines;
      this.__lines = [];
      this.previous_line = null;
      this.current_line = null;
      this.next_line = new OutputLine(this);
      this.space_before_token = false;
      this.non_breaking_space = false;
      this.previous_token_wrapped = false;
      this.__add_outputline();
    }
    Output.prototype.__add_outputline = function() {
      this.previous_line = this.current_line;
      this.current_line = this.next_line.clone_empty();
      this.__lines.push(this.current_line);
    };
    Output.prototype.get_line_number = function() {
      return this.__lines.length;
    };
    Output.prototype.get_indent_string = function(indent, column) {
      return this.__indent_cache.get_indent_string(indent, column);
    };
    Output.prototype.get_indent_size = function(indent, column) {
      return this.__indent_cache.get_indent_size(indent, column);
    };
    Output.prototype.is_empty = function() {
      return !this.previous_line && this.current_line.is_empty();
    };
    Output.prototype.add_new_line = function(force_newline) {
      if (this.is_empty() || !force_newline && this.just_added_newline()) {
        return false;
      }
      if (!this.raw) {
        this.__add_outputline();
      }
      return true;
    };
    Output.prototype.get_code = function(eol) {
      this.trim(true);
      var last_item = this.current_line.pop();
      if (last_item) {
        if (last_item[last_item.length - 1] === "\n") {
          last_item = last_item.replace(/\n+$/g, "");
        }
        this.current_line.push(last_item);
      }
      if (this._end_with_newline) {
        this.__add_outputline();
      }
      var sweet_code = this.__lines.join("\n");
      if (eol !== "\n") {
        sweet_code = sweet_code.replace(/[\n]/g, eol);
      }
      return sweet_code;
    };
    Output.prototype.set_wrap_point = function() {
      this.current_line._set_wrap_point();
    };
    Output.prototype.set_indent = function(indent, alignment) {
      indent = indent || 0;
      alignment = alignment || 0;
      this.next_line.set_indent(indent, alignment);
      if (this.__lines.length > 1) {
        this.current_line.set_indent(indent, alignment);
        return true;
      }
      this.current_line.set_indent();
      return false;
    };
    Output.prototype.add_raw_token = function(token) {
      for (var x = 0; x < token.newlines; x++) {
        this.__add_outputline();
      }
      this.current_line.set_indent(-1);
      this.current_line.push(token.whitespace_before);
      this.current_line.push(token.text);
      this.space_before_token = false;
      this.non_breaking_space = false;
      this.previous_token_wrapped = false;
    };
    Output.prototype.add_token = function(printable_token) {
      this.__add_space_before_token();
      this.current_line.push(printable_token);
      this.space_before_token = false;
      this.non_breaking_space = false;
      this.previous_token_wrapped = this.current_line._allow_wrap();
    };
    Output.prototype.__add_space_before_token = function() {
      if (this.space_before_token && !this.just_added_newline()) {
        if (!this.non_breaking_space) {
          this.set_wrap_point();
        }
        this.current_line.push(" ");
      }
    };
    Output.prototype.remove_indent = function(index) {
      var output_length = this.__lines.length;
      while (index < output_length) {
        this.__lines[index]._remove_indent();
        index++;
      }
      this.current_line._remove_wrap_indent();
    };
    Output.prototype.trim = function(eat_newlines) {
      eat_newlines = eat_newlines === void 0 ? false : eat_newlines;
      this.current_line.trim();
      while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
        this.__lines.pop();
        this.current_line = this.__lines[this.__lines.length - 1];
        this.current_line.trim();
      }
      this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
    };
    Output.prototype.just_added_newline = function() {
      return this.current_line.is_empty();
    };
    Output.prototype.just_added_blankline = function() {
      return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
    };
    Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
      var index = this.__lines.length - 2;
      while (index >= 0) {
        var potentialEmptyLine = this.__lines[index];
        if (potentialEmptyLine.is_empty()) {
          break;
        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
          this.__lines.splice(index + 1, 0, new OutputLine(this));
          this.previous_line = this.__lines[this.__lines.length - 2];
          break;
        }
        index--;
      }
    };
    module2.exports.Output = Output;
  }
});

// server/node_modules/js-beautify/js/src/core/token.js
var require_token = __commonJS({
  "server/node_modules/js-beautify/js/src/core/token.js"(exports, module2) {
    "use strict";
    function Token(type2, text, newlines, whitespace_before) {
      this.type = type2;
      this.text = text;
      this.comments_before = null;
      this.newlines = newlines || 0;
      this.whitespace_before = whitespace_before || "";
      this.parent = null;
      this.next = null;
      this.previous = null;
      this.opened = null;
      this.closed = null;
      this.directives = null;
    }
    module2.exports.Token = Token;
  }
});

// server/node_modules/js-beautify/js/src/javascript/acorn.js
var require_acorn = __commonJS({
  "server/node_modules/js-beautify/js/src/javascript/acorn.js"(exports) {
    "use strict";
    var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
    var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
    var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
    var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
    var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
    var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
    exports.identifier = new RegExp(identifierStart + identifierChars, "g");
    exports.identifierStart = new RegExp(identifierStart);
    exports.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
    exports.newline = /[\n\r\u2028\u2029]/;
    exports.lineBreak = new RegExp("\r\n|" + exports.newline.source);
    exports.allLineBreaks = new RegExp(exports.lineBreak.source, "g");
  }
});

// server/node_modules/js-beautify/js/src/core/options.js
var require_options = __commonJS({
  "server/node_modules/js-beautify/js/src/core/options.js"(exports, module2) {
    "use strict";
    function Options(options, merge_child_field) {
      this.raw_options = _mergeOpts(options, merge_child_field);
      this.disabled = this._get_boolean("disabled");
      this.eol = this._get_characters("eol", "auto");
      this.end_with_newline = this._get_boolean("end_with_newline");
      this.indent_size = this._get_number("indent_size", 4);
      this.indent_char = this._get_characters("indent_char", " ");
      this.indent_level = this._get_number("indent_level");
      this.preserve_newlines = this._get_boolean("preserve_newlines", true);
      this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
      if (!this.preserve_newlines) {
        this.max_preserve_newlines = 0;
      }
      this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
      if (this.indent_with_tabs) {
        this.indent_char = "	";
        if (this.indent_size === 1) {
          this.indent_size = 4;
        }
      }
      this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
      this.indent_empty_lines = this._get_boolean("indent_empty_lines");
      this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
    }
    Options.prototype._get_array = function(name, default_value) {
      var option_value = this.raw_options[name];
      var result = default_value || [];
      if (typeof option_value === "object") {
        if (option_value !== null && typeof option_value.concat === "function") {
          result = option_value.concat();
        }
      } else if (typeof option_value === "string") {
        result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
      }
      return result;
    };
    Options.prototype._get_boolean = function(name, default_value) {
      var option_value = this.raw_options[name];
      var result = option_value === void 0 ? !!default_value : !!option_value;
      return result;
    };
    Options.prototype._get_characters = function(name, default_value) {
      var option_value = this.raw_options[name];
      var result = default_value || "";
      if (typeof option_value === "string") {
        result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
      }
      return result;
    };
    Options.prototype._get_number = function(name, default_value) {
      var option_value = this.raw_options[name];
      default_value = parseInt(default_value, 10);
      if (isNaN(default_value)) {
        default_value = 0;
      }
      var result = parseInt(option_value, 10);
      if (isNaN(result)) {
        result = default_value;
      }
      return result;
    };
    Options.prototype._get_selection = function(name, selection_list, default_value) {
      var result = this._get_selection_list(name, selection_list, default_value);
      if (result.length !== 1) {
        throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
      }
      return result[0];
    };
    Options.prototype._get_selection_list = function(name, selection_list, default_value) {
      if (!selection_list || selection_list.length === 0) {
        throw new Error("Selection list cannot be empty.");
      }
      default_value = default_value || [selection_list[0]];
      if (!this._is_valid_selection(default_value, selection_list)) {
        throw new Error("Invalid Default Value!");
      }
      var result = this._get_array(name, default_value);
      if (!this._is_valid_selection(result, selection_list)) {
        throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
      }
      return result;
    };
    Options.prototype._is_valid_selection = function(result, selection_list) {
      return result.length && selection_list.length && !result.some(function(item) {
        return selection_list.indexOf(item) === -1;
      });
    };
    function _mergeOpts(allOptions, childFieldName) {
      var finalOpts = {};
      allOptions = _normalizeOpts(allOptions);
      var name;
      for (name in allOptions) {
        if (name !== childFieldName) {
          finalOpts[name] = allOptions[name];
        }
      }
      if (childFieldName && allOptions[childFieldName]) {
        for (name in allOptions[childFieldName]) {
          finalOpts[name] = allOptions[childFieldName][name];
        }
      }
      return finalOpts;
    }
    function _normalizeOpts(options) {
      var convertedOpts = {};
      var key;
      for (key in options) {
        var newKey = key.replace(/-/g, "_");
        convertedOpts[newKey] = options[key];
      }
      return convertedOpts;
    }
    module2.exports.Options = Options;
    module2.exports.normalizeOpts = _normalizeOpts;
    module2.exports.mergeOpts = _mergeOpts;
  }
});

// server/node_modules/js-beautify/js/src/javascript/options.js
var require_options2 = __commonJS({
  "server/node_modules/js-beautify/js/src/javascript/options.js"(exports, module2) {
    "use strict";
    var BaseOptions = require_options().Options;
    var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
    function Options(options) {
      BaseOptions.call(this, options, "js");
      var raw_brace_style = this.raw_options.brace_style || null;
      if (raw_brace_style === "expand-strict") {
        this.raw_options.brace_style = "expand";
      } else if (raw_brace_style === "collapse-preserve-inline") {
        this.raw_options.brace_style = "collapse,preserve-inline";
      } else if (this.raw_options.braces_on_own_line !== void 0) {
        this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
      }
      var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
      this.brace_preserve_inline = false;
      this.brace_style = "collapse";
      for (var bs = 0; bs < brace_style_split.length; bs++) {
        if (brace_style_split[bs] === "preserve-inline") {
          this.brace_preserve_inline = true;
        } else {
          this.brace_style = brace_style_split[bs];
        }
      }
      this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
      this.break_chained_methods = this._get_boolean("break_chained_methods");
      this.space_in_paren = this._get_boolean("space_in_paren");
      this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
      this.jslint_happy = this._get_boolean("jslint_happy");
      this.space_after_anon_function = this._get_boolean("space_after_anon_function");
      this.space_after_named_function = this._get_boolean("space_after_named_function");
      this.keep_array_indentation = this._get_boolean("keep_array_indentation");
      this.space_before_conditional = this._get_boolean("space_before_conditional", true);
      this.unescape_strings = this._get_boolean("unescape_strings");
      this.e4x = this._get_boolean("e4x");
      this.comma_first = this._get_boolean("comma_first");
      this.operator_position = this._get_selection("operator_position", validPositionValues);
      this.test_output_raw = this._get_boolean("test_output_raw");
      if (this.jslint_happy) {
        this.space_after_anon_function = true;
      }
    }
    Options.prototype = new BaseOptions();
    module2.exports.Options = Options;
  }
});

// server/node_modules/js-beautify/js/src/core/inputscanner.js
var require_inputscanner = __commonJS({
  "server/node_modules/js-beautify/js/src/core/inputscanner.js"(exports, module2) {
    "use strict";
    var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
    function InputScanner(input_string) {
      this.__input = input_string || "";
      this.__input_length = this.__input.length;
      this.__position = 0;
    }
    InputScanner.prototype.restart = function() {
      this.__position = 0;
    };
    InputScanner.prototype.back = function() {
      if (this.__position > 0) {
        this.__position -= 1;
      }
    };
    InputScanner.prototype.hasNext = function() {
      return this.__position < this.__input_length;
    };
    InputScanner.prototype.next = function() {
      var val = null;
      if (this.hasNext()) {
        val = this.__input.charAt(this.__position);
        this.__position += 1;
      }
      return val;
    };
    InputScanner.prototype.peek = function(index) {
      var val = null;
      index = index || 0;
      index += this.__position;
      if (index >= 0 && index < this.__input_length) {
        val = this.__input.charAt(index);
      }
      return val;
    };
    InputScanner.prototype.__match = function(pattern, index) {
      pattern.lastIndex = index;
      var pattern_match = pattern.exec(this.__input);
      if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
        if (pattern_match.index !== index) {
          pattern_match = null;
        }
      }
      return pattern_match;
    };
    InputScanner.prototype.test = function(pattern, index) {
      index = index || 0;
      index += this.__position;
      if (index >= 0 && index < this.__input_length) {
        return !!this.__match(pattern, index);
      } else {
        return false;
      }
    };
    InputScanner.prototype.testChar = function(pattern, index) {
      var val = this.peek(index);
      pattern.lastIndex = 0;
      return val !== null && pattern.test(val);
    };
    InputScanner.prototype.match = function(pattern) {
      var pattern_match = this.__match(pattern, this.__position);
      if (pattern_match) {
        this.__position += pattern_match[0].length;
      } else {
        pattern_match = null;
      }
      return pattern_match;
    };
    InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
      var val = "";
      var match;
      if (starting_pattern) {
        match = this.match(starting_pattern);
        if (match) {
          val += match[0];
        }
      }
      if (until_pattern && (match || !starting_pattern)) {
        val += this.readUntil(until_pattern, until_after);
      }
      return val;
    };
    InputScanner.prototype.readUntil = function(pattern, until_after) {
      var val = "";
      var match_index = this.__position;
      pattern.lastIndex = this.__position;
      var pattern_match = pattern.exec(this.__input);
      if (pattern_match) {
        match_index = pattern_match.index;
        if (until_after) {
          match_index += pattern_match[0].length;
        }
      } else {
        match_index = this.__input_length;
      }
      val = this.__input.substring(this.__position, match_index);
      this.__position = match_index;
      return val;
    };
    InputScanner.prototype.readUntilAfter = function(pattern) {
      return this.readUntil(pattern, true);
    };
    InputScanner.prototype.get_regexp = function(pattern, match_from) {
      var result = null;
      var flags = "g";
      if (match_from && regexp_has_sticky) {
        flags = "y";
      }
      if (typeof pattern === "string" && pattern !== "") {
        result = new RegExp(pattern, flags);
      } else if (pattern) {
        result = new RegExp(pattern.source, flags);
      }
      return result;
    };
    InputScanner.prototype.get_literal_regexp = function(literal_string) {
      return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
    };
    InputScanner.prototype.peekUntilAfter = function(pattern) {
      var start = this.__position;
      var val = this.readUntilAfter(pattern);
      this.__position = start;
      return val;
    };
    InputScanner.prototype.lookBack = function(testVal) {
      var start = this.__position - 1;
      return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
    };
    module2.exports.InputScanner = InputScanner;
  }
});

// server/node_modules/js-beautify/js/src/core/tokenstream.js
var require_tokenstream = __commonJS({
  "server/node_modules/js-beautify/js/src/core/tokenstream.js"(exports, module2) {
    "use strict";
    function TokenStream(parent_token) {
      this.__tokens = [];
      this.__tokens_length = this.__tokens.length;
      this.__position = 0;
      this.__parent_token = parent_token;
    }
    TokenStream.prototype.restart = function() {
      this.__position = 0;
    };
    TokenStream.prototype.isEmpty = function() {
      return this.__tokens_length === 0;
    };
    TokenStream.prototype.hasNext = function() {
      return this.__position < this.__tokens_length;
    };
    TokenStream.prototype.next = function() {
      var val = null;
      if (this.hasNext()) {
        val = this.__tokens[this.__position];
        this.__position += 1;
      }
      return val;
    };
    TokenStream.prototype.peek = function(index) {
      var val = null;
      index = index || 0;
      index += this.__position;
      if (index >= 0 && index < this.__tokens_length) {
        val = this.__tokens[index];
      }
      return val;
    };
    TokenStream.prototype.add = function(token) {
      if (this.__parent_token) {
        token.parent = this.__parent_token;
      }
      this.__tokens.push(token);
      this.__tokens_length += 1;
    };
    module2.exports.TokenStream = TokenStream;
  }
});

// server/node_modules/js-beautify/js/src/core/pattern.js
var require_pattern = __commonJS({
  "server/node_modules/js-beautify/js/src/core/pattern.js"(exports, module2) {
    "use strict";
    function Pattern(input_scanner, parent) {
      this._input = input_scanner;
      this._starting_pattern = null;
      this._match_pattern = null;
      this._until_pattern = null;
      this._until_after = false;
      if (parent) {
        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
        this._until_pattern = this._input.get_regexp(parent._until_pattern);
        this._until_after = parent._until_after;
      }
    }
    Pattern.prototype.read = function() {
      var result = this._input.read(this._starting_pattern);
      if (!this._starting_pattern || result) {
        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
      }
      return result;
    };
    Pattern.prototype.read_match = function() {
      return this._input.match(this._match_pattern);
    };
    Pattern.prototype.until_after = function(pattern) {
      var result = this._create();
      result._until_after = true;
      result._until_pattern = this._input.get_regexp(pattern);
      result._update();
      return result;
    };
    Pattern.prototype.until = function(pattern) {
      var result = this._create();
      result._until_after = false;
      result._until_pattern = this._input.get_regexp(pattern);
      result._update();
      return result;
    };
    Pattern.prototype.starting_with = function(pattern) {
      var result = this._create();
      result._starting_pattern = this._input.get_regexp(pattern, true);
      result._update();
      return result;
    };
    Pattern.prototype.matching = function(pattern) {
      var result = this._create();
      result._match_pattern = this._input.get_regexp(pattern, true);
      result._update();
      return result;
    };
    Pattern.prototype._create = function() {
      return new Pattern(this._input, this);
    };
    Pattern.prototype._update = function() {
    };
    module2.exports.Pattern = Pattern;
  }
});

// server/node_modules/js-beautify/js/src/core/whitespacepattern.js
var require_whitespacepattern = __commonJS({
  "server/node_modules/js-beautify/js/src/core/whitespacepattern.js"(exports, module2) {
    "use strict";
    var Pattern = require_pattern().Pattern;
    function WhitespacePattern(input_scanner, parent) {
      Pattern.call(this, input_scanner, parent);
      if (parent) {
        this._line_regexp = this._input.get_regexp(parent._line_regexp);
      } else {
        this.__set_whitespace_patterns("", "");
      }
      this.newline_count = 0;
      this.whitespace_before_token = "";
    }
    WhitespacePattern.prototype = new Pattern();
    WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
      whitespace_chars += "\\t ";
      newline_chars += "\\n\\r";
      this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
      this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
    };
    WhitespacePattern.prototype.read = function() {
      this.newline_count = 0;
      this.whitespace_before_token = "";
      var resulting_string = this._input.read(this._match_pattern);
      if (resulting_string === " ") {
        this.whitespace_before_token = " ";
      } else if (resulting_string) {
        var matches = this.__split(this._newline_regexp, resulting_string);
        this.newline_count = matches.length - 1;
        this.whitespace_before_token = matches[this.newline_count];
      }
      return resulting_string;
    };
    WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
      var result = this._create();
      result.__set_whitespace_patterns(whitespace_chars, newline_chars);
      result._update();
      return result;
    };
    WhitespacePattern.prototype._create = function() {
      return new WhitespacePattern(this._input, this);
    };
    WhitespacePattern.prototype.__split = function(regexp, input_string) {
      regexp.lastIndex = 0;
      var start_index = 0;
      var result = [];
      var next_match = regexp.exec(input_string);
      while (next_match) {
        result.push(input_string.substring(start_index, next_match.index));
        start_index = next_match.index + next_match[0].length;
        next_match = regexp.exec(input_string);
      }
      if (start_index < input_string.length) {
        result.push(input_string.substring(start_index, input_string.length));
      } else {
        result.push("");
      }
      return result;
    };
    module2.exports.WhitespacePattern = WhitespacePattern;
  }
});

// server/node_modules/js-beautify/js/src/core/tokenizer.js
var require_tokenizer = __commonJS({
  "server/node_modules/js-beautify/js/src/core/tokenizer.js"(exports, module2) {
    "use strict";
    var InputScanner = require_inputscanner().InputScanner;
    var Token = require_token().Token;
    var TokenStream = require_tokenstream().TokenStream;
    var WhitespacePattern = require_whitespacepattern().WhitespacePattern;
    var TOKEN = {
      START: "TK_START",
      RAW: "TK_RAW",
      EOF: "TK_EOF"
    };
    var Tokenizer = function(input_string, options) {
      this._input = new InputScanner(input_string);
      this._options = options || {};
      this.__tokens = null;
      this._patterns = {};
      this._patterns.whitespace = new WhitespacePattern(this._input);
    };
    Tokenizer.prototype.tokenize = function() {
      this._input.restart();
      this.__tokens = new TokenStream();
      this._reset();
      var current;
      var previous = new Token(TOKEN.START, "");
      var open_token = null;
      var open_stack = [];
      var comments = new TokenStream();
      while (previous.type !== TOKEN.EOF) {
        current = this._get_next_token(previous, open_token);
        while (this._is_comment(current)) {
          comments.add(current);
          current = this._get_next_token(previous, open_token);
        }
        if (!comments.isEmpty()) {
          current.comments_before = comments;
          comments = new TokenStream();
        }
        current.parent = open_token;
        if (this._is_opening(current)) {
          open_stack.push(open_token);
          open_token = current;
        } else if (open_token && this._is_closing(current, open_token)) {
          current.opened = open_token;
          open_token.closed = current;
          open_token = open_stack.pop();
          current.parent = open_token;
        }
        current.previous = previous;
        previous.next = current;
        this.__tokens.add(current);
        previous = current;
      }
      return this.__tokens;
    };
    Tokenizer.prototype._is_first_token = function() {
      return this.__tokens.isEmpty();
    };
    Tokenizer.prototype._reset = function() {
    };
    Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
      this._readWhitespace();
      var resulting_string = this._input.read(/.+/g);
      if (resulting_string) {
        return this._create_token(TOKEN.RAW, resulting_string);
      } else {
        return this._create_token(TOKEN.EOF, "");
      }
    };
    Tokenizer.prototype._is_comment = function(current_token) {
      return false;
    };
    Tokenizer.prototype._is_opening = function(current_token) {
      return false;
    };
    Tokenizer.prototype._is_closing = function(current_token, open_token) {
      return false;
    };
    Tokenizer.prototype._create_token = function(type2, text) {
      var token = new Token(type2, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
      return token;
    };
    Tokenizer.prototype._readWhitespace = function() {
      return this._patterns.whitespace.read();
    };
    module2.exports.Tokenizer = Tokenizer;
    module2.exports.TOKEN = TOKEN;
  }
});

// server/node_modules/js-beautify/js/src/core/directives.js
var require_directives = __commonJS({
  "server/node_modules/js-beautify/js/src/core/directives.js"(exports, module2) {
    "use strict";
    function Directives(start_block_pattern, end_block_pattern) {
      start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
      end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
      this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
      this.__directive_pattern = / (\w+)[:](\w+)/g;
      this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
    }
    Directives.prototype.get_directives = function(text) {
      if (!text.match(this.__directives_block_pattern)) {
        return null;
      }
      var directives = {};
      this.__directive_pattern.lastIndex = 0;
      var directive_match = this.__directive_pattern.exec(text);
      while (directive_match) {
        directives[directive_match[1]] = directive_match[2];
        directive_match = this.__directive_pattern.exec(text);
      }
      return directives;
    };
    Directives.prototype.readIgnored = function(input) {
      return input.readUntilAfter(this.__directives_end_ignore_pattern);
    };
    module2.exports.Directives = Directives;
  }
});

// server/node_modules/js-beautify/js/src/core/templatablepattern.js
var require_templatablepattern = __commonJS({
  "server/node_modules/js-beautify/js/src/core/templatablepattern.js"(exports, module2) {
    "use strict";
    var Pattern = require_pattern().Pattern;
    var template_names = {
      django: false,
      erb: false,
      handlebars: false,
      php: false,
      smarty: false
    };
    function TemplatablePattern(input_scanner, parent) {
      Pattern.call(this, input_scanner, parent);
      this.__template_pattern = null;
      this._disabled = Object.assign({}, template_names);
      this._excluded = Object.assign({}, template_names);
      if (parent) {
        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
        this._excluded = Object.assign(this._excluded, parent._excluded);
        this._disabled = Object.assign(this._disabled, parent._disabled);
      }
      var pattern = new Pattern(input_scanner);
      this.__patterns = {
        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
        handlebars: pattern.starting_with(/{{/).until_after(/}}/),
        php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
        django: pattern.starting_with(/{%/).until_after(/%}/),
        django_value: pattern.starting_with(/{{/).until_after(/}}/),
        django_comment: pattern.starting_with(/{#/).until_after(/#}/),
        smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
        smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
      };
    }
    TemplatablePattern.prototype = new Pattern();
    TemplatablePattern.prototype._create = function() {
      return new TemplatablePattern(this._input, this);
    };
    TemplatablePattern.prototype._update = function() {
      this.__set_templated_pattern();
    };
    TemplatablePattern.prototype.disable = function(language) {
      var result = this._create();
      result._disabled[language] = true;
      result._update();
      return result;
    };
    TemplatablePattern.prototype.read_options = function(options) {
      var result = this._create();
      for (var language in template_names) {
        result._disabled[language] = options.templating.indexOf(language) === -1;
      }
      result._update();
      return result;
    };
    TemplatablePattern.prototype.exclude = function(language) {
      var result = this._create();
      result._excluded[language] = true;
      result._update();
      return result;
    };
    TemplatablePattern.prototype.read = function() {
      var result = "";
      if (this._match_pattern) {
        result = this._input.read(this._starting_pattern);
      } else {
        result = this._input.read(this._starting_pattern, this.__template_pattern);
      }
      var next = this._read_template();
      while (next) {
        if (this._match_pattern) {
          next += this._input.read(this._match_pattern);
        } else {
          next += this._input.readUntil(this.__template_pattern);
        }
        result += next;
        next = this._read_template();
      }
      if (this._until_after) {
        result += this._input.readUntilAfter(this._until_pattern);
      }
      return result;
    };
    TemplatablePattern.prototype.__set_templated_pattern = function() {
      var items = [];
      if (!this._disabled.php) {
        items.push(this.__patterns.php._starting_pattern.source);
      }
      if (!this._disabled.handlebars) {
        items.push(this.__patterns.handlebars._starting_pattern.source);
      }
      if (!this._disabled.erb) {
        items.push(this.__patterns.erb._starting_pattern.source);
      }
      if (!this._disabled.django) {
        items.push(this.__patterns.django._starting_pattern.source);
        items.push(this.__patterns.django_value._starting_pattern.source);
        items.push(this.__patterns.django_comment._starting_pattern.source);
      }
      if (!this._disabled.smarty) {
        items.push(this.__patterns.smarty._starting_pattern.source);
      }
      if (this._until_pattern) {
        items.push(this._until_pattern.source);
      }
      this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
    };
    TemplatablePattern.prototype._read_template = function() {
      var resulting_string = "";
      var c = this._input.peek();
      if (c === "<") {
        var peek1 = this._input.peek(1);
        if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
          resulting_string = resulting_string || this.__patterns.php.read();
        }
        if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
          resulting_string = resulting_string || this.__patterns.erb.read();
        }
      } else if (c === "{") {
        if (!this._disabled.handlebars && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
        }
        if (!this._disabled.django) {
          if (!this._excluded.django && !this._excluded.handlebars) {
            resulting_string = resulting_string || this.__patterns.django_value.read();
          }
          if (!this._excluded.django) {
            resulting_string = resulting_string || this.__patterns.django_comment.read();
            resulting_string = resulting_string || this.__patterns.django.read();
          }
        }
        if (!this._disabled.smarty) {
          if (this._disabled.django && this._disabled.handlebars) {
            resulting_string = resulting_string || this.__patterns.smarty_comment.read();
            resulting_string = resulting_string || this.__patterns.smarty_literal.read();
            resulting_string = resulting_string || this.__patterns.smarty.read();
          }
        }
      }
      return resulting_string;
    };
    module2.exports.TemplatablePattern = TemplatablePattern;
  }
});

// server/node_modules/js-beautify/js/src/javascript/tokenizer.js
var require_tokenizer2 = __commonJS({
  "server/node_modules/js-beautify/js/src/javascript/tokenizer.js"(exports, module2) {
    "use strict";
    var InputScanner = require_inputscanner().InputScanner;
    var BaseTokenizer = require_tokenizer().Tokenizer;
    var BASETOKEN = require_tokenizer().TOKEN;
    var Directives = require_directives().Directives;
    var acorn = require_acorn();
    var Pattern = require_pattern().Pattern;
    var TemplatablePattern = require_templatablepattern().TemplatablePattern;
    function in_array(what, arr) {
      return arr.indexOf(what) !== -1;
    }
    var TOKEN = {
      START_EXPR: "TK_START_EXPR",
      END_EXPR: "TK_END_EXPR",
      START_BLOCK: "TK_START_BLOCK",
      END_BLOCK: "TK_END_BLOCK",
      WORD: "TK_WORD",
      RESERVED: "TK_RESERVED",
      SEMICOLON: "TK_SEMICOLON",
      STRING: "TK_STRING",
      EQUALS: "TK_EQUALS",
      OPERATOR: "TK_OPERATOR",
      COMMA: "TK_COMMA",
      BLOCK_COMMENT: "TK_BLOCK_COMMENT",
      COMMENT: "TK_COMMENT",
      DOT: "TK_DOT",
      UNKNOWN: "TK_UNKNOWN",
      START: BASETOKEN.START,
      RAW: BASETOKEN.RAW,
      EOF: BASETOKEN.EOF
    };
    var directives_core = new Directives(/\/\*/, /\*\//);
    var number_pattern = /0[xX][0123456789abcdefABCDEF]*|0[oO][01234567]*|0[bB][01]*|\d+n|(?:\.\d+|\d+\.?\d*)(?:[eE][+-]?\d+)?/;
    var digit = /[0-9]/;
    var dot_pattern = /[^\d\.]/;
    var positionable_operators = ">>> === !== << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
    var punct = ">>>= ... >>= <<= === >>> !== **= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
    punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
    punct = "\\?\\.(?!\\d) " + punct;
    punct = punct.replace(/ /g, "|");
    var punct_pattern = new RegExp(punct);
    var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
    var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as"]);
    var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
    var in_html_comment;
    var Tokenizer = function(input_string, options) {
      BaseTokenizer.call(this, input_string, options);
      this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
      var pattern_reader = new Pattern(this._input);
      var templatable = new TemplatablePattern(this._input).read_options(this._options);
      this.__patterns = {
        template: templatable,
        identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
        number: pattern_reader.matching(number_pattern),
        punct: pattern_reader.matching(punct_pattern),
        comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
        block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
        html_comment_start: pattern_reader.matching(/<!--/),
        html_comment_end: pattern_reader.matching(/-->/),
        include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
        shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
        xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[\s\S]+?}|!\[CDATA\[[\s\S]*?\]\]|)(\s+{[\s\S]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{[\s\S]+?}))*\s*(\/?)\s*>/),
        single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
        double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
        template_text: templatable.until(/[`\\$]/),
        template_expression: templatable.until(/[`}\\]/)
      };
    };
    Tokenizer.prototype = new BaseTokenizer();
    Tokenizer.prototype._is_comment = function(current_token) {
      return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
    };
    Tokenizer.prototype._is_opening = function(current_token) {
      return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
    };
    Tokenizer.prototype._is_closing = function(current_token, open_token) {
      return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
    };
    Tokenizer.prototype._reset = function() {
      in_html_comment = false;
    };
    Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
      var token = null;
      this._readWhitespace();
      var c = this._input.peek();
      if (c === null) {
        return this._create_token(TOKEN.EOF, "");
      }
      token = token || this._read_non_javascript(c);
      token = token || this._read_string(c);
      token = token || this._read_word(previous_token);
      token = token || this._read_singles(c);
      token = token || this._read_comment(c);
      token = token || this._read_regexp(c, previous_token);
      token = token || this._read_xml(c, previous_token);
      token = token || this._read_punctuation();
      token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
      return token;
    };
    Tokenizer.prototype._read_word = function(previous_token) {
      var resulting_string;
      resulting_string = this.__patterns.identifier.read();
      if (resulting_string !== "") {
        resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
        if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
          if (resulting_string === "in" || resulting_string === "of") {
            return this._create_token(TOKEN.OPERATOR, resulting_string);
          }
          return this._create_token(TOKEN.RESERVED, resulting_string);
        }
        return this._create_token(TOKEN.WORD, resulting_string);
      }
      resulting_string = this.__patterns.number.read();
      if (resulting_string !== "") {
        return this._create_token(TOKEN.WORD, resulting_string);
      }
    };
    Tokenizer.prototype._read_singles = function(c) {
      var token = null;
      if (c === "(" || c === "[") {
        token = this._create_token(TOKEN.START_EXPR, c);
      } else if (c === ")" || c === "]") {
        token = this._create_token(TOKEN.END_EXPR, c);
      } else if (c === "{") {
        token = this._create_token(TOKEN.START_BLOCK, c);
      } else if (c === "}") {
        token = this._create_token(TOKEN.END_BLOCK, c);
      } else if (c === ";") {
        token = this._create_token(TOKEN.SEMICOLON, c);
      } else if (c === "." && dot_pattern.test(this._input.peek(1))) {
        token = this._create_token(TOKEN.DOT, c);
      } else if (c === ",") {
        token = this._create_token(TOKEN.COMMA, c);
      }
      if (token) {
        this._input.next();
      }
      return token;
    };
    Tokenizer.prototype._read_punctuation = function() {
      var resulting_string = this.__patterns.punct.read();
      if (resulting_string !== "") {
        if (resulting_string === "=") {
          return this._create_token(TOKEN.EQUALS, resulting_string);
        } else if (resulting_string === "?.") {
          return this._create_token(TOKEN.DOT, resulting_string);
        } else {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
      }
    };
    Tokenizer.prototype._read_non_javascript = function(c) {
      var resulting_string = "";
      if (c === "#") {
        if (this._is_first_token()) {
          resulting_string = this.__patterns.shebang.read();
          if (resulting_string) {
            return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
          }
        }
        resulting_string = this.__patterns.include.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
        }
        c = this._input.next();
        var sharp = "#";
        if (this._input.hasNext() && this._input.testChar(digit)) {
          do {
            c = this._input.next();
            sharp += c;
          } while (this._input.hasNext() && c !== "#" && c !== "=");
          if (c === "#") {
          } else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
            sharp += "[]";
            this._input.next();
            this._input.next();
          } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
            sharp += "{}";
            this._input.next();
            this._input.next();
          }
          return this._create_token(TOKEN.WORD, sharp);
        }
        this._input.back();
      } else if (c === "<" && this._is_first_token()) {
        resulting_string = this.__patterns.html_comment_start.read();
        if (resulting_string) {
          while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
            resulting_string += this._input.next();
          }
          in_html_comment = true;
          return this._create_token(TOKEN.COMMENT, resulting_string);
        }
      } else if (in_html_comment && c === "-") {
        resulting_string = this.__patterns.html_comment_end.read();
        if (resulting_string) {
          in_html_comment = false;
          return this._create_token(TOKEN.COMMENT, resulting_string);
        }
      }
      return null;
    };
    Tokenizer.prototype._read_comment = function(c) {
      var token = null;
      if (c === "/") {
        var comment = "";
        if (this._input.peek(1) === "*") {
          comment = this.__patterns.block_comment.read();
          var directives = directives_core.get_directives(comment);
          if (directives && directives.ignore === "start") {
            comment += directives_core.readIgnored(this._input);
          }
          comment = comment.replace(acorn.allLineBreaks, "\n");
          token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
          token.directives = directives;
        } else if (this._input.peek(1) === "/") {
          comment = this.__patterns.comment.read();
          token = this._create_token(TOKEN.COMMENT, comment);
        }
      }
      return token;
    };
    Tokenizer.prototype._read_string = function(c) {
      if (c === "`" || c === "'" || c === '"') {
        var resulting_string = this._input.next();
        this.has_char_escapes = false;
        if (c === "`") {
          resulting_string += this._read_string_recursive("`", true, "${");
        } else {
          resulting_string += this._read_string_recursive(c);
        }
        if (this.has_char_escapes && this._options.unescape_strings) {
          resulting_string = unescape_string(resulting_string);
        }
        if (this._input.peek() === c) {
          resulting_string += this._input.next();
        }
        resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
        return this._create_token(TOKEN.STRING, resulting_string);
      }
      return null;
    };
    Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
      return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
        TOKEN.COMMENT,
        TOKEN.START_EXPR,
        TOKEN.START_BLOCK,
        TOKEN.START,
        TOKEN.END_BLOCK,
        TOKEN.OPERATOR,
        TOKEN.EQUALS,
        TOKEN.EOF,
        TOKEN.SEMICOLON,
        TOKEN.COMMA
      ]);
    };
    Tokenizer.prototype._read_regexp = function(c, previous_token) {
      if (c === "/" && this._allow_regexp_or_xml(previous_token)) {
        var resulting_string = this._input.next();
        var esc = false;
        var in_char_class = false;
        while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn.newline))) {
          resulting_string += this._input.peek();
          if (!esc) {
            esc = this._input.peek() === "\\";
            if (this._input.peek() === "[") {
              in_char_class = true;
            } else if (this._input.peek() === "]") {
              in_char_class = false;
            }
          } else {
            esc = false;
          }
          this._input.next();
        }
        if (this._input.peek() === c) {
          resulting_string += this._input.next();
          resulting_string += this._input.read(acorn.identifier);
        }
        return this._create_token(TOKEN.STRING, resulting_string);
      }
      return null;
    };
    Tokenizer.prototype._read_xml = function(c, previous_token) {
      if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
        var xmlStr = "";
        var match = this.__patterns.xml.read_match();
        if (match) {
          var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
          var isCurlyRoot = rootTag.indexOf("{") === 0;
          var depth = 0;
          while (match) {
            var isEndTag = !!match[1];
            var tagName = match[2];
            var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
            if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
              if (isEndTag) {
                --depth;
              } else {
                ++depth;
              }
            }
            xmlStr += match[0];
            if (depth <= 0) {
              break;
            }
            match = this.__patterns.xml.read_match();
          }
          if (!match) {
            xmlStr += this._input.match(/[\s\S]*/g)[0];
          }
          xmlStr = xmlStr.replace(acorn.allLineBreaks, "\n");
          return this._create_token(TOKEN.STRING, xmlStr);
        }
      }
      return null;
    };
    function unescape_string(s) {
      var out = "", escaped = 0;
      var input_scan = new InputScanner(s);
      var matched = null;
      while (input_scan.hasNext()) {
        matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
        if (matched) {
          out += matched[0];
        }
        if (input_scan.peek() === "\\") {
          input_scan.next();
          if (input_scan.peek() === "x") {
            matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
          } else if (input_scan.peek() === "u") {
            matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
          } else {
            out += "\\";
            if (input_scan.hasNext()) {
              out += input_scan.next();
            }
            continue;
          }
          if (!matched) {
            return s;
          }
          escaped = parseInt(matched[1], 16);
          if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
            return s;
          } else if (escaped >= 0 && escaped < 32) {
            out += "\\" + matched[0];
            continue;
          } else if (escaped === 34 || escaped === 39 || escaped === 92) {
            out += "\\" + String.fromCharCode(escaped);
          } else {
            out += String.fromCharCode(escaped);
          }
        }
      }
      return out;
    }
    Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
      var current_char;
      var pattern;
      if (delimiter === "'") {
        pattern = this.__patterns.single_quote;
      } else if (delimiter === '"') {
        pattern = this.__patterns.double_quote;
      } else if (delimiter === "`") {
        pattern = this.__patterns.template_text;
      } else if (delimiter === "}") {
        pattern = this.__patterns.template_expression;
      }
      var resulting_string = pattern.read();
      var next = "";
      while (this._input.hasNext()) {
        next = this._input.next();
        if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {
          this._input.back();
          break;
        } else if (next === "\\" && this._input.hasNext()) {
          current_char = this._input.peek();
          if (current_char === "x" || current_char === "u") {
            this.has_char_escapes = true;
          } else if (current_char === "\r" && this._input.peek(1) === "\n") {
            this._input.next();
          }
          next += this._input.next();
        } else if (start_sub) {
          if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
            next += this._input.next();
          }
          if (start_sub === next) {
            if (delimiter === "`") {
              next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
            } else {
              next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
            }
            if (this._input.hasNext()) {
              next += this._input.next();
            }
          }
        }
        next += pattern.read();
        resulting_string += next;
      }
      return resulting_string;
    };
    module2.exports.Tokenizer = Tokenizer;
    module2.exports.TOKEN = TOKEN;
    module2.exports.positionable_operators = positionable_operators.slice();
    module2.exports.line_starters = line_starters.slice();
  }
});

// server/node_modules/js-beautify/js/src/javascript/beautifier.js
var require_beautifier = __commonJS({
  "server/node_modules/js-beautify/js/src/javascript/beautifier.js"(exports, module2) {
    "use strict";
    var Output = require_output().Output;
    var Token = require_token().Token;
    var acorn = require_acorn();
    var Options = require_options2().Options;
    var Tokenizer = require_tokenizer2().Tokenizer;
    var line_starters = require_tokenizer2().line_starters;
    var positionable_operators = require_tokenizer2().positionable_operators;
    var TOKEN = require_tokenizer2().TOKEN;
    function in_array(what, arr) {
      return arr.indexOf(what) !== -1;
    }
    function ltrim(s) {
      return s.replace(/^\s+/g, "");
    }
    function generateMapFromStrings(list) {
      var result = {};
      for (var x = 0; x < list.length; x++) {
        result[list[x].replace(/-/g, "_")] = list[x];
      }
      return result;
    }
    function reserved_word(token, word) {
      return token && token.type === TOKEN.RESERVED && token.text === word;
    }
    function reserved_array(token, words) {
      return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
    }
    var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
    var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
    var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
    var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
    var MODE = {
      BlockStatement: "BlockStatement",
      Statement: "Statement",
      ObjectLiteral: "ObjectLiteral",
      ArrayLiteral: "ArrayLiteral",
      ForInitializer: "ForInitializer",
      Conditional: "Conditional",
      Expression: "Expression"
    };
    function remove_redundant_indentation(output, frame) {
      if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
        return;
      }
      output.remove_indent(frame.start_line_index);
    }
    function split_linebreaks(s) {
      s = s.replace(acorn.allLineBreaks, "\n");
      var out = [], idx = s.indexOf("\n");
      while (idx !== -1) {
        out.push(s.substring(0, idx));
        s = s.substring(idx + 1);
        idx = s.indexOf("\n");
      }
      if (s.length) {
        out.push(s);
      }
      return out;
    }
    function is_array(mode) {
      return mode === MODE.ArrayLiteral;
    }
    function is_expression(mode) {
      return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
    }
    function all_lines_start_with(lines, c) {
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (line.charAt(0) !== c) {
          return false;
        }
      }
      return true;
    }
    function each_line_matches_indent(lines, indent) {
      var i = 0, len = lines.length, line;
      for (; i < len; i++) {
        line = lines[i];
        if (line && line.indexOf(indent) !== 0) {
          return false;
        }
      }
      return true;
    }
    function Beautifier(source_text, options) {
      options = options || {};
      this._source_text = source_text || "";
      this._output = null;
      this._tokens = null;
      this._last_last_text = null;
      this._flags = null;
      this._previous_flags = null;
      this._flag_store = null;
      this._options = new Options(options);
    }
    Beautifier.prototype.create_flags = function(flags_base, mode) {
      var next_indent_level = 0;
      if (flags_base) {
        next_indent_level = flags_base.indentation_level;
        if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
          next_indent_level = flags_base.line_indent_level;
        }
      }
      var next_flags = {
        mode,
        parent: flags_base,
        last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
        last_word: flags_base ? flags_base.last_word : "",
        declaration_statement: false,
        declaration_assignment: false,
        multiline_frame: false,
        inline_frame: false,
        if_block: false,
        else_block: false,
        do_block: false,
        do_while: false,
        import_block: false,
        in_case_statement: false,
        in_case: false,
        case_body: false,
        indentation_level: next_indent_level,
        alignment: 0,
        line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
        start_line_index: this._output.get_line_number(),
        ternary_depth: 0
      };
      return next_flags;
    };
    Beautifier.prototype._reset = function(source_text) {
      var baseIndentString = source_text.match(/^[\t ]*/)[0];
      this._last_last_text = "";
      this._output = new Output(this._options, baseIndentString);
      this._output.raw = this._options.test_output_raw;
      this._flag_store = [];
      this.set_mode(MODE.BlockStatement);
      var tokenizer = new Tokenizer(source_text, this._options);
      this._tokens = tokenizer.tokenize();
      return source_text;
    };
    Beautifier.prototype.beautify = function() {
      if (this._options.disabled) {
        return this._source_text;
      }
      var sweet_code;
      var source_text = this._reset(this._source_text);
      var eol = this._options.eol;
      if (this._options.eol === "auto") {
        eol = "\n";
        if (source_text && acorn.lineBreak.test(source_text || "")) {
          eol = source_text.match(acorn.lineBreak)[0];
        }
      }
      var current_token = this._tokens.next();
      while (current_token) {
        this.handle_token(current_token);
        this._last_last_text = this._flags.last_token.text;
        this._flags.last_token = current_token;
        current_token = this._tokens.next();
      }
      sweet_code = this._output.get_code(eol);
      return sweet_code;
    };
    Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
      if (current_token.type === TOKEN.START_EXPR) {
        this.handle_start_expr(current_token);
      } else if (current_token.type === TOKEN.END_EXPR) {
        this.handle_end_expr(current_token);
      } else if (current_token.type === TOKEN.START_BLOCK) {
        this.handle_start_block(current_token);
      } else if (current_token.type === TOKEN.END_BLOCK) {
        this.handle_end_block(current_token);
      } else if (current_token.type === TOKEN.WORD) {
        this.handle_word(current_token);
      } else if (current_token.type === TOKEN.RESERVED) {
        this.handle_word(current_token);
      } else if (current_token.type === TOKEN.SEMICOLON) {
        this.handle_semicolon(current_token);
      } else if (current_token.type === TOKEN.STRING) {
        this.handle_string(current_token);
      } else if (current_token.type === TOKEN.EQUALS) {
        this.handle_equals(current_token);
      } else if (current_token.type === TOKEN.OPERATOR) {
        this.handle_operator(current_token);
      } else if (current_token.type === TOKEN.COMMA) {
        this.handle_comma(current_token);
      } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
        this.handle_block_comment(current_token, preserve_statement_flags);
      } else if (current_token.type === TOKEN.COMMENT) {
        this.handle_comment(current_token, preserve_statement_flags);
      } else if (current_token.type === TOKEN.DOT) {
        this.handle_dot(current_token);
      } else if (current_token.type === TOKEN.EOF) {
        this.handle_eof(current_token);
      } else if (current_token.type === TOKEN.UNKNOWN) {
        this.handle_unknown(current_token, preserve_statement_flags);
      } else {
        this.handle_unknown(current_token, preserve_statement_flags);
      }
    };
    Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
      var newlines = current_token.newlines;
      var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
      if (current_token.comments_before) {
        var comment_token = current_token.comments_before.next();
        while (comment_token) {
          this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
          this.handle_token(comment_token, preserve_statement_flags);
          comment_token = current_token.comments_before.next();
        }
      }
      if (keep_whitespace) {
        for (var i = 0; i < newlines; i += 1) {
          this.print_newline(i > 0, preserve_statement_flags);
        }
      } else {
        if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
          newlines = this._options.max_preserve_newlines;
        }
        if (this._options.preserve_newlines) {
          if (newlines > 1) {
            this.print_newline(false, preserve_statement_flags);
            for (var j = 1; j < newlines; j += 1) {
              this.print_newline(true, preserve_statement_flags);
            }
          }
        }
      }
    };
    var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
    Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
      force_linewrap = force_linewrap === void 0 ? false : force_linewrap;
      if (this._output.just_added_newline()) {
        return;
      }
      var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
      var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
      if (operatorLogicApplies) {
        var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
        shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
      }
      if (shouldPreserveOrForce) {
        this.print_newline(false, true);
      } else if (this._options.wrap_line_length) {
        if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          return;
        }
        this._output.set_wrap_point();
      }
    };
    Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
      if (!preserve_statement_flags) {
        if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
          var next_token = this._tokens.peek();
          while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
            this.restore_mode();
          }
        }
      }
      if (this._output.add_new_line(force_newline)) {
        this._flags.multiline_frame = true;
      }
    };
    Beautifier.prototype.print_token_line_indentation = function(current_token) {
      if (this._output.just_added_newline()) {
        if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
          this._output.current_line.set_indent(-1);
          this._output.current_line.push(current_token.whitespace_before);
          this._output.space_before_token = false;
        } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
          this._flags.line_indent_level = this._flags.indentation_level;
        }
      }
    };
    Beautifier.prototype.print_token = function(current_token) {
      if (this._output.raw) {
        this._output.add_raw_token(current_token);
        return;
      }
      if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
        if (this._output.previous_line.last() === ",") {
          var popped = this._output.previous_line.pop();
          if (this._output.previous_line.is_empty()) {
            this._output.previous_line.push(popped);
            this._output.trim(true);
            this._output.current_line.pop();
            this._output.trim();
          }
          this.print_token_line_indentation(current_token);
          this._output.add_token(",");
          this._output.space_before_token = true;
        }
      }
      this.print_token_line_indentation(current_token);
      this._output.non_breaking_space = true;
      this._output.add_token(current_token.text);
      if (this._output.previous_token_wrapped) {
        this._flags.multiline_frame = true;
      }
    };
    Beautifier.prototype.indent = function() {
      this._flags.indentation_level += 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    };
    Beautifier.prototype.deindent = function() {
      if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
        this._flags.indentation_level -= 1;
        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      }
    };
    Beautifier.prototype.set_mode = function(mode) {
      if (this._flags) {
        this._flag_store.push(this._flags);
        this._previous_flags = this._flags;
      } else {
        this._previous_flags = this.create_flags(null, mode);
      }
      this._flags = this.create_flags(this._previous_flags, mode);
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    };
    Beautifier.prototype.restore_mode = function() {
      if (this._flag_store.length > 0) {
        this._previous_flags = this._flags;
        this._flags = this._flag_store.pop();
        if (this._previous_flags.mode === MODE.Statement) {
          remove_redundant_indentation(this._output, this._previous_flags);
        }
        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      }
    };
    Beautifier.prototype.start_of_object_property = function() {
      return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    };
    Beautifier.prototype.start_of_statement = function(current_token) {
      var start = false;
      start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
      start = start || reserved_word(this._flags.last_token, "do");
      start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
      start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
      start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
      start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
      start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
      if (start) {
        this.set_mode(MODE.Statement);
        this.indent();
        this.handle_whitespace_and_comments(current_token, true);
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, ["do", "for", "if", "while"]));
        }
        return true;
      }
      return false;
    };
    Beautifier.prototype.handle_start_expr = function(current_token) {
      if (!this.start_of_statement(current_token)) {
        this.handle_whitespace_and_comments(current_token);
      }
      var next_mode = MODE.Expression;
      if (current_token.text === "[") {
        if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
          if (reserved_array(this._flags.last_token, line_starters)) {
            this._output.space_before_token = true;
          }
          this.print_token(current_token);
          this.set_mode(next_mode);
          this.indent();
          if (this._options.space_in_paren) {
            this._output.space_before_token = true;
          }
          return;
        }
        next_mode = MODE.ArrayLiteral;
        if (is_array(this._flags.mode)) {
          if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
            if (!this._options.keep_array_indentation) {
              this.print_newline();
            }
          }
        }
        if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
          this._output.space_before_token = true;
        }
      } else {
        if (this._flags.last_token.type === TOKEN.RESERVED) {
          if (this._flags.last_token.text === "for") {
            this._output.space_before_token = this._options.space_before_conditional;
            next_mode = MODE.ForInitializer;
          } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
            this._output.space_before_token = this._options.space_before_conditional;
            next_mode = MODE.Conditional;
          } else if (in_array(this._flags.last_word, ["await", "async"])) {
            this._output.space_before_token = true;
          } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
            this._output.space_before_token = false;
          } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
            this._output.space_before_token = true;
          }
        } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
          if (!this.start_of_object_property()) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else if (this._flags.last_token.type === TOKEN.WORD) {
          this._output.space_before_token = false;
          var peek_back_two = this._tokens.peek(-3);
          if (this._options.space_after_named_function && peek_back_two) {
            var peek_back_three = this._tokens.peek(-4);
            if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
              this._output.space_before_token = true;
            } else if (this._flags.mode === MODE.ObjectLiteral) {
              if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
                this._output.space_before_token = true;
              }
            }
          }
        } else {
          this.allow_wrap_or_preserved_newline(current_token);
        }
        if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
          this._output.space_before_token = this._options.space_after_anon_function;
        }
      }
      if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
        this.print_newline();
      } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
        this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
      }
      this.print_token(current_token);
      this.set_mode(next_mode);
      if (this._options.space_in_paren) {
        this._output.space_before_token = true;
      }
      this.indent();
    };
    Beautifier.prototype.handle_end_expr = function(current_token) {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.multiline_frame) {
        this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
      }
      if (this._options.space_in_paren) {
        if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
          this._output.trim();
          this._output.space_before_token = false;
        } else {
          this._output.space_before_token = true;
        }
      }
      this.deindent();
      this.print_token(current_token);
      this.restore_mode();
      remove_redundant_indentation(this._output, this._previous_flags);
      if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
        this._previous_flags.mode = MODE.Expression;
        this._flags.do_block = false;
        this._flags.do_while = false;
      }
    };
    Beautifier.prototype.handle_start_block = function(current_token) {
      this.handle_whitespace_and_comments(current_token);
      var next_token = this._tokens.peek();
      var second_token = this._tokens.peek(1);
      if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
        this.set_mode(MODE.BlockStatement);
        this._flags.in_case_statement = true;
      } else if (this._flags.case_body) {
        this.set_mode(MODE.BlockStatement);
      } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
        if (!in_array(this._last_last_text, ["class", "interface"])) {
          this.set_mode(MODE.ObjectLiteral);
        } else {
          this.set_mode(MODE.BlockStatement);
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
        this.set_mode(MODE.BlockStatement);
      } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
        this.set_mode(MODE.ObjectLiteral);
      } else {
        this.set_mode(MODE.BlockStatement);
      }
      var empty_braces = !next_token.comments_before && next_token.text === "}";
      var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
      if (this._options.brace_preserve_inline) {
        var index = 0;
        var check_token = null;
        this._flags.inline_frame = true;
        do {
          index += 1;
          check_token = this._tokens.peek(index - 1);
          if (check_token.newlines) {
            this._flags.inline_frame = false;
            break;
          }
        } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
      }
      if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
          this._output.space_before_token = true;
        } else {
          this.print_newline(false, true);
        }
      } else {
        if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
          if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
            this._output.space_before_token = true;
          }
          if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
            this.allow_wrap_or_preserved_newline(current_token);
            this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
            this._flags.multiline_frame = false;
          }
        }
        if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
          if (this._flags.last_token.type === TOKEN.START_BLOCK && !this._flags.inline_frame) {
            this.print_newline();
          } else {
            this._output.space_before_token = true;
          }
        }
      }
      this.print_token(current_token);
      this.indent();
      if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
        this.print_newline();
      }
    };
    Beautifier.prototype.handle_end_block = function(current_token) {
      this.handle_whitespace_and_comments(current_token);
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
      if (this._flags.inline_frame && !empty_braces) {
        this._output.space_before_token = true;
      } else if (this._options.brace_style === "expand") {
        if (!empty_braces) {
          this.print_newline();
        }
      } else {
        if (!empty_braces) {
          if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
            this._options.keep_array_indentation = false;
            this.print_newline();
            this._options.keep_array_indentation = true;
          } else {
            this.print_newline();
          }
        }
      }
      this.restore_mode();
      this.print_token(current_token);
    };
    Beautifier.prototype.handle_word = function(current_token) {
      if (current_token.type === TOKEN.RESERVED) {
        if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
          current_token.type = TOKEN.WORD;
        } else if (current_token.text === "import" && this._tokens.peek().text === "(") {
          current_token.type = TOKEN.WORD;
        } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
          current_token.type = TOKEN.WORD;
        } else if (this._flags.mode === MODE.ObjectLiteral) {
          var next_token = this._tokens.peek();
          if (next_token.text === ":") {
            current_token.type = TOKEN.WORD;
          }
        }
      }
      if (this.start_of_statement(current_token)) {
        if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
          this._flags.declaration_statement = true;
        }
      } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
        this.handle_whitespace_and_comments(current_token);
        this.print_newline();
      } else {
        this.handle_whitespace_and_comments(current_token);
      }
      if (this._flags.do_block && !this._flags.do_while) {
        if (reserved_word(current_token, "while")) {
          this._output.space_before_token = true;
          this.print_token(current_token);
          this._output.space_before_token = true;
          this._flags.do_while = true;
          return;
        } else {
          this.print_newline();
          this._flags.do_block = false;
        }
      }
      if (this._flags.if_block) {
        if (!this._flags.else_block && reserved_word(current_token, "else")) {
          this._flags.else_block = true;
        } else {
          while (this._flags.mode === MODE.Statement) {
            this.restore_mode();
          }
          this._flags.if_block = false;
          this._flags.else_block = false;
        }
      }
      if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
        this.print_newline();
        if (this._flags.last_token.type !== TOKEN.END_BLOCK && (this._flags.case_body || this._options.jslint_happy)) {
          this.deindent();
        }
        this._flags.case_body = false;
        this.print_token(current_token);
        this._flags.in_case = true;
        return;
      }
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      }
      if (reserved_word(current_token, "function")) {
        if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
          if (!this._output.just_added_blankline() && !current_token.comments_before) {
            this.print_newline();
            this.print_newline(true);
          }
        }
        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
          if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
            this._output.space_before_token = true;
          } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
            this._output.space_before_token = true;
          } else if (this._flags.last_token.text === "declare") {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
          this._output.space_before_token = true;
        } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
        } else {
          this.print_newline();
        }
        this.print_token(current_token);
        this._flags.last_word = current_token.text;
        return;
      }
      var prefix = "NONE";
      if (this._flags.last_token.type === TOKEN.END_BLOCK) {
        if (this._previous_flags.inline_frame) {
          prefix = "SPACE";
        } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
          prefix = "NEWLINE";
        } else {
          if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
            prefix = "NEWLINE";
          } else {
            prefix = "SPACE";
            this._output.space_before_token = true;
          }
        }
      } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
        prefix = "NEWLINE";
      } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
        prefix = "SPACE";
      } else if (this._flags.last_token.type === TOKEN.STRING) {
        prefix = "NEWLINE";
      } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        prefix = "SPACE";
      } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
        if (this._flags.inline_frame) {
          prefix = "SPACE";
        } else {
          prefix = "NEWLINE";
        }
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        this._output.space_before_token = true;
        prefix = "NEWLINE";
      }
      if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
          prefix = "SPACE";
        } else {
          prefix = "NEWLINE";
        }
      }
      if (reserved_array(current_token, ["else", "catch", "finally"])) {
        if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.trim(true);
          var line = this._output.current_line;
          if (line.last() !== "}") {
            this.print_newline();
          }
          this._output.space_before_token = true;
        }
      } else if (prefix === "NEWLINE") {
        if (reserved_array(this._flags.last_token, special_words)) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
          if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
            if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
              this._output.space_before_token = true;
            } else {
              this.print_newline();
            }
          }
        } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
          this.print_newline();
        }
      } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
        this.print_newline();
      } else if (prefix === "SPACE") {
        this._output.space_before_token = true;
      }
      if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
        this._output.space_before_token = true;
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      if (current_token.type === TOKEN.RESERVED) {
        if (current_token.text === "do") {
          this._flags.do_block = true;
        } else if (current_token.text === "if") {
          this._flags.if_block = true;
        } else if (current_token.text === "import") {
          this._flags.import_block = true;
        } else if (this._flags.import_block && reserved_word(current_token, "from")) {
          this._flags.import_block = false;
        }
      }
    };
    Beautifier.prototype.handle_semicolon = function(current_token) {
      if (this.start_of_statement(current_token)) {
        this._output.space_before_token = false;
      } else {
        this.handle_whitespace_and_comments(current_token);
      }
      var next_token = this._tokens.peek();
      while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
        this.restore_mode();
      }
      if (this._flags.import_block) {
        this._flags.import_block = false;
      }
      this.print_token(current_token);
    };
    Beautifier.prototype.handle_string = function(current_token) {
      if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD)) {
      } else if (this.start_of_statement(current_token)) {
        this._output.space_before_token = true;
      } else {
        this.handle_whitespace_and_comments(current_token);
        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
          if (!this.start_of_object_property()) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      }
      this.print_token(current_token);
    };
    Beautifier.prototype.handle_equals = function(current_token) {
      if (this.start_of_statement(current_token)) {
      } else {
        this.handle_whitespace_and_comments(current_token);
      }
      if (this._flags.declaration_statement) {
        this._flags.declaration_assignment = true;
      }
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
    };
    Beautifier.prototype.handle_comma = function(current_token) {
      this.handle_whitespace_and_comments(current_token, true);
      this.print_token(current_token);
      this._output.space_before_token = true;
      if (this._flags.declaration_statement) {
        if (is_expression(this._flags.parent.mode)) {
          this._flags.declaration_assignment = false;
        }
        if (this._flags.declaration_assignment) {
          this._flags.declaration_assignment = false;
          this.print_newline(false, true);
        } else if (this._options.comma_first) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
        if (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        if (!this._flags.inline_frame) {
          this.print_newline();
        }
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    };
    Beautifier.prototype.handle_operator = function(current_token) {
      var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
      var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
      if (this.start_of_statement(current_token)) {
      } else {
        var preserve_statement_flags = !isGeneratorAsterisk;
        this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
      }
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        return;
      }
      if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
        this.print_token(current_token);
        return;
      }
      if (current_token.text === "::") {
        this.print_token(current_token);
        return;
      }
      if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (current_token.text === ":" && this._flags.in_case) {
        this.print_token(current_token);
        this._flags.in_case = false;
        this._flags.case_body = true;
        if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
          this.indent();
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
        return;
      }
      var space_before = true;
      var space_after = true;
      var in_ternary = false;
      if (current_token.text === ":") {
        if (this._flags.ternary_depth === 0) {
          space_before = false;
        } else {
          this._flags.ternary_depth -= 1;
          in_ternary = true;
        }
      } else if (current_token.text === "?") {
        this._flags.ternary_depth += 1;
      }
      if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
        var isColon = current_token.text === ":";
        var isTernaryColon = isColon && in_ternary;
        var isOtherColon = isColon && !in_ternary;
        switch (this._options.operator_position) {
          case OPERATOR_POSITION.before_newline:
            this._output.space_before_token = !isOtherColon;
            this.print_token(current_token);
            if (!isColon || isTernaryColon) {
              this.allow_wrap_or_preserved_newline(current_token);
            }
            this._output.space_before_token = true;
            return;
          case OPERATOR_POSITION.after_newline:
            this._output.space_before_token = true;
            if (!isColon || isTernaryColon) {
              if (this._tokens.peek().newlines) {
                this.print_newline(false, true);
              } else {
                this.allow_wrap_or_preserved_newline(current_token);
              }
            } else {
              this._output.space_before_token = false;
            }
            this.print_token(current_token);
            this._output.space_before_token = true;
            return;
          case OPERATOR_POSITION.preserve_newline:
            if (!isOtherColon) {
              this.allow_wrap_or_preserved_newline(current_token);
            }
            space_before = !(this._output.just_added_newline() || isOtherColon);
            this._output.space_before_token = space_before;
            this.print_token(current_token);
            this._output.space_before_token = true;
            return;
        }
      }
      if (isGeneratorAsterisk) {
        this.allow_wrap_or_preserved_newline(current_token);
        space_before = false;
        var next_token = this._tokens.peek();
        space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
      } else if (current_token.text === "...") {
        this.allow_wrap_or_preserved_newline(current_token);
        space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
        space_after = false;
      } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
        space_before = false;
        space_after = false;
        if (current_token.newlines && (current_token.text === "--" || current_token.text === "++")) {
          this.print_newline(false, true);
        }
        if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
          space_before = true;
        }
        if (this._flags.last_token.type === TOKEN.RESERVED) {
          space_before = true;
        } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
          space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
        } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
          space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
          if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
            space_after = true;
          }
        }
        if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
          this.print_newline();
        }
      }
      this._output.space_before_token = this._output.space_before_token || space_before;
      this.print_token(current_token);
      this._output.space_before_token = space_after;
    };
    Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
      if (this._output.raw) {
        this._output.add_raw_token(current_token);
        if (current_token.directives && current_token.directives.preserve === "end") {
          this._output.raw = this._options.test_output_raw;
        }
        return;
      }
      if (current_token.directives) {
        this.print_newline(false, preserve_statement_flags);
        this.print_token(current_token);
        if (current_token.directives.preserve === "start") {
          this._output.raw = true;
        }
        this.print_newline(false, true);
        return;
      }
      if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        return;
      } else {
        this.print_block_commment(current_token, preserve_statement_flags);
      }
    };
    Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
      var lines = split_linebreaks(current_token.text);
      var j;
      var javadoc = false;
      var starless = false;
      var lastIndent = current_token.whitespace_before;
      var lastIndentLength = lastIndent.length;
      this.print_newline(false, preserve_statement_flags);
      this.print_token_line_indentation(current_token);
      this._output.add_token(lines[0]);
      this.print_newline(false, preserve_statement_flags);
      if (lines.length > 1) {
        lines = lines.slice(1);
        javadoc = all_lines_start_with(lines, "*");
        starless = each_line_matches_indent(lines, lastIndent);
        if (javadoc) {
          this._flags.alignment = 1;
        }
        for (j = 0; j < lines.length; j++) {
          if (javadoc) {
            this.print_token_line_indentation(current_token);
            this._output.add_token(ltrim(lines[j]));
          } else if (starless && lines[j]) {
            this.print_token_line_indentation(current_token);
            this._output.add_token(lines[j].substring(lastIndentLength));
          } else {
            this._output.current_line.set_indent(-1);
            this._output.add_token(lines[j]);
          }
          this.print_newline(false, preserve_statement_flags);
        }
        this._flags.alignment = 0;
      }
    };
    Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
      if (current_token.newlines) {
        this.print_newline(false, preserve_statement_flags);
      } else {
        this._output.trim(true);
      }
      this._output.space_before_token = true;
      this.print_token(current_token);
      this.print_newline(false, preserve_statement_flags);
    };
    Beautifier.prototype.handle_dot = function(current_token) {
      if (this.start_of_statement(current_token)) {
      } else {
        this.handle_whitespace_and_comments(current_token, true);
      }
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = false;
      } else {
        this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
      }
      if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
        this.deindent();
      }
      this.print_token(current_token);
    };
    Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
      this.print_token(current_token);
      if (current_token.text[current_token.text.length - 1] === "\n") {
        this.print_newline(false, preserve_statement_flags);
      }
    };
    Beautifier.prototype.handle_eof = function(current_token) {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this.handle_whitespace_and_comments(current_token);
    };
    module2.exports.Beautifier = Beautifier;
  }
});

// server/node_modules/js-beautify/js/src/javascript/index.js
var require_javascript = __commonJS({
  "server/node_modules/js-beautify/js/src/javascript/index.js"(exports, module2) {
    "use strict";
    var Beautifier = require_beautifier().Beautifier;
    var Options = require_options2().Options;
    function js_beautify(js_source_text, options) {
      var beautifier = new Beautifier(js_source_text, options);
      return beautifier.beautify();
    }
    module2.exports = js_beautify;
    module2.exports.defaultOptions = function() {
      return new Options();
    };
  }
});

// server/node_modules/js-beautify/js/src/css/options.js
var require_options3 = __commonJS({
  "server/node_modules/js-beautify/js/src/css/options.js"(exports, module2) {
    "use strict";
    var BaseOptions = require_options().Options;
    function Options(options) {
      BaseOptions.call(this, options, "css");
      this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
      this.newline_between_rules = this._get_boolean("newline_between_rules", true);
      var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
      this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
      var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
      this.brace_style = "collapse";
      for (var bs = 0; bs < brace_style_split.length; bs++) {
        if (brace_style_split[bs] !== "expand") {
          this.brace_style = "collapse";
        } else {
          this.brace_style = brace_style_split[bs];
        }
      }
    }
    Options.prototype = new BaseOptions();
    module2.exports.Options = Options;
  }
});

// server/node_modules/js-beautify/js/src/css/beautifier.js
var require_beautifier2 = __commonJS({
  "server/node_modules/js-beautify/js/src/css/beautifier.js"(exports, module2) {
    "use strict";
    var Options = require_options3().Options;
    var Output = require_output().Output;
    var InputScanner = require_inputscanner().InputScanner;
    var Directives = require_directives().Directives;
    var directives_core = new Directives(/\/\*/, /\*\//);
    var lineBreak = /\r\n|[\r\n]/;
    var allLineBreaks = /\r\n|[\r\n]/g;
    var whitespaceChar = /\s/;
    var whitespacePattern = /(?:\s|\n)+/g;
    var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
    var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
    function Beautifier(source_text, options) {
      this._source_text = source_text || "";
      this._options = new Options(options);
      this._ch = null;
      this._input = null;
      this.NESTED_AT_RULE = {
        "@page": true,
        "@font-face": true,
        "@keyframes": true,
        "@media": true,
        "@supports": true,
        "@document": true
      };
      this.CONDITIONAL_GROUP_RULE = {
        "@media": true,
        "@supports": true,
        "@document": true
      };
    }
    Beautifier.prototype.eatString = function(endChars) {
      var result = "";
      this._ch = this._input.next();
      while (this._ch) {
        result += this._ch;
        if (this._ch === "\\") {
          result += this._input.next();
        } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
          break;
        }
        this._ch = this._input.next();
      }
      return result;
    };
    Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
      var result = whitespaceChar.test(this._input.peek());
      var newline_count = 0;
      while (whitespaceChar.test(this._input.peek())) {
        this._ch = this._input.next();
        if (allowAtLeastOneNewLine && this._ch === "\n") {
          if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
            newline_count++;
            this._output.add_new_line(true);
          }
        }
      }
      return result;
    };
    Beautifier.prototype.foundNestedPseudoClass = function() {
      var openParen = 0;
      var i = 1;
      var ch = this._input.peek(i);
      while (ch) {
        if (ch === "{") {
          return true;
        } else if (ch === "(") {
          openParen += 1;
        } else if (ch === ")") {
          if (openParen === 0) {
            return false;
          }
          openParen -= 1;
        } else if (ch === ";" || ch === "}") {
          return false;
        }
        i++;
        ch = this._input.peek(i);
      }
      return false;
    };
    Beautifier.prototype.print_string = function(output_string) {
      this._output.set_indent(this._indentLevel);
      this._output.non_breaking_space = true;
      this._output.add_token(output_string);
    };
    Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
      if (isAfterSpace) {
        this._output.space_before_token = true;
      }
    };
    Beautifier.prototype.indent = function() {
      this._indentLevel++;
    };
    Beautifier.prototype.outdent = function() {
      if (this._indentLevel > 0) {
        this._indentLevel--;
      }
    };
    Beautifier.prototype.beautify = function() {
      if (this._options.disabled) {
        return this._source_text;
      }
      var source_text = this._source_text;
      var eol = this._options.eol;
      if (eol === "auto") {
        eol = "\n";
        if (source_text && lineBreak.test(source_text || "")) {
          eol = source_text.match(lineBreak)[0];
        }
      }
      source_text = source_text.replace(allLineBreaks, "\n");
      var baseIndentString = source_text.match(/^[\t ]*/)[0];
      this._output = new Output(this._options, baseIndentString);
      this._input = new InputScanner(source_text);
      this._indentLevel = 0;
      this._nestedLevel = 0;
      this._ch = null;
      var parenLevel = 0;
      var insideRule = false;
      var insidePropertyValue = false;
      var enteringConditionalGroup = false;
      var insideAtExtend = false;
      var insideAtImport = false;
      var topCharacter = this._ch;
      var whitespace;
      var isAfterSpace;
      var previous_ch;
      while (true) {
        whitespace = this._input.read(whitespacePattern);
        isAfterSpace = whitespace !== "";
        previous_ch = topCharacter;
        this._ch = this._input.next();
        if (this._ch === "\\" && this._input.hasNext()) {
          this._ch += this._input.next();
        }
        topCharacter = this._ch;
        if (!this._ch) {
          break;
        } else if (this._ch === "/" && this._input.peek() === "*") {
          this._output.add_new_line();
          this._input.back();
          var comment = this._input.read(block_comment_pattern);
          var directives = directives_core.get_directives(comment);
          if (directives && directives.ignore === "start") {
            comment += directives_core.readIgnored(this._input);
          }
          this.print_string(comment);
          this.eatWhitespace(true);
          this._output.add_new_line();
        } else if (this._ch === "/" && this._input.peek() === "/") {
          this._output.space_before_token = true;
          this._input.back();
          this.print_string(this._input.read(comment_pattern));
          this.eatWhitespace(true);
        } else if (this._ch === "@") {
          this.preserveSingleSpace(isAfterSpace);
          if (this._input.peek() === "{") {
            this.print_string(this._ch + this.eatString("}"));
          } else {
            this.print_string(this._ch);
            var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
            if (variableOrRule.match(/[ :]$/)) {
              variableOrRule = this.eatString(": ").replace(/\s$/, "");
              this.print_string(variableOrRule);
              this._output.space_before_token = true;
            }
            variableOrRule = variableOrRule.replace(/\s$/, "");
            if (variableOrRule === "extend") {
              insideAtExtend = true;
            } else if (variableOrRule === "import") {
              insideAtImport = true;
            }
            if (variableOrRule in this.NESTED_AT_RULE) {
              this._nestedLevel += 1;
              if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                enteringConditionalGroup = true;
              }
            } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
              insidePropertyValue = true;
              this.indent();
            }
          }
        } else if (this._ch === "#" && this._input.peek() === "{") {
          this.preserveSingleSpace(isAfterSpace);
          this.print_string(this._ch + this.eatString("}"));
        } else if (this._ch === "{") {
          if (insidePropertyValue) {
            insidePropertyValue = false;
            this.outdent();
          }
          if (enteringConditionalGroup) {
            enteringConditionalGroup = false;
            insideRule = this._indentLevel >= this._nestedLevel;
          } else {
            insideRule = this._indentLevel >= this._nestedLevel - 1;
          }
          if (this._options.newline_between_rules && insideRule) {
            if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
              this._output.ensure_empty_line_above("/", ",");
            }
          }
          this._output.space_before_token = true;
          if (this._options.brace_style === "expand") {
            this._output.add_new_line();
            this.print_string(this._ch);
            this.indent();
            this._output.set_indent(this._indentLevel);
          } else {
            this.indent();
            this.print_string(this._ch);
          }
          this.eatWhitespace(true);
          this._output.add_new_line();
        } else if (this._ch === "}") {
          this.outdent();
          this._output.add_new_line();
          if (previous_ch === "{") {
            this._output.trim(true);
          }
          insideAtImport = false;
          insideAtExtend = false;
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          this.print_string(this._ch);
          insideRule = false;
          if (this._nestedLevel) {
            this._nestedLevel--;
          }
          this.eatWhitespace(true);
          this._output.add_new_line();
          if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
            if (this._input.peek() !== "}") {
              this._output.add_new_line(true);
            }
          }
        } else if (this._ch === ":") {
          if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
            this.print_string(":");
            if (!insidePropertyValue) {
              insidePropertyValue = true;
              this._output.space_before_token = true;
              this.eatWhitespace(true);
              this.indent();
            }
          } else {
            if (this._input.lookBack(" ")) {
              this._output.space_before_token = true;
            }
            if (this._input.peek() === ":") {
              this._ch = this._input.next();
              this.print_string("::");
            } else {
              this.print_string(":");
            }
          }
        } else if (this._ch === '"' || this._ch === "'") {
          this.preserveSingleSpace(isAfterSpace);
          this.print_string(this._ch + this.eatString(this._ch));
          this.eatWhitespace(true);
        } else if (this._ch === ";") {
          if (parenLevel === 0) {
            if (insidePropertyValue) {
              this.outdent();
              insidePropertyValue = false;
            }
            insideAtExtend = false;
            insideAtImport = false;
            this.print_string(this._ch);
            this.eatWhitespace(true);
            if (this._input.peek() !== "/") {
              this._output.add_new_line();
            }
          } else {
            this.print_string(this._ch);
            this.eatWhitespace(true);
            this._output.space_before_token = true;
          }
        } else if (this._ch === "(") {
          if (this._input.lookBack("url")) {
            this.print_string(this._ch);
            this.eatWhitespace();
            parenLevel++;
            this.indent();
            this._ch = this._input.next();
            if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
              this._input.back();
            } else if (this._ch) {
              this.print_string(this._ch + this.eatString(")"));
              if (parenLevel) {
                parenLevel--;
                this.outdent();
              }
            }
          } else {
            this.preserveSingleSpace(isAfterSpace);
            this.print_string(this._ch);
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        } else if (this._ch === ")") {
          if (parenLevel) {
            parenLevel--;
            this.outdent();
          }
          this.print_string(this._ch);
        } else if (this._ch === ",") {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport) {
            this._output.add_new_line();
          } else {
            this._output.space_before_token = true;
          }
        } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
          if (this._options.space_around_combinator) {
            this._output.space_before_token = true;
            this.print_string(this._ch);
            this._output.space_before_token = true;
          } else {
            this.print_string(this._ch);
            this.eatWhitespace();
            if (this._ch && whitespaceChar.test(this._ch)) {
              this._ch = "";
            }
          }
        } else if (this._ch === "]") {
          this.print_string(this._ch);
        } else if (this._ch === "[") {
          this.preserveSingleSpace(isAfterSpace);
          this.print_string(this._ch);
        } else if (this._ch === "=") {
          this.eatWhitespace();
          this.print_string("=");
          if (whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        } else if (this._ch === "!" && !this._input.lookBack("\\")) {
          this.print_string(" ");
          this.print_string(this._ch);
        } else {
          this.preserveSingleSpace(isAfterSpace);
          this.print_string(this._ch);
        }
      }
      var sweetCode = this._output.get_code(eol);
      return sweetCode;
    };
    module2.exports.Beautifier = Beautifier;
  }
});

// server/node_modules/js-beautify/js/src/css/index.js
var require_css = __commonJS({
  "server/node_modules/js-beautify/js/src/css/index.js"(exports, module2) {
    "use strict";
    var Beautifier = require_beautifier2().Beautifier;
    var Options = require_options3().Options;
    function css_beautify(source_text, options) {
      var beautifier = new Beautifier(source_text, options);
      return beautifier.beautify();
    }
    module2.exports = css_beautify;
    module2.exports.defaultOptions = function() {
      return new Options();
    };
  }
});

// server/node_modules/js-beautify/js/src/html/options.js
var require_options4 = __commonJS({
  "server/node_modules/js-beautify/js/src/html/options.js"(exports, module2) {
    "use strict";
    var BaseOptions = require_options().Options;
    function Options(options) {
      BaseOptions.call(this, options, "html");
      if (this.templating.length === 1 && this.templating[0] === "auto") {
        this.templating = ["django", "erb", "handlebars", "php"];
      }
      this.indent_inner_html = this._get_boolean("indent_inner_html");
      this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
      this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
      this.indent_handlebars = this._get_boolean("indent_handlebars", true);
      this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
      this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
      this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
      this.inline = this._get_array("inline", [
        "a",
        "abbr",
        "area",
        "audio",
        "b",
        "bdi",
        "bdo",
        "br",
        "button",
        "canvas",
        "cite",
        "code",
        "data",
        "datalist",
        "del",
        "dfn",
        "em",
        "embed",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "keygen",
        "label",
        "map",
        "mark",
        "math",
        "meter",
        "noscript",
        "object",
        "output",
        "progress",
        "q",
        "ruby",
        "s",
        "samp",
        "select",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "svg",
        "template",
        "textarea",
        "time",
        "u",
        "var",
        "video",
        "wbr",
        "text",
        "acronym",
        "big",
        "strike",
        "tt"
      ]);
      this.void_elements = this._get_array("void_elements", [
        "area",
        "base",
        "br",
        "col",
        "embed",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
        "!doctype",
        "?xml",
        "basefont",
        "isindex"
      ]);
      this.unformatted = this._get_array("unformatted", []);
      this.content_unformatted = this._get_array("content_unformatted", [
        "pre",
        "textarea"
      ]);
      this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
      this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
    }
    Options.prototype = new BaseOptions();
    module2.exports.Options = Options;
  }
});

// server/node_modules/js-beautify/js/src/html/tokenizer.js
var require_tokenizer3 = __commonJS({
  "server/node_modules/js-beautify/js/src/html/tokenizer.js"(exports, module2) {
    "use strict";
    var BaseTokenizer = require_tokenizer().Tokenizer;
    var BASETOKEN = require_tokenizer().TOKEN;
    var Directives = require_directives().Directives;
    var TemplatablePattern = require_templatablepattern().TemplatablePattern;
    var Pattern = require_pattern().Pattern;
    var TOKEN = {
      TAG_OPEN: "TK_TAG_OPEN",
      TAG_CLOSE: "TK_TAG_CLOSE",
      ATTRIBUTE: "TK_ATTRIBUTE",
      EQUALS: "TK_EQUALS",
      VALUE: "TK_VALUE",
      COMMENT: "TK_COMMENT",
      TEXT: "TK_TEXT",
      UNKNOWN: "TK_UNKNOWN",
      START: BASETOKEN.START,
      RAW: BASETOKEN.RAW,
      EOF: BASETOKEN.EOF
    };
    var directives_core = new Directives(/<\!--/, /-->/);
    var Tokenizer = function(input_string, options) {
      BaseTokenizer.call(this, input_string, options);
      this._current_tag_name = "";
      var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
      var pattern_reader = new Pattern(this._input);
      this.__patterns = {
        word: templatable_reader.until(/[\n\r\t <]/),
        single_quote: templatable_reader.until_after(/'/),
        double_quote: templatable_reader.until_after(/"/),
        attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
        element_name: templatable_reader.until(/[\n\r\t >\/]/),
        handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
        handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
        handlebars_open: pattern_reader.until(/[\n\r\t }]/),
        handlebars_raw_close: pattern_reader.until(/}}/),
        comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
        cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
        conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
        processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
      };
      if (this._options.indent_handlebars) {
        this.__patterns.word = this.__patterns.word.exclude("handlebars");
      }
      this._unformatted_content_delimiter = null;
      if (this._options.unformatted_content_delimiter) {
        var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
        this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
      }
    };
    Tokenizer.prototype = new BaseTokenizer();
    Tokenizer.prototype._is_comment = function(current_token) {
      return false;
    };
    Tokenizer.prototype._is_opening = function(current_token) {
      return current_token.type === TOKEN.TAG_OPEN;
    };
    Tokenizer.prototype._is_closing = function(current_token, open_token) {
      return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
    };
    Tokenizer.prototype._reset = function() {
      this._current_tag_name = "";
    };
    Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
      var token = null;
      this._readWhitespace();
      var c = this._input.peek();
      if (c === null) {
        return this._create_token(TOKEN.EOF, "");
      }
      token = token || this._read_open_handlebars(c, open_token);
      token = token || this._read_attribute(c, previous_token, open_token);
      token = token || this._read_close(c, open_token);
      token = token || this._read_raw_content(c, previous_token, open_token);
      token = token || this._read_content_word(c);
      token = token || this._read_comment_or_cdata(c);
      token = token || this._read_processing(c);
      token = token || this._read_open(c, open_token);
      token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
      return token;
    };
    Tokenizer.prototype._read_comment_or_cdata = function(c) {
      var token = null;
      var resulting_string = null;
      var directives = null;
      if (c === "<") {
        var peek1 = this._input.peek(1);
        if (peek1 === "!") {
          resulting_string = this.__patterns.comment.read();
          if (resulting_string) {
            directives = directives_core.get_directives(resulting_string);
            if (directives && directives.ignore === "start") {
              resulting_string += directives_core.readIgnored(this._input);
            }
          } else {
            resulting_string = this.__patterns.cdata.read();
          }
        }
        if (resulting_string) {
          token = this._create_token(TOKEN.COMMENT, resulting_string);
          token.directives = directives;
        }
      }
      return token;
    };
    Tokenizer.prototype._read_processing = function(c) {
      var token = null;
      var resulting_string = null;
      var directives = null;
      if (c === "<") {
        var peek1 = this._input.peek(1);
        if (peek1 === "!" || peek1 === "?") {
          resulting_string = this.__patterns.conditional_comment.read();
          resulting_string = resulting_string || this.__patterns.processing.read();
        }
        if (resulting_string) {
          token = this._create_token(TOKEN.COMMENT, resulting_string);
          token.directives = directives;
        }
      }
      return token;
    };
    Tokenizer.prototype._read_open = function(c, open_token) {
      var resulting_string = null;
      var token = null;
      if (!open_token) {
        if (c === "<") {
          resulting_string = this._input.next();
          if (this._input.peek() === "/") {
            resulting_string += this._input.next();
          }
          resulting_string += this.__patterns.element_name.read();
          token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
      return token;
    };
    Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
      var resulting_string = null;
      var token = null;
      if (!open_token) {
        if (this._options.indent_handlebars && c === "{" && this._input.peek(1) === "{") {
          if (this._input.peek(2) === "!") {
            resulting_string = this.__patterns.handlebars_comment.read();
            resulting_string = resulting_string || this.__patterns.handlebars.read();
            token = this._create_token(TOKEN.COMMENT, resulting_string);
          } else {
            resulting_string = this.__patterns.handlebars_open.read();
            token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
          }
        }
      }
      return token;
    };
    Tokenizer.prototype._read_close = function(c, open_token) {
      var resulting_string = null;
      var token = null;
      if (open_token) {
        if (open_token.text[0] === "<" && (c === ">" || c === "/" && this._input.peek(1) === ">")) {
          resulting_string = this._input.next();
          if (c === "/") {
            resulting_string += this._input.next();
          }
          token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
        } else if (open_token.text[0] === "{" && c === "}" && this._input.peek(1) === "}") {
          this._input.next();
          this._input.next();
          token = this._create_token(TOKEN.TAG_CLOSE, "}}");
        }
      }
      return token;
    };
    Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
      var token = null;
      var resulting_string = "";
      if (open_token && open_token.text[0] === "<") {
        if (c === "=") {
          token = this._create_token(TOKEN.EQUALS, this._input.next());
        } else if (c === '"' || c === "'") {
          var content = this._input.next();
          if (c === '"') {
            content += this.__patterns.double_quote.read();
          } else {
            content += this.__patterns.single_quote.read();
          }
          token = this._create_token(TOKEN.VALUE, content);
        } else {
          resulting_string = this.__patterns.attribute.read();
          if (resulting_string) {
            if (previous_token.type === TOKEN.EQUALS) {
              token = this._create_token(TOKEN.VALUE, resulting_string);
            } else {
              token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
            }
          }
        }
      }
      return token;
    };
    Tokenizer.prototype._is_content_unformatted = function(tag_name) {
      return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
    };
    Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {
      var resulting_string = "";
      if (open_token && open_token.text[0] === "{") {
        resulting_string = this.__patterns.handlebars_raw_close.read();
      } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
        var tag_name = previous_token.opened.text.substr(1).toLowerCase();
        if (tag_name === "script" || tag_name === "style") {
          var token = this._read_comment_or_cdata(c);
          if (token) {
            token.type = TOKEN.TEXT;
            return token;
          }
          resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
        } else if (this._is_content_unformatted(tag_name)) {
          resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
        }
      }
      if (resulting_string) {
        return this._create_token(TOKEN.TEXT, resulting_string);
      }
      return null;
    };
    Tokenizer.prototype._read_content_word = function(c) {
      var resulting_string = "";
      if (this._options.unformatted_content_delimiter) {
        if (c === this._options.unformatted_content_delimiter[0]) {
          resulting_string = this.__patterns.unformatted_content_delimiter.read();
        }
      }
      if (!resulting_string) {
        resulting_string = this.__patterns.word.read();
      }
      if (resulting_string) {
        return this._create_token(TOKEN.TEXT, resulting_string);
      }
    };
    module2.exports.Tokenizer = Tokenizer;
    module2.exports.TOKEN = TOKEN;
  }
});

// server/node_modules/js-beautify/js/src/html/beautifier.js
var require_beautifier3 = __commonJS({
  "server/node_modules/js-beautify/js/src/html/beautifier.js"(exports, module2) {
    "use strict";
    var Options = require_options4().Options;
    var Output = require_output().Output;
    var Tokenizer = require_tokenizer3().Tokenizer;
    var TOKEN = require_tokenizer3().TOKEN;
    var lineBreak = /\r\n|[\r\n]/;
    var allLineBreaks = /\r\n|[\r\n]/g;
    var Printer = function(options, base_indent_string) {
      this.indent_level = 0;
      this.alignment_size = 0;
      this.max_preserve_newlines = options.max_preserve_newlines;
      this.preserve_newlines = options.preserve_newlines;
      this._output = new Output(options, base_indent_string);
    };
    Printer.prototype.current_line_has_match = function(pattern) {
      return this._output.current_line.has_match(pattern);
    };
    Printer.prototype.set_space_before_token = function(value, non_breaking) {
      this._output.space_before_token = value;
      this._output.non_breaking_space = non_breaking;
    };
    Printer.prototype.set_wrap_point = function() {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.set_wrap_point();
    };
    Printer.prototype.add_raw_token = function(token) {
      this._output.add_raw_token(token);
    };
    Printer.prototype.print_preserved_newlines = function(raw_token) {
      var newlines = 0;
      if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
        newlines = raw_token.newlines ? 1 : 0;
      }
      if (this.preserve_newlines) {
        newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
      }
      for (var n = 0; n < newlines; n++) {
        this.print_newline(n > 0);
      }
      return newlines !== 0;
    };
    Printer.prototype.traverse_whitespace = function(raw_token) {
      if (raw_token.whitespace_before || raw_token.newlines) {
        if (!this.print_preserved_newlines(raw_token)) {
          this._output.space_before_token = true;
        }
        return true;
      }
      return false;
    };
    Printer.prototype.previous_token_wrapped = function() {
      return this._output.previous_token_wrapped;
    };
    Printer.prototype.print_newline = function(force) {
      this._output.add_new_line(force);
    };
    Printer.prototype.print_token = function(token) {
      if (token.text) {
        this._output.set_indent(this.indent_level, this.alignment_size);
        this._output.add_token(token.text);
      }
    };
    Printer.prototype.indent = function() {
      this.indent_level++;
    };
    Printer.prototype.get_full_indent = function(level) {
      level = this.indent_level + (level || 0);
      if (level < 1) {
        return "";
      }
      return this._output.get_indent_string(level);
    };
    var get_type_attribute = function(start_token) {
      var result = null;
      var raw_token = start_token.next;
      while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
        if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
          if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
            result = raw_token.next.next.text;
          }
          break;
        }
        raw_token = raw_token.next;
      }
      return result;
    };
    var get_custom_beautifier_name = function(tag_check, raw_token) {
      var typeAttribute = null;
      var result = null;
      if (!raw_token.closed) {
        return null;
      }
      if (tag_check === "script") {
        typeAttribute = "text/javascript";
      } else if (tag_check === "style") {
        typeAttribute = "text/css";
      }
      typeAttribute = get_type_attribute(raw_token) || typeAttribute;
      if (typeAttribute.search("text/css") > -1) {
        result = "css";
      } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
        result = "javascript";
      } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
        result = "html";
      } else if (typeAttribute.search(/test\/null/) > -1) {
        result = "null";
      }
      return result;
    };
    function in_array(what, arr) {
      return arr.indexOf(what) !== -1;
    }
    function TagFrame(parent, parser_token, indent_level) {
      this.parent = parent || null;
      this.tag = parser_token ? parser_token.tag_name : "";
      this.indent_level = indent_level || 0;
      this.parser_token = parser_token || null;
    }
    function TagStack(printer) {
      this._printer = printer;
      this._current_frame = null;
    }
    TagStack.prototype.get_parser_token = function() {
      return this._current_frame ? this._current_frame.parser_token : null;
    };
    TagStack.prototype.record_tag = function(parser_token) {
      var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
      this._current_frame = new_frame;
    };
    TagStack.prototype._try_pop_frame = function(frame) {
      var parser_token = null;
      if (frame) {
        parser_token = frame.parser_token;
        this._printer.indent_level = frame.indent_level;
        this._current_frame = frame.parent;
      }
      return parser_token;
    };
    TagStack.prototype._get_frame = function(tag_list, stop_list) {
      var frame = this._current_frame;
      while (frame) {
        if (tag_list.indexOf(frame.tag) !== -1) {
          break;
        } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
          frame = null;
          break;
        }
        frame = frame.parent;
      }
      return frame;
    };
    TagStack.prototype.try_pop = function(tag, stop_list) {
      var frame = this._get_frame([tag], stop_list);
      return this._try_pop_frame(frame);
    };
    TagStack.prototype.indent_to_tag = function(tag_list) {
      var frame = this._get_frame(tag_list);
      if (frame) {
        this._printer.indent_level = frame.indent_level;
      }
    };
    function Beautifier(source_text, options, js_beautify, css_beautify) {
      this._source_text = source_text || "";
      options = options || {};
      this._js_beautify = js_beautify;
      this._css_beautify = css_beautify;
      this._tag_stack = null;
      var optionHtml = new Options(options, "html");
      this._options = optionHtml;
      this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
      this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
      this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
      this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
      this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
      this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
    }
    Beautifier.prototype.beautify = function() {
      if (this._options.disabled) {
        return this._source_text;
      }
      var source_text = this._source_text;
      var eol = this._options.eol;
      if (this._options.eol === "auto") {
        eol = "\n";
        if (source_text && lineBreak.test(source_text)) {
          eol = source_text.match(lineBreak)[0];
        }
      }
      source_text = source_text.replace(allLineBreaks, "\n");
      var baseIndentString = source_text.match(/^[\t ]*/)[0];
      var last_token = {
        text: "",
        type: ""
      };
      var last_tag_token = new TagOpenParserToken();
      var printer = new Printer(this._options, baseIndentString);
      var tokens = new Tokenizer(source_text, this._options).tokenize();
      this._tag_stack = new TagStack(printer);
      var parser_token = null;
      var raw_token = tokens.next();
      while (raw_token.type !== TOKEN.EOF) {
        if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
          parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
          last_tag_token = parser_token;
        } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
          parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
        } else if (raw_token.type === TOKEN.TAG_CLOSE) {
          parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
        } else if (raw_token.type === TOKEN.TEXT) {
          parser_token = this._handle_text(printer, raw_token, last_tag_token);
        } else {
          printer.add_raw_token(raw_token);
        }
        last_token = parser_token;
        raw_token = tokens.next();
      }
      var sweet_code = printer._output.get_code(eol);
      return sweet_code;
    };
    Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
      var parser_token = {
        text: raw_token.text,
        type: raw_token.type
      };
      printer.alignment_size = 0;
      last_tag_token.tag_complete = true;
      printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
      if (last_tag_token.is_unformatted) {
        printer.add_raw_token(raw_token);
      } else {
        if (last_tag_token.tag_start_char === "<") {
          printer.set_space_before_token(raw_token.text[0] === "/", true);
          if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
            printer.print_newline(false);
          }
        }
        printer.print_token(raw_token);
      }
      if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
        printer.indent();
        last_tag_token.indent_content = false;
      }
      if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
        printer.set_wrap_point();
      }
      return parser_token;
    };
    Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
      var wrapped = last_tag_token.has_wrapped_attrs;
      var parser_token = {
        text: raw_token.text,
        type: raw_token.type
      };
      printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
      if (last_tag_token.is_unformatted) {
        printer.add_raw_token(raw_token);
      } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
        if (printer.print_preserved_newlines(raw_token)) {
          raw_token.newlines = 0;
          printer.add_raw_token(raw_token);
        } else {
          printer.print_token(raw_token);
        }
      } else {
        if (raw_token.type === TOKEN.ATTRIBUTE) {
          printer.set_space_before_token(true);
          last_tag_token.attr_count += 1;
        } else if (raw_token.type === TOKEN.EQUALS) {
          printer.set_space_before_token(false);
        } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
          printer.set_space_before_token(false);
        }
        if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
          if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
            printer.traverse_whitespace(raw_token);
            wrapped = wrapped || raw_token.newlines !== 0;
          }
          if (this._is_wrap_attributes_force) {
            var force_attr_wrap = last_tag_token.attr_count > 1;
            if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
              var is_only_attribute = true;
              var peek_index = 0;
              var peek_token;
              do {
                peek_token = tokens.peek(peek_index);
                if (peek_token.type === TOKEN.ATTRIBUTE) {
                  is_only_attribute = false;
                  break;
                }
                peek_index += 1;
              } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
              force_attr_wrap = !is_only_attribute;
            }
            if (force_attr_wrap) {
              printer.print_newline(false);
              wrapped = true;
            }
          }
        }
        printer.print_token(raw_token);
        wrapped = wrapped || printer.previous_token_wrapped();
        last_tag_token.has_wrapped_attrs = wrapped;
      }
      return parser_token;
    };
    Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
      var parser_token = {
        text: raw_token.text,
        type: "TK_CONTENT"
      };
      if (last_tag_token.custom_beautifier_name) {
        this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
      } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
        printer.add_raw_token(raw_token);
      } else {
        printer.traverse_whitespace(raw_token);
        printer.print_token(raw_token);
      }
      return parser_token;
    };
    Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
      var local = this;
      if (raw_token.text !== "") {
        var text = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
        if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
          _beautifier = this._js_beautify;
        } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
          _beautifier = this._css_beautify;
        } else if (last_tag_token.custom_beautifier_name === "html") {
          _beautifier = function(html_source, options) {
            var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
            return beautifier.beautify();
          };
        }
        if (this._options.indent_scripts === "keep") {
          script_indent_level = 0;
        } else if (this._options.indent_scripts === "separate") {
          script_indent_level = -printer.indent_level;
        }
        var indentation = printer.get_full_indent(script_indent_level);
        text = text.replace(/\n[ \t]*$/, "");
        if (last_tag_token.custom_beautifier_name !== "html" && text[0] === "<" && text.match(/^(<!--|<!\[CDATA\[)/)) {
          var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);
          if (!matched) {
            printer.add_raw_token(raw_token);
            return;
          }
          pre = indentation + matched[1] + "\n";
          text = matched[4];
          if (matched[5]) {
            post = indentation + matched[5];
          }
          text = text.replace(/\n[ \t]*$/, "");
          if (matched[2] || matched[3].indexOf("\n") !== -1) {
            matched = matched[3].match(/[ \t]+$/);
            if (matched) {
              raw_token.whitespace_before = matched[0];
            }
          }
        }
        if (text) {
          if (_beautifier) {
            var Child_options = function() {
              this.eol = "\n";
            };
            Child_options.prototype = this._options.raw_options;
            var child_options = new Child_options();
            text = _beautifier(indentation + text, child_options);
          } else {
            var white = raw_token.whitespace_before;
            if (white) {
              text = text.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
            }
            text = indentation + text.replace(/\n/g, "\n" + indentation);
          }
        }
        if (pre) {
          if (!text) {
            text = pre + post;
          } else {
            text = pre + text + "\n" + post;
          }
        }
        printer.print_newline(false);
        if (text) {
          raw_token.text = text;
          raw_token.whitespace_before = "";
          raw_token.newlines = 0;
          printer.add_raw_token(raw_token);
          printer.print_newline(true);
        }
      }
    };
    Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
      var parser_token = this._get_tag_open_token(raw_token);
      if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf("</") === 0) {
        printer.add_raw_token(raw_token);
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        printer.traverse_whitespace(raw_token);
        this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
        if (!parser_token.is_inline_element) {
          printer.set_wrap_point();
        }
        printer.print_token(raw_token);
      }
      if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
        parser_token.alignment_size = raw_token.text.length + 1;
      }
      if (!parser_token.tag_complete && !parser_token.is_unformatted) {
        printer.alignment_size = parser_token.alignment_size;
      }
      return parser_token;
    };
    var TagOpenParserToken = function(parent, raw_token) {
      this.parent = parent || null;
      this.text = "";
      this.type = "TK_TAG_OPEN";
      this.tag_name = "";
      this.is_inline_element = false;
      this.is_unformatted = false;
      this.is_content_unformatted = false;
      this.is_empty_element = false;
      this.is_start_tag = false;
      this.is_end_tag = false;
      this.indent_content = false;
      this.multiline_content = false;
      this.custom_beautifier_name = null;
      this.start_tag_token = null;
      this.attr_count = 0;
      this.has_wrapped_attrs = false;
      this.alignment_size = 0;
      this.tag_complete = false;
      this.tag_start_char = "";
      this.tag_check = "";
      if (!raw_token) {
        this.tag_complete = true;
      } else {
        var tag_check_match;
        this.tag_start_char = raw_token.text[0];
        this.text = raw_token.text;
        if (this.tag_start_char === "<") {
          tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
          this.tag_check = tag_check_match ? tag_check_match[1] : "";
        } else {
          tag_check_match = raw_token.text.match(/^{{(?:[\^]|#\*?)?([^\s}]+)/);
          this.tag_check = tag_check_match ? tag_check_match[1] : "";
          if (raw_token.text === "{{#>" && this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text;
          }
        }
        this.tag_check = this.tag_check.toLowerCase();
        if (raw_token.type === TOKEN.COMMENT) {
          this.tag_complete = true;
        }
        this.is_start_tag = this.tag_check.charAt(0) !== "/";
        this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
        this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
        this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(2)));
      }
    };
    Beautifier.prototype._get_tag_open_token = function(raw_token) {
      var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
      parser_token.alignment_size = this._options.wrap_attributes_indent_size;
      parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
      parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
      parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
      parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
      parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === "{";
      return parser_token;
    };
    Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
      if (!parser_token.is_empty_element) {
        if (parser_token.is_end_tag) {
          parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
        } else {
          if (this._do_optional_end_element(parser_token)) {
            if (!parser_token.is_inline_element) {
              printer.print_newline(false);
            }
          }
          this._tag_stack.record_tag(parser_token);
          if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
            parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
          }
        }
      }
      if (in_array(parser_token.tag_check, this._options.extra_liners)) {
        printer.print_newline(false);
        if (!printer._output.just_added_blankline()) {
          printer.print_newline(true);
        }
      }
      if (parser_token.is_empty_element) {
        if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
          this._tag_stack.indent_to_tag(["if", "unless", "each"]);
          parser_token.indent_content = true;
          var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
          if (!foundIfOnCurrentLine) {
            printer.print_newline(false);
          }
        }
        if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) {
        } else {
          if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
            printer.print_newline(false);
          }
          this._calcluate_parent_multiline(printer, parser_token);
        }
      } else if (parser_token.is_end_tag) {
        var do_end_expand = false;
        do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
        do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
        if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
          do_end_expand = false;
        }
        if (do_end_expand) {
          printer.print_newline(false);
        }
      } else {
        parser_token.indent_content = !parser_token.custom_beautifier_name;
        if (parser_token.tag_start_char === "<") {
          if (parser_token.tag_name === "html") {
            parser_token.indent_content = this._options.indent_inner_html;
          } else if (parser_token.tag_name === "head") {
            parser_token.indent_content = this._options.indent_head_inner_html;
          } else if (parser_token.tag_name === "body") {
            parser_token.indent_content = this._options.indent_body_inner_html;
          }
        }
        if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    };
    Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
      if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
        parser_token.parent.multiline_content = true;
      }
    };
    var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"];
    var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
    Beautifier.prototype._do_optional_end_element = function(parser_token) {
      var result = null;
      if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
        return;
      }
      if (parser_token.tag_name === "body") {
        result = result || this._tag_stack.try_pop("head");
      } else if (parser_token.tag_name === "li") {
        result = result || this._tag_stack.try_pop("li", ["ol", "ul"]);
      } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
        result = result || this._tag_stack.try_pop("dt", ["dl"]);
        result = result || this._tag_stack.try_pop("dd", ["dl"]);
      } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
        var p_parent = parser_token.parent.parent;
        if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
          result = result || this._tag_stack.try_pop("p");
        }
      } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
        result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
        result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
      } else if (parser_token.tag_name === "optgroup") {
        result = result || this._tag_stack.try_pop("optgroup", ["select"]);
      } else if (parser_token.tag_name === "option") {
        result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
      } else if (parser_token.tag_name === "colgroup") {
        result = result || this._tag_stack.try_pop("caption", ["table"]);
      } else if (parser_token.tag_name === "thead") {
        result = result || this._tag_stack.try_pop("caption", ["table"]);
        result = result || this._tag_stack.try_pop("colgroup", ["table"]);
      } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
        result = result || this._tag_stack.try_pop("caption", ["table"]);
        result = result || this._tag_stack.try_pop("colgroup", ["table"]);
        result = result || this._tag_stack.try_pop("thead", ["table"]);
        result = result || this._tag_stack.try_pop("tbody", ["table"]);
      } else if (parser_token.tag_name === "tr") {
        result = result || this._tag_stack.try_pop("caption", ["table"]);
        result = result || this._tag_stack.try_pop("colgroup", ["table"]);
        result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
      } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
        result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
        result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
      }
      parser_token.parent = this._tag_stack.get_parser_token();
      return result;
    };
    module2.exports.Beautifier = Beautifier;
  }
});

// server/node_modules/js-beautify/js/src/html/index.js
var require_html = __commonJS({
  "server/node_modules/js-beautify/js/src/html/index.js"(exports, module2) {
    "use strict";
    var Beautifier = require_beautifier3().Beautifier;
    var Options = require_options4().Options;
    function style_html(html_source, options, js_beautify, css_beautify) {
      var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
      return beautifier.beautify();
    }
    module2.exports = style_html;
    module2.exports.defaultOptions = function() {
      return new Options();
    };
  }
});

// server/node_modules/js-beautify/js/src/index.js
var require_src = __commonJS({
  "server/node_modules/js-beautify/js/src/index.js"(exports, module2) {
    "use strict";
    var js_beautify = require_javascript();
    var css_beautify = require_css();
    var html_beautify = require_html();
    function style_html(html_source, options, js, css) {
      js = js || js_beautify;
      css = css || css_beautify;
      return html_beautify(html_source, options, js, css);
    }
    style_html.defaultOptions = html_beautify.defaultOptions;
    module2.exports.js = js_beautify;
    module2.exports.css = css_beautify;
    module2.exports.html = style_html;
  }
});

// server/node_modules/js-beautify/js/index.js
var require_js = __commonJS({
  "server/node_modules/js-beautify/js/index.js"(exports, module2) {
    "use strict";
    function get_beautify(js_beautify, css_beautify, html_beautify) {
      var beautify2 = function(src, config) {
        return js_beautify.js_beautify(src, config);
      };
      beautify2.js = js_beautify.js_beautify;
      beautify2.css = css_beautify.css_beautify;
      beautify2.html = html_beautify.html_beautify;
      beautify2.js_beautify = js_beautify.js_beautify;
      beautify2.css_beautify = css_beautify.css_beautify;
      beautify2.html_beautify = html_beautify.html_beautify;
      return beautify2;
    }
    if (typeof define === "function" && define.amd) {
      define([
        "./lib/beautify",
        "./lib/beautify-css",
        "./lib/beautify-html"
      ], function(js_beautify, css_beautify, html_beautify) {
        return get_beautify(js_beautify, css_beautify, html_beautify);
      });
    } else {
      (function(mod) {
        var beautifier = require_src();
        beautifier.js_beautify = beautifier.js;
        beautifier.css_beautify = beautifier.css;
        beautifier.html_beautify = beautifier.html;
        mod.exports = get_beautify(beautifier, beautifier, beautifier);
      })(module2);
    }
  }
});

// server/node_modules/y18n/build/index.cjs
var require_build = __commonJS({
  "server/node_modules/y18n/build/index.cjs"(exports, module2) {
    "use strict";
    var fs2 = require("fs");
    var util = require("util");
    var path = require("path");
    var shim;
    var Y18N = class {
      constructor(opts) {
        opts = opts || {};
        this.directory = opts.directory || "./locales";
        this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
        this.locale = opts.locale || "en";
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
        this.cache = /* @__PURE__ */ Object.create(null);
        this.writeQueue = [];
      }
      __(...args) {
        if (typeof arguments[0] !== "string") {
          return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str2 = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        cb = cb || function() {
        };
        if (!this.cache[this.locale])
          this._readLocaleFile();
        if (!this.cache[this.locale][str2] && this.updateFiles) {
          this.cache[this.locale][str2] = str2;
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        return shim.format.apply(shim.format, [this.cache[this.locale][str2] || str2].concat(args));
      }
      __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function() {
        };
        if (typeof args[args.length - 1] === "function")
          cb = args.pop();
        if (!this.cache[this.locale])
          this._readLocaleFile();
        let str2 = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
          const entry = this.cache[this.locale][singular];
          str2 = entry[quantity === 1 ? "one" : "other"];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
          this.cache[this.locale][singular] = {
            one: singular,
            other: plural
          };
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        const values = [str2];
        if (~str2.indexOf("%d"))
          values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
      }
      setLocale(locale) {
        this.locale = locale;
      }
      getLocale() {
        return this.locale;
      }
      updateLocale(obj) {
        if (!this.cache[this.locale])
          this._readLocaleFile();
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            this.cache[this.locale][key] = obj[key];
          }
        }
      }
      _taggedLiteral(parts, ...args) {
        let str2 = "";
        parts.forEach(function(part, i) {
          const arg = args[i + 1];
          str2 += part;
          if (typeof arg !== "undefined") {
            str2 += "%s";
          }
        });
        return this.__.apply(this, [str2].concat([].slice.call(args, 1)));
      }
      _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
          this._processWriteQueue();
      }
      _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
          _this.writeQueue.shift();
          if (_this.writeQueue.length > 0)
            _this._processWriteQueue();
          cb(err);
        });
      }
      _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
          if (shim.fs.readFileSync) {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
          }
        } catch (err) {
          if (err instanceof SyntaxError) {
            err.message = "syntax error in " + languageFile;
          }
          if (err.code === "ENOENT")
            localeLookup = {};
          else
            throw err;
        }
        this.cache[this.locale] = localeLookup;
      }
      _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, "./", locale + ".json");
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
          const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
          if (this._fileExistsSync(languageFile))
            file = languageFile;
        }
        return file;
      }
      _fileExistsSync(file) {
        return shim.exists(file);
      }
    };
    function y18n$1(opts, _shim) {
      shim = _shim;
      const y18n2 = new Y18N(opts);
      return {
        __: y18n2.__.bind(y18n2),
        __n: y18n2.__n.bind(y18n2),
        setLocale: y18n2.setLocale.bind(y18n2),
        getLocale: y18n2.getLocale.bind(y18n2),
        updateLocale: y18n2.updateLocale.bind(y18n2),
        locale: y18n2.locale
      };
    }
    var nodePlatformShim = {
      fs: {
        readFileSync: fs2.readFileSync,
        writeFile: fs2.writeFile
      },
      format: util.format,
      resolve: path.resolve,
      exists: (file) => {
        try {
          return fs2.statSync(file).isFile();
        } catch (err) {
          return false;
        }
      }
    };
    var y18n = (opts) => {
      return y18n$1(opts, nodePlatformShim);
    };
    module2.exports = y18n;
  }
});

// server/node_modules/yargs-parser/build/index.cjs
var require_build2 = __commonJS({
  "server/node_modules/yargs-parser/build/index.cjs"(exports, module2) {
    "use strict";
    var util = require("util");
    var path = require("path");
    var fs2 = require("fs");
    function camelCase(str2) {
      const isCamelCase = str2 !== str2.toLowerCase() && str2 !== str2.toUpperCase();
      if (!isCamelCase) {
        str2 = str2.toLowerCase();
      }
      if (str2.indexOf("-") === -1 && str2.indexOf("_") === -1) {
        return str2;
      } else {
        let camelcase = "";
        let nextChrUpper = false;
        const leadingHyphens = str2.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str2.length; i++) {
          let chr = str2.charAt(i);
          if (nextChrUpper) {
            nextChrUpper = false;
            chr = chr.toUpperCase();
          }
          if (i !== 0 && (chr === "-" || chr === "_")) {
            nextChrUpper = true;
          } else if (chr !== "-" && chr !== "_") {
            camelcase += chr;
          }
        }
        return camelcase;
      }
    }
    function decamelize(str2, joinString) {
      const lowercase = str2.toLowerCase();
      joinString = joinString || "-";
      let notCamelcase = "";
      for (let i = 0; i < str2.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str2.charAt(i);
        if (chrLower !== chrString && i > 0) {
          notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
          notCamelcase += chrString;
        }
      }
      return notCamelcase;
    }
    function looksLikeNumber(x) {
      if (x === null || x === void 0)
        return false;
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      if (/^0[^.]/.test(x))
        return false;
      return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function tokenizeArgString(argString) {
      if (Array.isArray(argString)) {
        return argString.map((e) => typeof e !== "string" ? e + "" : e);
      }
      argString = argString.trim();
      let i = 0;
      let prevC = null;
      let c = null;
      let opening = null;
      const args = [];
      for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === " " && !opening) {
          if (!(prevC === " ")) {
            i++;
          }
          continue;
        }
        if (c === opening) {
          opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
          opening = c;
        }
        if (!args[i])
          args[i] = "";
        args[i] += c;
      }
      return args;
    }
    var DefaultValuesForTypeKey;
    (function(DefaultValuesForTypeKey2) {
      DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
      DefaultValuesForTypeKey2["STRING"] = "string";
      DefaultValuesForTypeKey2["NUMBER"] = "number";
      DefaultValuesForTypeKey2["ARRAY"] = "array";
    })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
    var mixin;
    var YargsParser = class {
      constructor(_mixin) {
        mixin = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === "string";
        const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = /* @__PURE__ */ Object.create(null);
        const defaulted = /* @__PURE__ */ Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
          aliases: /* @__PURE__ */ Object.create(null),
          arrays: /* @__PURE__ */ Object.create(null),
          bools: /* @__PURE__ */ Object.create(null),
          strings: /* @__PURE__ */ Object.create(null),
          numbers: /* @__PURE__ */ Object.create(null),
          counts: /* @__PURE__ */ Object.create(null),
          normalize: /* @__PURE__ */ Object.create(null),
          configs: /* @__PURE__ */ Object.create(null),
          nargs: /* @__PURE__ */ Object.create(null),
          coercions: /* @__PURE__ */ Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value]) => {
            if (typeof value === "number") {
              flags.nargs[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value]) => {
            if (typeof value === "function") {
              flags.coercions[key] = value;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value]) => {
              if (typeof value === "boolean" || typeof value === "function") {
                flags.configs[key] = value;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv2 = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          const truncatedArg = arg.replace(/^-{3,}/, "---");
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value;
          if (arg !== "--" && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (truncatedArg.match(/---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args, m[2]);
              } else {
                setArg(m[1], m[2], true);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args, value);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args, value);
                } else {
                  setArg(key, value);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv2, true);
        applyEnvVars(argv2, false);
        setConfig(argv2);
        setConfigObjects();
        applyDefaultsAndAliases(argv2, flags.aliases, defaults, true);
        applyCoercions(argv2);
        if (configuration["set-placeholder-key"])
          setPlaceholderKeys(argv2);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv2, key.split(".")))
            setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
          argv2[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv2[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv2).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv2[key];
          });
        }
        if (configuration["strip-aliased"]) {
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv2[alias.split(".").map((prop) => camelCase(prop)).join(".")];
            }
            delete argv2[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv2._.push(maybeCoercedNumber);
          }
        }
        function eatNargs(i, key, args2, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args2.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args2.length; ii++) {
              if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
                available++;
              else
                break;
            }
            if (available < toEat)
              error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args2[ii]);
          }
          return i + consumed;
        }
        function eatArray(i, key, args2, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args2[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign, true));
            }
            for (let ii = i + 1; ii < args2.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
                break;
              next = args2[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                break;
              i = ii;
              argsToSet.push(processValue(key, next, inputIsString));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value = processValue(key, val, shouldStripQuotes);
          const splitKey = key.split(".");
          setKey(argv2, splitKey, value);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv2, keyProperties, value);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv2, keyProperties, value);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [key].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value2) {
                  val = typeof value2 === "string" ? mixin.normalize(value2) : value2;
                }
              });
            });
          }
        }
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [alias];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        function processValue(key, val, shouldStripQuotes) {
          if (shouldStripQuotes) {
            val = stripQuotes(val);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string")
              val = val === "true";
          }
          let value = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
            value = increment();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val))
              value = val.map((val2) => {
                return mixin.normalize(val2);
              });
            else
              value = mixin.normalize(val);
          }
          return value;
        }
        function maybeCoerceNumber(key, value) {
          if (!configuration["parse-positional-numbers"] && key === "_")
            return value;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
            const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
            if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
              value = Number(value);
            }
          }
          return value;
        }
        function setConfig(argv3) {
          const configLookup = /* @__PURE__ */ Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv3[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied")
                  error = ex;
                else if (argv3[configKey])
                  error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
              setConfigObject(value, fullKey);
            } else {
              if (!hasKey(argv2, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value);
              }
            }
          });
        }
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        function applyEnvVars(argv3, configOnly) {
          if (typeof envPrefix === "undefined")
            return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env2 = mixin.env();
          Object.keys(env2).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv3, keys)) {
                setArg(keys.join("."), env2[envVar]);
              }
            }
          });
        }
        function applyCoercions(argv3) {
          let coerce;
          const applied = /* @__PURE__ */ new Set();
          Object.keys(argv3).forEach(function(key) {
            if (!applied.has(key)) {
              coerce = checkAllAliases(key, flags.coercions);
              if (typeof coerce === "function") {
                try {
                  const value = maybeCoerceNumber(key, coerce(argv3[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv3[ali] = value;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        function setPlaceholderKeys(argv3) {
          flags.keys.forEach((key) => {
            if (~key.indexOf("."))
              return;
            if (typeof argv3[key] === "undefined")
              argv3[key] = void 0;
          });
          return argv3;
        }
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog)
                defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split(".")))
                  return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object")
            return false;
          else
            return key in o;
        }
        function setKey(obj, keys, value) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [o[key2], {}];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value === increment()) {
            o[key] = increment(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value;
            } else {
              o[key] = o[key].concat([value]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value : [value];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [o[key], value];
          } else {
            o[key] = value;
          }
        }
        function extendAliases(...args2) {
          args2.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key])
                return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
          arg = arg.replace(/^-{3,}/, "--");
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType(key));
          }
        }
        function defaultForType(type2) {
          const def = {
            [DefaultValuesForTypeKey.BOOLEAN]: true,
            [DefaultValuesForTypeKey.STRING]: "",
            [DefaultValuesForTypeKey.NUMBER]: void 0,
            [DefaultValuesForTypeKey.ARRAY]: []
          };
          return def[type2];
        }
        function guessType(key) {
          let type2 = DefaultValuesForTypeKey.BOOLEAN;
          if (checkAllAliases(key, flags.strings))
            type2 = DefaultValuesForTypeKey.STRING;
          else if (checkAllAliases(key, flags.numbers))
            type2 = DefaultValuesForTypeKey.NUMBER;
          else if (checkAllAliases(key, flags.bools))
            type2 = DefaultValuesForTypeKey.BOOLEAN;
          else if (checkAllAliases(key, flags.arrays))
            type2 = DefaultValuesForTypeKey.ARRAY;
          return type2;
        }
        function isUndefined(num) {
          return num === void 0;
        }
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv2),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
    function combineAliases(aliases) {
      const aliasArrays = [];
      const combined = /* @__PURE__ */ Object.create(null);
      let change = true;
      Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
      });
      while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
          for (let ii = i + 1; ii < aliasArrays.length; ii++) {
            const intersect2 = aliasArrays[i].filter(function(v) {
              return aliasArrays[ii].indexOf(v) !== -1;
            });
            if (intersect2.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
              aliasArrays.splice(ii, 1);
              change = true;
              break;
            }
          }
        }
      }
      aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self) {
          return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== void 0 && typeof lastAlias === "string") {
          combined[lastAlias] = aliasArray;
        }
      });
      return combined;
    }
    function increment(orig) {
      return orig !== void 0 ? orig + 1 : 1;
    }
    function sanitizeKey(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    function stripQuotes(val) {
      return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
    }
    var minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    if (process && process.version) {
      const major = Number(process.version.match(/v([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    var env = process ? process.env : {};
    var parser = new YargsParser({
      cwd: process.cwd,
      env: () => {
        return env;
      },
      format: util.format,
      normalize: path.normalize,
      resolve: path.resolve,
      require: (path2) => {
        if (typeof require !== "undefined") {
          return require(path2);
        } else if (path2.match(/\.json$/)) {
          return JSON.parse(fs2.readFileSync(path2, "utf8"));
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }
    });
    var yargsParser = function Parser(args, opts) {
      const result = parser.parse(args.slice(), opts);
      return result.argv;
    };
    yargsParser.detailed = function(args, opts) {
      return parser.parse(args.slice(), opts);
    };
    yargsParser.camelCase = camelCase;
    yargsParser.decamelize = decamelize;
    yargsParser.looksLikeNumber = looksLikeNumber;
    module2.exports = yargsParser;
  }
});

// server/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "server/node_modules/ansi-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// server/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "server/node_modules/strip-ansi/index.js"(exports, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// server/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "server/node_modules/is-fullwidth-code-point/index.js"(exports, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// server/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "server/node_modules/emoji-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// server/node_modules/string-width/index.js
var require_string_width = __commonJS({
  "server/node_modules/string-width/index.js"(exports, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// server/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "server/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// server/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "server/node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// server/node_modules/color-convert/route.js
var require_route = __commonJS({
  "server/node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// server/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "server/node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// server/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "server/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// server/node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  "server/node_modules/wrap-ansi/index.js"(exports, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = /* @__PURE__ */ new Set([
      "\x1B",
      "\x9B"
    ]);
    var END_CODE = 39;
    var ANSI_ESCAPE_BELL = "\x07";
    var ANSI_CSI = "[";
    var ANSI_OSC = "]";
    var ANSI_SGR_TERMINATOR = "m";
    var ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
    var wrapAnsi = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
    var wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let isInsideLinkEscape = false;
      let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
          isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK);
        }
        if (isInsideEscape) {
          if (isInsideLinkEscape) {
            if (character === ANSI_ESCAPE_BELL) {
              isInsideEscape = false;
              isInsideLinkEscape = false;
            }
          } else if (character === ANSI_SGR_TERMINATOR) {
            isInsideEscape = false;
          }
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (string) => {
      const words = string.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return string;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let returnValue = "";
      let escapeCode;
      let escapeUrl;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimStart();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      const pre = [...rows.join("\n")];
      for (const [index, character] of pre.entries()) {
        returnValue += character;
        if (ESCAPES.has(character)) {
          const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || { groups: {} };
          if (groups.code !== void 0) {
            const code2 = Number.parseFloat(groups.code);
            escapeCode = code2 === END_CODE ? void 0 : code2;
          } else if (groups.uri !== void 0) {
            escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
          }
        }
        const code = ansiStyles.codes.get(Number(escapeCode));
        if (pre[index + 1] === "\n") {
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink("");
          }
          if (escapeCode && code) {
            returnValue += wrapAnsi(code);
          }
        } else if (character === "\n") {
          if (escapeCode && code) {
            returnValue += wrapAnsi(escapeCode);
          }
          if (escapeUrl) {
            returnValue += wrapAnsiHyperlink(escapeUrl);
          }
        }
      }
      return returnValue;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
    };
  }
});

// server/node_modules/cliui/build/index.cjs
var require_build3 = __commonJS({
  "server/node_modules/cliui/build/index.cjs"(exports, module2) {
    "use strict";
    var align = {
      right: alignRight,
      center: alignCenter
    };
    var top = 0;
    var right = 1;
    var bottom = 2;
    var left = 3;
    var UI = class {
      constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
      }
      span(...args) {
        const cols = this.div(...args);
        cols.span = true;
      }
      resetOutput() {
        this.rows = [];
      }
      div(...args) {
        if (args.length === 0) {
          this.div("");
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
          return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg) => {
          if (typeof arg === "string") {
            return this.colFromString(arg);
          }
          return arg;
        });
        this.rows.push(cols);
        return cols;
      }
      shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
      }
      applyLayoutDSL(str2) {
        const rows = str2.split("\n").map((row) => row.split("	"));
        let leftColumnWidth = 0;
        rows.forEach((columns) => {
          if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
            leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
          }
        });
        rows.forEach((columns) => {
          this.div(...columns.map((r, i) => {
            return {
              text: r.trim(),
              padding: this.measurePadding(r),
              width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
            };
          }));
        });
        return this.rows[this.rows.length - 1];
      }
      colFromString(text) {
        return {
          text,
          padding: this.measurePadding(text)
        };
      }
      measurePadding(str2) {
        const noAnsi = mixin.stripAnsi(str2);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
      }
      toString() {
        const lines = [];
        this.rows.forEach((row) => {
          this.rowToString(row, lines);
        });
        return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
      }
      rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
          let str2 = "";
          rrow.forEach((col, c) => {
            const { width } = row[c];
            const wrapWidth = this.negatePadding(row[c]);
            let ts = col;
            if (wrapWidth > mixin.stringWidth(col)) {
              ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
            }
            if (row[c].align && row[c].align !== "left" && this.wrap) {
              const fn = align[row[c].align];
              ts = fn(ts, wrapWidth);
              if (mixin.stringWidth(ts) < wrapWidth) {
                ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
              }
            }
            const padding = row[c].padding || [0, 0, 0, 0];
            if (padding[left]) {
              str2 += " ".repeat(padding[left]);
            }
            str2 += addBorder(row[c], ts, "| ");
            str2 += ts;
            str2 += addBorder(row[c], ts, " |");
            if (padding[right]) {
              str2 += " ".repeat(padding[right]);
            }
            if (r === 0 && lines.length > 0) {
              str2 = this.renderInline(str2, lines[lines.length - 1]);
            }
          });
          lines.push({
            text: str2.replace(/ +$/, ""),
            span: row.span
          });
        });
        return lines;
      }
      renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
          return source;
        }
        if (!this.wrap) {
          previousLine.hidden = true;
          return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
          return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
      }
      rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
          col.width = widths[c];
          if (this.wrap) {
            wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
          } else {
            wrapped = col.text.split("\n");
          }
          if (col.border) {
            wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
            wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
          }
          if (col.padding) {
            wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
            wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
          }
          wrapped.forEach((str2, r) => {
            if (!rrows[r]) {
              rrows.push([]);
            }
            const rrow = rrows[r];
            for (let i = 0; i < c; i++) {
              if (rrow[i] === void 0) {
                rrow.push("");
              }
            }
            rrow.push(str2);
          });
        });
        return rrows;
      }
      negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
          wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
          wrapWidth -= 4;
        }
        return wrapWidth;
      }
      columnWidths(row) {
        if (!this.wrap) {
          return row.map((col) => {
            return col.width || mixin.stringWidth(col.text);
          });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col) => {
          if (col.width) {
            unset--;
            remainingWidth -= col.width;
            return col.width;
          }
          return void 0;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
          if (w === void 0) {
            return Math.max(unsetWidth, _minWidth(row[i]));
          }
          return w;
        });
      }
    };
    function addBorder(col, ts, style) {
      if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
          return "";
        }
        if (ts.trim().length !== 0) {
          return style;
        }
        return "  ";
      }
      return "";
    }
    function _minWidth(col) {
      const padding = col.padding || [];
      const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
      if (col.border) {
        return minWidth + 4;
      }
      return minWidth;
    }
    function getWindowWidth() {
      if (typeof process === "object" && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
      }
      return 80;
    }
    function alignRight(str2, width) {
      str2 = str2.trim();
      const strWidth = mixin.stringWidth(str2);
      if (strWidth < width) {
        return " ".repeat(width - strWidth) + str2;
      }
      return str2;
    }
    function alignCenter(str2, width) {
      str2 = str2.trim();
      const strWidth = mixin.stringWidth(str2);
      if (strWidth >= width) {
        return str2;
      }
      return " ".repeat(width - strWidth >> 1) + str2;
    }
    var mixin;
    function cliui(opts, _mixin) {
      mixin = _mixin;
      return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
      });
    }
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var wrap = require_wrap_ansi();
    function ui(opts) {
      return cliui(opts, {
        stringWidth,
        stripAnsi,
        wrap
      });
    }
    module2.exports = ui;
  }
});

// server/node_modules/escalade/sync/index.js
var require_sync = __commonJS({
  "server/node_modules/escalade/sync/index.js"(exports, module2) {
    var { dirname, resolve } = require("path");
    var { readdirSync, statSync } = require("fs");
    module2.exports = function(start, callback) {
      let dir = resolve(".", start);
      let tmp, stats = statSync(dir);
      if (!stats.isDirectory()) {
        dir = dirname(dir);
      }
      while (true) {
        tmp = callback(dir, readdirSync(dir));
        if (tmp)
          return resolve(dir, tmp);
        dir = dirname(tmp = dir);
        if (tmp === dir)
          break;
      }
    };
  }
});

// server/node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS({
  "server/node_modules/get-caller-file/index.js"(exports, module2) {
    "use strict";
    module2.exports = function getCallerFile(position) {
      if (position === void 0) {
        position = 2;
      }
      if (position >= Error.stackTraceLimit) {
        throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
      }
      var oldPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = oldPrepareStackTrace;
      if (stack !== null && typeof stack === "object") {
        return stack[position] ? stack[position].getFileName() : void 0;
      }
    };
  }
});

// server/node_modules/require-directory/index.js
var require_require_directory = __commonJS({
  "server/node_modules/require-directory/index.js"(exports, module2) {
    "use strict";
    var fs2 = require("fs");
    var join = require("path").join;
    var resolve = require("path").resolve;
    var dirname = require("path").dirname;
    var defaultOptions = {
      extensions: ["js", "json", "coffee"],
      recurse: true,
      rename: function(name) {
        return name;
      },
      visit: function(obj) {
        return obj;
      }
    };
    function checkFileInclusion(path, filename, options) {
      return new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && !(options.include && options.include instanceof RegExp && !options.include.test(path)) && !(options.include && typeof options.include === "function" && !options.include(path, filename)) && !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && !(options.exclude && typeof options.exclude === "function" && options.exclude(path, filename));
    }
    function requireDirectory(m, path, options) {
      var retval = {};
      if (path && !options && typeof path !== "string") {
        options = path;
        path = null;
      }
      options = options || {};
      for (var prop in defaultOptions) {
        if (typeof options[prop] === "undefined") {
          options[prop] = defaultOptions[prop];
        }
      }
      path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);
      fs2.readdirSync(path).forEach(function(filename) {
        var joined = join(path, filename), files, key, obj;
        if (fs2.statSync(joined).isDirectory() && options.recurse) {
          files = requireDirectory(m, joined, options);
          if (Object.keys(files).length) {
            retval[options.rename(filename, joined, filename)] = files;
          }
        } else {
          if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
            key = filename.substring(0, filename.lastIndexOf("."));
            obj = m.require(joined);
            retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
          }
        }
      });
      return retval;
    }
    module2.exports = requireDirectory;
    module2.exports.defaults = defaultOptions;
  }
});

// server/node_modules/yargs/build/index.cjs
var require_build4 = __commonJS({
  "server/node_modules/yargs/build/index.cjs"(exports, module2) {
    "use strict";
    var t = require("assert");
    var e = class extends Error {
      constructor(t2) {
        super(t2 || "yargs error"), this.name = "YError", Error.captureStackTrace(this, e);
      }
    };
    var s;
    var i = [];
    function n(t2, o2, a2, h2) {
      s = h2;
      let l2 = {};
      if (Object.prototype.hasOwnProperty.call(t2, "extends")) {
        if (typeof t2.extends != "string")
          return l2;
        const r2 = /\.json|\..*rc$/.test(t2.extends);
        let h3 = null;
        if (r2)
          h3 = function(t3, e2) {
            return s.path.resolve(t3, e2);
          }(o2, t2.extends);
        else
          try {
            h3 = require.resolve(t2.extends);
          } catch (e2) {
            return t2;
          }
        !function(t3) {
          if (i.indexOf(t3) > -1)
            throw new e(`Circular extended configurations: '${t3}'.`);
        }(h3), i.push(h3), l2 = r2 ? JSON.parse(s.readFileSync(h3, "utf8")) : require(t2.extends), delete t2.extends, l2 = n(l2, s.path.dirname(h3), a2, s);
      }
      return i = [], a2 ? r(l2, t2) : Object.assign({}, l2, t2);
    }
    function r(t2, e2) {
      const s2 = {};
      function i2(t3) {
        return t3 && typeof t3 == "object" && !Array.isArray(t3);
      }
      Object.assign(s2, t2);
      for (const n2 of Object.keys(e2))
        i2(e2[n2]) && i2(s2[n2]) ? s2[n2] = r(t2[n2], e2[n2]) : s2[n2] = e2[n2];
      return s2;
    }
    function o(t2) {
      const e2 = t2.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/), s2 = /\.*[\][<>]/g, i2 = e2.shift();
      if (!i2)
        throw new Error(`No command found in: ${t2}`);
      const n2 = { cmd: i2.replace(s2, ""), demanded: [], optional: [] };
      return e2.forEach((t3, i3) => {
        let r2 = false;
        t3 = t3.replace(/\s/g, ""), /\.+[\]>]/.test(t3) && i3 === e2.length - 1 && (r2 = true), /^\[/.test(t3) ? n2.optional.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 }) : n2.demanded.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 });
      }), n2;
    }
    var a = ["first", "second", "third", "fourth", "fifth", "sixth"];
    function h(t2, s2, i2) {
      try {
        let n2 = 0;
        const [r2, a2, h2] = typeof t2 == "object" ? [{ demanded: [], optional: [] }, t2, s2] : [o(`cmd ${t2}`), s2, i2], f2 = [].slice.call(a2);
        for (; f2.length && f2[f2.length - 1] === void 0; )
          f2.pop();
        const d2 = h2 || f2.length;
        if (d2 < r2.demanded.length)
          throw new e(`Not enough arguments provided. Expected ${r2.demanded.length} but received ${f2.length}.`);
        const u2 = r2.demanded.length + r2.optional.length;
        if (d2 > u2)
          throw new e(`Too many arguments provided. Expected max ${u2} but received ${d2}.`);
        r2.demanded.forEach((t3) => {
          const e2 = l(f2.shift());
          t3.cmd.filter((t4) => t4 === e2 || t4 === "*").length === 0 && c(e2, t3.cmd, n2), n2 += 1;
        }), r2.optional.forEach((t3) => {
          if (f2.length === 0)
            return;
          const e2 = l(f2.shift());
          t3.cmd.filter((t4) => t4 === e2 || t4 === "*").length === 0 && c(e2, t3.cmd, n2), n2 += 1;
        });
      } catch (t3) {
        console.warn(t3.stack);
      }
    }
    function l(t2) {
      return Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
    }
    function c(t2, s2, i2) {
      throw new e(`Invalid ${a[i2] || "manyith"} argument. Expected ${s2.join(" or ")} but received ${t2}.`);
    }
    function f(t2) {
      return !!t2 && !!t2.then && typeof t2.then == "function";
    }
    function d(t2, e2, s2, i2) {
      s2.assert.notStrictEqual(t2, e2, i2);
    }
    function u(t2, e2) {
      e2.assert.strictEqual(typeof t2, "string");
    }
    function p(t2) {
      return Object.keys(t2);
    }
    function g(t2 = {}, e2 = () => true) {
      const s2 = {};
      return p(t2).forEach((i2) => {
        e2(i2, t2[i2]) && (s2[i2] = t2[i2]);
      }), s2;
    }
    function m() {
      return process.versions.electron && !process.defaultApp ? 0 : 1;
    }
    function y() {
      return process.argv[m()];
    }
    var b = Object.freeze({ __proto__: null, hideBin: function(t2) {
      return t2.slice(m() + 1);
    }, getProcessArgvBin: y });
    function v(t2, e2, s2, i2) {
      if (s2 === "a" && !i2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof e2 == "function" ? t2 !== e2 || !i2 : !e2.has(t2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return s2 === "m" ? i2 : s2 === "a" ? i2.call(t2) : i2 ? i2.value : e2.get(t2);
    }
    function O(t2, e2, s2, i2, n2) {
      if (i2 === "m")
        throw new TypeError("Private method is not writable");
      if (i2 === "a" && !n2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof e2 == "function" ? t2 !== e2 || !n2 : !e2.has(t2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return i2 === "a" ? n2.call(t2, s2) : n2 ? n2.value = s2 : e2.set(t2, s2), s2;
    }
    var w = class {
      constructor(t2) {
        this.globalMiddleware = [], this.frozens = [], this.yargs = t2;
      }
      addMiddleware(t2, e2, s2 = true, i2 = false) {
        if (h("<array|function> [boolean] [boolean] [boolean]", [t2, e2, s2], arguments.length), Array.isArray(t2)) {
          for (let i3 = 0; i3 < t2.length; i3++) {
            if (typeof t2[i3] != "function")
              throw Error("middleware must be a function");
            const n2 = t2[i3];
            n2.applyBeforeValidation = e2, n2.global = s2;
          }
          Array.prototype.push.apply(this.globalMiddleware, t2);
        } else if (typeof t2 == "function") {
          const n2 = t2;
          n2.applyBeforeValidation = e2, n2.global = s2, n2.mutates = i2, this.globalMiddleware.push(t2);
        }
        return this.yargs;
      }
      addCoerceMiddleware(t2, e2) {
        const s2 = this.yargs.getAliases();
        return this.globalMiddleware = this.globalMiddleware.filter((t3) => {
          const i2 = [...s2[e2] || [], e2];
          return !t3.option || !i2.includes(t3.option);
        }), t2.option = e2, this.addMiddleware(t2, true, true, true);
      }
      getMiddleware() {
        return this.globalMiddleware;
      }
      freeze() {
        this.frozens.push([...this.globalMiddleware]);
      }
      unfreeze() {
        const t2 = this.frozens.pop();
        t2 !== void 0 && (this.globalMiddleware = t2);
      }
      reset() {
        this.globalMiddleware = this.globalMiddleware.filter((t2) => t2.global);
      }
    };
    function C(t2, e2, s2, i2) {
      return s2.reduce((t3, s3) => {
        if (s3.applyBeforeValidation !== i2)
          return t3;
        if (s3.mutates) {
          if (s3.applied)
            return t3;
          s3.applied = true;
        }
        if (f(t3))
          return t3.then((t4) => Promise.all([t4, s3(t4, e2)])).then(([t4, e3]) => Object.assign(t4, e3));
        {
          const i3 = s3(t3, e2);
          return f(i3) ? i3.then((e3) => Object.assign(t3, e3)) : Object.assign(t3, i3);
        }
      }, t2);
    }
    function j(t2, e2, s2 = (t3) => {
      throw t3;
    }) {
      try {
        const s3 = typeof t2 == "function" ? t2() : t2;
        return f(s3) ? s3.then((t3) => e2(t3)) : e2(s3);
      } catch (t3) {
        return s2(t3);
      }
    }
    var _ = /(^\*)|(^\$0)/;
    var M = class {
      constructor(t2, e2, s2, i2) {
        this.requireCache = /* @__PURE__ */ new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i2, this.usage = t2, this.globalMiddleware = s2, this.validation = e2;
      }
      addDirectory(t2, e2, s2, i2) {
        typeof (i2 = i2 || {}).recurse != "boolean" && (i2.recurse = false), Array.isArray(i2.extensions) || (i2.extensions = ["js"]);
        const n2 = typeof i2.visit == "function" ? i2.visit : (t3) => t3;
        i2.visit = (t3, e3, s3) => {
          const i3 = n2(t3, e3, s3);
          if (i3) {
            if (this.requireCache.has(e3))
              return i3;
            this.requireCache.add(e3), this.addHandler(i3);
          }
          return i3;
        }, this.shim.requireDirectory({ require: e2, filename: s2 }, t2, i2);
      }
      addHandler(t2, e2, s2, i2, n2, r2) {
        let a2 = [];
        const h2 = function(t3) {
          return t3 ? t3.map((t4) => (t4.applyBeforeValidation = false, t4)) : [];
        }(n2);
        if (i2 = i2 || (() => {
        }), Array.isArray(t2))
          if (function(t3) {
            return t3.every((t4) => typeof t4 == "string");
          }(t2))
            [t2, ...a2] = t2;
          else
            for (const e3 of t2)
              this.addHandler(e3);
        else {
          if (function(t3) {
            return typeof t3 == "object" && !Array.isArray(t3);
          }(t2)) {
            let e3 = Array.isArray(t2.command) || typeof t2.command == "string" ? t2.command : this.moduleName(t2);
            return t2.aliases && (e3 = [].concat(e3).concat(t2.aliases)), void this.addHandler(e3, this.extractDesc(t2), t2.builder, t2.handler, t2.middlewares, t2.deprecated);
          }
          if (k(s2))
            return void this.addHandler([t2].concat(a2), e2, s2.builder, s2.handler, s2.middlewares, s2.deprecated);
        }
        if (typeof t2 == "string") {
          const n3 = o(t2);
          a2 = a2.map((t3) => o(t3).cmd);
          let l2 = false;
          const c2 = [n3.cmd].concat(a2).filter((t3) => !_.test(t3) || (l2 = true, false));
          c2.length === 0 && l2 && c2.push("$0"), l2 && (n3.cmd = c2[0], a2 = c2.slice(1), t2 = t2.replace(_, n3.cmd)), a2.forEach((t3) => {
            this.aliasMap[t3] = n3.cmd;
          }), e2 !== false && this.usage.command(t2, e2, l2, a2, r2), this.handlers[n3.cmd] = { original: t2, description: e2, handler: i2, builder: s2 || {}, middlewares: h2, deprecated: r2, demanded: n3.demanded, optional: n3.optional }, l2 && (this.defaultCommand = this.handlers[n3.cmd]);
        }
      }
      getCommandHandlers() {
        return this.handlers;
      }
      getCommands() {
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
      }
      hasDefaultCommand() {
        return !!this.defaultCommand;
      }
      runCommand(t2, e2, s2, i2, n2, r2) {
        const o2 = this.handlers[t2] || this.handlers[this.aliasMap[t2]] || this.defaultCommand, a2 = e2.getInternalMethods().getContext(), h2 = a2.commands.slice(), l2 = !t2;
        t2 && (a2.commands.push(t2), a2.fullCommands.push(o2.original));
        const c2 = this.applyBuilderUpdateUsageAndParse(l2, o2, e2, s2.aliases, h2, i2, n2, r2);
        return f(c2) ? c2.then((t3) => this.applyMiddlewareAndGetResult(l2, o2, t3.innerArgv, a2, n2, t3.aliases, e2)) : this.applyMiddlewareAndGetResult(l2, o2, c2.innerArgv, a2, n2, c2.aliases, e2);
      }
      applyBuilderUpdateUsageAndParse(t2, e2, s2, i2, n2, r2, o2, a2) {
        const h2 = e2.builder;
        let l2 = s2;
        if (E(h2)) {
          const c2 = h2(s2.getInternalMethods().reset(i2), a2);
          if (f(c2))
            return c2.then((i3) => {
              var a3;
              return l2 = (a3 = i3) && typeof a3.getInternalMethods == "function" ? i3 : s2, this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
            });
        } else
          (function(t3) {
            return typeof t3 == "object";
          })(h2) && (l2 = s2.getInternalMethods().reset(i2), Object.keys(e2.builder).forEach((t3) => {
            l2.option(t3, h2[t3]);
          }));
        return this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
      }
      parseAndUpdateUsage(t2, e2, s2, i2, n2, r2) {
        t2 && s2.getInternalMethods().getUsageInstance().unfreeze(), this.shouldUpdateUsage(s2) && s2.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i2, e2), e2.description);
        const o2 = s2.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, n2, r2);
        return f(o2) ? o2.then((t3) => ({ aliases: s2.parsed.aliases, innerArgv: t3 })) : { aliases: s2.parsed.aliases, innerArgv: o2 };
      }
      shouldUpdateUsage(t2) {
        return !t2.getInternalMethods().getUsageInstance().getUsageDisabled() && t2.getInternalMethods().getUsageInstance().getUsage().length === 0;
      }
      usageFromParentCommandsCommandHandler(t2, e2) {
        const s2 = _.test(e2.original) ? e2.original.replace(_, "").trim() : e2.original, i2 = t2.filter((t3) => !_.test(t3));
        return i2.push(s2), `$0 ${i2.join(" ")}`;
      }
      applyMiddlewareAndGetResult(t2, e2, s2, i2, n2, r2, o2) {
        let a2 = {};
        if (n2)
          return s2;
        o2.getInternalMethods().getHasOutput() || (a2 = this.populatePositionals(e2, s2, i2, o2));
        const h2 = this.globalMiddleware.getMiddleware().slice(0).concat(e2.middlewares);
        if (s2 = C(s2, o2, h2, true), !o2.getInternalMethods().getHasOutput()) {
          const e3 = o2.getInternalMethods().runValidation(r2, a2, o2.parsed.error, t2);
          s2 = j(s2, (t3) => (e3(t3), t3));
        }
        if (e2.handler && !o2.getInternalMethods().getHasOutput()) {
          o2.getInternalMethods().setHasOutput();
          const i3 = !!o2.getOptions().configuration["populate--"];
          o2.getInternalMethods().postProcess(s2, i3, false, false), s2 = j(s2 = C(s2, o2, h2, false), (t3) => {
            const s3 = e2.handler(t3);
            return f(s3) ? s3.then(() => t3) : t3;
          }), t2 || o2.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s2) && !o2.getInternalMethods().hasParseCallback() && s2.catch((t3) => {
            try {
              o2.getInternalMethods().getUsageInstance().fail(null, t3);
            } catch (t4) {
            }
          });
        }
        return t2 || (i2.commands.pop(), i2.fullCommands.pop()), s2;
      }
      populatePositionals(t2, e2, s2, i2) {
        e2._ = e2._.slice(s2.commands.length);
        const n2 = t2.demanded.slice(0), r2 = t2.optional.slice(0), o2 = {};
        for (this.validation.positionalCount(n2.length, e2._.length); n2.length; ) {
          const t3 = n2.shift();
          this.populatePositional(t3, e2, o2);
        }
        for (; r2.length; ) {
          const t3 = r2.shift();
          this.populatePositional(t3, e2, o2);
        }
        return e2._ = s2.commands.concat(e2._.map((t3) => "" + t3)), this.postProcessPositionals(e2, o2, this.cmdToParseOptions(t2.original), i2), o2;
      }
      populatePositional(t2, e2, s2) {
        const i2 = t2.cmd[0];
        t2.variadic ? s2[i2] = e2._.splice(0).map(String) : e2._.length && (s2[i2] = [String(e2._.shift())]);
      }
      cmdToParseOptions(t2) {
        const e2 = { array: [], default: {}, alias: {}, demand: {} }, s2 = o(t2);
        return s2.demanded.forEach((t3) => {
          const [s3, ...i2] = t3.cmd;
          t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2, e2.demand[s3] = true;
        }), s2.optional.forEach((t3) => {
          const [s3, ...i2] = t3.cmd;
          t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2;
        }), e2;
      }
      postProcessPositionals(t2, e2, s2, i2) {
        const n2 = Object.assign({}, i2.getOptions());
        n2.default = Object.assign(s2.default, n2.default);
        for (const t3 of Object.keys(s2.alias))
          n2.alias[t3] = (n2.alias[t3] || []).concat(s2.alias[t3]);
        n2.array = n2.array.concat(s2.array), n2.config = {};
        const r2 = [];
        if (Object.keys(e2).forEach((t3) => {
          e2[t3].map((e3) => {
            n2.configuration["unknown-options-as-args"] && (n2.key[t3] = true), r2.push(`--${t3}`), r2.push(e3);
          });
        }), !r2.length)
          return;
        const o2 = Object.assign({}, n2.configuration, { "populate--": false }), a2 = this.shim.Parser.detailed(r2, Object.assign({}, n2, { configuration: o2 }));
        if (a2.error)
          i2.getInternalMethods().getUsageInstance().fail(a2.error.message, a2.error);
        else {
          const s3 = Object.keys(e2);
          Object.keys(e2).forEach((t3) => {
            s3.push(...a2.aliases[t3]);
          });
          const n3 = i2.getOptions().default;
          Object.keys(a2.argv).forEach((i3) => {
            s3.includes(i3) && (e2[i3] || (e2[i3] = a2.argv[i3]), !Object.prototype.hasOwnProperty.call(n3, i3) && Object.prototype.hasOwnProperty.call(t2, i3) && Object.prototype.hasOwnProperty.call(a2.argv, i3) && (Array.isArray(t2[i3]) || Array.isArray(a2.argv[i3])) ? t2[i3] = [].concat(t2[i3], a2.argv[i3]) : t2[i3] = a2.argv[i3]);
          });
        }
      }
      runDefaultBuilderOn(t2) {
        if (!this.defaultCommand)
          return;
        if (this.shouldUpdateUsage(t2)) {
          const e3 = _.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
          t2.getInternalMethods().getUsageInstance().usage(e3, this.defaultCommand.description);
        }
        const e2 = this.defaultCommand.builder;
        if (E(e2))
          return e2(t2, true);
        k(e2) || Object.keys(e2).forEach((s2) => {
          t2.option(s2, e2[s2]);
        });
      }
      moduleName(t2) {
        const e2 = function(t3) {
          if (typeof require == "undefined")
            return null;
          for (let e3, s2 = 0, i2 = Object.keys(require.cache); s2 < i2.length; s2++)
            if (e3 = require.cache[i2[s2]], e3.exports === t3)
              return e3;
          return null;
        }(t2);
        if (!e2)
          throw new Error(`No command name given for module: ${this.shim.inspect(t2)}`);
        return this.commandFromFilename(e2.filename);
      }
      commandFromFilename(t2) {
        return this.shim.path.basename(t2, this.shim.path.extname(t2));
      }
      extractDesc({ describe: t2, description: e2, desc: s2 }) {
        for (const i2 of [t2, e2, s2]) {
          if (typeof i2 == "string" || i2 === false)
            return i2;
          d(i2, true, this.shim);
        }
        return false;
      }
      freeze() {
        this.frozens.push({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand });
      }
      unfreeze() {
        const t2 = this.frozens.pop();
        d(t2, void 0, this.shim), { handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = t2;
      }
      reset() {
        return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = /* @__PURE__ */ new Set(), this;
      }
    };
    function k(t2) {
      return typeof t2 == "object" && !!t2.builder && typeof t2.handler == "function";
    }
    function E(t2) {
      return typeof t2 == "function";
    }
    function x(t2) {
      typeof process != "undefined" && [process.stdout, process.stderr].forEach((e2) => {
        const s2 = e2;
        s2._handle && s2.isTTY && typeof s2._handle.setBlocking == "function" && s2._handle.setBlocking(t2);
      });
    }
    function A(t2) {
      return typeof t2 == "boolean";
    }
    function S(t2, s2) {
      const i2 = s2.y18n.__, n2 = {}, r2 = [];
      n2.failFn = function(t3) {
        r2.push(t3);
      };
      let o2 = null, a2 = true;
      n2.showHelpOnFail = function(t3 = true, e2) {
        const [s3, i3] = typeof t3 == "string" ? [true, t3] : [t3, e2];
        return o2 = i3, a2 = s3, n2;
      };
      let h2 = false;
      n2.fail = function(s3, i3) {
        const l3 = t2.getInternalMethods().getLoggerInstance();
        if (!r2.length) {
          if (t2.getExitProcess() && x(true), h2 || (h2 = true, a2 && (t2.showHelp("error"), l3.error()), (s3 || i3) && l3.error(s3 || i3), o2 && ((s3 || i3) && l3.error(""), l3.error(o2))), i3 = i3 || new e(s3), t2.getExitProcess())
            return t2.exit(1);
          if (t2.getInternalMethods().hasParseCallback())
            return t2.exit(1, i3);
          throw i3;
        }
        for (let t3 = r2.length - 1; t3 >= 0; --t3) {
          const e2 = r2[t3];
          if (A(e2)) {
            if (i3)
              throw i3;
            if (s3)
              throw Error(s3);
          } else
            e2(s3, i3, n2);
        }
      };
      let l2 = [], c2 = false;
      n2.usage = (t3, e2) => t3 === null ? (c2 = true, l2 = [], n2) : (c2 = false, l2.push([t3, e2 || ""]), n2), n2.getUsage = () => l2, n2.getUsageDisabled = () => c2, n2.getPositionalGroupName = () => i2("Positionals:");
      let f2 = [];
      n2.example = (t3, e2) => {
        f2.push([t3, e2 || ""]);
      };
      let d2 = [];
      n2.command = function(t3, e2, s3, i3, n3 = false) {
        s3 && (d2 = d2.map((t4) => (t4[2] = false, t4))), d2.push([t3, e2 || "", s3, i3, n3]);
      }, n2.getCommands = () => d2;
      let u2 = {};
      n2.describe = function(t3, e2) {
        Array.isArray(t3) ? t3.forEach((t4) => {
          n2.describe(t4, e2);
        }) : typeof t3 == "object" ? Object.keys(t3).forEach((e3) => {
          n2.describe(e3, t3[e3]);
        }) : u2[t3] = e2;
      }, n2.getDescriptions = () => u2;
      let p2 = [];
      n2.epilog = (t3) => {
        p2.push(t3);
      };
      let m2, y2 = false;
      function b2() {
        return y2 || (m2 = function() {
          const t3 = 80;
          return s2.process.stdColumns ? Math.min(t3, s2.process.stdColumns) : t3;
        }(), y2 = true), m2;
      }
      n2.wrap = (t3) => {
        y2 = true, m2 = t3;
      };
      const v2 = "__yargsString__:";
      function O2(t3, e2, i3) {
        let n3 = 0;
        return Array.isArray(t3) || (t3 = Object.values(t3).map((t4) => [t4])), t3.forEach((t4) => {
          n3 = Math.max(s2.stringWidth(i3 ? `${i3} ${I(t4[0])}` : I(t4[0])) + $(t4[0]), n3);
        }), e2 && (n3 = Math.min(n3, parseInt((0.5 * e2).toString(), 10))), n3;
      }
      let w2;
      function C2(e2) {
        return t2.getOptions().hiddenOptions.indexOf(e2) < 0 || t2.parsed.argv[t2.getOptions().showHiddenOpt];
      }
      function j2(t3, e2) {
        let s3 = `[${i2("default:")} `;
        if (t3 === void 0 && !e2)
          return null;
        if (e2)
          s3 += e2;
        else
          switch (typeof t3) {
            case "string":
              s3 += `"${t3}"`;
              break;
            case "object":
              s3 += JSON.stringify(t3);
              break;
            default:
              s3 += t3;
          }
        return `${s3}]`;
      }
      n2.deferY18nLookup = (t3) => v2 + t3, n2.help = function() {
        if (w2)
          return w2;
        !function() {
          const e3 = t2.getDemandedOptions(), s3 = t2.getOptions();
          (Object.keys(s3.alias) || []).forEach((i3) => {
            s3.alias[i3].forEach((r4) => {
              u2[r4] && n2.describe(i3, u2[r4]), r4 in e3 && t2.demandOption(i3, e3[r4]), s3.boolean.includes(r4) && t2.boolean(i3), s3.count.includes(r4) && t2.count(i3), s3.string.includes(r4) && t2.string(i3), s3.normalize.includes(r4) && t2.normalize(i3), s3.array.includes(r4) && t2.array(i3), s3.number.includes(r4) && t2.number(i3);
            });
          });
        }();
        const e2 = t2.customScriptName ? t2.$0 : s2.path.basename(t2.$0), r3 = t2.getDemandedOptions(), o3 = t2.getDemandedCommands(), a3 = t2.getDeprecatedOptions(), h3 = t2.getGroups(), g2 = t2.getOptions();
        let m3 = [];
        m3 = m3.concat(Object.keys(u2)), m3 = m3.concat(Object.keys(r3)), m3 = m3.concat(Object.keys(o3)), m3 = m3.concat(Object.keys(g2.default)), m3 = m3.filter(C2), m3 = Object.keys(m3.reduce((t3, e3) => (e3 !== "_" && (t3[e3] = true), t3), {}));
        const y3 = b2(), _3 = s2.cliui({ width: y3, wrap: !!y3 });
        if (!c2) {
          if (l2.length)
            l2.forEach((t3) => {
              _3.div({ text: `${t3[0].replace(/\$0/g, e2)}` }), t3[1] && _3.div({ text: `${t3[1]}`, padding: [1, 0, 0, 0] });
            }), _3.div();
          else if (d2.length) {
            let t3 = null;
            t3 = o3._ ? `${e2} <${i2("command")}>
` : `${e2} [${i2("command")}]
`, _3.div(`${t3}`);
          }
        }
        if (d2.length > 1 || d2.length === 1 && !d2[0][2]) {
          _3.div(i2("Commands:"));
          const s3 = t2.getInternalMethods().getContext(), n3 = s3.commands.length ? `${s3.commands.join(" ")} ` : "";
          t2.getInternalMethods().getParserConfiguration()["sort-commands"] === true && (d2 = d2.sort((t3, e3) => t3[0].localeCompare(e3[0])));
          const r4 = e2 ? `${e2} ` : "";
          d2.forEach((t3) => {
            const s4 = `${r4}${n3}${t3[0].replace(/^\$0 ?/, "")}`;
            _3.span({ text: s4, padding: [0, 2, 0, 2], width: O2(d2, y3, `${e2}${n3}`) + 4 }, { text: t3[1] });
            const o4 = [];
            t3[2] && o4.push(`[${i2("default")}]`), t3[3] && t3[3].length && o4.push(`[${i2("aliases:")} ${t3[3].join(", ")}]`), t3[4] && (typeof t3[4] == "string" ? o4.push(`[${i2("deprecated: %s", t3[4])}]`) : o4.push(`[${i2("deprecated")}]`)), o4.length ? _3.div({ text: o4.join(" "), padding: [0, 0, 0, 2], align: "right" }) : _3.div();
          }), _3.div();
        }
        const M3 = (Object.keys(g2.alias) || []).concat(Object.keys(t2.parsed.newAliases) || []);
        m3 = m3.filter((e3) => !t2.parsed.newAliases[e3] && M3.every((t3) => (g2.alias[t3] || []).indexOf(e3) === -1));
        const k2 = i2("Options:");
        h3[k2] || (h3[k2] = []), function(t3, e3, s3, i3) {
          let n3 = [], r4 = null;
          Object.keys(s3).forEach((t4) => {
            n3 = n3.concat(s3[t4]);
          }), t3.forEach((t4) => {
            r4 = [t4].concat(e3[t4]), r4.some((t5) => n3.indexOf(t5) !== -1) || s3[i3].push(t4);
          });
        }(m3, g2.alias, h3, k2);
        const E2 = (t3) => /^--/.test(I(t3)), x2 = Object.keys(h3).filter((t3) => h3[t3].length > 0).map((t3) => ({ groupName: t3, normalizedKeys: h3[t3].filter(C2).map((t4) => {
          if (M3.includes(t4))
            return t4;
          for (let e3, s3 = 0; (e3 = M3[s3]) !== void 0; s3++)
            if ((g2.alias[e3] || []).includes(t4))
              return e3;
          return t4;
        }) })).filter(({ normalizedKeys: t3 }) => t3.length > 0).map(({ groupName: t3, normalizedKeys: e3 }) => {
          const s3 = e3.reduce((e4, s4) => (e4[s4] = [s4].concat(g2.alias[s4] || []).map((e5) => t3 === n2.getPositionalGroupName() ? e5 : (/^[0-9]$/.test(e5) ? g2.boolean.includes(s4) ? "-" : "--" : e5.length > 1 ? "--" : "-") + e5).sort((t4, e5) => E2(t4) === E2(e5) ? 0 : E2(t4) ? 1 : -1).join(", "), e4), {});
          return { groupName: t3, normalizedKeys: e3, switches: s3 };
        });
        if (x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).some(({ normalizedKeys: t3, switches: e3 }) => !t3.every((t4) => E2(e3[t4]))) && x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).forEach(({ normalizedKeys: t3, switches: e3 }) => {
          t3.forEach((t4) => {
            var s3, i3;
            E2(e3[t4]) && (e3[t4] = (s3 = e3[t4], i3 = "-x, ".length, P(s3) ? { text: s3.text, indentation: s3.indentation + i3 } : { text: s3, indentation: i3 }));
          });
        }), x2.forEach(({ groupName: t3, normalizedKeys: e3, switches: s3 }) => {
          _3.div(t3), e3.forEach((t4) => {
            const e4 = s3[t4];
            let o4 = u2[t4] || "", h4 = null;
            o4.includes(v2) && (o4 = i2(o4.substring(v2.length))), g2.boolean.includes(t4) && (h4 = `[${i2("boolean")}]`), g2.count.includes(t4) && (h4 = `[${i2("count")}]`), g2.string.includes(t4) && (h4 = `[${i2("string")}]`), g2.normalize.includes(t4) && (h4 = `[${i2("string")}]`), g2.array.includes(t4) && (h4 = `[${i2("array")}]`), g2.number.includes(t4) && (h4 = `[${i2("number")}]`);
            const l3 = [t4 in a3 ? (c3 = a3[t4], typeof c3 == "string" ? `[${i2("deprecated: %s", c3)}]` : `[${i2("deprecated")}]`) : null, h4, t4 in r3 ? `[${i2("required")}]` : null, g2.choices && g2.choices[t4] ? `[${i2("choices:")} ${n2.stringifiedValues(g2.choices[t4])}]` : null, j2(g2.default[t4], g2.defaultDescription[t4])].filter(Boolean).join(" ");
            var c3;
            _3.span({ text: I(e4), padding: [0, 2, 0, 2 + $(e4)], width: O2(s3, y3) + 4 }, o4), l3 ? _3.div({ text: l3, padding: [0, 0, 0, 2], align: "right" }) : _3.div();
          }), _3.div();
        }), f2.length && (_3.div(i2("Examples:")), f2.forEach((t3) => {
          t3[0] = t3[0].replace(/\$0/g, e2);
        }), f2.forEach((t3) => {
          t3[1] === "" ? _3.div({ text: t3[0], padding: [0, 2, 0, 2] }) : _3.div({ text: t3[0], padding: [0, 2, 0, 2], width: O2(f2, y3) + 4 }, { text: t3[1] });
        }), _3.div()), p2.length > 0) {
          const t3 = p2.map((t4) => t4.replace(/\$0/g, e2)).join("\n");
          _3.div(`${t3}
`);
        }
        return _3.toString().replace(/\s*$/, "");
      }, n2.cacheHelpMessage = function() {
        w2 = this.help();
      }, n2.clearCachedHelpMessage = function() {
        w2 = void 0;
      }, n2.hasCachedHelpMessage = function() {
        return !!w2;
      }, n2.showHelp = (e2) => {
        const s3 = t2.getInternalMethods().getLoggerInstance();
        e2 || (e2 = "error");
        (typeof e2 == "function" ? e2 : s3[e2])(n2.help());
      }, n2.functionDescription = (t3) => ["(", t3.name ? s2.Parser.decamelize(t3.name, "-") : i2("generated-value"), ")"].join(""), n2.stringifiedValues = function(t3, e2) {
        let s3 = "";
        const i3 = e2 || ", ", n3 = [].concat(t3);
        return t3 && n3.length ? (n3.forEach((t4) => {
          s3.length && (s3 += i3), s3 += JSON.stringify(t4);
        }), s3) : s3;
      };
      let _2 = null;
      n2.version = (t3) => {
        _2 = t3;
      }, n2.showVersion = (e2) => {
        const s3 = t2.getInternalMethods().getLoggerInstance();
        e2 || (e2 = "error");
        (typeof e2 == "function" ? e2 : s3[e2])(_2);
      }, n2.reset = function(t3) {
        return o2 = null, h2 = false, l2 = [], c2 = false, p2 = [], f2 = [], d2 = [], u2 = g(u2, (e2) => !t3[e2]), n2;
      };
      const M2 = [];
      return n2.freeze = function() {
        M2.push({ failMessage: o2, failureOutput: h2, usages: l2, usageDisabled: c2, epilogs: p2, examples: f2, commands: d2, descriptions: u2 });
      }, n2.unfreeze = function() {
        const t3 = M2.pop();
        t3 && ({ failMessage: o2, failureOutput: h2, usages: l2, usageDisabled: c2, epilogs: p2, examples: f2, commands: d2, descriptions: u2 } = t3);
      }, n2;
    }
    function P(t2) {
      return typeof t2 == "object";
    }
    function $(t2) {
      return P(t2) ? t2.indentation : 0;
    }
    function I(t2) {
      return P(t2) ? t2.text : t2;
    }
    var D = class {
      constructor(t2, e2, s2, i2) {
        var n2, r2, o2;
        this.yargs = t2, this.usage = e2, this.command = s2, this.shim = i2, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.zshShell = (o2 = ((n2 = this.shim.getEnv("SHELL")) === null || n2 === void 0 ? void 0 : n2.includes("zsh")) || ((r2 = this.shim.getEnv("ZSH_NAME")) === null || r2 === void 0 ? void 0 : r2.includes("zsh"))) !== null && o2 !== void 0 && o2;
      }
      defaultCompletion(t2, e2, s2, i2) {
        const n2 = this.command.getCommandHandlers();
        for (let e3 = 0, s3 = t2.length; e3 < s3; ++e3)
          if (n2[t2[e3]] && n2[t2[e3]].builder) {
            const s4 = n2[t2[e3]].builder;
            if (E(s4)) {
              const t3 = this.yargs.getInternalMethods().reset();
              return s4(t3, true), t3.argv;
            }
          }
        const r2 = [];
        this.commandCompletions(r2, t2, s2), this.optionCompletions(r2, t2, e2, s2), this.choicesCompletions(r2, t2, e2, s2), i2(null, r2);
      }
      commandCompletions(t2, e2, s2) {
        const i2 = this.yargs.getInternalMethods().getContext().commands;
        s2.match(/^-/) || i2[i2.length - 1] === s2 || this.previousArgHasChoices(e2) || this.usage.getCommands().forEach((s3) => {
          const i3 = o(s3[0]).cmd;
          if (e2.indexOf(i3) === -1)
            if (this.zshShell) {
              const e3 = s3[1] || "";
              t2.push(i3.replace(/:/g, "\\:") + ":" + e3);
            } else
              t2.push(i3);
        });
      }
      optionCompletions(t2, e2, s2, i2) {
        if ((i2.match(/^-/) || i2 === "" && t2.length === 0) && !this.previousArgHasChoices(e2)) {
          const n2 = this.yargs.getOptions(), r2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
          Object.keys(n2.key).forEach((o2) => {
            const a2 = !!n2.configuration["boolean-negation"] && n2.boolean.includes(o2);
            r2.includes(o2) || this.argsContainKey(e2, s2, o2, a2) || (this.completeOptionKey(o2, t2, i2), a2 && n2.default[o2] && this.completeOptionKey(`no-${o2}`, t2, i2));
          });
        }
      }
      choicesCompletions(t2, e2, s2, i2) {
        if (this.previousArgHasChoices(e2)) {
          const s3 = this.getPreviousArgChoices(e2);
          s3 && s3.length > 0 && t2.push(...s3);
        }
      }
      getPreviousArgChoices(t2) {
        if (t2.length < 1)
          return;
        let e2 = t2[t2.length - 1], s2 = "";
        if (!e2.startsWith("--") && t2.length > 1 && (s2 = e2, e2 = t2[t2.length - 2]), !e2.startsWith("--"))
          return;
        const i2 = e2.replace(/-/g, ""), n2 = this.yargs.getOptions();
        return Object.keys(n2.key).some((t3) => t3 === i2) && Array.isArray(n2.choices[i2]) ? n2.choices[i2].filter((t3) => !s2 || t3.startsWith(s2)) : void 0;
      }
      previousArgHasChoices(t2) {
        const e2 = this.getPreviousArgChoices(t2);
        return e2 !== void 0 && e2.length > 0;
      }
      argsContainKey(t2, e2, s2, i2) {
        if (t2.indexOf(`--${s2}`) !== -1)
          return true;
        if (i2 && t2.indexOf(`--no-${s2}`) !== -1)
          return true;
        if (this.aliases) {
          for (const t3 of this.aliases[s2])
            if (e2[t3] !== void 0)
              return true;
        }
        return false;
      }
      completeOptionKey(t2, e2, s2) {
        const i2 = this.usage.getDescriptions(), n2 = !/^--/.test(s2) && ((t3) => /^[^0-9]$/.test(t3))(t2) ? "-" : "--";
        if (this.zshShell) {
          const s3 = i2[t2] || "";
          e2.push(n2 + `${t2.replace(/:/g, "\\:")}:${s3.replace("__yargsString__:", "")}`);
        } else
          e2.push(n2 + t2);
      }
      customCompletion(t2, e2, s2, i2) {
        if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {
          const t3 = this.customCompletionFunction(s2, e2);
          return f(t3) ? t3.then((t4) => {
            this.shim.process.nextTick(() => {
              i2(null, t4);
            });
          }).catch((t4) => {
            this.shim.process.nextTick(() => {
              i2(t4, void 0);
            });
          }) : i2(null, t3);
        }
        return function(t3) {
          return t3.length > 3;
        }(this.customCompletionFunction) ? this.customCompletionFunction(s2, e2, (n2 = i2) => this.defaultCompletion(t2, e2, s2, n2), (t3) => {
          i2(null, t3);
        }) : this.customCompletionFunction(s2, e2, (t3) => {
          i2(null, t3);
        });
      }
      getCompletion(t2, e2) {
        const s2 = t2.length ? t2[t2.length - 1] : "", i2 = this.yargs.parse(t2, true), n2 = this.customCompletionFunction ? (i3) => this.customCompletion(t2, i3, s2, e2) : (i3) => this.defaultCompletion(t2, i3, s2, e2);
        return f(i2) ? i2.then(n2) : n2(i2);
      }
      generateCompletionScript(t2, e2) {
        let s2 = this.zshShell ? `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
` : '###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="${COMP_WORDS[COMP_CWORD]}"\n    args=("${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "${args[@]}")\n\n    COMPREPLY=( $(compgen -W "${type_list}" -- ${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n';
        const i2 = this.shim.path.basename(t2);
        return t2.match(/\.js$/) && (t2 = `./${t2}`), s2 = s2.replace(/{{app_name}}/g, i2), s2 = s2.replace(/{{completion_command}}/g, e2), s2.replace(/{{app_path}}/g, t2);
      }
      registerFunction(t2) {
        this.customCompletionFunction = t2;
      }
      setParsed(t2) {
        this.aliases = t2.aliases;
      }
    };
    function N(t2, e2) {
      if (t2.length === 0)
        return e2.length;
      if (e2.length === 0)
        return t2.length;
      const s2 = [];
      let i2, n2;
      for (i2 = 0; i2 <= e2.length; i2++)
        s2[i2] = [i2];
      for (n2 = 0; n2 <= t2.length; n2++)
        s2[0][n2] = n2;
      for (i2 = 1; i2 <= e2.length; i2++)
        for (n2 = 1; n2 <= t2.length; n2++)
          e2.charAt(i2 - 1) === t2.charAt(n2 - 1) ? s2[i2][n2] = s2[i2 - 1][n2 - 1] : i2 > 1 && n2 > 1 && e2.charAt(i2 - 2) === t2.charAt(n2 - 1) && e2.charAt(i2 - 1) === t2.charAt(n2 - 2) ? s2[i2][n2] = s2[i2 - 2][n2 - 2] + 1 : s2[i2][n2] = Math.min(s2[i2 - 1][n2 - 1] + 1, Math.min(s2[i2][n2 - 1] + 1, s2[i2 - 1][n2] + 1));
      return s2[e2.length][t2.length];
    }
    var H = ["$0", "--", "_"];
    var z;
    var q;
    var W;
    var U;
    var F;
    var L;
    var V;
    var T;
    var R;
    var G;
    var K;
    var B;
    var Y;
    var J;
    var Z;
    var X;
    var Q;
    var tt;
    var et;
    var st;
    var it;
    var nt;
    var rt;
    var ot;
    var at;
    var ht;
    var lt;
    var ct;
    var ft;
    var dt;
    var ut;
    var pt;
    var gt;
    var mt = Symbol("copyDoubleDash");
    var yt = Symbol("copyDoubleDash");
    var bt = Symbol("deleteFromParserHintObject");
    var vt = Symbol("emitWarning");
    var Ot = Symbol("freeze");
    var wt = Symbol("getDollarZero");
    var Ct = Symbol("getParserConfiguration");
    var jt = Symbol("guessLocale");
    var _t = Symbol("guessVersion");
    var Mt = Symbol("parsePositionalNumbers");
    var kt = Symbol("pkgUp");
    var Et = Symbol("populateParserHintArray");
    var xt = Symbol("populateParserHintSingleValueDictionary");
    var At = Symbol("populateParserHintArrayDictionary");
    var St = Symbol("populateParserHintDictionary");
    var Pt = Symbol("sanitizeKey");
    var $t = Symbol("setKey");
    var It = Symbol("unfreeze");
    var Dt = Symbol("validateAsync");
    var Nt = Symbol("getCommandInstance");
    var Ht = Symbol("getContext");
    var zt = Symbol("getHasOutput");
    var qt = Symbol("getLoggerInstance");
    var Wt = Symbol("getParseContext");
    var Ut = Symbol("getUsageInstance");
    var Ft = Symbol("getValidationInstance");
    var Lt = Symbol("hasParseCallback");
    var Vt = Symbol("postProcess");
    var Tt = Symbol("rebase");
    var Rt = Symbol("reset");
    var Gt = Symbol("runYargsParserAndExecuteCommands");
    var Kt = Symbol("runValidation");
    var Bt = Symbol("setHasOutput");
    var Yt = Symbol("kTrackManuallySetKeys");
    var Jt = class {
      constructor(t2 = [], e2, s2, i2) {
        this.customScriptName = false, this.parsed = false, z.set(this, void 0), q.set(this, void 0), W.set(this, { commands: [], fullCommands: [] }), U.set(this, null), F.set(this, null), L.set(this, "show-hidden"), V.set(this, null), T.set(this, true), R.set(this, {}), G.set(this, true), K.set(this, []), B.set(this, void 0), Y.set(this, {}), J.set(this, false), Z.set(this, null), X.set(this, void 0), Q.set(this, ""), tt.set(this, void 0), et.set(this, void 0), st.set(this, {}), it.set(this, null), nt.set(this, null), rt.set(this, {}), ot.set(this, {}), at.set(this, void 0), ht.set(this, false), lt.set(this, void 0), ct.set(this, false), ft.set(this, false), dt.set(this, false), ut.set(this, void 0), pt.set(this, null), gt.set(this, void 0), O(this, lt, i2, "f"), O(this, at, t2, "f"), O(this, q, e2, "f"), O(this, et, s2, "f"), O(this, B, new w(this), "f"), this.$0 = this[wt](), this[Rt](), O(this, z, v(this, z, "f"), "f"), O(this, ut, v(this, ut, "f"), "f"), O(this, gt, v(this, gt, "f"), "f"), O(this, tt, v(this, tt, "f"), "f"), v(this, tt, "f").showHiddenOpt = v(this, L, "f"), O(this, X, this[yt](), "f");
      }
      addHelpOpt(t2, e2) {
        return h("[string|boolean] [string]", [t2, e2], arguments.length), v(this, Z, "f") && (this[bt](v(this, Z, "f")), O(this, Z, null, "f")), t2 === false && e2 === void 0 || (O(this, Z, typeof t2 == "string" ? t2 : "help", "f"), this.boolean(v(this, Z, "f")), this.describe(v(this, Z, "f"), e2 || v(this, ut, "f").deferY18nLookup("Show help"))), this;
      }
      help(t2, e2) {
        return this.addHelpOpt(t2, e2);
      }
      addShowHiddenOpt(t2, e2) {
        if (h("[string|boolean] [string]", [t2, e2], arguments.length), t2 === false && e2 === void 0)
          return this;
        const s2 = typeof t2 == "string" ? t2 : v(this, L, "f");
        return this.boolean(s2), this.describe(s2, e2 || v(this, ut, "f").deferY18nLookup("Show hidden options")), v(this, tt, "f").showHiddenOpt = s2, this;
      }
      showHidden(t2, e2) {
        return this.addShowHiddenOpt(t2, e2);
      }
      alias(t2, e2) {
        return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[At](this.alias.bind(this), "alias", t2, e2), this;
      }
      array(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("array", t2), this[Yt](t2), this;
      }
      boolean(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("boolean", t2), this[Yt](t2), this;
      }
      check(t2, e2) {
        return h("<function> [boolean]", [t2, e2], arguments.length), this.middleware((e3, s2) => j(() => t2(e3, s2.getOptions()), (s3) => (s3 ? (typeof s3 == "string" || s3 instanceof Error) && v(this, ut, "f").fail(s3.toString(), s3) : v(this, ut, "f").fail(v(this, lt, "f").y18n.__("Argument check failed: %s", t2.toString())), e3), (t3) => (v(this, ut, "f").fail(t3.message ? t3.message : t3.toString(), t3), e3)), false, e2), this;
      }
      choices(t2, e2) {
        return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[At](this.choices.bind(this), "choices", t2, e2), this;
      }
      coerce(t2, s2) {
        if (h("<object|string|array> [function]", [t2, s2], arguments.length), Array.isArray(t2)) {
          if (!s2)
            throw new e("coerce callback must be provided");
          for (const e2 of t2)
            this.coerce(e2, s2);
          return this;
        }
        if (typeof t2 == "object") {
          for (const e2 of Object.keys(t2))
            this.coerce(e2, t2[e2]);
          return this;
        }
        if (!s2)
          throw new e("coerce callback must be provided");
        return v(this, tt, "f").key[t2] = true, v(this, B, "f").addCoerceMiddleware((i2, n2) => {
          let r2;
          return j(() => (r2 = n2.getAliases(), s2(i2[t2])), (e2) => {
            if (i2[t2] = e2, r2[t2])
              for (const s3 of r2[t2])
                i2[s3] = e2;
            return i2;
          }, (t3) => {
            throw new e(t3.message);
          });
        }, t2), this;
      }
      conflicts(t2, e2) {
        return h("<string|object> [string|array]", [t2, e2], arguments.length), v(this, gt, "f").conflicts(t2, e2), this;
      }
      config(t2 = "config", e2, s2) {
        return h("[object|string] [string|function] [function]", [t2, e2, s2], arguments.length), typeof t2 != "object" || Array.isArray(t2) ? (typeof e2 == "function" && (s2 = e2, e2 = void 0), this.describe(t2, e2 || v(this, ut, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t2) ? t2 : [t2]).forEach((t3) => {
          v(this, tt, "f").config[t3] = s2 || true;
        }), this) : (t2 = n(t2, v(this, q, "f"), this[Ct]()["deep-merge-config"] || false, v(this, lt, "f")), v(this, tt, "f").configObjects = (v(this, tt, "f").configObjects || []).concat(t2), this);
      }
      completion(t2, e2, s2) {
        return h("[string] [string|boolean|function] [function]", [t2, e2, s2], arguments.length), typeof e2 == "function" && (s2 = e2, e2 = void 0), O(this, F, t2 || v(this, F, "f") || "completion", "f"), e2 || e2 === false || (e2 = "generate completion script"), this.command(v(this, F, "f"), e2), s2 && v(this, U, "f").registerFunction(s2), this;
      }
      command(t2, e2, s2, i2, n2, r2) {
        return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t2, e2, s2, i2, n2, r2], arguments.length), v(this, z, "f").addHandler(t2, e2, s2, i2, n2, r2), this;
      }
      commands(t2, e2, s2, i2, n2, r2) {
        return this.command(t2, e2, s2, i2, n2, r2);
      }
      commandDir(t2, e2) {
        h("<string> [object]", [t2, e2], arguments.length);
        const s2 = v(this, et, "f") || v(this, lt, "f").require;
        return v(this, z, "f").addDirectory(t2, s2, v(this, lt, "f").getCallerFile(), e2), this;
      }
      count(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("count", t2), this[Yt](t2), this;
      }
      default(t2, e2, s2) {
        return h("<object|string|array> [*] [string]", [t2, e2, s2], arguments.length), s2 && (u(t2, v(this, lt, "f")), v(this, tt, "f").defaultDescription[t2] = s2), typeof e2 == "function" && (u(t2, v(this, lt, "f")), v(this, tt, "f").defaultDescription[t2] || (v(this, tt, "f").defaultDescription[t2] = v(this, ut, "f").functionDescription(e2)), e2 = e2.call()), this[xt](this.default.bind(this), "default", t2, e2), this;
      }
      defaults(t2, e2, s2) {
        return this.default(t2, e2, s2);
      }
      demandCommand(t2 = 1, e2, s2, i2) {
        return h("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t2, e2, s2, i2], arguments.length), typeof e2 != "number" && (s2 = e2, e2 = 1 / 0), this.global("_", false), v(this, tt, "f").demandedCommands._ = { min: t2, max: e2, minMsg: s2, maxMsg: i2 }, this;
      }
      demand(t2, e2, s2) {
        return Array.isArray(e2) ? (e2.forEach((t3) => {
          d(s2, true, v(this, lt, "f")), this.demandOption(t3, s2);
        }), e2 = 1 / 0) : typeof e2 != "number" && (s2 = e2, e2 = 1 / 0), typeof t2 == "number" ? (d(s2, true, v(this, lt, "f")), this.demandCommand(t2, e2, s2, s2)) : Array.isArray(t2) ? t2.forEach((t3) => {
          d(s2, true, v(this, lt, "f")), this.demandOption(t3, s2);
        }) : typeof s2 == "string" ? this.demandOption(t2, s2) : s2 !== true && s2 !== void 0 || this.demandOption(t2), this;
      }
      demandOption(t2, e2) {
        return h("<object|string|array> [string]", [t2, e2], arguments.length), this[xt](this.demandOption.bind(this), "demandedOptions", t2, e2), this;
      }
      deprecateOption(t2, e2) {
        return h("<string> [string|boolean]", [t2, e2], arguments.length), v(this, tt, "f").deprecatedOptions[t2] = e2, this;
      }
      describe(t2, e2) {
        return h("<object|string|array> [string]", [t2, e2], arguments.length), this[$t](t2, true), v(this, ut, "f").describe(t2, e2), this;
      }
      detectLocale(t2) {
        return h("<boolean>", [t2], arguments.length), O(this, T, t2, "f"), this;
      }
      env(t2) {
        return h("[string|boolean]", [t2], arguments.length), t2 === false ? delete v(this, tt, "f").envPrefix : v(this, tt, "f").envPrefix = t2 || "", this;
      }
      epilogue(t2) {
        return h("<string>", [t2], arguments.length), v(this, ut, "f").epilog(t2), this;
      }
      epilog(t2) {
        return this.epilogue(t2);
      }
      example(t2, e2) {
        return h("<string|array> [string]", [t2, e2], arguments.length), Array.isArray(t2) ? t2.forEach((t3) => this.example(...t3)) : v(this, ut, "f").example(t2, e2), this;
      }
      exit(t2, e2) {
        O(this, J, true, "f"), O(this, V, e2, "f"), v(this, G, "f") && v(this, lt, "f").process.exit(t2);
      }
      exitProcess(t2 = true) {
        return h("[boolean]", [t2], arguments.length), O(this, G, t2, "f"), this;
      }
      fail(t2) {
        if (h("<function|boolean>", [t2], arguments.length), typeof t2 == "boolean" && t2 !== false)
          throw new e("Invalid first argument. Expected function or boolean 'false'");
        return v(this, ut, "f").failFn(t2), this;
      }
      getAliases() {
        return this.parsed ? this.parsed.aliases : {};
      }
      async getCompletion(t2, e2) {
        return h("<array> [function]", [t2, e2], arguments.length), e2 ? v(this, U, "f").getCompletion(t2, e2) : new Promise((e3, s2) => {
          v(this, U, "f").getCompletion(t2, (t3, i2) => {
            t3 ? s2(t3) : e3(i2);
          });
        });
      }
      getDemandedOptions() {
        return h([], 0), v(this, tt, "f").demandedOptions;
      }
      getDemandedCommands() {
        return h([], 0), v(this, tt, "f").demandedCommands;
      }
      getDeprecatedOptions() {
        return h([], 0), v(this, tt, "f").deprecatedOptions;
      }
      getDetectLocale() {
        return v(this, T, "f");
      }
      getExitProcess() {
        return v(this, G, "f");
      }
      getGroups() {
        return Object.assign({}, v(this, Y, "f"), v(this, ot, "f"));
      }
      getHelp() {
        if (O(this, J, true, "f"), !v(this, ut, "f").hasCachedHelpMessage()) {
          if (!this.parsed) {
            const t3 = this[Gt](v(this, at, "f"), void 0, void 0, 0, true);
            if (f(t3))
              return t3.then(() => v(this, ut, "f").help());
          }
          const t2 = v(this, z, "f").runDefaultBuilderOn(this);
          if (f(t2))
            return t2.then(() => v(this, ut, "f").help());
        }
        return Promise.resolve(v(this, ut, "f").help());
      }
      getOptions() {
        return v(this, tt, "f");
      }
      getStrict() {
        return v(this, ct, "f");
      }
      getStrictCommands() {
        return v(this, ft, "f");
      }
      getStrictOptions() {
        return v(this, dt, "f");
      }
      global(t2, e2) {
        return h("<string|array> [boolean]", [t2, e2], arguments.length), t2 = [].concat(t2), e2 !== false ? v(this, tt, "f").local = v(this, tt, "f").local.filter((e3) => t2.indexOf(e3) === -1) : t2.forEach((t3) => {
          v(this, tt, "f").local.includes(t3) || v(this, tt, "f").local.push(t3);
        }), this;
      }
      group(t2, e2) {
        h("<string|array> <string>", [t2, e2], arguments.length);
        const s2 = v(this, ot, "f")[e2] || v(this, Y, "f")[e2];
        v(this, ot, "f")[e2] && delete v(this, ot, "f")[e2];
        const i2 = {};
        return v(this, Y, "f")[e2] = (s2 || []).concat(t2).filter((t3) => !i2[t3] && (i2[t3] = true)), this;
      }
      hide(t2) {
        return h("<string>", [t2], arguments.length), v(this, tt, "f").hiddenOptions.push(t2), this;
      }
      implies(t2, e2) {
        return h("<string|object> [number|string|array]", [t2, e2], arguments.length), v(this, gt, "f").implies(t2, e2), this;
      }
      locale(t2) {
        return h("[string]", [t2], arguments.length), t2 ? (O(this, T, false, "f"), v(this, lt, "f").y18n.setLocale(t2), this) : (this[jt](), v(this, lt, "f").y18n.getLocale());
      }
      middleware(t2, e2, s2) {
        return v(this, B, "f").addMiddleware(t2, !!e2, s2);
      }
      nargs(t2, e2) {
        return h("<string|object|array> [number]", [t2, e2], arguments.length), this[xt](this.nargs.bind(this), "narg", t2, e2), this;
      }
      normalize(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("normalize", t2), this;
      }
      number(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("number", t2), this[Yt](t2), this;
      }
      option(t2, e2) {
        if (h("<string|object> [object]", [t2, e2], arguments.length), typeof t2 == "object")
          Object.keys(t2).forEach((e3) => {
            this.options(e3, t2[e3]);
          });
        else {
          typeof e2 != "object" && (e2 = {}), this[Yt](t2), !v(this, pt, "f") || t2 !== "version" && (e2 == null ? void 0 : e2.alias) !== "version" || this[vt](['"version" is a reserved word.', "Please do one of the following:", '- Disable version with `yargs.version(false)` if using "version" as an option', "- Use the built-in `yargs.version` method instead (if applicable)", "- Use a different option key", "https://yargs.js.org/docs/#api-reference-version"].join("\n"), void 0, "versionWarning"), v(this, tt, "f").key[t2] = true, e2.alias && this.alias(t2, e2.alias);
          const s2 = e2.deprecate || e2.deprecated;
          s2 && this.deprecateOption(t2, s2);
          const i2 = e2.demand || e2.required || e2.require;
          i2 && this.demand(t2, i2), e2.demandOption && this.demandOption(t2, typeof e2.demandOption == "string" ? e2.demandOption : void 0), e2.conflicts && this.conflicts(t2, e2.conflicts), "default" in e2 && this.default(t2, e2.default), e2.implies !== void 0 && this.implies(t2, e2.implies), e2.nargs !== void 0 && this.nargs(t2, e2.nargs), e2.config && this.config(t2, e2.configParser), e2.normalize && this.normalize(t2), e2.choices && this.choices(t2, e2.choices), e2.coerce && this.coerce(t2, e2.coerce), e2.group && this.group(t2, e2.group), (e2.boolean || e2.type === "boolean") && (this.boolean(t2), e2.alias && this.boolean(e2.alias)), (e2.array || e2.type === "array") && (this.array(t2), e2.alias && this.array(e2.alias)), (e2.number || e2.type === "number") && (this.number(t2), e2.alias && this.number(e2.alias)), (e2.string || e2.type === "string") && (this.string(t2), e2.alias && this.string(e2.alias)), (e2.count || e2.type === "count") && this.count(t2), typeof e2.global == "boolean" && this.global(t2, e2.global), e2.defaultDescription && (v(this, tt, "f").defaultDescription[t2] = e2.defaultDescription), e2.skipValidation && this.skipValidation(t2);
          const n2 = e2.describe || e2.description || e2.desc;
          this.describe(t2, n2), e2.hidden && this.hide(t2), e2.requiresArg && this.requiresArg(t2);
        }
        return this;
      }
      options(t2, e2) {
        return this.option(t2, e2);
      }
      parse(t2, e2, s2) {
        h("[string|array] [function|boolean|object] [function]", [t2, e2, s2], arguments.length), this[Ot](), t2 === void 0 && (t2 = v(this, at, "f")), typeof e2 == "object" && (O(this, nt, e2, "f"), e2 = s2), typeof e2 == "function" && (O(this, it, e2, "f"), e2 = false), e2 || O(this, at, t2, "f"), v(this, it, "f") && O(this, G, false, "f");
        const i2 = this[Gt](t2, !!e2), n2 = this.parsed;
        return v(this, U, "f").setParsed(this.parsed), f(i2) ? i2.then((t3) => (v(this, it, "f") && v(this, it, "f").call(this, v(this, V, "f"), t3, v(this, Q, "f")), t3)).catch((t3) => {
          throw v(this, it, "f") && v(this, it, "f")(t3, this.parsed.argv, v(this, Q, "f")), t3;
        }).finally(() => {
          this[It](), this.parsed = n2;
        }) : (v(this, it, "f") && v(this, it, "f").call(this, v(this, V, "f"), i2, v(this, Q, "f")), this[It](), this.parsed = n2, i2);
      }
      parseAsync(t2, e2, s2) {
        const i2 = this.parse(t2, e2, s2);
        return f(i2) ? i2 : Promise.resolve(i2);
      }
      parseSync(t2, s2, i2) {
        const n2 = this.parse(t2, s2, i2);
        if (f(n2))
          throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
        return n2;
      }
      parserConfiguration(t2) {
        return h("<object>", [t2], arguments.length), O(this, st, t2, "f"), this;
      }
      pkgConf(t2, e2) {
        h("<string> [string]", [t2, e2], arguments.length);
        let s2 = null;
        const i2 = this[kt](e2 || v(this, q, "f"));
        return i2[t2] && typeof i2[t2] == "object" && (s2 = n(i2[t2], e2 || v(this, q, "f"), this[Ct]()["deep-merge-config"] || false, v(this, lt, "f")), v(this, tt, "f").configObjects = (v(this, tt, "f").configObjects || []).concat(s2)), this;
      }
      positional(t2, e2) {
        h("<string> <object>", [t2, e2], arguments.length);
        const s2 = ["default", "defaultDescription", "implies", "normalize", "choices", "conflicts", "coerce", "type", "describe", "desc", "description", "alias"];
        e2 = g(e2, (t3, e3) => !(t3 === "type" && !["string", "number", "boolean"].includes(e3)) && s2.includes(t3));
        const i2 = v(this, W, "f").fullCommands[v(this, W, "f").fullCommands.length - 1], n2 = i2 ? v(this, z, "f").cmdToParseOptions(i2) : { array: [], alias: {}, default: {}, demand: {} };
        return p(n2).forEach((s3) => {
          const i3 = n2[s3];
          Array.isArray(i3) ? i3.indexOf(t2) !== -1 && (e2[s3] = true) : i3[t2] && !(s3 in e2) && (e2[s3] = i3[t2]);
        }), this.group(t2, v(this, ut, "f").getPositionalGroupName()), this.option(t2, e2);
      }
      recommendCommands(t2 = true) {
        return h("[boolean]", [t2], arguments.length), O(this, ht, t2, "f"), this;
      }
      required(t2, e2, s2) {
        return this.demand(t2, e2, s2);
      }
      require(t2, e2, s2) {
        return this.demand(t2, e2, s2);
      }
      requiresArg(t2) {
        return h("<array|string|object> [number]", [t2], arguments.length), typeof t2 == "string" && v(this, tt, "f").narg[t2] || this[xt](this.requiresArg.bind(this), "narg", t2, NaN), this;
      }
      showCompletionScript(t2, e2) {
        return h("[string] [string]", [t2, e2], arguments.length), t2 = t2 || this.$0, v(this, X, "f").log(v(this, U, "f").generateCompletionScript(t2, e2 || v(this, F, "f") || "completion")), this;
      }
      showHelp(t2) {
        if (h("[string|function]", [t2], arguments.length), O(this, J, true, "f"), !v(this, ut, "f").hasCachedHelpMessage()) {
          if (!this.parsed) {
            const e3 = this[Gt](v(this, at, "f"), void 0, void 0, 0, true);
            if (f(e3))
              return e3.then(() => {
                v(this, ut, "f").showHelp(t2);
              }), this;
          }
          const e2 = v(this, z, "f").runDefaultBuilderOn(this);
          if (f(e2))
            return e2.then(() => {
              v(this, ut, "f").showHelp(t2);
            }), this;
        }
        return v(this, ut, "f").showHelp(t2), this;
      }
      scriptName(t2) {
        return this.customScriptName = true, this.$0 = t2, this;
      }
      showHelpOnFail(t2, e2) {
        return h("[boolean|string] [string]", [t2, e2], arguments.length), v(this, ut, "f").showHelpOnFail(t2, e2), this;
      }
      showVersion(t2) {
        return h("[string|function]", [t2], arguments.length), v(this, ut, "f").showVersion(t2), this;
      }
      skipValidation(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("skipValidation", t2), this;
      }
      strict(t2) {
        return h("[boolean]", [t2], arguments.length), O(this, ct, t2 !== false, "f"), this;
      }
      strictCommands(t2) {
        return h("[boolean]", [t2], arguments.length), O(this, ft, t2 !== false, "f"), this;
      }
      strictOptions(t2) {
        return h("[boolean]", [t2], arguments.length), O(this, dt, t2 !== false, "f"), this;
      }
      string(t2) {
        return h("<array|string>", [t2], arguments.length), this[Et]("string", t2), this[Yt](t2), this;
      }
      terminalWidth() {
        return h([], 0), v(this, lt, "f").process.stdColumns;
      }
      updateLocale(t2) {
        return this.updateStrings(t2);
      }
      updateStrings(t2) {
        return h("<object>", [t2], arguments.length), O(this, T, false, "f"), v(this, lt, "f").y18n.updateLocale(t2), this;
      }
      usage(t2, s2, i2, n2) {
        if (h("<string|null|undefined> [string|boolean] [function|object] [function]", [t2, s2, i2, n2], arguments.length), s2 !== void 0) {
          if (d(t2, null, v(this, lt, "f")), (t2 || "").match(/^\$0( |$)/))
            return this.command(t2, s2, i2, n2);
          throw new e(".usage() description must start with $0 if being used as alias for .command()");
        }
        return v(this, ut, "f").usage(t2), this;
      }
      version(t2, e2, s2) {
        const i2 = "version";
        if (h("[boolean|string] [string] [string]", [t2, e2, s2], arguments.length), v(this, pt, "f") && (this[bt](v(this, pt, "f")), v(this, ut, "f").version(void 0), O(this, pt, null, "f")), arguments.length === 0)
          s2 = this[_t](), t2 = i2;
        else if (arguments.length === 1) {
          if (t2 === false)
            return this;
          s2 = t2, t2 = i2;
        } else
          arguments.length === 2 && (s2 = e2, e2 = void 0);
        return O(this, pt, typeof t2 == "string" ? t2 : i2, "f"), e2 = e2 || v(this, ut, "f").deferY18nLookup("Show version number"), v(this, ut, "f").version(s2 || void 0), this.boolean(v(this, pt, "f")), this.describe(v(this, pt, "f"), e2), this;
      }
      wrap(t2) {
        return h("<number|null|undefined>", [t2], arguments.length), v(this, ut, "f").wrap(t2), this;
      }
      [(z = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), Z = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), tt = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), ht = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), ft = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), mt)](t2) {
        if (!t2._ || !t2["--"])
          return t2;
        t2._.push.apply(t2._, t2["--"]);
        try {
          delete t2["--"];
        } catch (t3) {
        }
        return t2;
      }
      [yt]() {
        return { log: (...t2) => {
          this[Lt]() || console.log(...t2), O(this, J, true, "f"), v(this, Q, "f").length && O(this, Q, v(this, Q, "f") + "\n", "f"), O(this, Q, v(this, Q, "f") + t2.join(" "), "f");
        }, error: (...t2) => {
          this[Lt]() || console.error(...t2), O(this, J, true, "f"), v(this, Q, "f").length && O(this, Q, v(this, Q, "f") + "\n", "f"), O(this, Q, v(this, Q, "f") + t2.join(" "), "f");
        } };
      }
      [bt](t2) {
        p(v(this, tt, "f")).forEach((e2) => {
          if (e2 === "configObjects")
            return;
          const s2 = v(this, tt, "f")[e2];
          Array.isArray(s2) ? s2.includes(t2) && s2.splice(s2.indexOf(t2), 1) : typeof s2 == "object" && delete s2[t2];
        }), delete v(this, ut, "f").getDescriptions()[t2];
      }
      [vt](t2, e2, s2) {
        v(this, R, "f")[s2] || (v(this, lt, "f").process.emitWarning(t2, e2), v(this, R, "f")[s2] = true);
      }
      [Ot]() {
        v(this, K, "f").push({ options: v(this, tt, "f"), configObjects: v(this, tt, "f").configObjects.slice(0), exitProcess: v(this, G, "f"), groups: v(this, Y, "f"), strict: v(this, ct, "f"), strictCommands: v(this, ft, "f"), strictOptions: v(this, dt, "f"), completionCommand: v(this, F, "f"), output: v(this, Q, "f"), exitError: v(this, V, "f"), hasOutput: v(this, J, "f"), parsed: this.parsed, parseFn: v(this, it, "f"), parseContext: v(this, nt, "f") }), v(this, ut, "f").freeze(), v(this, gt, "f").freeze(), v(this, z, "f").freeze(), v(this, B, "f").freeze();
      }
      [wt]() {
        let t2, e2 = "";
        return t2 = /\b(node|iojs|electron)(\.exe)?$/.test(v(this, lt, "f").process.argv()[0]) ? v(this, lt, "f").process.argv().slice(1, 2) : v(this, lt, "f").process.argv().slice(0, 1), e2 = t2.map((t3) => {
          const e3 = this[Tt](v(this, q, "f"), t3);
          return t3.match(/^(\/|([a-zA-Z]:)?\\)/) && e3.length < t3.length ? e3 : t3;
        }).join(" ").trim(), v(this, lt, "f").getEnv("_") && v(this, lt, "f").getProcessArgvBin() === v(this, lt, "f").getEnv("_") && (e2 = v(this, lt, "f").getEnv("_").replace(`${v(this, lt, "f").path.dirname(v(this, lt, "f").process.execPath())}/`, "")), e2;
      }
      [Ct]() {
        return v(this, st, "f");
      }
      [jt]() {
        if (!v(this, T, "f"))
          return;
        const t2 = v(this, lt, "f").getEnv("LC_ALL") || v(this, lt, "f").getEnv("LC_MESSAGES") || v(this, lt, "f").getEnv("LANG") || v(this, lt, "f").getEnv("LANGUAGE") || "en_US";
        this.locale(t2.replace(/[.:].*/, ""));
      }
      [_t]() {
        return this[kt]().version || "unknown";
      }
      [Mt](t2) {
        const e2 = t2["--"] ? t2["--"] : t2._;
        for (let t3, s2 = 0; (t3 = e2[s2]) !== void 0; s2++)
          v(this, lt, "f").Parser.looksLikeNumber(t3) && Number.isSafeInteger(Math.floor(parseFloat(`${t3}`))) && (e2[s2] = Number(t3));
        return t2;
      }
      [kt](t2) {
        const e2 = t2 || "*";
        if (v(this, rt, "f")[e2])
          return v(this, rt, "f")[e2];
        let s2 = {};
        try {
          let e3 = t2 || v(this, lt, "f").mainFilename;
          !t2 && v(this, lt, "f").path.extname(e3) && (e3 = v(this, lt, "f").path.dirname(e3));
          const i2 = v(this, lt, "f").findUp(e3, (t3, e4) => e4.includes("package.json") ? "package.json" : void 0);
          d(i2, void 0, v(this, lt, "f")), s2 = JSON.parse(v(this, lt, "f").readFileSync(i2, "utf8"));
        } catch (t3) {
        }
        return v(this, rt, "f")[e2] = s2 || {}, v(this, rt, "f")[e2];
      }
      [Et](t2, e2) {
        (e2 = [].concat(e2)).forEach((e3) => {
          e3 = this[Pt](e3), v(this, tt, "f")[t2].push(e3);
        });
      }
      [xt](t2, e2, s2, i2) {
        this[St](t2, e2, s2, i2, (t3, e3, s3) => {
          v(this, tt, "f")[t3][e3] = s3;
        });
      }
      [At](t2, e2, s2, i2) {
        this[St](t2, e2, s2, i2, (t3, e3, s3) => {
          v(this, tt, "f")[t3][e3] = (v(this, tt, "f")[t3][e3] || []).concat(s3);
        });
      }
      [St](t2, e2, s2, i2, n2) {
        if (Array.isArray(s2))
          s2.forEach((e3) => {
            t2(e3, i2);
          });
        else if (((t3) => typeof t3 == "object")(s2))
          for (const e3 of p(s2))
            t2(e3, s2[e3]);
        else
          n2(e2, this[Pt](s2), i2);
      }
      [Pt](t2) {
        return t2 === "__proto__" ? "___proto___" : t2;
      }
      [$t](t2, e2) {
        return this[xt](this[$t].bind(this), "key", t2, e2), this;
      }
      [It]() {
        var t2, e2, s2, i2, n2, r2, o2, a2, h2, l2, c2, f2;
        const u2 = v(this, K, "f").pop();
        let p2;
        d(u2, void 0, v(this, lt, "f")), t2 = this, e2 = this, s2 = this, i2 = this, n2 = this, r2 = this, o2 = this, a2 = this, h2 = this, l2 = this, c2 = this, f2 = this, { options: { set value(e3) {
          O(t2, tt, e3, "f");
        } }.value, configObjects: p2, exitProcess: { set value(t3) {
          O(e2, G, t3, "f");
        } }.value, groups: { set value(t3) {
          O(s2, Y, t3, "f");
        } }.value, output: { set value(t3) {
          O(i2, Q, t3, "f");
        } }.value, exitError: { set value(t3) {
          O(n2, V, t3, "f");
        } }.value, hasOutput: { set value(t3) {
          O(r2, J, t3, "f");
        } }.value, parsed: this.parsed, strict: { set value(t3) {
          O(o2, ct, t3, "f");
        } }.value, strictCommands: { set value(t3) {
          O(a2, ft, t3, "f");
        } }.value, strictOptions: { set value(t3) {
          O(h2, dt, t3, "f");
        } }.value, completionCommand: { set value(t3) {
          O(l2, F, t3, "f");
        } }.value, parseFn: { set value(t3) {
          O(c2, it, t3, "f");
        } }.value, parseContext: { set value(t3) {
          O(f2, nt, t3, "f");
        } }.value } = u2, v(this, tt, "f").configObjects = p2, v(this, ut, "f").unfreeze(), v(this, gt, "f").unfreeze(), v(this, z, "f").unfreeze(), v(this, B, "f").unfreeze();
      }
      [Dt](t2, e2) {
        return j(e2, (e3) => (t2(e3), e3));
      }
      getInternalMethods() {
        return { getCommandInstance: this[Nt].bind(this), getContext: this[Ht].bind(this), getHasOutput: this[zt].bind(this), getLoggerInstance: this[qt].bind(this), getParseContext: this[Wt].bind(this), getParserConfiguration: this[Ct].bind(this), getUsageInstance: this[Ut].bind(this), getValidationInstance: this[Ft].bind(this), hasParseCallback: this[Lt].bind(this), postProcess: this[Vt].bind(this), reset: this[Rt].bind(this), runValidation: this[Kt].bind(this), runYargsParserAndExecuteCommands: this[Gt].bind(this), setHasOutput: this[Bt].bind(this) };
      }
      [Nt]() {
        return v(this, z, "f");
      }
      [Ht]() {
        return v(this, W, "f");
      }
      [zt]() {
        return v(this, J, "f");
      }
      [qt]() {
        return v(this, X, "f");
      }
      [Wt]() {
        return v(this, nt, "f") || {};
      }
      [Ut]() {
        return v(this, ut, "f");
      }
      [Ft]() {
        return v(this, gt, "f");
      }
      [Lt]() {
        return !!v(this, it, "f");
      }
      [Vt](t2, e2, s2, i2) {
        if (s2)
          return t2;
        if (f(t2))
          return t2;
        e2 || (t2 = this[mt](t2));
        return (this[Ct]()["parse-positional-numbers"] || this[Ct]()["parse-positional-numbers"] === void 0) && (t2 = this[Mt](t2)), i2 && (t2 = C(t2, this, v(this, B, "f").getMiddleware(), false)), t2;
      }
      [Rt](t2 = {}) {
        O(this, tt, v(this, tt, "f") || {}, "f");
        const e2 = {};
        e2.local = v(this, tt, "f").local || [], e2.configObjects = v(this, tt, "f").configObjects || [];
        const s2 = {};
        e2.local.forEach((e3) => {
          s2[e3] = true, (t2[e3] || []).forEach((t3) => {
            s2[t3] = true;
          });
        }), Object.assign(v(this, ot, "f"), Object.keys(v(this, Y, "f")).reduce((t3, e3) => {
          const i2 = v(this, Y, "f")[e3].filter((t4) => !(t4 in s2));
          return i2.length > 0 && (t3[e3] = i2), t3;
        }, {})), O(this, Y, {}, "f");
        return ["array", "boolean", "string", "skipValidation", "count", "normalize", "number", "hiddenOptions"].forEach((t3) => {
          e2[t3] = (v(this, tt, "f")[t3] || []).filter((t4) => !s2[t4]);
        }), ["narg", "key", "alias", "default", "defaultDescription", "config", "choices", "demandedOptions", "demandedCommands", "deprecatedOptions"].forEach((t3) => {
          e2[t3] = g(v(this, tt, "f")[t3], (t4) => !s2[t4]);
        }), e2.envPrefix = v(this, tt, "f").envPrefix, O(this, tt, e2, "f"), O(this, ut, v(this, ut, "f") ? v(this, ut, "f").reset(s2) : S(this, v(this, lt, "f")), "f"), O(this, gt, v(this, gt, "f") ? v(this, gt, "f").reset(s2) : function(t3, e3, s3) {
          const i2 = s3.y18n.__, n2 = s3.y18n.__n, r2 = { nonOptionCount: function(s4) {
            const i3 = t3.getDemandedCommands(), r3 = s4._.length + (s4["--"] ? s4["--"].length : 0) - t3.getInternalMethods().getContext().commands.length;
            i3._ && (r3 < i3._.min || r3 > i3._.max) && (r3 < i3._.min ? i3._.minMsg !== void 0 ? e3.fail(i3._.minMsg ? i3._.minMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.min.toString()) : null) : e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", r3, r3.toString(), i3._.min.toString())) : r3 > i3._.max && (i3._.maxMsg !== void 0 ? e3.fail(i3._.maxMsg ? i3._.maxMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.max.toString()) : null) : e3.fail(n2("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", r3, r3.toString(), i3._.max.toString()))));
          }, positionalCount: function(t4, s4) {
            s4 < t4 && e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", s4, s4 + "", t4 + ""));
          }, requiredArguments: function(t4, s4) {
            let i3 = null;
            for (const e4 of Object.keys(s4))
              Object.prototype.hasOwnProperty.call(t4, e4) && t4[e4] !== void 0 || (i3 = i3 || {}, i3[e4] = s4[e4]);
            if (i3) {
              const t5 = [];
              for (const e4 of Object.keys(i3)) {
                const s6 = i3[e4];
                s6 && t5.indexOf(s6) < 0 && t5.push(s6);
              }
              const s5 = t5.length ? `
${t5.join("\n")}` : "";
              e3.fail(n2("Missing required argument: %s", "Missing required arguments: %s", Object.keys(i3).length, Object.keys(i3).join(", ") + s5));
            }
          }, unknownArguments: function(s4, i3, o3, a3, h2 = true) {
            var l3;
            const c3 = t3.getInternalMethods().getCommandInstance().getCommands(), f2 = [], d2 = t3.getInternalMethods().getContext();
            if (Object.keys(s4).forEach((e4) => {
              H.includes(e4) || Object.prototype.hasOwnProperty.call(o3, e4) || Object.prototype.hasOwnProperty.call(t3.getInternalMethods().getParseContext(), e4) || r2.isValidAndSomeAliasIsNotNew(e4, i3) || f2.push(e4);
            }), h2 && (d2.commands.length > 0 || c3.length > 0 || a3) && s4._.slice(d2.commands.length).forEach((t4) => {
              c3.includes("" + t4) || f2.push("" + t4);
            }), h2) {
              const e4 = ((l3 = t3.getDemandedCommands()._) === null || l3 === void 0 ? void 0 : l3.max) || 0, i4 = d2.commands.length + e4;
              i4 < s4._.length && s4._.slice(i4).forEach((t4) => {
                t4 = String(t4), d2.commands.includes(t4) || f2.includes(t4) || f2.push(t4);
              });
            }
            f2.length && e3.fail(n2("Unknown argument: %s", "Unknown arguments: %s", f2.length, f2.join(", ")));
          }, unknownCommands: function(s4) {
            const i3 = t3.getInternalMethods().getCommandInstance().getCommands(), r3 = [], o3 = t3.getInternalMethods().getContext();
            return (o3.commands.length > 0 || i3.length > 0) && s4._.slice(o3.commands.length).forEach((t4) => {
              i3.includes("" + t4) || r3.push("" + t4);
            }), r3.length > 0 && (e3.fail(n2("Unknown command: %s", "Unknown commands: %s", r3.length, r3.join(", "))), true);
          }, isValidAndSomeAliasIsNotNew: function(e4, s4) {
            if (!Object.prototype.hasOwnProperty.call(s4, e4))
              return false;
            const i3 = t3.parsed.newAliases;
            return [e4, ...s4[e4]].some((t4) => !Object.prototype.hasOwnProperty.call(i3, t4) || !i3[e4]);
          }, limitedChoices: function(s4) {
            const n3 = t3.getOptions(), r3 = {};
            if (!Object.keys(n3.choices).length)
              return;
            Object.keys(s4).forEach((t4) => {
              H.indexOf(t4) === -1 && Object.prototype.hasOwnProperty.call(n3.choices, t4) && [].concat(s4[t4]).forEach((e4) => {
                n3.choices[t4].indexOf(e4) === -1 && e4 !== void 0 && (r3[t4] = (r3[t4] || []).concat(e4));
              });
            });
            const o3 = Object.keys(r3);
            if (!o3.length)
              return;
            let a3 = i2("Invalid values:");
            o3.forEach((t4) => {
              a3 += `
  ${i2("Argument: %s, Given: %s, Choices: %s", t4, e3.stringifiedValues(r3[t4]), e3.stringifiedValues(n3.choices[t4]))}`;
            }), e3.fail(a3);
          } };
          let o2 = {};
          function a2(t4, e4) {
            const s4 = Number(e4);
            return typeof (e4 = isNaN(s4) ? e4 : s4) == "number" ? e4 = t4._.length >= e4 : e4.match(/^--no-.+/) ? (e4 = e4.match(/^--no-(.+)/)[1], e4 = !Object.prototype.hasOwnProperty.call(t4, e4)) : e4 = Object.prototype.hasOwnProperty.call(t4, e4), e4;
          }
          r2.implies = function(e4, i3) {
            h("<string|object> [array|number|string]", [e4, i3], arguments.length), typeof e4 == "object" ? Object.keys(e4).forEach((t4) => {
              r2.implies(t4, e4[t4]);
            }) : (t3.global(e4), o2[e4] || (o2[e4] = []), Array.isArray(i3) ? i3.forEach((t4) => r2.implies(e4, t4)) : (d(i3, void 0, s3), o2[e4].push(i3)));
          }, r2.getImplied = function() {
            return o2;
          }, r2.implications = function(t4) {
            const s4 = [];
            if (Object.keys(o2).forEach((e4) => {
              const i3 = e4;
              (o2[e4] || []).forEach((e5) => {
                let n3 = i3;
                const r3 = e5;
                n3 = a2(t4, n3), e5 = a2(t4, e5), n3 && !e5 && s4.push(` ${i3} -> ${r3}`);
              });
            }), s4.length) {
              let t5 = `${i2("Implications failed:")}
`;
              s4.forEach((e4) => {
                t5 += e4;
              }), e3.fail(t5);
            }
          };
          let l2 = {};
          r2.conflicts = function(e4, s4) {
            h("<string|object> [array|string]", [e4, s4], arguments.length), typeof e4 == "object" ? Object.keys(e4).forEach((t4) => {
              r2.conflicts(t4, e4[t4]);
            }) : (t3.global(e4), l2[e4] || (l2[e4] = []), Array.isArray(s4) ? s4.forEach((t4) => r2.conflicts(e4, t4)) : l2[e4].push(s4));
          }, r2.getConflicting = () => l2, r2.conflicting = function(n3) {
            Object.keys(n3).forEach((t4) => {
              l2[t4] && l2[t4].forEach((s4) => {
                s4 && n3[t4] !== void 0 && n3[s4] !== void 0 && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, s4));
              });
            }), t3.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l2).forEach((t4) => {
              l2[t4].forEach((r3) => {
                r3 && n3[s3.Parser.camelCase(t4)] !== void 0 && n3[s3.Parser.camelCase(r3)] !== void 0 && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, r3));
              });
            });
          }, r2.recommendCommands = function(t4, s4) {
            s4 = s4.sort((t5, e4) => e4.length - t5.length);
            let n3 = null, r3 = 1 / 0;
            for (let e4, i3 = 0; (e4 = s4[i3]) !== void 0; i3++) {
              const s5 = N(t4, e4);
              s5 <= 3 && s5 < r3 && (r3 = s5, n3 = e4);
            }
            n3 && e3.fail(i2("Did you mean %s?", n3));
          }, r2.reset = function(t4) {
            return o2 = g(o2, (e4) => !t4[e4]), l2 = g(l2, (e4) => !t4[e4]), r2;
          };
          const c2 = [];
          return r2.freeze = function() {
            c2.push({ implied: o2, conflicting: l2 });
          }, r2.unfreeze = function() {
            const t4 = c2.pop();
            d(t4, void 0, s3), { implied: o2, conflicting: l2 } = t4;
          }, r2;
        }(this, v(this, ut, "f"), v(this, lt, "f")), "f"), O(this, z, v(this, z, "f") ? v(this, z, "f").reset() : function(t3, e3, s3, i2) {
          return new M(t3, e3, s3, i2);
        }(v(this, ut, "f"), v(this, gt, "f"), v(this, B, "f"), v(this, lt, "f")), "f"), v(this, U, "f") || O(this, U, function(t3, e3, s3, i2) {
          return new D(t3, e3, s3, i2);
        }(this, v(this, ut, "f"), v(this, z, "f"), v(this, lt, "f")), "f"), v(this, B, "f").reset(), O(this, F, null, "f"), O(this, Q, "", "f"), O(this, V, null, "f"), O(this, J, false, "f"), this.parsed = false, this;
      }
      [Tt](t2, e2) {
        return v(this, lt, "f").path.relative(t2, e2);
      }
      [Gt](t2, s2, i2, n2 = 0, r2 = false) {
        let o2 = !!i2 || r2;
        t2 = t2 || v(this, at, "f"), v(this, tt, "f").__ = v(this, lt, "f").y18n.__, v(this, tt, "f").configuration = this[Ct]();
        const a2 = !!v(this, tt, "f").configuration["populate--"], h2 = Object.assign({}, v(this, tt, "f").configuration, { "populate--": true }), l2 = v(this, lt, "f").Parser.detailed(t2, Object.assign({}, v(this, tt, "f"), { configuration: { "parse-positional-numbers": false, ...h2 } })), c2 = Object.assign(l2.argv, v(this, nt, "f"));
        let d2;
        const u2 = l2.aliases;
        let p2 = false, g2 = false;
        Object.keys(c2).forEach((t3) => {
          t3 === v(this, Z, "f") && c2[t3] ? p2 = true : t3 === v(this, pt, "f") && c2[t3] && (g2 = true);
        }), c2.$0 = this.$0, this.parsed = l2, n2 === 0 && v(this, ut, "f").clearCachedHelpMessage();
        try {
          if (this[jt](), s2)
            return this[Vt](c2, a2, !!i2, false);
          if (v(this, Z, "f")) {
            [v(this, Z, "f")].concat(u2[v(this, Z, "f")] || []).filter((t3) => t3.length > 1).includes("" + c2._[c2._.length - 1]) && (c2._.pop(), p2 = true);
          }
          const h3 = v(this, z, "f").getCommands(), m2 = v(this, U, "f").completionKey in c2, y2 = p2 || m2 || r2;
          if (c2._.length) {
            if (h3.length) {
              let t3;
              for (let e2, s3 = n2 || 0; c2._[s3] !== void 0; s3++) {
                if (e2 = String(c2._[s3]), h3.includes(e2) && e2 !== v(this, F, "f")) {
                  const t4 = v(this, z, "f").runCommand(e2, this, l2, s3 + 1, r2, p2 || g2 || r2);
                  return this[Vt](t4, a2, !!i2, false);
                }
                if (!t3 && e2 !== v(this, F, "f")) {
                  t3 = e2;
                  break;
                }
              }
              !v(this, z, "f").hasDefaultCommand() && v(this, ht, "f") && t3 && !y2 && v(this, gt, "f").recommendCommands(t3, h3);
            }
            v(this, F, "f") && c2._.includes(v(this, F, "f")) && !m2 && (v(this, G, "f") && x(true), this.showCompletionScript(), this.exit(0));
          }
          if (v(this, z, "f").hasDefaultCommand() && !y2) {
            const t3 = v(this, z, "f").runCommand(null, this, l2, 0, r2, p2 || g2 || r2);
            return this[Vt](t3, a2, !!i2, false);
          }
          if (m2) {
            v(this, G, "f") && x(true);
            const s3 = (t2 = [].concat(t2)).slice(t2.indexOf(`--${v(this, U, "f").completionKey}`) + 1);
            return v(this, U, "f").getCompletion(s3, (t3, s4) => {
              if (t3)
                throw new e(t3.message);
              (s4 || []).forEach((t4) => {
                v(this, X, "f").log(t4);
              }), this.exit(0);
            }), this[Vt](c2, !a2, !!i2, false);
          }
          if (v(this, J, "f") || (p2 ? (v(this, G, "f") && x(true), o2 = true, this.showHelp("log"), this.exit(0)) : g2 && (v(this, G, "f") && x(true), o2 = true, v(this, ut, "f").showVersion("log"), this.exit(0))), !o2 && v(this, tt, "f").skipValidation.length > 0 && (o2 = Object.keys(c2).some((t3) => v(this, tt, "f").skipValidation.indexOf(t3) >= 0 && c2[t3] === true)), !o2) {
            if (l2.error)
              throw new e(l2.error.message);
            if (!m2) {
              const t3 = this[Kt](u2, {}, l2.error);
              i2 || (d2 = C(c2, this, v(this, B, "f").getMiddleware(), true)), d2 = this[Dt](t3, d2 != null ? d2 : c2), f(d2) && !i2 && (d2 = d2.then(() => C(c2, this, v(this, B, "f").getMiddleware(), false)));
            }
          }
        } catch (t3) {
          if (!(t3 instanceof e))
            throw t3;
          v(this, ut, "f").fail(t3.message, t3);
        }
        return this[Vt](d2 != null ? d2 : c2, a2, !!i2, true);
      }
      [Kt](t2, s2, i2, n2) {
        const r2 = { ...this.getDemandedOptions() };
        return (o2) => {
          if (i2)
            throw new e(i2.message);
          v(this, gt, "f").nonOptionCount(o2), v(this, gt, "f").requiredArguments(o2, r2);
          let a2 = false;
          v(this, ft, "f") && (a2 = v(this, gt, "f").unknownCommands(o2)), v(this, ct, "f") && !a2 ? v(this, gt, "f").unknownArguments(o2, t2, s2, !!n2) : v(this, dt, "f") && v(this, gt, "f").unknownArguments(o2, t2, {}, false, false), v(this, gt, "f").limitedChoices(o2), v(this, gt, "f").implications(o2), v(this, gt, "f").conflicting(o2);
        };
      }
      [Bt]() {
        O(this, J, true, "f");
      }
      [Yt](t2) {
        if (typeof t2 == "string")
          v(this, tt, "f").key[t2] = true;
        else
          for (const e2 of t2)
            v(this, tt, "f").key[e2] = true;
      }
    };
    var Zt;
    var Xt;
    var { readFileSync: Qt } = require("fs");
    var { inspect: te } = require("util");
    var { resolve: ee } = require("path");
    var se = require_build();
    var ie = require_build2();
    var ne;
    var re = { assert: { notStrictEqual: t.notStrictEqual, strictEqual: t.strictEqual }, cliui: require_build3(), findUp: require_sync(), getEnv: (t2) => process.env[t2], getCallerFile: require_get_caller_file(), getProcessArgvBin: y, inspect: te, mainFilename: (Xt = (Zt = require === null || require === void 0 ? void 0 : require.main) === null || Zt === void 0 ? void 0 : Zt.filename) !== null && Xt !== void 0 ? Xt : process.cwd(), Parser: ie, path: require("path"), process: { argv: () => process.argv, cwd: process.cwd, emitWarning: (t2, e2) => process.emitWarning(t2, e2), execPath: () => process.execPath, exit: (t2) => {
      process.exit(t2);
    }, nextTick: process.nextTick, stdColumns: process.stdout.columns !== void 0 ? process.stdout.columns : null }, readFileSync: Qt, require, requireDirectory: require_require_directory(), stringWidth: require_string_width(), y18n: se({ directory: ee(__dirname, "../locales"), updateFiles: false }) };
    var oe = ((ne = process === null || process === void 0 ? void 0 : process.env) === null || ne === void 0 ? void 0 : ne.YARGS_MIN_NODE_VERSION) ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    if (process && process.version) {
      if (Number(process.version.match(/v([^.]+)/)[1]) < oe)
        throw Error(`yargs supports a minimum Node.js version of ${oe}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
    }
    var ae = require_build2();
    var he;
    var le = { applyExtends: n, cjsPlatformShim: re, Yargs: (he = re, (t2 = [], e2 = he.process.cwd(), s2) => {
      const i2 = new Jt(t2, e2, s2, he);
      return Object.defineProperty(i2, "argv", { get: () => i2.parse(), enumerable: true }), i2.help(), i2.version(), i2;
    }), argsert: h, isPromise: f, objFilter: g, parseCommand: o, Parser: ae, processArgv: b, YError: e };
    module2.exports = le;
  }
});

// server/node_modules/yargs/index.cjs
var require_yargs = __commonJS({
  "server/node_modules/yargs/index.cjs"(exports, module2) {
    "use strict";
    var { Yargs, processArgv } = require_build4();
    Argv(processArgv.hideBin(process.argv));
    module2.exports = Argv;
    function Argv(processArgs, cwd) {
      const argv2 = Yargs(processArgs, cwd, require);
      singletonify(argv2);
      return argv2;
    }
    function defineGetter(obj, key, getter) {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: true,
        get: getter
      });
    }
    function lookupGetter(obj, key) {
      const desc = Object.getOwnPropertyDescriptor(obj, key);
      if (typeof desc !== "undefined") {
        return desc.get;
      }
    }
    function singletonify(inst) {
      [
        ...Object.keys(inst),
        ...Object.getOwnPropertyNames(inst.constructor.prototype)
      ].forEach((key) => {
        if (key === "argv") {
          defineGetter(Argv, key, lookupGetter(inst, key));
        } else if (typeof inst[key] === "function") {
          Argv[key] = inst[key].bind(inst);
        } else {
          defineGetter(Argv, "$0", () => inst.$0);
          defineGetter(Argv, "parsed", () => inst.parsed);
        }
      });
    }
  }
});

// server/src/formatting/cli/index.ts
var fs = __toESM(require("fs"));

// server/src/projects/projectManager.ts
var ProjectManager = class {
  constructor() {
    this.currentStructure = null;
    this.isReloading = false;
    this.isDirtyState = false;
  }
  setActiveProject(project) {
    this.currentStructure = project;
  }
  getStructure() {
    return this.currentStructure;
  }
  hasStructure() {
    return this.currentStructure != null;
  }
  setDirtyState(isDirty) {
    this.isDirtyState = isDirty;
  }
  reloadDetails() {
    if (this.isReloading) {
      return;
    }
    if (this.isDirtyState == false) {
      return;
    }
    if (this.currentStructure != null) {
      this.isReloading = true;
      this.currentStructure = this.currentStructure.reloadDetails();
      this.isReloading = false;
    }
  }
};
ProjectManager.instance = null;
if (typeof ProjectManager.instance == "undefined" || ProjectManager.instance == null) {
  ProjectManager.instance = new ProjectManager();
}
var projectManager_default = ProjectManager;

// server/src/idehelper/documentDetailsManager.ts
var DocumentDetailsManager = class {
  static registerDetails(documentUri, details) {
    this.documentDetails.set(documentUri, details);
  }
  static hasDetails(documentUri) {
    return this.documentDetails.has(documentUri);
  }
};
DocumentDetailsManager.documentDetails = /* @__PURE__ */ new Map();

// server/src/idehelper/parser.ts
var EmptyEnvironmentHelper = {
  documentDescription: "",
  documentName: "",
  collectionInjections: [],
  blueprints: [],
  variableHelper: null,
  injectsParameters: [],
  varReferenceNames: /* @__PURE__ */ new Map()
};
var DocumentName = "@name";
var DocumentDescription = "@description";
var DocDescriptionShort = "@desc";
var EntryPrefix = "@entry";
var CollectionPrefix = "@collection";
var BlueprintPrefix = "@blueprint";
var VariablePrefix = "@var";
var SetPrefix = "@set";
var ParamPrefix = "@param";
var RequiredParamPrefix = "@param*";
var ParamFromViewDataDirective = "@front";
function parseIdeHelper(documentUri, symbol) {
  if (symbol == null || symbol.isComment == false) {
    return EmptyEnvironmentHelper;
  }
  const commentLines = symbol.content.replace(/(\r\n|\n|\r)/gm, "\n").split("\n").map((r) => r.trim()), injectsParameters = [], varReferenceNames = /* @__PURE__ */ new Map();
  let documentName = "", documentDescription = "", collectionNames = [], blueprintNames = [], varReference = "", variableHelper = null, isParsingDescription = false;
  for (let i = 0; i < commentLines.length; i++) {
    const thisLine = commentLines[i];
    if (thisLine.startsWith(EntryPrefix)) {
      collectionNames = collectionNames.concat(thisLine.slice(EntryPrefix.length).split(",").map((f) => f.trim()));
      isParsingDescription = false;
    } else if (thisLine.startsWith(CollectionPrefix)) {
      collectionNames = collectionNames.concat(thisLine.slice(CollectionPrefix.length).split(",").map((f) => f.trim()));
      isParsingDescription = false;
    } else if (thisLine.startsWith(BlueprintPrefix)) {
      blueprintNames = blueprintNames.concat(thisLine.slice(BlueprintPrefix.length).split(",").map((f) => f.trim()));
      isParsingDescription = false;
    } else if (thisLine.startsWith(DocumentName)) {
      documentName = thisLine.slice(DocumentName.length).trim();
      isParsingDescription = false;
    } else if (thisLine.startsWith(DocumentDescription)) {
      documentDescription = thisLine.slice(DocumentDescription.length).trim();
      isParsingDescription = true;
    } else if (thisLine.startsWith(DocDescriptionShort)) {
      documentDescription = thisLine.slice(DocDescriptionShort.length).trim();
      isParsingDescription = true;
    } else if (thisLine.startsWith(VariablePrefix)) {
      varReference = thisLine.slice(VariablePrefix.length).trim();
      isParsingDescription = false;
    } else if (thisLine.startsWith(SetPrefix)) {
      varReference = "@page " + thisLine.slice(SetPrefix.length).trim();
      isParsingDescription = false;
    } else if (thisLine.startsWith(ParamPrefix)) {
      let sliceLen = ParamPrefix.length, paramRequired = false;
      if (thisLine.startsWith(RequiredParamPrefix)) {
        sliceLen = RequiredParamPrefix.length;
        paramRequired = true;
      }
      const directiveDetails = thisLine.slice(sliceLen).trim();
      const directiveParts = directiveDetails.split(" ");
      if (directiveParts.length > 0) {
        if (directiveParts[0] == ParamFromViewDataDirective && directiveParts.length >= 4) {
          directiveParts.shift();
          const varName = directiveParts.shift(), paramName = directiveParts.shift(), paramDesc = directiveParts.join(" ");
          injectsParameters.push({
            acceptsVariableInterpolation: true,
            aliases: [],
            allowsVariableReference: true,
            description: paramDesc,
            expectsTypes: ["*"],
            isDynamic: true,
            isRequired: paramRequired,
            name: paramName
          });
          varReferenceNames.set(paramName, varName);
        }
      }
    } else {
      if (isParsingDescription) {
        documentDescription += "\n" + thisLine.trim();
      }
    }
  }
  if (varReference.length > 0) {
    const varNameParts = varReference.split(" ");
    if (varNameParts.length == 2) {
      const varName = varNameParts[0], fieldPath = varNameParts[1];
      if (fieldPath.includes(".")) {
        const refParts = fieldPath.split(".");
        if (refParts.length == 2) {
          const collectionName = refParts[0], fieldHandle = refParts[1];
          variableHelper = {
            variableName: varName,
            collectionName,
            fieldHandle,
            setHandle: ""
          };
        } else if (refParts.length == 3) {
          const collectionName = refParts[0], fieldHandle = refParts[1], setHandle = refParts[2];
          variableHelper = {
            variableName: varName,
            collectionName,
            fieldHandle,
            setHandle
          };
        }
      } else {
        variableHelper = {
          variableName: varName,
          setHandle: "",
          collectionName: "",
          fieldHandle: fieldPath
        };
      }
    }
  }
  if (projectManager_default.instance != null && projectManager_default.instance.hasStructure()) {
    const projectView = projectManager_default.instance.getStructure().findView(documentUri);
    if (projectView != null) {
      projectView.injectsParameters = injectsParameters;
      projectView.varReferenceNames = varReferenceNames;
    }
  }
  const ideHelper = {
    documentName,
    documentDescription,
    collectionInjections: collectionNames,
    blueprints: blueprintNames,
    variableHelper,
    injectsParameters,
    varReferenceNames
  };
  if (symbol.startPosition != null) {
    if (symbol.startPosition.line == 0 || symbol.index == 1) {
      DocumentDetailsManager.registerDetails(documentUri, ideHelper);
    }
  }
  return ideHelper;
}

// server/src/projects/blueprints/blueprintTypes.ts
var stringTypes = [
  "markdown",
  "text",
  "textarea",
  "slug",
  "button_group",
  "code",
  "color",
  "date",
  "form",
  "link",
  "structures",
  "select",
  "taxonomies",
  "terms",
  "template",
  "time",
  "video",
  "users",
  "user_groups",
  "user_roles"
];
var arrayTypes = [
  "array",
  "assets",
  "bard",
  "blueprints",
  "collections",
  "entries",
  "list",
  "grid",
  "replicator",
  "structures_multiple",
  "sites",
  "select_multiple",
  "form_multiple",
  "table",
  "tags",
  "terms_multiple",
  "taxonomies_multiple",
  "users_multiple",
  "checkboxes",
  "select_multiple",
  "yaml",
  "user_groups_multiple",
  "user_roles_multiple"
];
var numberTypes = ["integer", "range"];
var booleanTypes = ["toggle"];
function getFieldRuntimeType(fieldType) {
  if (stringTypes.includes(fieldType)) {
    return "string";
  }
  if (arrayTypes.includes(fieldType)) {
    return "array";
  }
  if (numberTypes.includes(fieldType)) {
    return "number";
  }
  if (booleanTypes.includes(fieldType)) {
    return "boolean";
  }
  return fieldType;
}

// server/src/references/referenceManager.ts
var ReferenceManager = class {
  constructor() {
    this.partialReferences = /* @__PURE__ */ new Map();
    this.cacheReferences = /* @__PURE__ */ new Map();
    this.removesPageScope = /* @__PURE__ */ new Map();
  }
  clearAllReferences(documentUri) {
    this.clearPartialReferences(documentUri);
    this.clearCacheReferences(documentUri);
  }
  registerPartialReferences(documentUri, nodes) {
    if (this.partialReferences.has(documentUri) == false) {
      this.partialReferences.set(documentUri, []);
    }
    this.partialReferences.set(documentUri, nodes);
  }
  registerCacheReferences(documentUri, nodes) {
    if (this.cacheReferences.has(documentUri) == false) {
      this.cacheReferences.set(documentUri, []);
    }
    this.cacheReferences.set(documentUri, nodes);
  }
  clearPartialReferences(documentUri) {
    if (this.partialReferences.has(documentUri)) {
      this.partialReferences.set(documentUri, []);
    }
  }
  clearRemovesPageScope(documentUri) {
    if (this.removesPageScope.has(documentUri)) {
      this.removesPageScope.delete(documentUri);
    }
  }
  pageScopeDisabled(documentUri) {
    return this.removesPageScope.has(documentUri);
  }
  clearCacheReferences(documentUri) {
    if (this.cacheReferences.has(documentUri)) {
      this.cacheReferences.set(documentUri, []);
    }
  }
  setRemovesPageScope(documentUri, node) {
    this.removesPageScope.set(documentUri, node);
  }
  getPartialReferences(documentUri) {
    if (this.partialReferences.has(documentUri) == false) {
      return [];
    }
    return this.partialReferences.get(documentUri);
  }
  getCacheReferencnes(documentUri) {
    if (this.cacheReferences.has(documentUri) == false) {
      return [];
    }
    return this.cacheReferences.get(documentUri);
  }
  hasPartialReferences(documentPath) {
    return this.partialReferences.has(documentPath);
  }
  hasCacheReferences(documentPath) {
    return this.cacheReferences.has(documentPath);
  }
};
ReferenceManager.instance = null;
if (typeof ReferenceManager.instance == "undefined" || ReferenceManager.instance == null) {
  ReferenceManager.instance = new ReferenceManager();
}
var referenceManager_default = ReferenceManager;

// server/src/runtime/nodes/position.ts
var Position = class {
  constructor() {
    this.index = -1;
    this.offset = 0;
    this.line = 0;
    this.char = 0;
  }
  shiftRight(shiftOffset) {
    const position = new Position();
    position.offset = this.offset + shiftOffset;
    position.index = this.index + shiftOffset;
    position.line = this.line;
    position.char = this.char + shiftOffset;
    return position;
  }
  isBefore(position) {
    if (position == null) {
      return false;
    }
    if (position.line > this.line) {
      return true;
    }
    if (position.line == this.line && this.offset < position.offset) {
      return true;
    }
    return false;
  }
  isWithin(start, end, shiftEnd = 0) {
    if (start == null || end == null) {
      return false;
    }
    if (this.index >= start.index && this.index <= end.index + shiftEnd) {
      return true;
    }
    return false;
  }
  isWithinRange(range) {
    if (range == null) {
      return false;
    }
    if (range.start != null && range.end != null) {
      return this.isWithin(range.start, range.end);
    }
    return false;
  }
};

// node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist(), 1);
var v1 = import_dist.default.v1;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var NIL = import_dist.default.NIL;
var version = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse = import_dist.default.parse;

// server/src/runtime/document/documentRange.ts
var _DocumentRange = class {
  constructor() {
    this.start = null;
    this.end = null;
  }
};
var DocumentRange = _DocumentRange;
DocumentRange.Empty = new _DocumentRange();

// server/src/antlers/modifiers/scopeAugmentation/augmentGroupByScope.ts
function augmentGroupByScope(node, scope) {
  const iterableItems = scope.copy(), groupScope = scope.copy();
  groupScope.addVariable({ sourceName: "*internal.group_by", sourceField: null, dataType: "string", name: "group", introducedBy: node });
  groupScope.addVariable({ sourceName: "*internal.group_by", sourceField: null, dataType: "string", name: "key", introducedBy: node });
  groupScope.addScopeList("items", iterableItems);
  scope.addScopeList("groups", groupScope);
  return scope;
}

// server/src/antlers/modifiers/scopeAugmentation/augmentSplitScope.ts
function augmentSplitScope(node, scope) {
  const itemsScope = scope.copy();
  scope.addScopeList("items", itemsScope);
  return scope;
}

// server/src/antlers/modifiers/arrayModifiers.ts
var arrayModifiers = [
  {
    name: "as",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Alias the array variable with a key.",
    docLink: "https://statamic.dev/modifiers/as",
    parameters: [
      {
        name: "alias",
        description: "The alias name."
      }
    ],
    canBeParameter: true
  },
  {
    name: "ampersand_list",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Converts the array into a comma delimited string, with an ampersand before the last item.",
    docLink: "https://statamic.dev/modifiers/ampersand_list",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "collapse",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Collapses an array of arrays into a single, flat, array.",
    docLink: "https://statamic.dev/modifiers/collapse",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "contains",
    acceptsType: ["array", "string"],
    returnsType: ["boolean"],
    description: "Tests if the value contains another value.",
    docLink: "https://statamic.dev/modifiers/contains",
    parameters: [
      {
        name: "needle",
        description: "The value to check for."
      }
    ],
    canBeParameter: false
  },
  {
    name: "count",
    acceptsType: ["array"],
    returnsType: ["number"],
    description: "Returns the number of items in the array.",
    docLink: "https://statamic.dev/modifiers/count",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "dl",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turns an associative array into an HTML definition list.",
    docLink: "https://statamic.dev/modifiers/dl",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "explode",
    acceptsType: ["string"],
    returnsType: ["array"],
    description: "Breaks a string into an array on a given delimiter.",
    docLink: "https://statamic.dev/modifiers/explode",
    parameters: [
      {
        name: "delimiter",
        description: "The delimiter to break the string apart on."
      }
    ],
    canBeParameter: true
  },
  {
    name: "flatten",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Flattens a multi-dimensional array.",
    docLink: "https://statamic.dev/modifiers/flatten",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "flip",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Swaps the array keys with their values.",
    docLink: "https://statamic.dev/modifiers/flip",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "group_by",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Groups the array items by the given key.",
    docLink: "https://statamic.dev/modifiers/group_by",
    parameters: [
      {
        name: "key",
        description: "The key to group by."
      }
    ],
    canBeParameter: true,
    augmentScope: augmentGroupByScope
  },
  {
    name: "in_array",
    acceptsType: ["array"],
    returnsType: ["boolean"],
    description: "Tests if an array contains a specific value.",
    docLink: "https://statamic.dev/modifiers/in_array",
    parameters: [
      {
        name: "needle",
        description: "The value to check for."
      }
    ],
    canBeParameter: false
  },
  {
    name: "is_empty",
    acceptsType: ["array"],
    returnsType: ["boolean"],
    description: "Tests if the array is empty.",
    docLink: "https://statamic.dev/modifiers/is_empty",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "join",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turn an array into a string by gluing together all the data.",
    docLink: "https://statamic.dev/modifiers/join",
    parameters: [
      {
        name: "glue",
        description: "The string to combine the parts by."
      }
    ],
    canBeParameter: true
  },
  {
    name: "joinplode",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turn an array into a string by gluing together all the data.",
    docLink: null,
    parameters: [
      {
        name: "glue",
        description: "The string to combine the parts by."
      }
    ],
    canBeParameter: true
  },
  {
    name: "limit",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Limits the number of items returned in the array",
    docLink: "https://statamic.dev/modifiers/limit",
    parameters: [
      {
        name: "count",
        description: "The maximum number of items to return."
      }
    ],
    canBeParameter: true
  },
  {
    name: "list",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Converts the array into a comma-separated string.",
    docLink: "https://statamic.dev/modifiers/list",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "offset",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Offsets the items returned in the array.",
    docLink: "https://statamic.dev/modifiers/offset",
    parameters: [
      {
        name: "offset",
        description: "The one-based index to start retrieving items."
      }
    ],
    canBeParameter: true
  },
  {
    name: "ol",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turns the array into an HTML ordered list.",
    docLink: "https://statamic.dev/modifiers/ol",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "option_list",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turns an array into a pipe-delimited string.",
    docLink: "https://statamic.dev/modifiers/option_list",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "pluck",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Plucks a value from a collection of items.",
    parameters: [
      {
        name: "value",
        description: "The value to pluck from the array or collection."
      }
    ],
    canBeParameter: true,
    docLink: null
  },
  {
    name: "pad",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Pads the array to a specified length with the given value.",
    docLink: "https://statamic.dev/modifiers/pad",
    parameters: [
      {
        name: "length",
        description: "The desired length of the array."
      },
      {
        name: "value",
        description: "The value to pad the array with."
      }
    ],
    canBeParameter: true
  },
  {
    name: "piped",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turns an array into a pipe-delimited string.",
    docLink: "https://statamic.dev/modifiers/piped",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "sentence_list",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: 'Turns the array into a comma-delimited list, with the word "and" before the last item.',
    docLink: "https://statamic.dev/modifiers/sentence_list",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "shuffle",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Randomizes the order of array elements.",
    docLink: "https://statamic.dev/modifiers/shuffle",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "sort",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Sorts the array by a key in ascending or descending order.",
    docLink: "https://statamic.dev/modifiers/sort",
    parameters: [
      {
        name: "key",
        description: "The key to sort by."
      },
      {
        name: "order",
        description: "The sort direction. `asc` or `desc`."
      }
    ],
    canBeParameter: true
  },
  {
    name: "sum",
    acceptsType: ["array"],
    returnsType: ["number"],
    description: "Returns the sum of all items in the array.",
    docLink: "https://statamic.dev/modifiers/sum",
    parameters: [
      {
        name: "key",
        description: "The value to sum."
      }
    ],
    canBeParameter: false
  },
  {
    name: "ul",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turns the array into an HTML unordered list.",
    docLink: "https://statamic.dev/modifiers/ul",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "unique",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Returns all unique items in the array.",
    docLink: "https://statamic.dev/modifiers/unique",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "where",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Filters the array by a given key and value.",
    docLink: "https://statamic.dev/modifiers/where",
    parameters: [
      {
        name: "key",
        description: "The property to filter by."
      },
      {
        name: "value",
        description: "The value to compare to."
      }
    ],
    canBeParameter: true
  },
  {
    name: "split",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Splits an array into smaller arrays with the provided size.",
    canBeParameter: true,
    docLink: "",
    parameters: [
      {
        name: "size",
        description: "The size of each new array"
      }
    ],
    augmentScope: augmentSplitScope
  },
  {
    name: "compact",
    acceptsType: ["string"],
    returnsType: ["array"],
    description: "Accepts a comma-delimited list of variable names and return an array with their values.",
    canBeParameter: true,
    docLink: "",
    parameters: [
      {
        name: "variables",
        description: "A comma-delimited list of variable names."
      }
    ]
  }
];

// server/src/antlers/modifiers/assetModifiers.ts
var assetModifiers = [
  {
    name: "background_position",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts an asset focal point into a background-position CSS property.",
    docLink: "https://statamic.dev/modifiers/background_position",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "image",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Generates an HTML image element with the variable's value as the src.",
    docLink: "https://statamic.dev/modifiers/image",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "output",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns the string output of an Asset file's contents.",
    docLink: "https://statamic.dev/modifiers/output",
    parameters: [],
    canBeParameter: false
  }
];

// server/src/antlers/modifiers/conditionalModifiers.ts
var conditionalModifiers = [
  {
    name: "contains_all",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if a string contains all of the provided needles.",
    docLink: "https://statamic.dev/modifiers/contains_all",
    parameters: [
      {
        name: "needle",
        description: "The string(s) to search for."
      }
    ],
    canBeParameter: false
  },
  {
    name: "contains_any",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if a string contains all of the provided needles.",
    docLink: "https://statamic.dev/modifiers/contains_any",
    parameters: [
      {
        name: "needle",
        description: "The string(s) to search for."
      }
    ],
    canBeParameter: false
  },
  {
    name: "ends_with",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if a string ends with another string.",
    docLink: "https://statamic.dev/modifiers/ends_with",
    parameters: [
      {
        name: "value",
        description: "The value to check against."
      }
    ],
    canBeParameter: false
  },
  {
    name: "has_lower_case",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string contains any lowercase characters.",
    docLink: "https://statamic.dev/modifiers/has_lower_case",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "has_upper_case",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string contains any uppercase characters.",
    docLink: "https://statamic.dev/modifiers/has_upper_case",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "in_array",
    acceptsType: ["array"],
    returnsType: ["boolean"],
    description: "Tests if an array contains a specific value.",
    docLink: "https://statamic.dev/modifiers/in_array",
    parameters: [
      {
        name: "needle",
        description: "The value(s) to search for."
      }
    ],
    canBeParameter: false
  },
  {
    name: "is_after",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the string contains only alphanumeric characters.",
    docLink: "https://statamic.dev/modifiers/is_after",
    parameters: [
      {
        name: "date",
        description: "The date to compare to."
      }
    ],
    canBeParameter: false
  },
  {
    name: "is_alphanumeric",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string contains only alphanumeric characters.",
    docLink: "https://statamic.dev/modifiers/is_alphanumeric",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_before",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if a date is before another date.",
    docLink: "https://statamic.dev/modifiers/is_before",
    parameters: [
      {
        name: "date",
        description: "The date to compare to."
      }
    ],
    canBeParameter: false
  },
  {
    name: "is_between",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if a date is between two other dates.",
    docLink: "https://statamic.dev/modifiers/is_between",
    parameters: [
      {
        name: "start_date",
        description: "The start date to compare."
      },
      {
        name: "end_date",
        description: "The end date to compare."
      }
    ],
    canBeParameter: false
  },
  {
    name: "is_blank",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string contains only whitespace characters.",
    docLink: "https://statamic.dev/modifiers/is_blank",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_email",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string is a valid email address.",
    docLink: "https://statamic.dev/modifiers/is_email",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_future",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is in the future.",
    docLink: "https://statamic.dev/modifiers/is_future",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_json",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string is valid JSON.",
    docLink: "https://statamic.dev/modifiers/is_json",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_leap_year",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is a leap year.",
    docLink: "https://statamic.dev/modifiers/is_leap_year",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_numeric",
    acceptsType: ["string", "number"],
    returnsType: ["boolean"],
    description: "Tests if the value is a number or numeric string.",
    docLink: "https://statamic.dev/modifiers/is_numeric",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_past",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is in the past.",
    docLink: "https://statamic.dev/modifiers/is_past",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_today",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is today.",
    docLink: "https://statamic.dev/modifiers/is_today",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_uppercase",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string contains only uppercase characters.",
    docLink: "https://statamic.dev/modifiers/is_uppercase",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_url",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if the string is a valid URL.",
    docLink: "https://statamic.dev/modifiers/is_url",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_weekday",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is a week day.",
    docLink: "https://statamic.dev/modifiers/is_weekday",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_weekend",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is a weekend day.",
    docLink: "https://statamic.dev/modifiers/is_weekend",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_yesterday",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is yesterday.",
    docLink: "https://statamic.dev/modifiers/is_yesterday",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_tomorrow",
    acceptsType: ["string", "date"],
    returnsType: ["boolean"],
    description: "Tests if the date is tomorrow.",
    docLink: null,
    parameters: [],
    canBeParameter: false
  },
  {
    name: "starts_with",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Tests if a value starts with the provided value.",
    docLink: "https://statamic.dev/modifiers/starts_with",
    parameters: [
      {
        name: "value",
        description: "The value to test for."
      }
    ],
    canBeParameter: false
  }
];

// server/src/antlers/modifiers/dateModifiers.ts
var dateModifiers = [
  {
    name: "days_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of days since a given date.",
    docLink: "https://statamic.dev/modifiers/days_ago",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "format_translated",
    acceptsType: ["string", "date"],
    returnsType: ["string", "date"],
    description: "Returns a formatted Carbon datetime/string.",
    docLink: "https://statamic.dev/modifiers/format",
    parameters: [
      {
        name: "format",
        description: "The format to use."
      }
    ],
    canBeParameter: true
  },
  {
    name: "format",
    acceptsType: ["string", "date"],
    returnsType: ["string", "date"],
    description: "Formats the date using the provided format using PHP's [date variables](https://www.php.net/date).",
    docLink: "https://statamic.dev/modifiers/format",
    parameters: [
      {
        name: "format",
        description: "The format to use."
      }
    ],
    canBeParameter: true
  },
  {
    name: "format_localized",
    acceptsType: ["string", "date"],
    returnsType: ["string", "date"],
    description: "Forms the date using server's locale, using PHP's [strftime format variables](https://www.php.net/strftime).",
    docLink: "https://statamic.dev/modifiers/format_localized",
    parameters: [
      {
        name: "format",
        description: "The format to use."
      }
    ],
    canBeParameter: true
  },
  {
    name: "hours_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of hours since the date.",
    docLink: "https://statamic.dev/modifiers/hours_ago",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "iso_format",
    acceptsType: ["string", "date"],
    returnsType: ["string", "date"],
    description: "Formats the date using an ISO format.",
    docLink: "https://statamic.dev/modifiers/iso_format",
    parameters: [
      {
        name: "format",
        description: "The format to use."
      }
    ],
    canBeParameter: false
  },
  {
    name: "minutes_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of minutes since the date.",
    docLink: "https://statamic.dev/modifiers/minutes_ago",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "modify_date",
    acceptsType: ["string", "date"],
    returnsType: ["string", "date"],
    description: "Alters the date by incrementing or decrementing it in a format accepted by PHP's [strtotime](https://www.php.net/strtotime) function.",
    docLink: "https://statamic.dev/modifiers/modify_date",
    parameters: [],
    canBeParameter: true
  },
  {
    name: "months_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of months since the date.",
    docLink: "https://statamic.dev/modifiers/months_ago",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "relative",
    acceptsType: ["string", "date"],
    returnsType: ["string"],
    description: "Returns a human readable date difference.",
    docLink: "https://statamic.dev/modifiers/relative",
    parameters: [
      {
        name: "add_ago",
        description: "Whether to add the relative suffix words at the end of the string."
      }
    ],
    canBeParameter: false
  },
  {
    name: "seconds_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of seconds since the date.",
    docLink: "https://statamic.dev/modifiers/seconds_ago",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "timezone",
    acceptsType: ["string", "date"],
    returnsType: ["string", "date"],
    description: "Applies a timezone to the date.",
    docLink: "https://statamic.dev/modifiers/timezone",
    parameters: [
      {
        name: "timezone",
        description: "The timezone to apply."
      }
    ],
    canBeParameter: false
  },
  {
    name: "weeks_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of weeks since the date.",
    docLink: "https://statamic.dev/modifiers/weeks_ago",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "years_ago",
    acceptsType: ["string", "date"],
    returnsType: ["number"],
    description: "Returns the number of years since the date.",
    docLink: "https://statamic.dev/modifiers/years_ago",
    parameters: [],
    canBeParameter: false
  }
];

// server/src/antlers/modifiers/markupModifiers.ts
var markupModifiers = [
  {
    name: "chunk",
    acceptsType: ["array"],
    returnsType: ["array"],
    description: "Breaks the array or collection into smaller arrays of a given size.",
    docLink: "https://statamic.dev/modifiers/chunk",
    parameters: [
      {
        name: "chunk_size",
        description: "The maximum length of each new chunk."
      }
    ],
    canBeParameter: true
  },
  {
    name: "favicon",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Generates a favicon HTML meta tag for the given value.",
    docLink: "https://statamic.dev/modifiers/favicon",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "first",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns the specified number of characters from the beginning of the string.",
    docLink: "https://statamic.dev/modifiers/first",
    parameters: [
      {
        name: "count",
        description: "The number of characters to return."
      }
    ],
    canBeParameter: true
  },
  {
    name: "last",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns the specified number of characters from the end of the string.",
    docLink: "https://statamic.dev/modifiers/last",
    parameters: [
      {
        name: "count",
        description: "The number of characters to return."
      }
    ],
    canBeParameter: true
  },
  {
    name: "link",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Generates an HTML link for the provided value.",
    docLink: "https://statamic.dev/modifiers/link",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "mailto",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Generates a mailto HTML link for the provided value.",
    docLink: "https://statamic.dev/modifiers/mailto",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "markdown",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Parses the value as Markdown and returns the HTML.",
    docLink: "https://statamic.dev/modifiers/markdown",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "nl2br",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Replaces line breaks with HTML `<br>` tags.",
    docLink: "https://statamic.dev/modifiers/nl2br",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "obfuscate",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Modifies the input string by replacing it with special characters, making it harder for bots but remains readable to site visitors.",
    docLink: "https://statamic.dev/modifiers/obfuscate",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "obfuscate_email",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Obfuscates an email address with special HTML characters.",
    docLink: "https://statamic.dev/modifiers/obfuscate_email",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "strip_tags",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Removes HTML tags from the string.",
    docLink: "https://statamic.dev/modifiers/strip_tags",
    parameters: [
      {
        name: "tags",
        description: "The HTML tag(s) to remove from the string."
      }
    ],
    canBeParameter: false
  },
  {
    name: "table",
    acceptsType: ["array"],
    returnsType: ["string"],
    description: "Turns a [Table FieldType](https://statamic.dev/fieldtypes/table) array into an HTML table.",
    docLink: "https://statamic.dev/modifiers/table",
    parameters: [
      {
        name: "content_markdown",
        description: "Whether to parse cell contents as Markdown."
      }
    ],
    canBeParameter: false
  },
  {
    name: "textile",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Parses a string with [Textile](http://demo.textilewiki.com/theme-default/) and returns the HTML.",
    docLink: "https://statamic.dev/modifiers/textile",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "wrap",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Wraps a string with a given HTML tag.",
    docLink: "https://statamic.dev/modifiers/wrap",
    parameters: [
      {
        name: "expression",
        description: "The HTML tag or Emmet-style expression to wrap the value in."
      }
    ],
    canBeParameter: false
  }
];

// server/src/antlers/modifiers/mathModifiers.ts
var mathModifiers = [
  {
    name: "add",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Adds two values together.",
    docLink: "https://statamic.dev/modifiers/add",
    parameters: [
      {
        name: "value",
        description: "The value to add."
      }
    ],
    canBeParameter: true
  },
  {
    name: "+",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Adds two values together.",
    docLink: "https://statamic.dev/modifiers/add",
    parameters: [
      {
        name: "value",
        description: "The value to add."
      }
    ],
    canBeParameter: false
  },
  {
    name: "ceil",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Rounds the value to the next whole number.",
    docLink: "https://statamic.dev/modifiers/ceil",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "divide",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Divides two values.",
    docLink: "https://statamic.dev/modifiers/divide",
    parameters: [
      {
        name: "value",
        description: "The value to divide."
      }
    ],
    canBeParameter: true
  },
  {
    name: "floor",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Rounds a number down to the next whole number.",
    docLink: "https://statamic.dev/modifiers/floor",
    parameters: [],
    canBeParameter: true
  },
  {
    name: "format_number",
    acceptsType: ["number"],
    returnsType: ["string"],
    description: "Formats a number.",
    docLink: "https://statamic.dev/modifiers/format_number",
    parameters: [
      {
        name: "precision",
        description: "Number of decimal places before rounding."
      },
      {
        name: "decimal_separator",
        description: "The decimal separator (defaults to `.`)."
      },
      {
        name: "thousands_separator",
        description: "The thousands separator (default `,`)."
      }
    ],
    canBeParameter: true
  },
  {
    name: "mode",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "",
    docLink: "",
    parameters: [],
    canBeParameter: true
  },
  {
    name: "multiply",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Multiplies two values.",
    docLink: "https://statamic.dev/modifiers/multiply",
    parameters: [
      {
        name: "value",
        description: "The value to multiply."
      }
    ],
    canBeParameter: true
  },
  {
    name: "*",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Multiplies two values.",
    docLink: "https://statamic.dev/modifiers/multiply",
    parameters: [
      {
        name: "value",
        description: "The value to multiply."
      }
    ],
    canBeParameter: false
  },
  {
    name: "round",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Rounds a number to a specified precision.",
    docLink: "https://statamic.dev/modifiers/round",
    parameters: [
      {
        name: "precision",
        description: "The number of digits after the decimal point."
      }
    ],
    canBeParameter: true
  },
  {
    name: "subtract",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Subtracts two values.",
    docLink: "https://statamic.dev/modifiers/subtract",
    parameters: [
      {
        name: "value",
        description: "The value to subtract."
      }
    ],
    canBeParameter: true
  },
  {
    name: "-",
    acceptsType: ["number"],
    returnsType: ["number"],
    description: "Subtracts two values.",
    docLink: "https://statamic.dev/modifiers/subtract",
    parameters: [
      {
        name: "value",
        description: "The value to subtract."
      }
    ],
    canBeParameter: false
  }
];

// server/src/antlers/modifiers/specialModifiers.ts
var specialModifiers = [
  {
    name: "partial",
    acceptsType: ["*"],
    returnsType: ["*view*"],
    description: "Injects data into a partial and renders it.",
    docLink: "https://statamic.dev/modifiers/partial",
    parameters: [
      {
        name: "partial",
        description: "The name of the partial."
      }
    ],
    canBeParameter: false
  },
  {
    name: "macro",
    acceptsType: ["*"],
    returnsType: ["*"],
    description: "Runs a pre-configured macro on the data.",
    docLink: "https://statamic.dev/modifiers/macro",
    parameters: [
      {
        name: "macro",
        description: "The macro name."
      }
    ],
    canBeParameter: false
  },
  {
    name: "url",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Locates the URL of an asset, page, entry, or taxonomy term based on the variable contents.",
    docLink: "https://statamic.dev/modifiers/url",
    parameters: [],
    canBeParameter: false
  }
];

// server/src/antlers/modifiers/stringModifiers.ts
var stringModifiers = [
  {
    name: "ascii",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Replaces all non-ASCII characters with their closest ASCII counterparts.",
    docLink: "https://statamic.dev/modifiers/ascii",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "at",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns the character at a given zero-based position.",
    docLink: "https://statamic.dev/modifiers/at",
    parameters: [
      {
        name: "position",
        description: "The zero-based position to retrieve a character from."
      }
    ],
    canBeParameter: true
  },
  {
    name: "backspace",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Removes a specified number of characters from the end of a string.",
    docLink: "https://statamic.dev/modifiers/backspace",
    parameters: [
      {
        name: "character_count",
        description: "The number of characters to remove from the end of the string."
      }
    ],
    canBeParameter: true
  },
  {
    name: "camelize",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts the string into camelCase.",
    docLink: "https://statamic.dev/modifiers/camelize",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "cdata",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Wraps the string in CDATA XML tags.",
    docLink: "https://statamic.dev/modifiers/cdata",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "collapse_whitespace",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Trims a string and replaces consecutive whitespace characters with a single space.",
    docLink: "https://statamic.dev/modifiers/collapse_whitespace",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "count_substring",
    acceptsType: ["string"],
    returnsType: ["number"],
    description: "Counts the number of occurrences of a term within the string.",
    docLink: "https://statamic.dev/modifiers/count_substring",
    parameters: [
      {
        name: "term",
        description: "The sub-string to search for"
      }
    ],
    canBeParameter: true
  },
  {
    name: "dashify",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a lower-cased and trimmed string, separated by dashes.",
    docLink: "https://statamic.dev/modifiers/dashify",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "deslugify",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Replaces all hyphens and underscores with spaces.",
    docLink: "https://statamic.dev/modifiers/deslugify",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "embed_url",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts a YouTube or Viemo link into their embed URLs.",
    docLink: "https://statamic.dev/modifiers/embed_url",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "trackable_embed_url",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Get the embed URL when given a youtube or vimeo link that's direct to the page.",
    docLink: null,
    parameters: [],
    canBeParameter: false
  },
  {
    name: "ensure_left",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Ensures that the string begins with the specified string.",
    docLink: "https://statamic.dev/modifiers/ensure_left",
    parameters: [
      {
        name: "start_string",
        description: "The value that should be at the start of the string."
      }
    ],
    canBeParameter: true
  },
  {
    name: "ensure_right",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Ensures that the string ends with the specified string.",
    docLink: "https://statamic.dev/modifiers/ensure_right",
    parameters: [
      {
        name: "end_string",
        description: "The value that should be at the end of the string."
      }
    ],
    canBeParameter: true
  },
  {
    name: "entities",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Encode a string with HTML entities.",
    docLink: "https://statamic.dev/modifiers/entities",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "excerpt",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Breaks a string at a given marker.",
    docLink: "https://statamic.dev/modifiers/excerpt",
    parameters: [
      {
        name: "marker",
        description: "The string to break by."
      }
    ],
    canBeParameter: false
  },
  {
    name: "explode",
    acceptsType: ["string"],
    returnsType: ["array"],
    description: "Breaks a string into an array of strings.",
    docLink: "https://statamic.dev/modifiers/explode",
    parameters: [
      {
        name: "delimiter",
        description: "The string to split the larger string by."
      }
    ],
    canBeParameter: true
  },
  {
    name: "gravatar",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts an email string to a Gravatar image URL.",
    docLink: "https://statamic.dev/modifiers/gravatar",
    parameters: [
      {
        name: "image size",
        description: "The desired image size."
      }
    ],
    canBeParameter: true
  },
  {
    name: "insert",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Inserts a string at the position provided.",
    docLink: "https://statamic.dev/modifiers/insert",
    parameters: [
      {
        name: "value",
        description: "The value to insert."
      },
      {
        name: "position",
        description: "The zero based position to insert the text at."
      }
    ],
    canBeParameter: true
  },
  {
    name: "is_email",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Returns true if the string is a valid email address.",
    docLink: "https://statamic.dev/modifiers/is_email",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_embeddable",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Checks to see if a video URL is embeddable.",
    docLink: "https://statamic.dev/modifiers/is_embeddable",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_lowercase",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Returns true if the string contains only lowercase characters.",
    docLink: "https://statamic.dev/modifiers/is_lowercase",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "is_url",
    acceptsType: ["string"],
    returnsType: ["boolean"],
    description: "Returns true if a string is a valid URL.",
    docLink: "https://statamic.dev/modifiers/is_url",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "lcfirst",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts the first character of the value to lower case.",
    docLink: "https://statamic.dev/modifiers/lcfirst",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "length",
    acceptsType: ["string"],
    returnsType: ["number"],
    description: "Returns the number of items in an array or number of characters in a string.",
    docLink: "https://statamic.dev/modifiers/length",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "lower",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts all characters to lowercase.",
    docLink: "https://statamic.dev/modifiers/lower",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "md5",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Creates an MD5 hash of the variable.",
    docLink: "https://statamic.dev/modifiers/md5",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "rawurlencode",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "URL-encode a variable according to RFC-3986.",
    docLink: "https://statamic.dev/modifiers/rawurlencode",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "read_time",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns an estimated read time, in minutes.",
    docLink: "https://statamic.dev/modifiers/read_time",
    parameters: [
      {
        name: "words per minute",
        description: "The words per minute to use as an estimate."
      }
    ],
    canBeParameter: true
  },
  {
    name: "regex_replace",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Replaces all regex matches with a string.",
    docLink: "https://statamic.dev/modifiers/regex_replace",
    parameters: [
      {
        name: "pattern",
        description: "The regex pattern."
      },
      {
        name: "replace",
        description: "The replacement value."
      }
    ],
    canBeParameter: true
  },
  {
    name: "remove_left",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Ensures that the string never begins with a specified string.",
    docLink: "https://statamic.dev/modifiers/remove_left/",
    parameters: [
      {
        name: "value",
        description: "The value to remove."
      }
    ],
    canBeParameter: true
  },
  {
    name: "remove_right",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Ensures that a string never ends with a specified string.",
    docLink: "https://statamic.dev/modifiers/remove_right",
    parameters: [
      {
        name: "value",
        description: "The value to remove."
      }
    ],
    canBeParameter: true
  },
  {
    name: "replace",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Replaces all occurrences of a string with a different value.",
    docLink: "https://statamic.dev/modifiers/replace",
    parameters: [
      {
        name: "needle",
        description: "The string to search for."
      },
      {
        name: "value",
        description: "The value to replace all occurrences with."
      }
    ],
    canBeParameter: true
  },
  {
    name: "reverse",
    acceptsType: ["string", "array"],
    returnsType: ["string", "array"],
    description: "Reverses all characters in a string, or all items in an array.",
    docLink: "https://statamic.dev/modifiers/reverse",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "safe_truncate",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Truncates a string to a given length.",
    docLink: "https://statamic.dev/modifiers/safe_truncate",
    parameters: [
      {
        name: "length",
        description: "The desired string length."
      },
      {
        name: "suffix",
        description: "An optional suffix to append to the string if truncation occurs."
      }
    ],
    canBeParameter: false
  },
  {
    name: "sanitize",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts special characters to HTML entities.",
    docLink: "https://statamic.dev/modifiers/sanitize",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "segment",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a segment by number from any valid URL or URI.",
    docLink: "https://statamic.dev/modifiers/segment",
    parameters: [
      {
        name: "segment",
        description: "The one-based segment to return."
      }
    ],
    canBeParameter: true
  },
  {
    name: "singular",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns the singular form of an English word.",
    docLink: "https://statamic.dev/modifiers/singular",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "slugify",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts the string into an URL slug.",
    docLink: "https://statamic.dev/modifiers/slugify",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "smartypants",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Translates plain ASCII punctuation characters into typographic punctuation HTML entities.",
    docLink: "https://statamic.dev/modifiers/smartypants",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "spaceless",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Removes excess whitespace and line breaks from a string.",
    docLink: "https://statamic.dev/modifiers/spaceless",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "substr",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a portion of a string based on provided a start index, and optional length.",
    docLink: "https://statamic.dev/modifiers/substr",
    parameters: [
      {
        name: "start",
        description: "The 0-based index to start searching."
      },
      {
        name: "length",
        description: "An optional length for the string to find."
      }
    ],
    canBeParameter: false
  },
  {
    name: "surround",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Surrounds a string with another string.",
    docLink: "https://statamic.dev/modifiers/surround",
    parameters: [
      {
        name: "value",
        description: "The value to surround the string with."
      }
    ],
    canBeParameter: false
  },
  {
    name: "swap_case",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a case swapped version of the string.",
    docLink: "https://statamic.dev/modifiers/swap_case",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "tidy",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a string with smart quotes, ellipsis characters, and dashes from Windows-1252 replaced by ASCII equivalents.",
    docLink: "https://statamic.dev/modifiers/tidy",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "title",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a Title Cased version of the string.",
    docLink: "https://statamic.dev/modifiers/title",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "trim",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Removes whitespace from the start and end of the string.",
    docLink: "https://statamic.dev/modifiers/trim",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "truncate",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Truncates a string to a given length.",
    docLink: "https://statamic.dev/modifiers/truncate",
    parameters: [
      {
        name: "length",
        description: "The maximum string length."
      },
      {
        name: "suffix",
        description: "An optional suffix to append to the string if truncation occurs."
      }
    ],
    canBeParameter: false
  },
  {
    name: "ucfirst",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Upper cases the first character in the string.",
    docLink: "https://statamic.dev/modifiers/ucfirst",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "underscored",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Returns a lower-cased and trimmed version of the string, separated by underscores.",
    docLink: "https://statamic.dev/modifiers/underscored",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "upper",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Transforms the string to uppercase.",
    docLink: "https://statamic.dev/modifiers/upper",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "urldecode",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "URL-decodes the string.",
    docLink: "https://statamic.dev/modifiers/urldecode",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "urlencode",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "URL-encodes the string.",
    docLink: "https://statamic.dev/modifiers/urlencode",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "widont",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Attempts to prevent lines with single words.",
    docLink: "https://statamic.dev/modifiers/widont",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "word_count",
    acceptsType: ["string"],
    returnsType: ["number"],
    description: "Returns the number of words in the string.",
    docLink: "https://statamic.dev/modifiers/word_count",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "add_slashes",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Adds slashes before characters that need to be escaped.",
    docLink: "https://statamic.dev/modifiers/add_slashes",
    canBeParameter: false,
    parameters: []
  }
];

// server/src/antlers/modifiers/utilityModifiers.ts
var utilityModifiers = [
  {
    name: "console_log",
    acceptsType: ["*"],
    returnsType: ["null"],
    description: "Displays variable data in the browser's JavaScript console.",
    docLink: "https://statamic.dev/modifiers/console_log",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "decode",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts all HTML entities to their applicable character codes.",
    docLink: "https://statamic.dev/modifiers/decode",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "dump",
    acceptsType: ["*"],
    returnsType: ["null"],
    description: "Displays variable data in the browser.",
    docLink: "https://statamic.dev/modifiers/dump",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "full_urls",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Replaces root-relative URLs with absolute URLs.",
    docLink: "https://statamic.dev/modifiers/full_urls",
    parameters: [],
    canBeParameter: false
  },
  {
    name: "repeat",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Repeats a value a given number of times.",
    docLink: "https://statamic.dev/modifiers/repeat",
    parameters: [{
      name: "repeat_count",
      description: "The number of times to repeat the value."
    }],
    canBeParameter: true
  },
  {
    name: "to_spaces",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts all tabs to spaces.",
    docLink: "https://statamic.dev/modifiers/to_spaces",
    parameters: [
      {
        name: "space_count",
        description: "The number of spaces to replace tabs with."
      }
    ],
    canBeParameter: false
  },
  {
    name: "to_tabs",
    acceptsType: ["string"],
    returnsType: ["string"],
    description: "Converts spaces to tabs.",
    docLink: "https://statamic.dev/modifiers/to_tabs",
    parameters: [
      {
        name: "space_count",
        description: "The number of spaces to convert to tabs."
      }
    ],
    canBeParameter: false
  },
  {
    name: "to_json",
    acceptsType: ["*"],
    returnsType: ["string"],
    description: "Converts the data to JSON.",
    docLink: "https://statamic.dev/modifiers/to_json",
    parameters: [],
    canBeParameter: false
  }
];

// server/src/antlers/modifierManager.ts
var ModifierManager = class {
  constructor() {
    this.registeredModifiers = /* @__PURE__ */ new Map();
    this.acceptTypedModifierReference = /* @__PURE__ */ new Map();
    this.returnTypeModifierReference = /* @__PURE__ */ new Map();
    this.macros = /* @__PURE__ */ new Map();
    this.modifierNameCache = [];
  }
  reset() {
    this.modifierNameCache = [];
    this.registeredModifiers.clear();
    this.acceptTypedModifierReference.clear();
    this.returnTypeModifierReference.clear();
  }
  getRegisteredModifiers() {
    return this.registeredModifiers;
  }
  resetMacros() {
    this.macros.clear();
  }
  loadCoreModifiers() {
    this.registerModifiers(arrayModifiers);
    this.registerModifiers(assetModifiers);
    this.registerModifiers(conditionalModifiers);
    this.registerModifiers(dateModifiers);
    this.registerModifiers(markupModifiers);
    this.registerModifiers(mathModifiers);
    this.registerModifiers(utilityModifiers);
    this.registerModifiers(stringModifiers);
    this.registerModifiers(specialModifiers);
  }
  getModifierNames() {
    return this.modifierNameCache;
  }
  registerMacro(macro) {
    this.macros.set(macro.name, macro);
  }
  registerMacros(macros) {
    for (let i = 0; i < macros.length; i++) {
      this.registerMacro(macros[i]);
    }
  }
  hasMacro(name) {
    if (this.macros.has(name)) {
      const macro = this.macros.get(name);
      if (typeof macro === "undefined" || macro === null) {
        return false;
      }
      return true;
    }
    return false;
  }
  getMacro(name) {
    if (this.macros.has(name)) {
      const macro = this.macros.get(name);
      if (typeof macro === "undefined" || macro === null) {
        return null;
      }
      return macro;
    }
    return null;
  }
  getMacroManifestingType(name) {
    const macro = this.getMacro(name);
    if (macro == null) {
      return "";
    }
    return macro.manifestsType;
  }
  getRegisteredModifier(name) {
    if (this.registeredModifiers.has(name)) {
      return this.registeredModifiers.get(name);
    }
    return null;
  }
  getModifiersForType(type2) {
    const lookupType = getFieldRuntimeType(type2);
    if (this.acceptTypedModifierReference.has(lookupType)) {
      return this.acceptTypedModifierReference.get(lookupType);
    }
    return [];
  }
  getProbableReturnType(modifier, isTagPair) {
    if (modifier == null) {
      return "";
    }
    if (modifier.returnsType.length == 0) {
      return "";
    }
    if (isTagPair && modifier.returnsType.includes("array")) {
      return "array";
    }
    return modifier.returnsType[0];
  }
  registerModifiers(modifiers) {
    var _a, _b;
    for (let i = 0; i < modifiers.length; i++) {
      const curModifier = modifiers[i];
      this.modifierNameCache.push(curModifier.name);
      for (let j = 0; j < curModifier.acceptsType.length; j++) {
        const curAcceptType = curModifier.acceptsType[j];
        if (this.acceptTypedModifierReference.has(curAcceptType) == false) {
          this.acceptTypedModifierReference.set(curAcceptType, []);
        }
        (_a = this.acceptTypedModifierReference.get(curAcceptType)) == null ? void 0 : _a.push(curModifier);
      }
      for (let j = 0; j < curModifier.returnsType.length; j++) {
        const curReturnType = curModifier.returnsType[j];
        if (this.returnTypeModifierReference.has(curReturnType) == false) {
          this.returnTypeModifierReference.set(curReturnType, []);
        }
        (_b = this.returnTypeModifierReference.get(curReturnType)) == null ? void 0 : _b.push(curModifier);
      }
      this.registeredModifiers.set(modifiers[i].name, modifiers[i]);
    }
  }
  registerModifier(modifier) {
    const modifiers = [];
    modifiers.push(modifier);
    this.registerModifiers(modifiers);
  }
  getModifier(name) {
    if (this.registeredModifiers.has(name) == false) {
      return null;
    }
    const modifier = this.registeredModifiers.get(name);
    if (typeof modifier == "undefined" || modifier == null) {
      return null;
    }
    return modifier;
  }
  hasModifier(name) {
    if (!this.registeredModifiers.has(name)) {
      return false;
    }
    const modifier = this.registeredModifiers.get(name);
    if (typeof modifier == "undefined" || modifier == null) {
      return false;
    }
    return true;
  }
};
ModifierManager.instance = null;
if (typeof ModifierManager.instance == "undefined" || ModifierManager.instance == null) {
  ModifierManager.instance = new ModifierManager();
  ModifierManager.instance.loadCoreModifiers();
}
var modifierManager_default = ModifierManager;

// server/src/runtime/nodes/antlersVirtualStructures/nodeVirtualModifiers.ts
var NodeVirtualModifiers = class {
  constructor(node) {
    this.parameterModifiers = [];
    this.hasMixedModifierStyles = false;
    this.modifierNames = [];
    this.node = node;
  }
  isPaired() {
    if (this.node instanceof AntlersNode) {
      return this.node.isPaired();
    }
    return false;
  }
  getModifierValue(modifierName) {
    var _a;
    if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0) {
      for (let i = 0; i < this.node.modifierChain.modifierChain.length; i++) {
        const thisModifier = this.node.modifierChain.modifierChain[i];
        if (((_a = thisModifier.nameNode) == null ? void 0 : _a.name) == modifierName) {
          if (thisModifier.valueNodes.length > 0) {
            return thisModifier.valueNodes[0].content;
          }
          return "";
        }
      }
    }
    if (this.hasParameterModifiers()) {
      for (let i = 0; i < this.parameterModifiers.length; i++) {
        const thisModifier = this.parameterModifiers[i];
        if (thisModifier.name == modifierName) {
          return thisModifier.value;
        }
      }
    }
    return null;
  }
  getModifierRange(modifierName) {
    var _a;
    if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0) {
      for (let i = 0; i < this.node.modifierChain.modifierChain.length; i++) {
        const thisModifier = this.node.modifierChain.modifierChain[i];
        if (((_a = thisModifier.nameNode) == null ? void 0 : _a.name) == modifierName) {
          if (thisModifier.valueNodes.length > 0) {
            return {
              start: thisModifier.startPosition,
              end: thisModifier.endPosition
            };
          }
          return null;
        }
      }
    }
    if (this.hasParameterModifiers()) {
      for (let i = 0; i < this.parameterModifiers.length; i++) {
        const thisModifier = this.parameterModifiers[i];
        if (thisModifier.name == modifierName) {
          if (thisModifier.namePosition != null && thisModifier.valuePosition != null) {
            return {
              start: thisModifier.namePosition.start,
              end: thisModifier.valuePosition.end
            };
          }
        }
      }
    }
    return null;
  }
  getLastManifestedModifierRuntimeType() {
    if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0 && this.node.modifierChain.lastManifestedModifier != null) {
      if (this.node.modifierChain.lastManifestedModifier.parameters.length > 0) {
        if (this.node.modifierChain.lastManifestedModifier.modifier != null && modifierManager_default.instance != null) {
          const tModifier = this.node.modifierChain.lastManifestedModifier.modifier;
          return modifierManager_default.instance.getProbableReturnType(tModifier, this.isPaired());
        }
      }
      return "*";
    }
    if (this.parameterModifiers.length > 0) {
      const pModifiers = this.parameterModifiers.reverse();
      for (let i = 0; i < pModifiers.length; i++) {
        if (pModifiers[i].modifier != null && modifierManager_default.instance != null) {
          const tModifier = pModifiers[i].modifier;
          return modifierManager_default.instance.getProbableReturnType(tModifier, this.isPaired());
        }
      }
    }
    return "*";
  }
  getLastManifestedModifierValue() {
    if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0 && this.node.modifierChain.lastManifestedModifier != null) {
      if (this.node.modifierChain.lastManifestedModifier.parameters.length > 0) {
        return this.node.modifierChain.lastManifestedModifier.parameters[0].value;
      }
      return "";
    }
    if (this.parameterModifiers.length > 0) {
      const pModifiers = this.parameterModifiers.reverse();
      for (let i = 0; i < pModifiers.length; i++) {
        if (pModifiers[i].modifier != null) {
          return pModifiers[i].value;
        }
      }
    }
    return "";
  }
  getLastManifestedModifier() {
    if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0 && this.node.modifierChain.lastModifier != null) {
      return this.node.modifierChain.lastModifier;
    }
    if (this.parameterModifiers.length > 0) {
      const pModifiers = this.parameterModifiers.reverse();
      for (let i = 0; i < pModifiers.length; i++) {
        if (pModifiers[i].modifier != null) {
          return pModifiers[i].modifier;
        }
      }
    }
    return null;
  }
  hasModifiers() {
    if (this.node.modifierChain == null || this.node.modifierChain.modifierChain.length == 0) {
      if (this.parameterModifiers.length > 0) {
        return true;
      }
      return false;
    }
    return true;
  }
  hasParameterModifiers() {
    return this.parameterModifiers.length > 0;
  }
  hasShorthandModifiers() {
    if (this.node.modifierChain != null && this.node.modifierChain.modifierChain.length > 0) {
      return true;
    }
    return false;
  }
  hasModifier(modifierName) {
    return this.modifierNames.includes(modifierName);
  }
};

// server/src/runtime/document/scanners/nodeFilters.ts
function filterStructuralAntlersNodes(sourceNodes) {
  const nodes = [];
  sourceNodes.forEach((node) => {
    if (node instanceof AntlersNode) {
      nodes.push(node);
    } else if (node instanceof ConditionNode) {
      if (node.logicBranches.length > 0) {
        node.logicBranches.forEach((branch) => {
          if (branch.head != null) {
            const tBrancHead = branch.head;
            if (tBrancHead.originalNode != null) {
              nodes.push(tBrancHead.originalNode);
            } else {
              nodes.push(tBrancHead);
            }
          }
        });
      }
    }
  });
  return nodes;
}

// server/src/runtime/utilities/stringUtilities.ts
var ctype = require_ctype();
var is_numeric = require_is_numeric();
var StringUtilities = class {
  static normalizeLineEndings(string, to = "\n") {
    return string.replace(/\r?\n/g, to);
  }
  static split(text) {
    return text.split("");
  }
  static substring(text, start, length) {
    return text.substr(start, length);
  }
  static ctypeSpace(char) {
    return ctype.ctype_space(char);
  }
  static ctypeAlpha(char) {
    return ctype.ctype_alpha(char);
  }
  static ctypeDigit(char) {
    return ctype.ctype_digit(char);
  }
  static ctypePunct(char) {
    return ctype.ctype_punct(char);
  }
  static trimLeft(value, charList = "\\s") {
    return value.replace(new RegExp("^[" + charList + "]+"), "");
  }
  static trimRight(value, charList = "\\s") {
    return value.replace(new RegExp("[" + charList + "]+$"), "");
  }
  static isNumeric(string) {
    return is_numeric(string);
  }
  static substringCount(haystack, needle) {
    const subStr = needle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return (haystack.match(new RegExp(subStr, "gi")) || []).length;
  }
};

// server/src/runtime/nodes/antlersVirtualStructures/nodeVirtualHierarchy.ts
var NodeVirtualHierarchy = class {
  constructor(node) {
    this.node = node;
  }
  findParentWithName(name) {
    const parser = this.node.getParser();
    if (parser == null) {
      return null;
    }
    return parser.structure.findParentWithName(name, this.node);
  }
};

// server/src/runtime/nodes/abstractNode.ts
var AbstractNode3 = class {
  constructor() {
    this.refId = null;
    this.index = 0;
    this.parent = null;
    this.content = "";
    this.sourceContent = "";
    this.startPosition = null;
    this.endPosition = null;
    this.modifierChain = null;
    this.originalAbstractNode = null;
    this.positionContexts = [];
    this.addedContexts = /* @__PURE__ */ new Map();
    this.isVirtual = true;
    this.isPartOfMethodChain = false;
    this.isVirtualGroupMember = false;
    this.isVirtualGroupOperatorResolve = false;
    this.isSwitchGroupMember = false;
    this.isListGroupMember = false;
    this.producesVirtualStatementTerminator = false;
    this.convertedToOperator = false;
    this.scopeVariable = null;
    this.currentScope = null;
    this.manifestType = "";
    this.scopeName = null;
    this.sourceType = "";
    this.runtimeType = null;
    this.modifiers = new NodeVirtualModifiers(this);
    this.prev = null;
    this.next = null;
    this.methodTarget = null;
    this.libraryTarget = null;
    this.antlersErrors = [];
    this.parser = null;
    this.refId = v4();
  }
  getContexts() {
    return this.positionContexts;
  }
  addContext(context) {
    if (this.addedContexts.has(context.refId) == false) {
      this.addedContexts.set(context.refId, true);
      this.positionContexts.push(context);
    }
  }
  getRange() {
    if (this.originalAbstractNode != null) {
      return this.originalAbstractNode.getRange();
    }
    if (this.startPosition == null || this.endPosition == null) {
      return DocumentRange.Empty;
    }
    const range = new DocumentRange();
    range.start = this.startPosition;
    range.end = this.endPosition;
    return range;
  }
  withParser(parser) {
    this.parser = parser;
  }
  getParser() {
    return this.parser;
  }
  pushError(error) {
    if (this.parent != null) {
      this.parent.pushError(error);
    }
    this.antlersErrors.push(error);
    if (this.parent == null) {
      if (this.parser != null) {
        this.parser.pushError(error);
      }
    }
  }
  mergeErrors(errors) {
    errors.forEach((error) => {
      if (error.node == null) {
        error.node = this;
      }
      this.antlersErrors.push(error);
    });
  }
  getErrors() {
    return this.antlersErrors;
  }
  innerContent() {
    return this.content;
  }
  rawContent() {
    return this.content;
  }
};
var ExecutionBranch = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.head = null;
    this.tail = null;
    this.nodes = [];
  }
};
var ConditionNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.logicBranches = [];
    this.chain = [];
  }
};
var AntlersNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.isNodeAbanonded = false;
    this.isComment = false;
    this.isTagNode = false;
    this.isConditionNode = false;
    this.runtimeContent = "";
    this.name = null;
    this.pathReference = null;
    this.isClosingTag = false;
    this.isInterpolationNode = false;
    this.isOpenedBy = null;
    this.isClosedBy = null;
    this.isSelfClosing = false;
    this.children = [];
    this.runtimeNodes = [];
    this.parsedRuntimeNodes = [];
    this.hasParsedRuntimeNodes = false;
    this.parameters = [];
    this.hasParameters = false;
    this.contentOffset = null;
    this.cachedContent = null;
    this.cachedInnerContent = null;
    this.hasRecursiveNode = false;
    this.recursiveReference = null;
    this.rawStart = "";
    this.rawEnd = "";
    this.originalNode = null;
    this.interpolationRegions = /* @__PURE__ */ new Map();
    this.processedInterpolationRegions = /* @__PURE__ */ new Map();
    this.hasProcessedInterpolationRegions = false;
    this.ref = 0;
    this.contentStartRelativeIndex = null;
    this.antlersNodeIndex = 0;
    this.nameStartsOn = null;
    this.nameEndsOn = null;
    this.nameMethodPartStartsOn = null;
    this.structure = new NodeVirtualHierarchy(this);
    this.mustClose = false;
    this.reference = null;
    this._conditionParserAbandonPairing = false;
    this._isEndVirtual = false;
  }
  nodeAtIndex(index) {
    if (this.runtimeNodes.length == 0) {
      return null;
    }
    for (let i = 0; i < this.runtimeNodes.length; i++) {
      if (this.runtimeNodes[i].index == index) {
        return this.runtimeNodes[i];
      }
    }
    return null;
  }
  isEmpty() {
    return this.content.trim().length == 0;
  }
  nameMatches(content) {
    if (this.name == null) {
      return false;
    }
    return this.name.content == content;
  }
  copyBasicDetails() {
    return this.copyBasicDetailsTo(new AntlersNode());
  }
  copyBasicDetailsTo(instance) {
    instance.refId = this.refId;
    instance.isComment = this.isComment;
    instance.isTagNode = this.isTagNode;
    instance.children = this.children;
    instance.parameters = this.parameters;
    instance.isClosingTag = this.isClosingTag;
    instance.rawStart = this.rawStart;
    instance.rawEnd = this.rawEnd;
    instance.startPosition = this.startPosition;
    instance.endPosition = this.endPosition;
    return instance;
  }
  id() {
    return this.refId;
  }
  innerContent() {
    if (this.cachedInnerContent == null) {
      this.cachedInnerContent = this.content.replace('"', '\\"');
    }
    return this.cachedInnerContent;
  }
  resetContentCache() {
    this.cachedContent = null;
    this.cachedInnerContent = null;
  }
  hasMethodPart() {
    if (this.name == null) {
      return false;
    }
    const methodPart = this.name.getMethodName();
    if (methodPart != null) {
      return true;
    }
    return false;
  }
  runtimeName() {
    if (this.name == null) {
      return "";
    }
    return this.name.getCompoundTagName();
  }
  getTagName() {
    if (this.name == null) {
      return "";
    }
    return this.name.name;
  }
  getNameContent() {
    if (this.name == null) {
      return "";
    }
    return this.name.content;
  }
  getMethodNameValue() {
    if (this.name == null) {
      return "";
    }
    const methodPart = this.name.getMethodName();
    if (methodPart != null) {
      return methodPart;
    }
    return "";
  }
  methodIsEmptyOrMatches(testValue) {
    return this.getMethodNameValue() == testValue;
  }
  hasParameter(name) {
    const paramMatch = this.findParameter(name);
    return paramMatch != null;
  }
  hasParameterWithValue(name, expectedValue) {
    const paramMatch = this.findParameter(name);
    if (paramMatch == null) {
      return false;
    }
    return paramMatch.value == expectedValue;
  }
  findParameterValue(name, defaultValue) {
    const paramMatch = this.findParameter(name);
    if (paramMatch == null) {
      return defaultValue;
    }
    return paramMatch.value;
  }
  findParameterValueOrNull(name) {
    const paramMatch = this.findParameter(name);
    if (paramMatch == null) {
      return null;
    }
    return paramMatch.value;
  }
  findParameter(name) {
    if (this.parameters.length == 0) {
      return null;
    }
    for (let i = 0; i < this.parameters.length; i++) {
      if (this.parameters[i].name == name) {
        return this.parameters[i];
      }
    }
    return null;
  }
  findAnyParameter(names) {
    for (let i = 0; i < names.length; i++) {
      const tempValue = this.findParameter(names[i]);
      if (tempValue != null) {
        return tempValue;
      }
    }
    return null;
  }
  getContentRelativeStartIndex() {
    if (this.contentStartRelativeIndex == null) {
      const chars = this.content.split("");
      for (let i = 0; i < chars.length; i++) {
        if (!StringUtilities.ctypeSpace(chars[i])) {
          this.contentStartRelativeIndex = i;
          break;
        }
      }
      if (this.contentStartRelativeIndex == null) {
        this.contentStartRelativeIndex = chars.length;
      }
      this.contentStartRelativeIndex += this.rawStart.length;
    }
    return this.contentStartRelativeIndex;
  }
  getContent() {
    if (this.cachedContent == null) {
      if (this.isComment) {
        this.cachedContent = this.content;
        this.contentOffset = this.startPosition;
      } else {
        if (this.isTagNode) {
          let contentToAnalyze = this.content;
          contentToAnalyze = StringUtilities.trimLeft(contentToAnalyze);
          let compoundNameLen = 0;
          if (this.name != null) {
            compoundNameLen = this.name.compound.length;
          }
          if (this.parameters.length > 0) {
            let startPosIndex = 0;
            const firstParam = this.parameters[0];
            if (firstParam.startPosition != null) {
              startPosIndex = firstParam.startPosition.index - 1;
            }
            const leadContent = contentToAnalyze, contentWithoutSpace2 = leadContent.trimLeft(), leadingWsCount2 = leadContent.length - contentWithoutSpace2.length, leadNameLen = compoundNameLen;
            contentToAnalyze = contentToAnalyze.substr(0, startPosIndex);
          }
          const contentWithoutSpace = contentToAnalyze.trimLeft(), leadingWsCount = contentToAnalyze.length - contentWithoutSpace.length, leadOffset = compoundNameLen + leadingWsCount + 2;
          if (this.parser != null) {
            let startPosOffset = 0;
            if (this.startPosition != null) {
              startPosOffset = this.startPosition.offset;
            }
            this.contentOffset == this.parser.positionFromOffset(startPosOffset + leadOffset, 0);
          }
          if (this.name != null) {
            if (this.name.name == "if" || this.name.name == "elseif" || this.name.name == "unless" || this.name.name == "elseunless") {
              contentToAnalyze = " " + contentToAnalyze.trimLeft();
              this.cachedContent = contentToAnalyze.substr(this.name.compound.length + 1);
            } else {
              this.cachedContent = contentToAnalyze;
            }
          } else {
            this.cachedContent = contentToAnalyze;
          }
        } else {
          if (this.parameters.length > 0) {
            const firstParam = this.parameters[0];
            let startPosIndex = 0;
            if (firstParam.startPosition != null) {
              startPosIndex = firstParam.startPosition.index - 1;
            }
            this.contentOffset = this.startPosition;
            this.cachedContent = this.content.substr(0, startPosIndex);
          } else {
            this.contentOffset = this.startPosition;
            this.cachedContent = this.content;
          }
        }
      }
    }
    return this.cachedContent;
  }
  relativePositionFromOffset(offset, index) {
    var _a, _b;
    if (this.parser == null) {
      return null;
    }
    return this.parser.positionFromOffset(((_b = (_a = this.contentOffset) == null ? void 0 : _a.offset) != null ? _b : 0) + offset, index);
  }
  getInterpolationNode(varName) {
    if (this.processedInterpolationRegions.has(varName)) {
      const refRegion = this.processedInterpolationRegions.get(varName);
      if (refRegion.length > 0 && refRegion[0] instanceof AntlersNode) {
        return refRegion[0];
      }
    }
    return null;
  }
  _lexerRelativeOffset(offset, index = null) {
    var _a, _b;
    let indexToUse = offset;
    if (index != null) {
      indexToUse = index;
    }
    if (this.parser == null) {
      const position = new Position();
      position.index = offset;
      position.offset = offset;
      return position;
    }
    let relativeIndex = offset + this.rawStart.length + ((_b = (_a = this.startPosition) == null ? void 0 : _a.index) != null ? _b : 0);
    if (this.isTagNode && this.nameStartsOn != null) {
      relativeIndex = this.nameStartsOn.index + offset;
    }
    const resolvedOffset = this.parser.positionFromOffset(relativeIndex, relativeIndex, true);
    return resolvedOffset;
  }
  relativeOffset(offset, index = null) {
    var _a, _b;
    let indexToUse = offset;
    if (index != null) {
      indexToUse = index;
    }
    if (this.parser == null) {
      const position = new Position();
      position.index = offset;
      position.offset = offset;
      return position;
    }
    const relativeIndex = offset + this.rawStart.length + ((_b = (_a = this.startPosition) == null ? void 0 : _a.index) != null ? _b : 0);
    const resolvedOffset = this.parser.positionFromOffset(relativeIndex, relativeIndex, true);
    return resolvedOffset;
  }
  isPaired() {
    if (this.isClosedBy == null) {
      return false;
    }
    if (this.isSelfClosing) {
      return false;
    }
    return true;
  }
  rawContent() {
    return this.rawStart + this.content + this.rawEnd;
  }
  getTrueRuntimeNodes() {
    if (this.originalNode != null && this.originalNode != this) {
      return this.originalNode.getTrueRuntimeNodes();
    }
    return this.runtimeNodes;
  }
  getTrueRawContent() {
    if (this.originalNode != null && this.originalNode != this) {
      return this.originalNode.getTrueRawContent();
    }
    return this.rawContent();
  }
  getTrueNode() {
    if (this.originalNode != null && this.originalNode != this) {
      return this.originalNode.getTrueNode();
    }
    return this;
  }
  getStructuralChildren() {
    if (this.isClosedBy != null) {
      return filterStructuralAntlersNodes(this.children.slice(0, -1));
    }
    return filterStructuralAntlersNodes(this.children);
  }
};
var ParserFailNode = class extends AntlersNode {
  static makeWithStartPosition(startPosition) {
    const newNode = new ParserFailNode();
    newNode.startPosition = startPosition;
    newNode.endPosition = startPosition;
    return newNode;
  }
};
var AntlersParserFailNode = class extends ParserFailNode {
};
var RecursiveNode = class extends AntlersNode {
  constructor() {
    super(...arguments);
    this.recursiveParent = null;
    this.isNestedRecursive = false;
  }
};
var PhpExecutionNode = class extends AntlersNode {
};
var CommentParserFailNode = class extends ParserFailNode {
};
var PhpParserFailNode = class extends ParserFailNode {
};
var EscapedContentNode = class extends AntlersNode {
  constructor() {
    super(...arguments);
    this.isNoParseRegion = false;
  }
};
var ParameterNode2 = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.modifier = null;
    this.isModifierParameter = false;
    this.nameDelimiter = '"';
    this.isVariableReference = false;
    this.name = "";
    this.value = "";
    this.interpolations = [];
    this.parent = null;
    this.blockPosition = null;
    this.namePosition = null;
    this.valuePosition = null;
  }
  containsSimpleValue() {
    return this.hasInterpolations() == false && this.isVariableReference == false;
  }
  hasInterpolations() {
    return this.interpolations.length > 0;
  }
  getArrayValue() {
    return this.value.split("|");
  }
  getValue() {
    return this.value;
  }
};
var ModifierChainNode = class {
  constructor() {
    this.modifierTarget = null;
    this.modifierChain = [];
    this.startPosition = null;
    this.endPosition = null;
    this.lastManifestedModifier = null;
    this.lastModifier = null;
  }
  updateValues() {
    if (this.modifierChain.length == 0) {
      this.startPosition = null;
      this.endPosition = null;
    } else {
      const firstModifier = this.modifierChain[0], lastModifier = this.modifierChain[this.modifierChain.length - 1];
      this.startPosition = firstModifier.startPosition;
      this.endPosition = lastModifier.endPosition;
    }
  }
};
var ModifierNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.modifier = null;
    this.methodStyleArguments = null;
    this.nameNode = null;
    this.name = "";
    this.valueNodes = [];
    this.parameters = [];
  }
  getParameterValues() {
    const values = [];
    this.parameters.forEach((param) => {
      values.push(param.value);
    });
    return values;
  }
};
var ValueDirectionNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.order = 0;
    this.name = null;
    this.directionNode = null;
  }
};
var ModifierParameterNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.value = "";
  }
};
var FalseConstant = class extends AbstractNode3 {
};
var NullConstant = class extends AbstractNode3 {
};
var TrueConstant = class extends AbstractNode3 {
};
var AdditionOperator = class extends AbstractNode3 {
};
var DivisionOperator = class extends AbstractNode3 {
};
var ExponentiationOperator = class extends AbstractNode3 {
};
var FactorialOperator = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.repeat = 1;
  }
};
var ModulusOperator = class extends AbstractNode3 {
};
var MultiplicationOperator = class extends AbstractNode3 {
};
var SubtractionOperator = class extends AbstractNode3 {
};
var AdditionAssignmentOperator = class extends AbstractNode3 {
};
var DivisionAssignmentOperator = class extends AbstractNode3 {
};
var LeftAssignmentOperator = class extends AbstractNode3 {
};
var ModulusAssignmentOperator = class extends AbstractNode3 {
};
var MultiplicationAssignmentOperator = class extends AbstractNode3 {
};
var SubtractionAssignmentOperator = class extends AbstractNode3 {
};
var EqualCompOperator = class extends AbstractNode3 {
};
var GreaterThanCompOperator = class extends AbstractNode3 {
};
var GreaterThanEqualCompOperator = class extends AbstractNode3 {
};
var LessThanCompOperator = class extends AbstractNode3 {
};
var LessThanEqualCompOperator = class extends AbstractNode3 {
};
var NotEqualCompOperator = class extends AbstractNode3 {
};
var NotStrictEqualCompOperator = class extends AbstractNode3 {
};
var SpaceshipCompOperator = class extends AbstractNode3 {
};
var StrictEqualCompOperator = class extends AbstractNode3 {
};
var ConditionalVariableFallbackOperator = class extends AbstractNode3 {
};
var LanguageOperatorConstruct = class extends AbstractNode3 {
};
var StatementSeparatorNode = class extends AbstractNode3 {
};
var DirectionGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.orderClauses = [];
  }
};
var InlineBranchSeparator = class extends AbstractNode3 {
};
var ModifierSeparator = class extends AbstractNode3 {
};
var NullCoalescenceGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.left = null;
    this.right = null;
  }
};
var ModifierValueSeparator = class extends AbstractNode3 {
};
var InlineTernarySeparator = class extends AbstractNode3 {
};
var LogicalAndOperator = class extends AbstractNode3 {
};
var LogicalNegationOperator = class extends AbstractNode3 {
};
var LogicalOrOperator = class extends AbstractNode3 {
};
var LogicalXorOperator = class extends AbstractNode3 {
};
var NullCoalesceOperator = class extends AbstractNode3 {
};
var ScopeAssignmentOperator = class extends AbstractNode3 {
};
var StringConcatenationOperator = class extends AbstractNode3 {
};
var LogicGroupEnd = class extends AbstractNode3 {
};
var LogicGroupBegin = class extends AbstractNode3 {
};
var ListValueNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.values = [];
    this.isNamedNode = false;
    this.parsedName = null;
  }
};
var LogicGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.start = null;
    this.end = null;
    this.nodes = [];
    this.scopeOperator = null;
  }
};
var SwitchCase = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.condition = null;
    this.expression = null;
  }
};
var SwitchGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.cases = [];
  }
};
var ConditionalFallbackGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.left = null;
    this.right = null;
  }
};
var ArrayNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.nodes = [];
  }
};
var TernaryCondition = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.head = null;
    this.truthBranch = null;
    this.falseBranch = null;
  }
};
var ArgSeparator = class extends AbstractNode3 {
};
var SemanticGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.nodes = [];
    this.separatorToken = null;
  }
};
var ScopedLogicGroup = class extends LogicGroup {
  constructor() {
    super(...arguments);
    this.scope = null;
  }
  extract() {
    let scopeName = null;
    if (this.scope != null) {
      scopeName = this.scope.name;
    }
    const sematicWrapper = this.nodes[0];
    return [
      scopeName,
      sematicWrapper.nodes
    ];
  }
};
var AliasedScopeLogicGroup = class extends ScopedLogicGroup {
  constructor() {
    super(...arguments);
    this.alias = null;
  }
};
var ArgumentGroup = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.args = [];
    this.hasNamedArguments = false;
    this.numberOfNamedArguments = 0;
  }
};
var TupleListStart = class extends AbstractNode3 {
};
var TupleList = class extends AbstractNode3 {
};
var LibraryInvocationConstruct = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.libraryName = "";
    this.methodName = "";
    this.arguments = null;
  }
};
var LiteralNode = class extends AbstractNode3 {
};
var MethodInvocationNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.method = null;
    this.args = null;
  }
};
var ModifierNameNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.name = "";
  }
};
var ModifierValueNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.value = "";
    this.name = "";
  }
};
var NamedArgumentNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.name = null;
    this.value = null;
  }
};
var NameValueNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.name = null;
    this.value = null;
  }
};
var NumberNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.value = null;
  }
};
var StringValueNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.value = "";
    this.sourceTerminator = "";
  }
};
var VariableNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.name = "";
    this.mergeRefName = "";
    this.variableReference = null;
    this.interpolationNodes = [];
    this.isInterpolationReference = false;
  }
};
var AccessorNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.name = "";
  }
};
var PathNode = class extends AbstractNode3 {
  constructor() {
    super(...arguments);
    this.delimiter = "";
    this.name = "";
    this.isStringVar = false;
    this.isFinal = false;
  }
};
var VariableReference = class {
  constructor() {
    this.originalContent = "";
    this.normalizedReference = "";
    this.isStrictTagReference = false;
    this.isStrictVariableReference = false;
    this.isExplicitVariableReference = false;
    this.isVariableVariable = false;
    this.pathParts = [];
    this.isFinal = false;
    this._isFromEmptyFailState = false;
  }
  clone() {
    const reference = new VariableReference();
    reference.originalContent = this.originalContent;
    reference.normalizedReference = this.normalizedReference;
    reference.isStrictVariableReference = this.isStrictVariableReference;
    reference.isExplicitVariableReference = this.isExplicitVariableReference;
    reference.pathParts = this.pathParts;
    reference.isFinal = this.isFinal;
    return reference;
  }
  implodePaths() {
    const stringParts = [];
    this.pathParts.forEach((part) => {
      if (part instanceof PathNode) {
        stringParts.push(part.name);
      } else if (part instanceof VariableReference) {
        stringParts.push(part.implodePaths());
      }
    });
    return stringParts.join(".");
  }
};

// server/src/antlers/tagManagerInstance.ts
var import_vscode_languageserver9 = __toESM(require_main4());

// server/src/suggestions/attributeSuggestions.ts
var import_vscode_languageserver_types = __toESM(require_main2());
function makeTagParameterSuggestions(request, parameters) {
  const paramSuggestions = [];
  if (request.currentNode == null) {
    return paramSuggestions;
  }
  const range = {
    start: {
      line: request.position.line,
      character: request.position.character - 0
    },
    end: request.position
  };
  for (let i = 0; i < parameters.length; i++) {
    const curParam = parameters[i];
    if (!request.currentNode.hasParameter(curParam.name)) {
      const paramSnippet = curParam.name + '="$1"';
      paramSuggestions.push({
        label: curParam.name,
        kind: import_vscode_languageserver_types.CompletionItemKind.Value,
        insertTextFormat: import_vscode_languageserver_types.InsertTextFormat.Snippet,
        textEdit: import_vscode_languageserver_types.TextEdit.replace(range, paramSnippet),
        command: {
          title: "Suggest",
          command: "editor.action.triggerSuggest"
        }
      });
    }
  }
  return paramSuggestions;
}

// server/src/suggestions/fieldFormatter.ts
var import_vscode_languageserver_types2 = __toESM(require_main2());
function makeFieldSuggest(name, description, valueType) {
  const item = {
    label: name,
    insertText: name,
    kind: import_vscode_languageserver_types2.CompletionItemKind.Field,
    detail: valueType + ": " + description
  };
  return item;
}
function formatSuggestionList(fields) {
  const items = [];
  for (let i = 0; i < fields.length; i++) {
    if (typeof fields[i].name === "undefined") {
      continue;
    }
    items.push(formatSuggestion(fields[i]));
  }
  return items;
}
function formatSuggestion(field) {
  let detail = "";
  let displayName = field.name;
  if (field.instructionText != null) {
    detail = field.instructionText;
  }
  if (field.displayName != null) {
    displayName = field.displayName + " (" + field.name + ")";
  }
  if (field.blueprintName != null) {
    if (detail.trim().length > 0) {
      detail += "\n";
    }
    detail += "Blueprint: " + field.blueprintName;
  }
  if (field.type != null) {
    displayName += ": " + field.type;
  }
  return {
    label: field.name,
    insertText: field.name,
    kind: import_vscode_languageserver_types2.CompletionItemKind.Field,
    documentation: detail,
    detail: displayName
  };
}

// server/src/utils/strings.ts
function trimLeft(value, charList) {
  if (charList == null) {
    charList = "s";
  }
  return value.replace(new RegExp("^[" + charList + "]+"), "");
}
function replaceAllInString(value, oldString, newString) {
  return value.replace(new RegExp(oldString, "g"), newString);
}
function trimRight(value, charList) {
  if (charList == null) {
    charList = "s";
  }
  return value.replace(new RegExp("[" + charList + "]+$"), "");
}

// server/src/documentation/utils.ts
function makeTagDocWithCodeSample(title, description, code, docLink) {
  let docs = "**" + title + "**  ";
  docs += "\n";
  docs += description + "  ";
  docs += "\n```antlers\n";
  docs += code;
  docs += "\n```";
  if (docLink != null) {
    docs += "\n\n";
    docs += "[Documentation Reference](" + docLink + ")";
  }
  return docs;
}
function makeTagDoc(title, description, docLink) {
  let docs = "**" + title + "**  ";
  docs += "\n";
  docs += description + "  ";
  if (docLink != null) {
    docs += "\n\n";
    docs += "[Documentation Reference](" + docLink + ")";
  }
  return docs;
}

// server/src/antlers/tags/core/collection/alternateParamSuggestions.ts
function suggestAlternativeCollectionParams(unknown) {
  const results = [];
  if (unknown == "order") {
    results.push("sort");
  }
  return results;
}

// server/src/projects/blueprints/fields.ts
function blueprintFieldFromScopeVariable(variable) {
  return {
    blueprintName: variable.sourceName,
    displayName: variable.name,
    instructionText: "",
    maxItems: -1,
    name: variable.name,
    refFieldSetField: null,
    type: variable.dataType,
    sets: null,
    import: null
  };
}
function variablesToBlueprintFields(variables) {
  const fields = [];
  for (let i = 0; i < variables.length; i++) {
    fields.push(blueprintFieldFromScopeVariable(variables[i]));
  }
  return fields;
}

// server/src/antlers/variables/loopVariables.ts
function makeLoopVariables(symbol) {
  return [
    { name: "first", dataType: "boolean", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "last", dataType: "boolean", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "count", dataType: "integer", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "index", dataType: "integer", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol },
    { name: "order", dataType: "integer", sourceField: null, sourceName: "*internal.loop", introducedBy: symbol }
  ];
}

// server/src/antlers/scope/factories/listFactory.ts
function checkSymbolForScopeAndAlias(node, scope, fields) {
  if (typeof fields === "undefined" || fields === null) {
    return;
  }
  const aliasParam = node.findParameter("as"), scopeParam = node.findParameter("scope");
  fields = fields.concat(variablesToBlueprintFields(makeLoopVariables(node)));
  if (aliasParam != null && scopeParam != null) {
    scope.introduceScopedAliasScope(node, scopeParam.value, aliasParam.value, fields);
  } else if (aliasParam != null) {
    scope.introduceAliasScope(node, aliasParam.value, fields);
  } else if (scopeParam != null) {
    scope.introduceDynamicScopeList(node, scopeParam.value, fields);
  } else {
    scope.addBlueprintFields(node, fields);
  }
}

// server/src/antlers/variables/collectionVariables.ts
function makeCollectionVariables(node) {
  return [
    { name: "no_results", dataType: "boolean", sourceField: null, sourceName: "*internal.collection.context", introducedBy: node },
    { name: "total_results", dataType: "integer", sourceField: null, sourceName: "*internal.collection.context", introducedBy: node }
  ];
}

// server/src/antlers/tags/core/collection/utils.ts
var import_vscode_languageserver_types3 = __toESM(require_main2());

// server/src/antlers/tags/core/collection/parameters.ts
var collectionParameters = [
  {
    isRequired: false,
    name: "from",
    description: "The collection name to retrieve entries from",
    aliases: ["folder", "use"],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["string", "array"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "not_from",
    aliases: ["not_folder", "dont_use"],
    description: "The collections to exclude when retrieving entries",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["string", "array"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "show_unpublished",
    aliases: null,
    description: "Controls whether unpbulished entries are returned",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "show_published",
    aliases: null,
    description: "Controls whether published entries are returned",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "show_past",
    aliases: null,
    description: "Controls whether to display entries with a past date",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "since",
    aliases: null,
    description: "Sets the minimum date an entry can have to be returned",
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "until",
    aliases: null,
    description: "Sets the maximum date an entry can have to be returned",
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "sort",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: null,
    description: "Specifies the entry sort order",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "limit",
    aliases: null,
    description: "Sets the maximum number of entries to return",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["integer"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "filter",
    aliases: ["query_scope"],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    description: "Specifies a custom query scope",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: null,
    description: "Sets the amount that entry results should be offset by",
    expectsTypes: ["integer"],
    isRequired: false,
    name: "offset",
    isDynamic: false
  },
  {
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: null,
    description: "Sets whether not to paginate entry results",
    expectsTypes: ["boolean", "number"],
    isRequired: false,
    name: "paginate",
    isDynamic: false
  },
  {
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: null,
    description: "Specifies a name to give to a new entries array variable",
    expectsTypes: ["string"],
    isRequired: false,
    name: "as",
    isDynamic: false
  },
  {
    name: "scope",
    aliases: null,
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    description: "Sets a prefix on all entry variables",
    expectsTypes: ["string"],
    isRequired: false,
    isDynamic: false
  },
  {
    name: "locale",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: null,
    description: "Specifies the locale in which to retrieve entry content",
    expectsTypes: ["string"],
    isRequired: false,
    isDynamic: false
  },
  {
    name: "redirects",
    aliases: ["links"],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    description: "Controls whether entries with redirects are returned",
    expectsTypes: ["boolean"],
    isRequired: false,
    isDynamic: false
  }
];
var CollectionSourceParams = ["from", "folder", "use"];
var CollectionRestrictionParams = ["not_from", "not_folder", "dont_use"];
var EntryStatuses = ["draft", "scheduled", "expired", "published"];

// server/src/antlers/tags/core/collection/utils.ts
function getTaxonomyCompletionItems(request) {
  const items = [];
  if (request.project != null) {
    const range = {
      start: {
        line: request.position.line,
        character: request.position.character - request.originalLeftWord.length
      },
      end: request.position
    };
    const taxonomyNames = request.project.getUniqueTaxonomyNames();
    for (let i = 0; i < taxonomyNames.length; i++) {
      const taxonomyName = taxonomyNames[i];
      const snippet2 = request.originalLeftWord + taxonomyName + '="$1"';
      items.push({
        label: request.originalLeftWord + taxonomyName,
        insertTextFormat: import_vscode_languageserver_types3.InsertTextFormat.Snippet,
        kind: import_vscode_languageserver_types3.CompletionItemKind.Field,
        textEdit: import_vscode_languageserver_types3.TextEdit.replace(range, snippet2),
        command: {
          title: "Suggest",
          command: "editor.action.triggerSuggest"
        }
      });
    }
  }
  return items;
}
function getCollectionBlueprintFields(node, scope) {
  let fields = [];
  if (node.reference != null) {
    const collectionNode = node.reference, nodeFields = scope.statamicProject.getBlueprintFields(collectionNode.collectionNames);
    if (typeof nodeFields !== "undefined" && nodeFields != null) {
      fields = nodeFields;
    }
  }
  return fields;
}
function makeStatusSuggestions(existingValues) {
  const items = [], validStatuses = EntryStatuses.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < validStatuses.length; i++) {
    items.push({
      label: validStatuses[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeTaxonomySuggestions(existingValues, taxonomyName, project) {
  const items = [], taxonomyTerms = project.getTaxonomyTerms(taxonomyName), termsToReturn = taxonomyTerms.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < termsToReturn.length; i++) {
    items.push({
      label: termsToReturn[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeSingleCollectionNameSuggestions(project) {
  const items = [], collectionNames = project.getCollectionNames();
  for (let i = 0; i < collectionNames.length; i++) {
    items.push({
      label: collectionNames[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeCollectionNameSuggestions(existingValues, project) {
  const items = [], collectionNames = project.getCollectionNames().filter((e) => !existingValues.includes(e));
  for (let i = 0; i < collectionNames.length; i++) {
    items.push({
      label: collectionNames[i],
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}
function makeQueryScopeSuggestions(project) {
  const items = [];
  const queryScopes = project.getCollectionQueryScopes();
  for (let i = 0; i < queryScopes.length; i++) {
    items.push({
      label: queryScopes[i].name,
      detail: queryScopes[i].description,
      kind: import_vscode_languageserver_types3.CompletionItemKind.Variable
    });
  }
  return items;
}

// server/src/antlers/tags/core/collection/augmentCollectionScope.ts
function augmentCollectionScope(node, scope) {
  if (node.isClosingTag) {
    return scope;
  }
  if (node.hasMethodPart() && node.getMethodNameValue() != "count") {
    scope.addVariables(makeCollectionVariables(node));
  }
  if (node.reference != null) {
    const fields = getCollectionBlueprintFields(node, scope);
    checkSymbolForScopeAndAlias(node, scope, fields);
  }
  return scope;
}

// server/src/antlers/tags/core/collection/resolveCollectionCompletions.ts
var import_vscode_languageserver4 = __toESM(require_main4());

// server/src/suggestions/defaults/conditionItems.ts
var import_vscode_languageserver_types4 = __toESM(require_main2());

// server/src/suggestions/defaults/stringConditions.ts
var StringConditionItems = [
  { name: "is", description: "Tests if a field is equal to a value" },
  { name: "equals", description: "Tests if a field is equal to a value" },
  { name: "not", description: "Tests if a field is not equal to a value" },
  { name: "isnt", description: "Tests if a field is not equal to a value" },
  { name: "exists", description: "Tests if a field exists" },
  { name: "isset", description: "Tests if a field exists" },
  { name: "doesnt_exist", description: "Tests if a field does not exist" },
  { name: "is_empty", description: "Tests if a field does not exist" },
  { name: "null", description: "Tests if a field does not exist" },
  { name: "contains", description: "Tests if a field contains a value" },
  { name: "doesnt_contain", description: "Tests if a field does not contain a value" },
  { name: "in", description: "Tests if a value is in an array" },
  { name: "not_in", description: "Tests if an array does not contain a value" },
  { name: "starts_with", description: "Tests if a field starts with a value" },
  { name: "doesnt_start_with", description: "Tests if a field does not start with a value" },
  { name: "ends_with", description: "Tests if a field ends with a value" },
  { name: "doesnt_end_with", description: "Tests if a field does not end with a value" },
  { name: "gt", description: "Tests if a field is greater than a value" },
  { name: "lt", description: "Tests if a field is less than a value" },
  { name: "gte", description: "Tests if a field is greater than or equal to a value" },
  { name: "lte", description: "Tests if a field is less than or equal to a value" },
  { name: "matches", description: "Tests if a field matches a case insensitive regex" },
  { name: "regex", description: "Tests if a field matches a case insensitive regex" },
  { name: "doesnt_match", description: "Tests if a field does not match a case insensitive regex" },
  { name: "is_alpha", description: "Tests if a field contains only alphabetical characters" },
  { name: "is_numeric", description: "Tests if a field contains only numeric characters" },
  { name: "is_alpha_numeric", description: "Tests if a field contains only alpha-numeric characters" },
  { name: "is_url", description: "Tests if a field is a valid URL" },
  { name: "is_embeddable", description: "Tests if a field is an embeddable video URL" },
  { name: "is_email", description: "Tests if a field is a valid email address" },
  { name: "is_after", description: "Tests if a field is after a given date" },
  { name: "is_before", description: "Tests if a field is before a given date" }
];

// server/src/suggestions/defaults/conditionItems.ts
function getConditionCompletionItems(request) {
  const items = [];
  const range = {
    start: {
      line: request.position.line,
      character: request.position.character - request.originalLeftWord.length
    },
    end: request.position
  };
  for (let i = 0; i < StringConditionItems.length; i++) {
    const thisCondition = StringConditionItems[i];
    const snippet2 = request.originalLeftWord + thisCondition.name + '="$1"';
    items.push({
      label: thisCondition.name,
      insertTextFormat: import_vscode_languageserver_types4.InsertTextFormat.PlainText,
      kind: import_vscode_languageserver_types4.CompletionItemKind.Field
    });
  }
  return items;
}

// server/src/suggestions/suggestionManager.ts
var import_vscode_languageserver_protocol = __toESM(require_main3());

// server/src/antlers/unclosedTagManager.ts
var UnclosedTagManager = class {
  static clear(documentUri) {
    this.unclosedNodes.delete(documentUri);
  }
  static registerNodes(documentUri, nodes) {
    this.unclosedNodes.set(documentUri, nodes);
  }
  static getUnclosedTags(documentUri, position) {
    var _a, _b, _c;
    const nodesToReturn = [];
    if (this.unclosedNodes.has(documentUri) == false) {
      return nodesToReturn;
    }
    const docNodes = this.unclosedNodes.get(documentUri);
    if (docNodes.length == 0) {
      return nodesToReturn;
    }
    const checkLine = position.line + 1;
    for (let i = 0; i < docNodes.length; i++) {
      const thisNode = docNodes[i];
      if (((_a = thisNode.endPosition) == null ? void 0 : _a.line) == checkLine && position.character > thisNode.endPosition.char) {
        nodesToReturn.push(thisNode);
      } else if (checkLine > ((_c = (_b = thisNode.endPosition) == null ? void 0 : _b.line) != null ? _c : 0)) {
        nodesToReturn.push(thisNode);
      }
    }
    return nodesToReturn;
  }
  static hasUnclosedTags(documentUri, position) {
    if (this.unclosedNodes.has(documentUri) == false) {
      return false;
    }
    const unclosedNodes = this.getUnclosedTags(documentUri, position);
    return unclosedNodes.length > 0;
  }
};
UnclosedTagManager.unclosedNodes = /* @__PURE__ */ new Map();

// server/src/antlers/variables/contentVariables.ts
function makeContentVariables(symbol) {
  return [
    { name: "edit_url", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "id", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "last_modified", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "permalink", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "published", dataType: "boolean", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "slug", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "template", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol },
    { name: "url", dataType: "string", sourceName: "*internal.entry", sourceField: null, introducedBy: symbol }
  ];
}

// server/src/suggestions/comments/documentPropertySuggestions.ts
var import_vscode_languageserver = __toESM(require_main4());
var DocumentPropertySuggestions = [
  { label: "name", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "description", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "desc", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "entry", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "collection", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "blueprint", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "var", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "set", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "param", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "param*", kind: import_vscode_languageserver.CompletionItemKind.Property },
  { label: "front", kind: import_vscode_languageserver.CompletionItemKind.Property }
];

// server/src/suggestions/defaults/languageConstructs.ts
var import_vscode_languageserver_types5 = __toESM(require_main2());
var LanguageConstructs = [
  { label: "if", kind: import_vscode_languageserver_types5.CompletionItemKind.Keyword },
  { label: "elseif", kind: import_vscode_languageserver_types5.CompletionItemKind.Keyword },
  { label: "else", kind: import_vscode_languageserver_types5.CompletionItemKind.Keyword }
];

// server/src/suggestions/genericTypesSuggestions.ts
var import_vscode_languageserver2 = __toESM(require_main4());
var import_vscode_languageserver_types6 = __toESM(require_main2());

// server/src/suggestions/defaults/booleanItems.ts
var import_vscode_languageserver_types7 = __toESM(require_main2());
var BooleanCompletionItems = [];
BooleanCompletionItems.push({ label: "true", kind: import_vscode_languageserver_types7.CompletionItemKind.Keyword });
BooleanCompletionItems.push({ label: "false", kind: import_vscode_languageserver_types7.CompletionItemKind.Keyword });

// server/src/antlers/variables/arrayVariables.ts
function makeArrayVariables(symbol) {
  return [
    { sourceName: "*internal.array", sourceField: null, dataType: "*", name: "value", introducedBy: symbol },
    { sourceName: "*internal.array", sourceField: null, dataType: "*", name: "key", introducedBy: symbol }
  ];
}

// server/src/antlers/fieldtypes/core/arrayFieldType.ts
var ArrayFieldType = {
  name: "array",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var arrayFieldType_default = ArrayFieldType;

// server/src/antlers/fieldtypes/core/bardFieldType.ts
var BardFieldType = {
  name: "bard",
  augmentScope: (symbol, scope) => {
    scope.addVariable({ name: "type", dataType: "string", sourceField: null, sourceName: "*internal.bard", introducedBy: symbol });
  },
  injectCompletions: (params, blueprintField, symbol) => {
    const items = [];
    return items;
  }
};
var bardFieldType_default = BardFieldType;

// server/src/antlers/fieldtypes/core/formMultiple.ts
var FormMultipleFieldtype = {
  name: "form_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var formMultiple_default = FormMultipleFieldtype;

// server/src/antlers/fieldtypes/core/listFieldType.ts
var ListFieldtype = {
  name: "list",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var listFieldType_default = ListFieldtype;

// server/src/antlers/variables/replicatorVariables.ts
function makeReplicatorVariables(symbol) {
  return [
    { name: "type", dataType: "string", sourceName: "*internal.replicator", sourceField: null, introducedBy: symbol }
  ];
}

// server/src/antlers/fieldtypes/core/replicatorFieldType.ts
var ReplicatorFieldtype = {
  name: "replicator",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeReplicatorVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  },
  injectCompletions: (params, blueprintField, symbol) => {
    const items = [];
    return items;
  }
};
var replicatorFieldType_default = ReplicatorFieldtype;

// server/src/antlers/fieldtypes/core/selectMultiple.ts
var SelectMultipleFieldtype = {
  name: "select_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var selectMultiple_default = SelectMultipleFieldtype;

// server/src/antlers/fieldtypes/core/sitesMultiple.ts
var SitesMultiple = {
  name: "sites_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var sitesMultiple_default = SitesMultiple;

// server/src/antlers/fieldtypes/core/structuresMultiple.ts
var StructuresMultipleFieldtype = {
  name: "structures_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var structuresMultiple_default = StructuresMultipleFieldtype;

// server/src/antlers/fieldtypes/core/table.ts
var TableFieldtype = {
  name: "table",
  augmentScope: (symbol, scope) => {
    scope.addVariable({ name: "cells", dataType: "array", sourceName: "*internal.fieldtype.table", sourceField: null, introducedBy: symbol });
  }
};
var table_default = TableFieldtype;

// server/src/antlers/fieldtypes/core/tagsFieldType.ts
var TagsFieldtype = {
  name: "tags",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var tagsFieldType_default = TagsFieldtype;

// server/src/antlers/variables/termVariables.ts
function makeTermVariables(symbol) {
  return makeContentVariables(symbol).concat([
    { name: "entries_count", dataType: "number", sourceName: "*internal.term", sourceField: null, introducedBy: symbol },
    { name: "is_term", dataType: "boolean", sourceName: "*internal.term", sourceField: null, introducedBy: symbol },
    { name: "taxonomy", dataType: "string", sourceName: "*internal.term", sourceField: null, introducedBy: symbol }
  ]);
}

// server/src/antlers/fieldtypes/core/taxonomiesMultiple.ts
var TaxonomiesMultipleFieldtype = {
  name: "taxonomies_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
    scope.addVariables(makeTermVariables(symbol));
  }
};
var taxonomiesMultiple_default = TaxonomiesMultipleFieldtype;

// server/src/antlers/fieldtypes/core/termsMultiple.ts
var TermsMultipleFieldtype = {
  name: "terms_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
    scope.addVariables(makeTermVariables(symbol));
  }
};
var termsMultiple_default = TermsMultipleFieldtype;

// server/src/antlers/fieldtypes/core/userGroupsMultiple.ts
var UserGroupsMultipleFieldtype = {
  name: "user_groups_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var userGroupsMultiple_default = UserGroupsMultipleFieldtype;

// server/src/antlers/fieldtypes/core/userRolesMultiple.ts
var UserRolesMultipleFieldtype = {
  name: "user_roles_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var userRolesMultiple_default = UserRolesMultipleFieldtype;

// server/src/antlers/fieldtypes/core/usersMultiple.ts
var UsersMultipleFieldtype = {
  name: "users_multiple",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
    scope.injectBlueprint(symbol, "user");
  }
};
var usersMultiple_default = UsersMultipleFieldtype;

// server/src/antlers/fieldtypes/core/yamlFieldType.ts
var YamlFieldtype = {
  name: "yaml",
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeArrayVariables(symbol));
    scope.addVariables(makeLoopVariables(symbol));
  }
};
var yamlFieldType_default = YamlFieldtype;

// server/src/antlers/fieldtypes/core/coreFieldtypes.ts
var CoreFieldtypes = [
  arrayFieldType_default,
  bardFieldType_default,
  formMultiple_default,
  listFieldType_default,
  replicatorFieldType_default,
  selectMultiple_default,
  sitesMultiple_default,
  structuresMultiple_default,
  yamlFieldType_default,
  table_default,
  taxonomiesMultiple_default,
  tagsFieldType_default,
  termsMultiple_default,
  usersMultiple_default,
  userGroupsMultiple_default,
  userRolesMultiple_default
];
var coreFieldtypes_default = CoreFieldtypes;

// server/src/antlers/fieldtypes/fieldtypeManager.ts
var FieldtypeManager = class {
  constructor() {
    this.fieldTypes = /* @__PURE__ */ new Map();
  }
  getFieldTypes() {
    return this.fieldTypes;
  }
  getFieldType(name) {
    return this.fieldTypes.get(name);
  }
  registerFieldtypes(types2) {
    for (let i = 0; i < types2.length; i++) {
      this.fieldTypes.set(types2[i].name, types2[i]);
    }
  }
  loadCoreFieldtypes() {
    this.registerFieldtypes(coreFieldtypes_default);
  }
  hasFieldtype(name) {
    return this.fieldTypes.has(name);
  }
};
FieldtypeManager.instance = null;
if (typeof FieldtypeManager.instance == "undefined" || FieldtypeManager.instance == null) {
  FieldtypeManager.instance = new FieldtypeManager();
  FieldtypeManager.instance.loadCoreFieldtypes();
}
var fieldtypeManager_default = FieldtypeManager;

// server/src/suggestions/suggestionManager.ts
function getCurrentSymbolMethodNameValue(params) {
  let valueToReturnn = "";
  if (params.currentNode != null) {
    valueToReturnn = params.currentNode.getMethodNameValue();
  }
  return valueToReturnn;
}
function getRoot(word) {
  if (word.includes(":") == false) {
    return word;
  }
  const parts = word.split(":");
  if (parts.length > 1) {
    return parts[parts.length - 1];
  }
  return parts[0].trim();
}
function getAbsoluteRoot(word) {
  if (word.includes(":") == false) {
    return word;
  }
  return word.split(":")[0];
}
function convertImmediateScopeToCompletionList(params) {
  var _a;
  if (params.nodesInScope.length == 0) {
    return [];
  }
  let lastScopeItem = params.nodesInScope[params.nodesInScope.length - 1];
  if (((_a = params.context) == null ? void 0 : _a.node) != null) {
    lastScopeItem = params.context.node;
  }
  if (lastScopeItem.currentScope == null) {
    return [];
  }
  return convertScopeToCompletionList(params, lastScopeItem.currentScope);
}
function convertScopeToCompletionList(params, scope) {
  const items = [];
  scope.values.forEach((val) => {
    var _a;
    if (val.sourceField != null) {
      items.push({
        label: val.name,
        detail: val.sourceField.blueprintName,
        documentation: (_a = val.sourceField.instructionText) != null ? _a : "",
        kind: import_vscode_languageserver_protocol.CompletionItemKind.Field
      });
    } else {
      items.push(makeFieldSuggest(val.name, "", ""));
    }
    if (val.dataType.trim().length > 0 && val.dataType == "array") {
      const arrayCompleteSnippet = val.name + " }}\n    $1\n{{ /" + val.name + " ", range = {
        start: {
          line: params.position.line,
          character: params.position.character - params.originalLeftWord.length
        },
        end: params.position
      };
      items.push({
        label: val.name + " loop",
        insertTextFormat: import_vscode_languageserver_protocol.InsertTextFormat.Snippet,
        kind: import_vscode_languageserver_protocol.CompletionItemKind.Snippet,
        textEdit: import_vscode_languageserver_protocol.TextEdit.replace(range, arrayCompleteSnippet),
        command: {
          title: "Suggest",
          command: "editor.action.triggerSuggest"
        }
      });
    }
  });
  scope.lists.forEach((val, key) => {
    items.push(makeFieldSuggest(key, "", ""));
  });
  return items;
}

// server/src/antlers/documentedLabel.ts
var import_vscode_languageserver3 = __toESM(require_main4());
function tagToCompletionItem(tag) {
  let docs = "";
  if (typeof tag !== "undefined" && typeof tag.resolveDocumentation !== "undefined" && tag.resolveDocumentation != null) {
    docs = tag.resolveDocumentation();
  }
  let completionLabel = tag.tagName;
  if (completionLabel.includes(":")) {
    const parts = completionLabel.split(":");
    completionLabel = parts[parts.length - 1];
  }
  return {
    label: completionLabel,
    kind: import_vscode_languageserver3.CompletionItemKind.Text,
    sortText: "1",
    documentation: {
      kind: "markdown",
      value: docs
    }
  };
}

// server/src/antlers/tagManager.ts
var import_vscode_languageserver_types8 = __toESM(require_main2());

// server/src/antlers/htmlCompat/parameters.ts
function makeHtmlParam(name, description, mdnReference) {
  return {
    name,
    acceptsVariableInterpolation: true,
    aliases: [],
    allowsVariableReference: true,
    description,
    expectsTypes: ["string"],
    isDynamic: true,
    isRequired: false,
    documentationLink: mdnReference,
    docLinkName: "MDN Reference"
  };
}
var HtmlClassParameter = makeHtmlParam("class", "A space-separated list of the classes of the element.", "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class");
var HtmlStyleParameter = makeHtmlParam("style", "Contains CSS styling declarations to be applied to the element. Note that it is recommended for styles to be defined in a separate file or files.", "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/style");

// server/src/antlers/tagManager.ts
function dynamicParameter(name) {
  if (name == "class") {
    return HtmlClassParameter;
  } else if (name == "style") {
    return HtmlStyleParameter;
  }
  return {
    name,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    description: "",
    expectsTypes: ["string", "number", "array"],
    isRequired: false,
    isDynamic: true
  };
}
function resultList(items) {
  const completionItems = [];
  for (let i = 0; i < items.length; i++) {
    completionItems.push({
      label: items[i],
      kind: import_vscode_languageserver_types8.CompletionItemKind.Field
    });
  }
  return exclusiveResult(completionItems);
}
function exclusiveResultList(items) {
  const completionItems = [];
  for (let i = 0; i < items.length; i++) {
    completionItems.push({
      label: items[i],
      kind: import_vscode_languageserver_types8.CompletionItemKind.Field
    });
  }
  return exclusiveResult(completionItems);
}
function exclusiveResult(items) {
  return {
    items,
    isExclusiveResult: true,
    analyzeDefaults: false
  };
}
function nonExclusiveResult(items) {
  return {
    items,
    isExclusiveResult: false,
    analyzeDefaults: true
  };
}
var EmptyCompletionResult = {
  items: [],
  isExclusiveResult: false,
  analyzeDefaults: true
};

// server/src/antlers/tags/alias.ts
function createDefinitionAlias(tag, alias) {
  const tagCopy = copyTagDefinition(tag);
  tagCopy.tagName = alias;
  return tagCopy;
}
function copyTagDefinition(tag) {
  return {
    allowsArbitraryParameters: tag.allowsArbitraryParameters,
    allowsContentClose: tag.allowsContentClose,
    injectParentScope: tag.injectParentScope,
    parameters: tag.parameters,
    requiresClose: tag.requiresClose,
    tagName: tag.tagName,
    introducedIn: tag.introducedIn,
    hideFromCompletions: tag.hideFromCompletions,
    augmentScope: tag.augmentScope,
    requiresCloseResolver: tag.requiresCloseResolver,
    resolveCompletionItems: tag.resolveCompletionItems,
    resolveDynamicParameter: tag.resolveDynamicParameter,
    resolveSpecialType: tag.resolveSpecialType,
    resovleParameterCompletionItems: tag.resovleParameterCompletionItems,
    suggestAlternativeParams: tag.suggestAlternativeParams,
    resolveDocumentation: tag.resolveDocumentation
  };
}

// server/src/antlers/tags.ts
function getScopeName(node) {
  return node.findParameterValueOrNull("scope");
}
function resolveTypedTree(document) {
  const docNodes = document.getAllNodes();
  docNodes.forEach((node) => {
    if (node instanceof AntlersNode) {
      if (node.manifestType === "array") {
        node.mustClose = true;
      }
    }
  });
}

// server/src/antlers/tags/core/collection/resolvesCollectionScope.ts
function getAliasName(node) {
  return node.findParameterValueOrNull("as");
}
var BuiltInCollectionMethods = ["count", "next", "previous"];
function getCollectionName(node, statamicProject) {
  let collectionNames = [];
  if (node.hasMethodPart()) {
    const methodNameValue = node.getMethodNameValue();
    if (BuiltInCollectionMethods.includes(methodNameValue) == false) {
      collectionNames.push(methodNameValue);
      return collectionNames;
    }
  }
  const fromParam = node.findAnyParameter(CollectionSourceParams), restrictParam = node.findAnyParameter(CollectionRestrictionParams);
  let fromList = [], notInList = [];
  if (typeof fromParam !== "undefined" && fromParam !== null) {
    if (fromParam.value.trim() === "*") {
      fromList = statamicProject.getUniqueCollectionNames();
      if (typeof restrictParam !== "undefined" && restrictParam !== null) {
        if (restrictParam.isVariableReference == false && restrictParam.hasInterpolations() == false) {
          notInList = restrictParam.getArrayValue();
        }
      }
    } else {
      if (fromParam.isVariableReference == false && fromParam.hasInterpolations() == false) {
        fromList = fromParam.getArrayValue();
      }
    }
  }
  if (notInList.length > 0) {
    collectionNames = fromList.filter(function(n) {
      return notInList.includes(n) == false;
    });
  } else {
    collectionNames = fromList;
  }
  return collectionNames;
}
function resolveCollectionScope(symbol, project) {
  var _a, _b, _c, _d, _e, _f;
  const collectionNames = getCollectionName(symbol, project);
  let isAliased = false, isPaginated = false, isScoped = false, scopeName = null, aliasName = "";
  if (symbol.isClosingTag == false) {
    const alias = getAliasName(symbol), scope = getScopeName(symbol);
    if (alias != null) {
      isAliased = true;
      aliasName = alias;
    }
    if (scope != null) {
      isScoped = true;
      scopeName = scope;
    }
    isPaginated = symbol.hasParameter("paginate");
  }
  const collectionScope = {
    collectionNames: collectionNames != null ? collectionNames : [],
    endPosition: (_b = (_a = symbol.endPosition) == null ? void 0 : _a.char) != null ? _b : 0,
    aliasName,
    isAliased,
    isScoped,
    scopeName,
    isStartOfScope: !symbol.isClosingTag,
    line: (_d = (_c = symbol.startPosition) == null ? void 0 : _c.line) != null ? _d : 0,
    startPosition: (_f = (_e = symbol.startPosition) == null ? void 0 : _e.char) != null ? _f : 0,
    isPaginated,
    excludeCollections: [],
    includeCollections: []
  };
  return {
    context: collectionScope,
    issues: []
  };
}

// server/src/antlers/tags/core/collection/resolvesConditionalParameters.ts
function resolveConditionalParmaters(symbol, paramName) {
  if (symbol == null) {
    return null;
  }
  let checkName = trimLeft(paramName, ":");
  if (checkName.includes(":")) {
    checkName = checkName.split(":")[0];
  }
  if (checkName == "status" || checkName == "taxonomy" || symbol.currentScope != null && symbol.currentScope.containsReference(checkName)) {
    return dynamicParameter(paramName);
  }
  return null;
}

// server/src/antlers/tags/core/collection/resolvesParameterSuggestions.ts
var collectionParamNames = [
  "from",
  "folder",
  "use",
  "not_from",
  "not_folder"
];
var singleCollectionTagActivators = ["previous", "next"];
var singleCollectionParamNames = [
  "in",
  "collection"
];
function resolveCollectionParameterCompletiontems(parameter, params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  if (parameter.isDynamic) {
    const checkName = getAbsoluteRoot(parameter.name);
    if (params.nodesInScope.length > 0) {
      const lastSymbolInScope = params.nodesInScope[params.nodesInScope.length - 1];
      if (lastSymbolInScope != null && lastSymbolInScope.currentScope != null) {
        const blueprintFields = getCollectionBlueprintFields(lastSymbolInScope, lastSymbolInScope.currentScope), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
        if (fieldNames.includes(rootLeft)) {
          return exclusiveResult(getConditionCompletionItems(params));
        }
      }
    }
    if (checkName == "status") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeStatusSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : []));
      }
    }
    if (checkName == "taxonomy") {
      const taxonomyName = getRoot(parameter.name);
      if (params.project.hasTaxonomy(taxonomyName)) {
        if (((_d = params.context) == null ? void 0 : _d.parameterContext) != null) {
          return exclusiveResult(makeTaxonomySuggestions((_f = (_e = params.context.parameterContext.parameter) == null ? void 0 : _e.getArrayValue()) != null ? _f : [], taxonomyName, params.project));
        }
      }
    }
  }
  if (parameter.name == "filter" || parameter.name == "query_scope") {
    return exclusiveResult(makeQueryScopeSuggestions(params.project));
  }
  if (params.nodesInScope.length > 0) {
    const lastSymbolInScope = params.nodesInScope[params.nodesInScope.length - 1];
    if (lastSymbolInScope.hasMethodPart()) {
      if (singleCollectionTagActivators.includes(lastSymbolInScope.getMethodNameValue())) {
        if (singleCollectionParamNames.includes(parameter.name)) {
          return exclusiveResult(makeSingleCollectionNameSuggestions(params.project));
        }
      }
    }
  }
  if (collectionParamNames.includes(parameter.name)) {
    if (((_g = params.context) == null ? void 0 : _g.parameterContext) != null) {
      return exclusiveResult(makeCollectionNameSuggestions((_j = (_i = (_h = params.context) == null ? void 0 : _h.parameterContext.parameter) == null ? void 0 : _i.getArrayValue()) != null ? _j : [], params.project));
    }
  }
  return null;
}

// server/src/antlers/tags/core/collection/previous.ts
var CollectionPrevious = {
  tagName: "collection:previous",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [
    ...collectionParameters,
    {
      name: "in",
      aliases: ["collection"],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The collection to search in",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "current",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Sets the current entry by ID",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    }
  ],
  augmentScope: augmentCollectionScope,
  resolveDynamicParameter: resolveConditionalParmaters,
  resolveSpecialType: resolveCollectionScope,
  suggestAlternativeParams: suggestAlternativeCollectionParams,
  resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
  resolveCompletionItems: resolveCollectionCompletions,
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("collection:previous Tag", "The `collection:previous` tag is used to show the entries that appear before the current entry, based on some entry order (publish date, alphabetical, or manual).", `{{# Retrieve the previous two entries, based on dates in ascending order. #}}
{{ collection:previous in="articles" limit="2" sort="date:asc" }}

{{ /collection:previous }}`, "https://statamic.dev/tags/collection-previous");
  }
};
var previous_default = CollectionPrevious;

// server/src/antlers/tags/core/collection/ageDirectional.ts
var CollectionOlder = createDefinitionAlias(previous_default, "collection:older");
var CollectionNewer = createDefinitionAlias(previous_default, "collection:newer");

// server/src/antlers/tags/core/collection/count.ts
var CollectionCount = {
  tagName: "collection:count",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [
    ...collectionParameters,
    {
      isRequired: true,
      name: "in",
      aliases: ["from"],
      description: "The collection from which to count entries",
      acceptsVariableInterpolation: true,
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  resolveSpecialType: resolveCollectionScope,
  resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("collection:count Tag", "The `collection:count` tag returns the total number of entries in the specified collection(s). The collection count tag accepts the same parameters as the collection tag, allowing developers to count entries that meet specific conditions.", `Total entry count: {{ collection:count in="collection-name" }}
Draft count: {{ collection:count in="collection-name" status:in="draft" }}`, "https://statamic.dev/tags/collection-count");
  }
};
var count_default = CollectionCount;

// server/src/antlers/tags/core/collection/next.ts
var CollectionNext = {
  tagName: "collection:next",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [
    ...collectionParameters,
    {
      name: "in",
      aliases: ["collection"],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The collection to search in",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "current",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Sets the current entry by ID",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    }
  ],
  augmentScope: augmentCollectionScope,
  resolveDynamicParameter: resolveConditionalParmaters,
  resolveSpecialType: resolveCollectionScope,
  suggestAlternativeParams: suggestAlternativeCollectionParams,
  resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
  resolveCompletionItems: resolveCollectionCompletions,
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("collection:next Tag", "The `collection:next` tag is used to show the entries that will appear after the current entry, based on some entry order (publish date, alphabetical, or manual).", `{{# Retrieve the next two entries, based on dates in ascending order. #}}
{{ collection:next in="articles" limit="2" sort="date:asc" }}

{{ /collection:next }}`, "https://statamic.dev/tags/collection-next");
  }
};
var next_default = CollectionNext;

// server/src/antlers/tags/core/collection/resolveCollectionCompletions.ts
function resolveCollectionCompletions(params) {
  var _a, _b;
  let items = [];
  if (params.isPastTagPart == false && (params.leftWord == "collection" || params.leftWord == "/collection") && params.leftChar == ":") {
    const collectionNames = params.project.getCollectionNames();
    for (let i = 0; i < collectionNames.length; i++) {
      items.push({
        label: collectionNames[i],
        kind: import_vscode_languageserver4.CompletionItemKind.Field,
        sortText: "0"
      });
    }
    items.push(tagToCompletionItem(count_default));
    items.push(tagToCompletionItem(next_default));
    items.push(tagToCompletionItem(previous_default));
    items.push(tagToCompletionItem(CollectionOlder));
    items.push(tagToCompletionItem(CollectionNewer));
    return {
      items,
      analyzeDefaults: false,
      isExclusiveResult: false
    };
  }
  if (params.currentNode != null && params.currentNode.currentScope != null) {
    const blueprintFields = getCollectionBlueprintFields(params.currentNode, params.currentNode.currentScope), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
    if (rootLeft === "taxonomy") {
      return exclusiveResult(getTaxonomyCompletionItems(params));
    }
    if (fieldNames.includes(rootLeft)) {
      items = getConditionCompletionItems(params);
      return exclusiveResult(items);
    }
    if (params.isCaretInTag && !((_a = params.context) == null ? void 0 : _a.isInParameter) && ["collection", "/collection"].includes(params.leftWord) == false && params.leftChar != " ") {
      const addedNames = [];
      for (let i = 0; i < blueprintFields.length; i++) {
        const thisField = blueprintFields[i];
        if (addedNames.includes(thisField.name) == false) {
          items.push({
            label: thisField.name,
            detail: thisField.blueprintName,
            documentation: (_b = thisField.instructionText) != null ? _b : "",
            kind: import_vscode_languageserver4.CompletionItemKind.Field
          });
          addedNames.push(thisField.name);
        }
      }
      items.push({
        label: "taxonomy",
        insertText: "taxonomy:",
        kind: import_vscode_languageserver4.CompletionItemKind.Field
      });
      items.push({
        label: "status",
        insertText: "status:",
        kind: import_vscode_languageserver4.CompletionItemKind.Field
      });
      if (items.length > 0) {
        return nonExclusiveResult(items);
      }
    }
  }
  return EmptyCompletionResult;
}

// server/src/antlers/tags/core/collection/collection.ts
var Collection = {
  tagName: "collection",
  hideFromCompletions: false,
  introducedIn: null,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  parameters: collectionParameters,
  augmentScope: augmentCollectionScope,
  resolveDynamicParameter: resolveConditionalParmaters,
  resolveSpecialType: resolveCollectionScope,
  suggestAlternativeParams: suggestAlternativeCollectionParams,
  resovleParameterCompletionItems: resolveCollectionParameterCompletiontems,
  resolveCompletionItems: resolveCollectionCompletions,
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("collection Tag", "The `collection` tag provides access to entry data such as blog posts, products, etc.", `{{ collection:articles as="posts" }}

	{{ posts }}
		{{ title }}
	{{ /posts }}

{{ /collection:articles }}`, "https://statamic.dev/tags/collection");
  }
};
var collection_default = Collection;

// server/src/antlers/tags/core/cache.ts
var Cache = {
  tagName: "cache",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  resovleParameterCompletionItems: (parameter, params) => {
    if (parameter.name == "scope") {
      return exclusiveResultList(["page", "site"]);
    }
    return null;
  },
  parameters: [
    {
      isRequired: false,
      name: "for",
      description: "The duration the cache is valid for",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "key",
      description: "An arbitrary name the cache entry may be referenced by",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "scope",
      description: " The scope of the cached value. Either site or page.",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  resolveSpecialType: (node, project) => {
    const keyParameter = node.findParameter("key");
    let cacheContext = null;
    if (keyParameter != null) {
      const cacheKeyValue = keyParameter.value;
      if (cacheKeyValue.trim().length > 0) {
        cacheContext = {
          key: cacheKeyValue,
          reference: node
        };
      }
    }
    return {
      context: cacheContext,
      issues: []
    };
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("cache Tag", "The `cache` tag can be used to save the results of an expensive template operation. The duration of the cache can be configured.", `{{ cache for="10 minutes" }}
    {{# Template code that won't be re-rendered for at least 10 minutes. #}}
{{ /cache }}`, "https://statamic.dev/tags/cache");
  }
};
var cache_default = Cache;

// server/src/antlers/tags/core/dump.ts
var Dump = {
  tagName: "dump",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [],
  resolveCompletionItems: (params) => {
    if (params.leftWord == "dump" && params.leftChar == ":") {
      return exclusiveResult(convertImmediateScopeToCompletionList(params));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("dump Tag", "The `dump` tag is a useful tag for debugging, and will display the raw data available at the point the tag is rendered.", `{{ collection:articles }}
	{{# View all data available, for each entry. #}}
    {{ dump }}
{{ /collection:articles }}`, "https://statamic.dev/tags/dump");
  }
};
var dump_default = Dump;

// server/src/antlers/tags/core/error404.ts
var Error404 = {
  tagName: "404",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("404 (Not Found) Tag", "The `404` (Not Found) tag will trigger a 404 status code, and display the 404 template to the site visitor.", `{{ unless logged_in }}
	{{# Display the 404 Not Found page. #}}
	{{ 404 }}
{{ /unless }}`, "https://statamic.dev/tags/404");
  }
};
var error404_default = Error404;

// server/src/antlers/tags/core/link.ts
var Link = {
  tagName: "link",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [
    {
      name: "to",
      description: "The relative path",
      expectsTypes: ["string"],
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      isRequired: true,
      isDynamic: false
    },
    {
      name: "absolute",
      description: "Whether to generate absolute URLs. Default false",
      expectsTypes: ["boolean"],
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      isRequired: false,
      isDynamic: false
    },
    {
      name: "id",
      description: "The ID of the entry to link to",
      expectsTypes: ["string"],
      allowsVariableReference: true,
      acceptsVariableInterpolation: true,
      aliases: [],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "in",
      description: "The handle of the site to link to.",
      expectsTypes: ["string"],
      allowsVariableReference: true,
      acceptsVariableInterpolation: true,
      aliases: [],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("link Tag", "The `link` tag accepts relative URLs or entry IDs and generates fully-qualified URLs to the desired content.", "https://statamic.dev/tags/link");
  }
};
var link_default = Link;

// server/src/antlers/tags/core/loop.ts
var Loop = {
  tagName: "loop",
  hideFromCompletions: false,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  introducedIn: null,
  augmentScope: (node, scope) => {
    scope.addVariable({
      name: "value",
      dataType: "*",
      sourceName: "*internal.loop.value",
      sourceField: null,
      introducedBy: node
    });
    return scope;
  },
  parameters: [
    {
      name: "times",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["number"],
      description: "The number of iterations",
      isRequired: false,
      isDynamic: false
    },
    {
      name: "from",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["number"],
      description: "The value to start iterating from. Default 1",
      isRequired: false,
      isDynamic: false
    },
    {
      name: "to",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["number"],
      description: "The value to stop iterating at",
      isRequired: false,
      isDynamic: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("loop Tag", "The `loop` tag is used to create an array of items between two values, and then iterate the created array. Alternatively, a max value can be set using the `times` parameter to loop that number of times.", "https://statamic.dev/tags/loop");
  }
};
var RangeTag = {
  tagName: "range",
  hideFromCompletions: false,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  introducedIn: null,
  augmentScope: (node, scope) => {
    scope.addVariable({
      name: "value",
      dataType: "*",
      sourceName: "*internal.loop.value",
      sourceField: null,
      introducedBy: node
    });
    return scope;
  },
  parameters: [
    {
      name: "times",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["number"],
      description: "The number of iterations",
      isRequired: false,
      isDynamic: false
    },
    {
      name: "from",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["number"],
      description: "The value to start iterating from. Default 1",
      isRequired: false,
      isDynamic: false
    },
    {
      name: "to",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["number"],
      description: "The value to stop iterating at",
      isRequired: false,
      isDynamic: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("range Tag", "The `range` tag is used to create an array of items between two values, and then iterate the created array. Alternatively, a max value can be set using the `times` parameter to loop that number of times.", "https://statamic.dev/tags/loop");
  }
};

// server/src/antlers/tags/core/partials/partial.ts
var import_vscode_languageserver6 = __toESM(require_main4());

// server/src/runtime/document/documentManager.ts
var DocumentManager = class {
  constructor() {
    this.loadedDocuments = /* @__PURE__ */ new Map();
    this.activeProject = null;
  }
  getDocuments() {
    const docs = [];
    this.loadedDocuments.forEach((doc) => {
      docs.push(doc);
    });
    return docs;
  }
  setProject(project) {
    this.activeProject = project;
    this.loadedDocuments.forEach((document) => {
      if (this.activeProject != null) {
        document.updateProject(this.activeProject);
      }
    });
  }
  refreshDocumentState() {
    if (this.activeProject != null) {
      this.setProject(this.activeProject);
    }
  }
  hasDocument(uri) {
    return this.loadedDocuments.has(uri);
  }
  createDocument(uri) {
    if (!this.loadedDocuments.has(uri)) {
      const doc = new AntlersDocument();
      doc.documentUri = uri;
      this.loadedDocuments.set(uri, doc);
    }
  }
  loadDocument(uri, text) {
    this.loadedDocuments.set(uri, AntlersDocument.fromText(text));
  }
  getDocument(uri) {
    return this.loadedDocuments.get(uri);
  }
  updateDocument(uri, text) {
    if (this.loadedDocuments.has(uri)) {
      const document = this.loadedDocuments.get(uri);
      document.loadString(text);
    }
  }
  createOrUpdate(uri, text) {
    this.createDocument(uri);
    this.updateDocument(uri, text);
  }
  getDocumentErrors(uri) {
    if (!this.loadedDocuments.has(uri)) {
      return [];
    }
    const doc = this.loadedDocuments.get(uri);
    return doc.errors.all();
  }
};
DocumentManager.instance = null;
if (typeof DocumentManager.instance == "undefined" || DocumentManager.instance) {
  DocumentManager.instance = new DocumentManager();
}
var documentManager_default = DocumentManager;

// server/src/languageService/documents.ts
var sessionDocuments = new documentManager_default();

// server/src/antlers/tags/dynamicParameterResolver.ts
function returnDynamicParameter(node, paramName) {
  if (paramName.trim().length > 0) {
    return dynamicParameter(paramName);
  }
  return null;
}

// server/src/antlers/tags/core/partials/partialParameters.ts
var PartialParameters = [
  {
    isRequired: false,
    name: "src",
    description: "The name of the partial view",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: [],
    expectsTypes: ["string"],
    isDynamic: false
  }
];

// server/src/antlers/tags/core/partials/resolvePartialParameterCompletions.ts
var import_vscode_languageserver5 = __toESM(require_main4());
function resolvePartialParameterCompletions(parameter, params) {
  var _a;
  if (parameter.isDynamic) {
    if (params.currentNode != null && params.currentNode.getTagName() == "partial" && params.currentNode.hasMethodPart()) {
      const nodeMethodName = params.currentNode.getMethodNameValue();
      if (nodeMethodName.trim().length > 0) {
        if ((_a = projectManager_default.instance) == null ? void 0 : _a.hasStructure()) {
          const projectView = projectManager_default.instance.getStructure().findRelativeView(nodeMethodName);
          if (projectView != null && projectView.varReferenceNames.has(parameter.name)) {
            const viewDataRef = projectView.varReferenceNames.get(parameter.name);
            if (params.antlersDocument.hasFrontMatter()) {
              const frontMatterScope = params.antlersDocument.getFrontMatterScope();
              if (frontMatterScope != null) {
                return resultList(frontMatterScope.getVariableNames());
              }
            }
          }
        }
      }
    }
  }
  if (parameter.name == "src") {
    const partials = params.project.getViews(), completionItems = [];
    partials.forEach((view) => {
      if (DocumentDetailsManager.hasDetails(view.documentUri)) {
        const partialDetails = DocumentDetailsManager.documentDetails.get(view.documentUri);
        completionItems.push({
          label: partialDetails.documentName + "(" + view.relativeDisplayName + ")",
          insertText: view.relativeDisplayName,
          detail: partialDetails.documentName,
          documentation: {
            kind: import_vscode_languageserver5.MarkupKind.Markdown,
            value: partialDetails.documentDescription
          },
          kind: import_vscode_languageserver5.CompletionItemKind.File
        });
      } else {
        completionItems.push({
          label: view.relativeDisplayName,
          kind: import_vscode_languageserver5.CompletionItemKind.File
        });
      }
    });
    return exclusiveResult(completionItems);
  }
  return null;
}

// server/src/antlers/tags/core/partials/partialExists.ts
var PartialExists = {
  tagName: "partial:exists",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  parameters: PartialParameters,
  introducedIn: "3.2.7",
  resovleParameterCompletionItems: resolvePartialParameterCompletions,
  resolveDocumentation: (params) => {
    return makeTagDoc("partial:exists Tag", "The `partial:exists` can be used within conditional statements to test if a partial exists.", "https://statamic.dev/tags/partial-exists");
  }
};
var partialExists_default = PartialExists;

// server/src/antlers/tags/core/partials/partialIfExists.ts
var PartialIfExists = {
  tagName: "partial:if_exists",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  parameters: PartialParameters,
  introducedIn: "3.2.7",
  resovleParameterCompletionItems: resolvePartialParameterCompletions,
  resolveDocumentation: (params) => {
    return makeTagDoc("partial:if_exists Tag", "The `partial:if_exists` can be used to output the contents of a partial if it exists.", "https://statamic.dev/tags/partial-if-exists");
  }
};
var partialIfExists_default = PartialIfExists;

// server/src/antlers/tags/core/partials/partial.ts
var PartialCompletionItems = [
  tagToCompletionItem(partialExists_default),
  tagToCompletionItem(partialIfExists_default)
];
var Partial = {
  tagName: "partial",
  hideFromCompletions: false,
  injectParentScope: false,
  allowsArbitraryParameters: true,
  parameters: PartialParameters,
  requiresClose: false,
  allowsContentClose: true,
  introducedIn: null,
  resolveDocumentation: (params) => {
    return `**Partial Tag**  
Includes another view into the current template.  

[Documentation Reference](https://statamic.dev/tags/partial)
`;
  },
  resolveDynamicParameter: returnDynamicParameter,
  resovleParameterCompletionItems: resolvePartialParameterCompletions,
  resolveCompletionItems: (params) => {
    let items = [];
    if (params.leftChar == '"' && params.leftWord == ':src="') {
      return {
        items: [],
        analyzeDefaults: true,
        isExclusiveResult: false
      };
    }
    if ((params.leftWord == "partial" || params.leftWord == "/partial") && params.leftChar == ":" || params.leftWord == 'src="' && params.leftChar == '"') {
      const partials = params.project.getViews();
      partials.forEach((view) => {
        if (DocumentDetailsManager.hasDetails(view.documentUri)) {
          const partialDetails = DocumentDetailsManager.documentDetails.get(view.documentUri);
          items.push({
            label: partialDetails.documentName + "(" + view.relativeDisplayName + ")",
            insertText: view.relativeDisplayName,
            detail: partialDetails.documentName,
            documentation: {
              kind: import_vscode_languageserver6.MarkupKind.Markdown,
              value: partialDetails.documentDescription
            },
            kind: import_vscode_languageserver6.CompletionItemKind.File
          });
        } else {
          items.push({
            label: view.relativeDisplayName,
            kind: import_vscode_languageserver6.CompletionItemKind.File
          });
        }
      });
      if (params.leftWord != 'src="') {
        items = items.concat(PartialCompletionItems);
      }
      return {
        analyzeDefaults: false,
        isExclusiveResult: true,
        items
      };
    }
    if (params.currentNode != null && params.project != null) {
      const viewName = getViewName(params.currentNode);
      if (viewName != null && viewName.trim().length > 0) {
        const viewRef = params.project.findRelativeView(viewName);
        if (viewRef != null) {
          if (sessionDocuments.hasDocument(viewRef.documentUri)) {
            const docInstance = sessionDocuments.getDocument(viewRef.documentUri);
            if (docInstance != null) {
              const symbols = docInstance.getAllAntlersNodes(), variableNames = getVariableNames(symbols), addedNames = [];
              if (viewRef.varReferenceNames != null) {
                viewRef.varReferenceNames.forEach((val, varName) => {
                  variableNames.push(varName);
                });
              }
              if (variableNames.length > 0) {
                const completionItems = [];
                const range = {
                  start: {
                    line: params.position.line,
                    character: params.position.character - 0
                  },
                  end: params.position
                };
                variableNames.forEach((variableName) => {
                  const paramSnippet = variableName + '="$1"';
                  if (addedNames.includes(variableName)) {
                    return;
                  }
                  addedNames.push(variableName);
                  completionItems.push({
                    label: variableName,
                    kind: import_vscode_languageserver6.CompletionItemKind.Value,
                    insertTextFormat: import_vscode_languageserver6.InsertTextFormat.Snippet,
                    textEdit: import_vscode_languageserver6.TextEdit.replace(range, paramSnippet),
                    command: {
                      title: "Suggest",
                      command: "editor.action.triggerSuggest"
                    }
                  });
                });
                return nonExclusiveResult(completionItems);
              }
            }
          }
        }
      }
    }
    return {
      analyzeDefaults: true,
      isExclusiveResult: false,
      items: []
    };
  }
};
function getViewName(node) {
  if (node.getTagName() != "partial") {
    return null;
  }
  let partialName = "";
  if (node.hasMethodPart()) {
    partialName = node.getMethodNameValue();
  } else {
    const srcParam = node.findParameter("src");
    if (srcParam != null) {
      partialName = srcParam.value;
    }
  }
  return partialName;
}
function getVariableNames(symbols) {
  const namesToReturn = [];
  symbols.forEach((symbol) => {
    if (symbol.isTagNode || symbol.isClosingTag) {
      return;
    }
    if (symbol.isComment) {
      return;
    }
    if (symbol.hasMethodPart() && symbol.getMethodNameValue().length > 0) {
      return;
    }
    if (symbol.name != null && symbol.name.content.includes("[")) {
      return;
    }
    const nodeTagName = symbol.getTagName();
    if (!namesToReturn.includes(nodeTagName) && nodeTagName != "#" && nodeTagName != "slot") {
      namesToReturn.push(nodeTagName);
    }
  });
  return namesToReturn;
}
var partial_default = Partial;

// server/src/antlers/tags/core/incrementReset.ts
var IncrementReset = {
  tagName: "increment:reset",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: "3.2.28",
  parameters: [
    {
      isRequired: true,
      name: "counter",
      aliases: [],
      description: "The incrementing counter to reset",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "to",
      aliases: [],
      description: "An optional value to reset the counter to before incrementing starts again",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      expectsTypes: ["number"],
      isDynamic: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("increment:reset Tag", "The `increment:reset` tag can be used to reset the value of an incrementing counter.", `{{ array_variable }}
    {{ increment:counter_name }}
{{ /array_variable }}

{{ increment:reset counter="counter_name" }}
`, null);
  }
};
var incrementReset_default = IncrementReset;

// server/src/antlers/tags/core/increment.ts
var IncrementCompletionItems = [
  tagToCompletionItem(incrementReset_default)
];
var Increment = {
  tagName: "increment",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: false,
      name: "from",
      aliases: [],
      description: "The number to start incrementing by",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      expectsTypes: ["number"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "by",
      aliases: [],
      description: "The number to increment by",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      expectsTypes: ["number"],
      isDynamic: false
    }
  ],
  resolveCompletionItems: (params) => {
    if (params.leftWord == "increment" || params.leftWord == "/increment" && params.leftChar == ":") {
      return exclusiveResult(IncrementCompletionItems);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("increment Tag", "The `increment` tag can be used to increment a value each time the tag is encountered.", "https://statamic.dev/tags/increment");
  }
};
var increment_default = Increment;

// server/src/antlers/tags/core/sections/yield.ts
var YieldContext = class {
  constructor(node) {
    this.node = node;
  }
};
var Yields = {
  tagName: "yields",
  hideFromCompletions: false,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: true,
  parameters: [],
  introducedIn: null,
  requiresClose: false,
  resolveSpecialType: (node, project) => {
    const context = new YieldContext(node);
    return {
      context,
      issues: []
    };
  }
};
var Yield = {
  tagName: "yield",
  hideFromCompletions: false,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: true,
  parameters: [],
  introducedIn: null,
  requiresClose: false,
  resolveSpecialType: (node, project) => {
    const context = new YieldContext(node);
    return {
      context,
      issues: []
    };
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("yield Tag", "The `yield` tag may be used to push rendered content to named regions within a template's structure.", "https://statamic.dev/tags/yield");
  }
};

// server/src/suggestions/permissionSuggestions.ts
var import_vscode_languageserver_types9 = __toESM(require_main2());

// server/src/antlers/permissions/nativePermissions.ts
var NativePermissions = [
  { handle: "access cp" },
  { handle: "configure collections" },
  { handle: "[view edit create delete publish reorder] {collection} entries" },
  { handle: "configure structures" },
  { handle: "[view edit] {structure} structure" },
  { handle: "edit {global} globals" },
  { handle: "[view upload edit move rename delete] {container} assets" },
  { handle: "[view perform] updates" },
  { handle: "[view edit create delete] users" },
  { handle: "change passwords" },
  { handle: "edit roles" },
  { handle: "configure forms" },
  { handle: "[view delete] {form} submissions" }
];

// server/src/antlers/permissions/permissionManager.ts
var PermissionsManager = class {
  constructor() {
    this.contextItems = /* @__PURE__ */ new Map();
    this.triggerNames = [];
    this.collectionTriggers = [];
    this.collectionTriggerCaps = [];
    this.globalTriggers = [];
    this.globalTriggerCaps = [];
    this.formTriggers = [];
    this.formTriggerCaps = [];
    this.structureTriggers = [];
    this.structureTriggerCaps = [];
    this.assetTriggers = [];
    this.assetTriggerCaps = [];
  }
  getCollectionTriggerCaps() {
    return this.collectionTriggerCaps;
  }
  getGlobalTriggerCaps() {
    return this.globalTriggerCaps;
  }
  getFormTriggerCaps() {
    return this.formTriggerCaps;
  }
  getStructureTriggerCaps() {
    return this.structureTriggerCaps;
  }
  getAssetTriggerCaps() {
    return this.assetTriggerCaps;
  }
  loadCorePermissions() {
    this.registerPermissions(NativePermissions);
  }
  getTriggerNames() {
    return this.triggerNames;
  }
  isCollectionTrigger(trigger) {
    return this.collectionTriggers.includes(trigger);
  }
  isGlobalTrigger(trigger) {
    return this.globalTriggers.includes(trigger);
  }
  isFormTrigger(trigger) {
    return this.formTriggers.includes(trigger);
  }
  isStructureTrigger(trigger) {
    return this.structureTriggers.includes(trigger);
  }
  isAssetTrigger(trigger) {
    return this.assetTriggers.includes(trigger);
  }
  getTriggerContextItems(trigger) {
    if (this.contextItems.has(trigger)) {
      return this.contextItems.get(trigger);
    }
    return [];
  }
  registerSpecialTrigger(trigger, specialTrigger, context) {
    if (specialTrigger == "{collection}") {
      if (this.collectionTriggerCaps.includes(context) == false) {
        this.collectionTriggerCaps.push(context);
      }
      if (this.collectionTriggers.includes(trigger) == false) {
        this.collectionTriggers.push(trigger);
      }
    } else if (specialTrigger == "{structure}") {
      if (this.structureTriggerCaps.includes(context) == false) {
        this.structureTriggerCaps.push(context);
      }
      if (this.structureTriggers.includes(trigger) == false) {
        this.structureTriggers.push(trigger);
      }
    } else if (specialTrigger == "{container}") {
      if (this.assetTriggerCaps.includes(context) == false) {
        this.assetTriggerCaps.push(context);
      }
      if (this.assetTriggers.includes(trigger) == false) {
        this.assetTriggers.push(trigger);
      }
    } else if (specialTrigger == "{global}") {
      if (this.globalTriggerCaps.includes(context) == false) {
        this.globalTriggerCaps.push(context);
      }
      if (this.globalTriggers.includes(trigger) == false) {
        this.globalTriggers.push(trigger);
      }
    } else if (specialTrigger == "{form}") {
      if (this.formTriggerCaps.includes(context) == false) {
        this.formTriggerCaps.push(context);
      }
      if (this.formTriggers.includes(trigger) == false) {
        this.formTriggers.push(trigger);
      }
    }
  }
  addContextToTrigger(trigger, context) {
    var _a;
    if (this.triggerNames.includes(trigger) == false) {
      this.triggerNames.push(trigger);
    }
    if (this.contextItems.has(trigger) == false) {
      this.contextItems.set(trigger, [context]);
    } else {
      (_a = this.contextItems.get(trigger)) == null ? void 0 : _a.push(context);
    }
  }
  registerPermissions(permissions) {
    for (let i = 0; i < permissions.length; i++) {
      const thisPermission = permissions[i];
      let triggers = [], specialTrigger = "", contextItem = "";
      if (thisPermission.handle.includes("[") && thisPermission.handle.includes("]")) {
        const openBracket = thisPermission.handle.indexOf("["), closeBracket = thisPermission.handle.indexOf("]"), len = closeBracket - openBracket, nestedTriggers = thisPermission.handle.substr(openBracket + 1, len - 1).split(" ").filter((n) => n.trim().length > 0), additionalPieces = thisPermission.handle.substr(closeBracket + 1).split(" ").filter((n) => n.trim().length > 0);
        triggers = nestedTriggers;
        if (additionalPieces.length == 2) {
          specialTrigger = additionalPieces[0];
          contextItem = additionalPieces[1];
        } else if (additionalPieces.length == 1) {
          specialTrigger = "";
          contextItem = additionalPieces[0];
        }
      } else {
        const pieces = thisPermission.handle.split(" ").filter((n) => n.trim().length > 0);
        if (pieces.length == 2) {
          triggers = [pieces[0]];
          contextItem = pieces[1];
        }
      }
      for (let j = 0; j < triggers.length; j++) {
        const thisTrigger = triggers[j];
        if (specialTrigger.trim().length > 0) {
          this.registerSpecialTrigger(thisTrigger, specialTrigger, contextItem);
        } else {
          this.addContextToTrigger(thisTrigger, contextItem);
        }
      }
    }
  }
};
PermissionsManager.instance = null;
if (typeof PermissionsManager.instance == "undefined" || PermissionsManager.instance == null) {
  PermissionsManager.instance = new PermissionsManager();
  PermissionsManager.instance.loadCorePermissions();
}
var permissionManager_default = PermissionsManager;

// server/src/suggestions/permissionSuggestions.ts
function getPermissionSuggestions(currentValue, params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
  const items = [];
  if (currentValue.trim().length == 0) {
    const baseTriggerNames = (_b = (_a = permissionManager_default.instance) == null ? void 0 : _a.getTriggerNames()) != null ? _b : [];
    for (let i = 0; i < baseTriggerNames.length; i++) {
      items.push({
        label: baseTriggerNames[i],
        kind: import_vscode_languageserver_types9.CompletionItemKind.Value
      });
    }
  } else {
    const currentParts = currentValue.split(" ").filter((n) => n.trim().length > 0), currentTrigger = currentParts[0], allContextualItems = (_d = (_c = permissionManager_default.instance) == null ? void 0 : _c.getTriggerContextItems(currentTrigger)) != null ? _d : [], isCollectionTrigger = (_e = permissionManager_default.instance) == null ? void 0 : _e.isCollectionTrigger(currentTrigger), isGlobalTrigger = (_f = permissionManager_default.instance) == null ? void 0 : _f.isGlobalTrigger(currentTrigger), isFormTrigger = (_g = permissionManager_default.instance) == null ? void 0 : _g.isFormTrigger(currentTrigger), isStructureTrigger = (_h = permissionManager_default.instance) == null ? void 0 : _h.isStructureTrigger(currentTrigger), isAssetTrigger = (_i = permissionManager_default.instance) == null ? void 0 : _i.isAssetTrigger(currentTrigger);
    let candidateItems = [];
    if (currentParts.length <= 2) {
      if (isCollectionTrigger) {
        candidateItems = candidateItems.concat(params.project.getUniqueCollectionNames());
      } else if (isGlobalTrigger) {
        candidateItems = candidateItems.concat(params.project.getUniqueGlobalsNames());
      } else if (isFormTrigger) {
        candidateItems = candidateItems.concat(params.project.getUniqueFormNames());
      } else if (isStructureTrigger) {
        candidateItems = candidateItems.concat(params.project.getUniqueNavigationMenuNames());
      } else if (isAssetTrigger) {
        candidateItems = candidateItems.concat(params.project.getUniqueAssetNames());
      }
      if (allContextualItems.length > 0) {
        candidateItems = candidateItems.concat(allContextualItems);
      }
      candidateItems = [...new Set(candidateItems)];
      for (let i = 0; i < candidateItems.length; i++) {
        items.push({
          label: candidateItems[i],
          kind: import_vscode_languageserver_types9.CompletionItemKind.Value
        });
      }
    } else {
      let capCandidates = [];
      if (isCollectionTrigger) {
        capCandidates = capCandidates.concat((_k = (_j = permissionManager_default.instance) == null ? void 0 : _j.getCollectionTriggerCaps()) != null ? _k : []);
      } else if (isGlobalTrigger) {
        capCandidates = capCandidates.concat((_m = (_l = permissionManager_default.instance) == null ? void 0 : _l.getGlobalTriggerCaps()) != null ? _m : []);
      } else if (isFormTrigger) {
        capCandidates = capCandidates.concat((_o = (_n = permissionManager_default.instance) == null ? void 0 : _n.getFormTriggerCaps()) != null ? _o : []);
      } else if (isStructureTrigger) {
        capCandidates = capCandidates.concat((_q = (_p = permissionManager_default.instance) == null ? void 0 : _p.getStructureTriggerCaps()) != null ? _q : []);
      } else if (isAssetTrigger) {
        capCandidates = capCandidates.concat((_s = (_r = permissionManager_default.instance) == null ? void 0 : _r.getAssetTriggerCaps()) != null ? _s : []);
      }
      capCandidates = [...new Set(capCandidates)];
      for (let i = 0; i < capCandidates.length; i++) {
        items.push({
          label: capCandidates[i],
          kind: import_vscode_languageserver_types9.CompletionItemKind.Value
        });
      }
    }
  }
  return items;
}

// server/src/antlers/tags/core/user/parameterCompletions.ts
function resolveUserParameterCompletionItems(parameter, params) {
  var _a, _b, _c, _d;
  const checkName = getAbsoluteRoot(parameter.name);
  if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null && ["do", "permission"].includes(checkName)) {
    return exclusiveResult(getPermissionSuggestions((_d = (_c = (_b = params.context) == null ? void 0 : _b.parameterContext.parameter) == null ? void 0 : _c.value) != null ? _d : "", params));
  }
  return null;
}

// server/src/antlers/tags/core/userCan.ts
var UserCan = {
  tagName: "user:can",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: true,
  introducedIn: null,
  resovleParameterCompletionItems: resolveUserParameterCompletionItems,
  parameters: [
    {
      name: "do",
      acceptsVariableInterpolation: false,
      aliases: ["permission"],
      allowsVariableReference: false,
      description: "The permissions to check against",
      expectsTypes: ["string"],
      isRequired: true,
      isDynamic: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("user:can Tag", "The `user:can` tag is used to check if the currently authenticated user has a specific set of permissions. When used as a tag pair, the tag contents will only be rendered if the user has the specified permissions.", "https://statamic.dev/tags/user-can");
  }
};
var userCan_default = UserCan;

// server/src/antlers/tags/core/userLogout.ts
var UserLogout = {
  tagName: "user:logout",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [{
    name: "redirect",
    description: "An optional URL to redirect the user after being logged out",
    aliases: [],
    isRequired: false,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string"]
  }],
  resolveDocumentation: (params) => {
    return makeTagDoc("user:logout Tag", "The `user:logout` tag will sign out the currently authenticated user. An optional `redirect` parameter may be used to redirect the visitor to a different page after being logged out.", "https://statamic.dev/tags/user-logout");
  }
};
var userLogout_default = UserLogout;

// server/src/antlers/tags/core/userLogoutUrl.ts
var UserLogoutUrl = {
  tagName: "user:logout_url",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [{
    name: "redirect",
    description: "An optional URL to redirect the user after being logged out",
    aliases: [],
    isRequired: false,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string"]
  }],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("user:logout_url", "The `user:logout_url` tag can be used to retrieve the URL that will sign the current user out.", `<a href="{{ user:logout_url }}">Log out</a>`, "https://statamic.dev/tags/user-logout_url");
  }
};
var userLogoutUrl_default = UserLogoutUrl;

// server/src/antlers/tags/core/switch.ts
var Switch = {
  tagName: "switch",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [{
    name: "between",
    description: "A set of values to iterate over",
    aliases: [],
    isRequired: false,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string", "array"]
  }, {
    name: "for",
    description: "A unique name for the switch instance",
    aliases: [],
    isRequired: false,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string"]
  }],
  resolveDocumentation: (params) => {
    return makeTagDoc("switch Tag", "The `switch` tag can be used to alternate between a set of values each time the tag is evaluated.", "https://statamic.dev/tags/switch");
  }
};
var Rotate = {
  tagName: "rotate",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  introducedIn: null,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  parameters: [{
    name: "between",
    description: "A set of values to iterate over",
    aliases: [],
    isRequired: false,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string", "array"]
  }, {
    name: "for",
    description: "A unique name for the switch instance",
    aliases: [],
    isRequired: false,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string"]
  }],
  resolveDocumentation: (params) => {
    return makeTagDoc("rotate Tag", "The `rotate` tag can be used to alternate between a set of values each time the tag is evaluated.", "https://statamic.dev/tags/switch");
  }
};

// server/src/antlers/tags/core/oauth.ts
var OAuth = {
  tagName: "oauth",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [{
    name: "provider",
    description: "The OAuth provider to be used",
    aliases: [],
    isRequired: true,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string"]
  }, {
    name: "redirect",
    description: "The URL to be taken to after authenticating",
    aliases: [],
    isRequired: true,
    acceptsVariableInterpolation: true,
    allowsVariableReference: false,
    isDynamic: false,
    expectsTypes: ["string"]
  }],
  resovleParameterCompletionItems: (parameter, params) => {
    if (parameter.name == "provider") {
      return exclusiveResultList(params.project.getOAuthProviders());
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("oauth Tag", "The `oauth` tag can be used to generate login URls for various third-party services.", `<a href="{{ oauth provider="github" }}">Sign In with Github</a>`, "https://statamic.dev/tags/oauth");
  }
};
var oauth_default = OAuth;

// server/src/antlers/tags/core/sessionDump.ts
var SessionDump = {
  tagName: "session:dump",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  parameters: [],
  introducedIn: null,
  resolveDocumentation: (params) => {
    return makeTagDoc("session:dump Tag", "The `session:dump` tag will display the contents of the user's session to the browser. This tag behaves similarly to the `dd` helper functions, but returns just the session data.", "https://statamic.dev/tags/session-dump");
  }
};
var sessionDump_default = SessionDump;

// server/src/antlers/tags/core/contexts/sessionContext.ts
var SessionVariableContext = class {
  constructor(node) {
    this.node = node;
  }
};

// server/src/antlers/tags/core/sessionSet.ts
var SessionSet = {
  tagName: "session:set",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: true,
  allowsContentClose: true,
  parameters: [],
  introducedIn: null,
  resolveDynamicParameter: returnDynamicParameter,
  resolveSpecialType: (node, project) => {
    const context = new SessionVariableContext(node);
    return {
      context,
      issues: []
    };
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("session:set Tag", "The `session:set` tag is used to add new data to the user's session.", "https://statamic.dev/tags/session-set");
  }
};
var sessionSet_default = SessionSet;

// server/src/references/sessionVariableManager.ts
var SessionVariableManager = class {
  constructor() {
    this.knownVariables = /* @__PURE__ */ new Map();
  }
  registerDocumentSessionVariables(fileContext, contexts) {
    if (!this.knownVariables.has(fileContext)) {
      this.knownVariables.set(fileContext, /* @__PURE__ */ new Map());
    }
    const fileVars = this.knownVariables.get(fileContext);
    fileVars.clear();
    for (let i = 0; i < contexts.length; i++) {
      const node = contexts[i].node;
      if (node.hasParameters) {
        for (let j = 0; j < node.parameters.length; j++) {
          const thisParam = node.parameters[j];
          fileVars.set(thisParam.name, contexts[i]);
        }
      }
    }
  }
  getKnownSessionVariableNames() {
    const variableNames = [];
    this.knownVariables.forEach((mapping) => {
      mapping.forEach((val, name) => {
        if (variableNames.includes(name) == false) {
          variableNames.push(name);
        }
      });
    });
    return variableNames;
  }
};
SessionVariableManager.instance = null;
if (typeof SessionVariableManager.instance == "undefined" || SessionVariableManager.instance == null) {
  SessionVariableManager.instance = new SessionVariableManager();
}
var sessionVariableManager_default = SessionVariableManager;

// server/src/suggestions/uniqueParameterArraySuggestions.ts
var import_vscode_languageserver_types10 = __toESM(require_main2());
function getUniqueParameterArrayValuesSuggestions(paramAttribute, allValues) {
  const items = [], paramValues = paramAttribute.getArrayValue(), valuesToUse = allValues.filter((e) => !paramValues.includes(e));
  for (let i = 0; i < valuesToUse.length; i++) {
    items.push({
      label: valuesToUse[i],
      kind: import_vscode_languageserver_types10.CompletionItemKind.Variable
    });
  }
  return exclusiveResult(items);
}

// server/src/antlers/tags/core/sessionForget.ts
var SessionForget = {
  tagName: "session:forget",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [
    {
      name: "keys",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "The session keys to clear",
      expectsTypes: ["string"],
      isRequired: true,
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "keys" && ((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
      const existingVarNames = (_c = (_b = sessionVariableManager_default.instance) == null ? void 0 : _b.getKnownSessionVariableNames()) != null ? _c : [];
      if (params.context.parameterContext.parameter != null) {
        return getUniqueParameterArrayValuesSuggestions(params.context.parameterContext.parameter, existingVarNames);
      }
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("session:forget Tag", "The `session:forget` tag is used to remove variables from the user's session.", "https://statamic.dev/tags/session-forget");
  }
};
var sessionForget_default = SessionForget;

// server/src/antlers/tags/core/sessionFlush.ts
var SessionFlush = {
  tagName: "session:flush",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  parameters: [],
  introducedIn: null,
  resolveDocumentation: (params) => {
    return makeTagDoc("session:flush Tag", "The `session:flush` tag will clear all values from the visitor's session. If the visitor is currently signed in they will also be signed out.", "https://statamic.dev/tags/session-flush");
  }
};
var sessionFlush_default = SessionFlush;

// server/src/antlers/tags/core/sessionFlash.ts
var SessionFlash = {
  tagName: "session:flash",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  parameters: [],
  introducedIn: null,
  resolveDynamicParameter: returnDynamicParameter,
  resolveSpecialType: (node, project) => {
    const context = new SessionVariableContext(node);
    return {
      context,
      issues: []
    };
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("session:flash Tag", "The `session:flash` tag can be used to add a value to the user's session. Flashed values only persist for a single request, and are then removed.", "https://statamic.dev/tags/session-flash");
  }
};
var sessionFlash_default = SessionFlash;

// server/src/antlers/tags/core/markdownIndent.ts
var MarkdownIndent = {
  tagName: "markdown:indent",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDoc("markdown:indent Tag", "The `markdown:indent` tag is similar to the markdown tag, but will ignore leading whitepsace while rendering the tag's content as markdown.", "https://statamic.dev/tags/markdown-indent");
  }
};
var markdownIndent_default = MarkdownIndent;

// server/src/antlers/tags/core/markdown.ts
var MarkdownCompletionItems = [
  tagToCompletionItem(markdownIndent_default)
];
var Markdown = {
  tagName: "markdown",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [],
  resolveCompletionItems: (params) => {
    if (params.isPastTagPart == false && (params.leftWord == "markdown" || params.leftWord == "/markdown") && params.leftChar == ":") {
      return exclusiveResult(MarkdownCompletionItems);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("markdown Tag", "The `markdown` tag can be used to render the tags contents as markdown.", "https://statamic.dev/tags/markdown");
  }
};
var markdown_default = Markdown;

// server/src/suggestions/project/dotStringCompletions.ts
var import_vscode_languageserver7 = __toESM(require_main4());
function createSuggestionsFromDotStrings(currentValue, values) {
  const items = [];
  let valuesToSuggest = values;
  if (currentValue.trim().length > 0) {
    if (currentValue.includes(".")) {
      if (currentValue.endsWith(".")) {
        const testValue = currentValue.substr(0, currentValue.length - 1);
        valuesToSuggest = valuesToSuggest.filter((e) => e.startsWith(testValue));
      }
    }
  }
  for (let i = 0; i < valuesToSuggest.length; i++) {
    let insertText = valuesToSuggest[i], doAdd = true;
    if (currentValue.includes(".")) {
      if (insertText.startsWith(currentValue) == false) {
        doAdd = false;
      } else {
        insertText = insertText.substr(currentValue.length);
      }
    }
    if (doAdd) {
      items.push({
        label: insertText,
        insertText,
        kind: import_vscode_languageserver7.CompletionItemKind.Text
      });
    }
  }
  return items;
}

// server/src/suggestions/project/routeCompletions.ts
function getRouteCompletions(currentValue, project) {
  return createSuggestionsFromDotStrings(currentValue, project.getRouteNames());
}

// server/src/antlers/tags/core/route.ts
var Route = {
  tagName: "route",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  parameters: [],
  introducedIn: null,
  resolveDynamicParameter: returnDynamicParameter,
  resolveCompletionItems: (params) => {
    if (params.leftMeaningfulWord == "route") {
      const existingRouteValue = getCurrentSymbolMethodNameValue(params);
      return exclusiveResult(getRouteCompletions(existingRouteValue, params.project));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("route Tag", "The `route` tag can be used to generate a full URL [to a named route](https://laravel.com/docs/8.x/routing#named-routes), including any defined route parameters.", "https://statamic.dev/tags/route");
  }
};
var route_default = Route;

// server/src/suggestions/defaults/httpStatusCodes.ts
var import_vscode_languageserver_types11 = __toESM(require_main2());
var RedirectStatusCodes = [
  { label: "301 Permanent", insertText: "301", kind: import_vscode_languageserver_types11.CompletionItemKind.EnumMember },
  { label: "302 Temporary", insertText: "302", kind: import_vscode_languageserver_types11.CompletionItemKind.EnumMember },
  { label: "404 Not Found", insertText: "404", kind: import_vscode_languageserver_types11.CompletionItemKind.EnumMember }
];

// server/src/antlers/tags/core/redirect.ts
var Redirect = {
  tagName: "redirect",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [{
    name: "to",
    description: "The destination URL",
    aliases: ["url"],
    allowsVariableReference: false,
    acceptsVariableInterpolation: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: true
  }, {
    name: "response",
    description: "The HTTP response code to use",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false
  }],
  resovleParameterCompletionItems: (parameter) => {
    if (parameter.name == "response") {
      return exclusiveResult(RedirectStatusCodes);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("redirect Tag", "The `redirect` tag can be used to redirect the site visitor to a URL or named route. An optional HTTP status code can also be specified on the response using the `response` parameter.", "https://statamic.dev/tags/redirect");
  }
};
var redirect_default = Redirect;

// server/src/antlers/tags/core/sections/section.ts
var import_vscode_languageserver_types12 = __toESM(require_main2());

// server/src/references/sectionManager.ts
var SectionManager = class {
  constructor() {
    this.knownSections = /* @__PURE__ */ new Map();
  }
  registerDocumentSections(fileContext, contexts) {
    if (!this.knownSections.has(fileContext)) {
      this.knownSections.set(fileContext, /* @__PURE__ */ new Map());
    }
    const fileSections = this.knownSections.get(fileContext);
    fileSections.clear();
    for (let i = 0; i < contexts.length; i++) {
      const contextRef = contexts[i];
      if (contextRef.node.hasMethodPart()) {
        fileSections.set(contextRef.node.getMethodNameValue(), contextRef);
      }
    }
  }
  getKnownSectionNames() {
    const sectionNames = [];
    this.knownSections.forEach((mapping) => {
      mapping.forEach((val, name) => {
        if (sectionNames.includes(name) == false) {
          sectionNames.push(name);
        }
      });
    });
    return sectionNames;
  }
};
SectionManager.instance = null;
if (typeof SectionManager.instance == "undefined" || SectionManager.instance == null) {
  SectionManager.instance = new SectionManager();
}
var sectionManager_default = SectionManager;

// server/src/antlers/tags/core/sections/section.ts
var Section = {
  tagName: "section",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [],
  resolveCompletionItems: (params) => {
    var _a, _b;
    if ((params.leftWord == "section" || params.leftWord == "/section") && params.leftChar == ":") {
      const items = [], knownSectionNames = (_b = (_a = sectionManager_default.instance) == null ? void 0 : _a.getKnownSectionNames()) != null ? _b : [];
      for (let i = 0; i < knownSectionNames.length; i++) {
        items.push({
          label: knownSectionNames[i],
          kind: import_vscode_languageserver_types12.CompletionItemKind.Field
        });
      }
      return nonExclusiveResult(items);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("section Tag", "The `section` tag is used to push content to a named region defined by the `yield` tag.", "https://statamic.dev/tags/section");
  }
};
var section_default = Section;

// server/src/antlers/tags/core/obfuscate.ts
var Obfuscate = {
  tagName: "obfuscate",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDoc("obfuscate Tag", "The `obfuscate` tag converts the tags's content into a format that is difficult for bots to read, but can easily be viewed by users within their browser.", "https://statamic.dev/tags/obfuscate");
  }
};
var obfuscate_default = Obfuscate;

// server/src/antlers/tags/core/parent.ts
var Parent = {
  tagName: "parent",
  hideFromCompletions: false,
  requiresClose: false,
  allowsContentClose: true,
  allowsArbitraryParameters: false,
  injectParentScope: true,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDoc("parent Tag", "The `parent` tag provides access to data from the current page's parent (the URL one level above the current page).", "https://statamic.dev/tags/parent");
  }
};
var parent_default = Parent;

// server/src/suggestions/project/translationCompletions.ts
function getTranslationSuggestions(currentValue, project) {
  return createSuggestionsFromDotStrings(currentValue, project.getTranslationKeys());
}

// server/src/antlers/tags/core/translate.ts
var TranslateTriggerTagNames = [
  "translate",
  "trans",
  "trans_choice"
];
var Translate = {
  tagName: "translate",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  introducedIn: null,
  allowsArbitraryParameters: true,
  parameters: [
    {
      isRequired: false,
      name: "key",
      description: "The key of the translation string to find",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "locale",
      description: "The locale to be used when translating",
      acceptsVariableInterpolation: false,
      aliases: ["site"],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "count",
      description: "The number of items to use for pluralization",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["number"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a;
    if (parameter.name == "key") {
      let curValue = "";
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null && params.context.parameterContext.parameter != null) {
        curValue = params.context.parameterContext.parameter.value;
      }
      return exclusiveResult(getTranslationSuggestions(curValue, params.project));
    }
    return EmptyCompletionResult;
  },
  resolveDynamicParameter: returnDynamicParameter,
  resolveCompletionItems: (params) => {
    if (params.leftMeaningfulWord != null && TranslateTriggerTagNames.includes(params.leftMeaningfulWord)) {
      const existingTranslateValue = getCurrentSymbolMethodNameValue(params);
      return exclusiveResult(getTranslationSuggestions(existingTranslateValue, params.project));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("trans Tag", "The `trans` tag can be used to retrieve a string for the current locale's language file.", "https://statamic.dev/tags/trans");
  }
};
var TransTag = createDefinitionAlias(Translate, "trans");
var TransChoiceTag = createDefinitionAlias(Translate, "trans_choice");
TransChoiceTag.resolveDocumentation = (params) => {
  return makeTagDoc("trans_choice Tag", "The `trans_choice` tag can be used to retrieve a pluralized string for the current locale's language file.", "https://statamic.dev/tags/trans#pluralization");
};

// server/src/antlers/tags/core/svg.ts
var SVGTag = {
  tagName: "svg",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: false,
      name: "src",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "The SVG filename relative to the project root",
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  resolveDynamicParameter: returnDynamicParameter,
  resolveDocumentation: (params) => {
    return makeTagDoc("svg Tag", "The `svg` tag can be used to render inline SVGs, as well as set attributes on the rendered `<svg>` element.", "https://statamic.dev/tags/svg");
  }
};
var svg_default = SVGTag;

// server/src/antlers/variables/assetVariables.ts
function makeAssetVariables(symbol) {
  return [
    { name: "basename", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "extension", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "filename", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "focus", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "focus_css", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "height", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_asset", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "is_image", dataType: "boolean", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "path", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size", dataType: "string", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_bytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_gigabytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_kilobytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "size_megabytes", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol },
    { name: "width", dataType: "number", sourceName: "*internal.asset", sourceField: null, introducedBy: symbol }
  ];
}

// server/src/antlers/tags/core/asset.ts
var Asset = {
  tagName: "asset",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "The path to the file",
      expectsTypes: ["string"],
      isDynamic: false,
      name: "url"
    }
  ],
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeAssetVariables(symbol));
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("asset Tag", "The `asset` tag can be used to retrive Assets by supplying a URL.", `{{ asset url="/url/for/asset.png" }}
    <img src="{{ url }}" alt="{{ alt }}" />
{{ /asset }}`, "https://statamic.dev/tags/asset");
  }
};
var asset_default = Asset;

// server/src/suggestions/project/assetCompletions.ts
var import_vscode_languageserver_types13 = __toESM(require_main2());
function getAllAssetCompletions(project) {
  const items = [], containers = project.getUniqueAssetNames();
  for (let i = 0; i < containers.length; i++) {
    items.push({ label: containers[i], kind: import_vscode_languageserver_types13.CompletionItemKind.Field });
  }
  return items;
}

// server/src/antlers/tags/core/assets.ts
var AssetContainerParameters = ["container", "id", "handle"];
var Assets = {
  tagName: "assets",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: false,
      name: "container",
      aliases: ["id", "handle"],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The handle of the asset container",
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "folder",
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "Filters the resulting assets by specific folder",
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "recursive",
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "Returns all assets in all subdirectories",
      expectsTypes: ["boolean"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "limit",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Limits the total results",
      expectsTypes: ["number"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "sort",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Sort entries by any asset variable",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    if (AssetContainerParameters.includes(parameter.name)) {
      return exclusiveResult(getAllAssetCompletions(params.project));
    }
    return EmptyCompletionResult;
  },
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeAssetVariables(symbol));
    let containerName = "";
    if (symbol.name != null && symbol.name.getMethodName() != null) {
      containerName = symbol.name.getMethodName();
    } else {
      const containerParam = symbol.findAnyParameter(AssetContainerParameters);
      if (containerParam != null && containerParam.containsSimpleValue()) {
        containerName = containerParam.value;
      }
    }
    if (containerName.length > 0) {
      scope.injectAssetContainer(symbol, containerName);
    }
    return scope;
  },
  resolveCompletionItems: (params) => {
    if ((params.leftWord == "assets" || params.leftWord == "/assets") && params.leftChar == ":") {
      return exclusiveResult(getAllAssetCompletions(params.project));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("assets Tag", "The `assets` tag can be used to retrieve multiple Assets from an Asset container.", `{{ assets container="container-name" }}
    {{# Loop over all assets in the container. #}}
	<img src="{{ url }}" alt="{{ alt }}" />
{{ /assets }}`, "https://statamic.dev/tags/assets");
  }
};
var assets_default = Assets;

// server/src/antlers/tags/core/getContent.ts
var GetContent = {
  tagName: "get_content",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  introducedIn: null,
  allowsArbitraryParameters: false,
  parameters: [
    {
      isRequired: false,
      name: "from",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      description: "The ID to retrieve data for",
      expectsTypes: ["string", "array"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "locale",
      aliases: ["site"],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The locale to show the content in",
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    if (parameter.name == "locale" || parameter.name == "site") {
      return exclusiveResultList(params.project.getSiteNames());
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("get_content Tag", "The `get_content` tag can be used to retrieve content from other entries. This tag accepts the ID of another entry, and will return access to all data for that entry.", `{{ get_content from="the-entry-id" }}
{{ /get_content }}`, "https://statamic.dev/tags/get_content");
  }
};
var getContent_default = GetContent;

// server/src/antlers/variables/fileVariables.ts
function makeFileVariables(symbol) {
  return [
    { name: "basename", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "extension", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "filename", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "is_image", dataType: "boolean", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "file", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "file", dataType: "last_modified", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size", dataType: "string", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_bytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_b", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_gigabytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_gb", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_kilobytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_kb", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_megabytes", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol },
    { name: "size_mb", dataType: "number", sourceName: "*internal.file", sourceField: null, introducedBy: symbol }
  ];
}

// server/src/antlers/tags/core/getFiles.ts
var GetFiles = {
  tagName: "get_files",
  hideFromCompletions: false,
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: false,
      name: "in",
      aliases: ["from"],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The directory to find files in relative to the public directory",
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "depth",
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The depth of the subdirectories",
      expectsTypes: ["number"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "not_in",
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      description: "The subdirectories or pattern to exclude",
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "file_size",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["string"],
      description: "The file size filter to use",
      isDynamic: false
    },
    {
      isRequired: false,
      name: "ext",
      aliases: ["extension"],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      description: "The extension(s) to filter by",
      expectsTypes: ["string", "array"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "include",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: ["match"],
      description: "Filter files by a regular expression",
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "exclude",
      description: "Excludes files by a regular expression",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "file_date",
      description: "Filters files by last modified date",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "limit",
      description: "Limits the total number of results",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["number"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "offset",
      description: "The number of entries the results should be offset by",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["number"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "sort",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Sorts the listing by extension, size, last_modified, or random",
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeFileVariables(symbol));
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("get_files Tag", "The `get_files` tag can be used to display information about files on the site's local filesystem.", "https://statamic.dev/tags/get_files");
  }
};
var getFiles_default = GetFiles;

// server/src/antlers/variables/glideVariables.ts
function makeGlideVariables(node) {
  return [
    { name: "width", dataType: "number", sourceName: "*internal.glide", sourceField: null, introducedBy: node },
    { name: "height", dataType: "number", sourceName: "*internal.glide", sourceField: null, introducedBy: node },
    { name: "url", dataType: "string", sourceName: "*internal.glide", sourceField: null, introducedBy: node }
  ];
}

// server/src/diagnostics/utils.ts
var import_vscode_languageserver_types14 = __toESM(require_main2());
function parameterError(message, symbol, parameter) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  return {
    endLine: (_c = (_b = (_a = parameter.valuePosition) == null ? void 0 : _a.end) == null ? void 0 : _b.line) != null ? _c : 0,
    startLine: (_f = (_e = (_d = parameter.namePosition) == null ? void 0 : _d.start) == null ? void 0 : _e.line) != null ? _f : 0,
    endPos: (_i = (_h = (_g = parameter.valuePosition) == null ? void 0 : _g.end) == null ? void 0 : _h.char) != null ? _i : 0,
    startPos: (_l = (_k = (_j = parameter.namePosition) == null ? void 0 : _j.start) == null ? void 0 : _k.char) != null ? _l : 0,
    message,
    severity: import_vscode_languageserver_types14.DiagnosticSeverity.Error
  };
}

// server/src/antlers/tags/core/glideParameters.ts
var GlideFilters = ["greyscale", "sepia"];
var GlideFormats = [
  "jpg",
  "pjpg",
  "png",
  "gif",
  "webp",
  "tif",
  "bmp",
  "psd"
];
var GlideOrients = ["auto", "0", "90", "180", "270"];
var GlideParameters = [
  {
    isRequired: false,
    name: "src",
    aliases: ["path", "id"],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    description: "The URL of the image when not using shorthand syntax",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "tag",
    aliases: [],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    description: "Outputs an image tag when set to true",
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "alt",
    description: "The alt attribute value to use when generating tags",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "absolute",
    description: "Whether to output full URLs",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    name: "width",
    expectsTypes: ["number"],
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "The width of the image, in pixels",
    isDynamic: false
  },
  {
    name: "height",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: [],
    description: "The height of the image, in pixels",
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "square",
    expectsTypes: ["number"],
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "Sets both then height and width of the iamge",
    isDynamic: false,
    isRequired: false
  },
  {
    name: "fit",
    expectsTypes: ["string"],
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "How the image is fitted to its target dimensions",
    isDynamic: false,
    isRequired: false
  },
  {
    name: "crop",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "Crops the image to the specific dimensions",
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "orient",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "Rotates the image",
    expectsTypes: ["*"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (parameter.value.trim().length > 0 && !GlideOrients.includes(parameter.value)) {
        issues.push(parameterError("Invalid orient value", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "quality",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "Defines the quality of the image",
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "dpr",
    allowsVariableReference: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    description: "Defines the device pixel ratio",
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const intVal = parseInt(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (intVal < 1 || intVal > 8) {
        issues.push(parameterError("dpr must be an integer between 1 and 8.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "format",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    description: "Encodes the image to a specific format",
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (parameter.value.trim().length > 0 && !GlideFormats.includes(parameter.value)) {
        issues.push(parameterError("Format must be one of: " + GlideFormats.join(","), node, parameter));
      }
      return issues;
    }
  },
  {
    name: "bg",
    description: "Sets the background color for transparent images",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "blur",
    description: "Adds a blur effect to the image",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const intVal = parseInt(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (intVal < 0 || intVal > 100) {
        issues.push(parameterError("blur must be a value between 0 and 100.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "brightness",
    description: "Adjusts the image brightness",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const intVal = parseInt(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (intVal < -100 || intVal > 100) {
        issues.push(parameterError("brightness must be a value between -100 and 100.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "contrast",
    description: "Adjusts the image contrast",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const intVal = parseInt(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (intVal < -100 || intVal > 100) {
        issues.push(parameterError("contrast must be a value between -100 and 100.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "gamma",
    description: "Adjusts the image gamma",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const floatVal = parseFloat(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (floatVal < 0.1 || floatVal > 9.99) {
        issues.push(parameterError("gamma must be a value between 0.1 and 9.99.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "sharpen",
    description: "Sharpens the iamge",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const intVal = parseInt(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (intVal < 0 || intVal > 100) {
        issues.push(parameterError("sharpen must be a value between 0 and 100.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "pixelate",
    description: "Applies a pixelation effect to the image",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const intVal = parseInt(parameter.value), issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (intVal < 0 || intVal > 100) {
        issues.push(parameterError("pixelate must be a value between 0 and 100.", node, parameter));
      }
      return issues;
    }
  },
  {
    name: "filter",
    description: "Applies a filter effect to the image",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false,
    validate: (node, parameter) => {
      const issues = [];
      if (!parameter.containsSimpleValue()) {
        return issues;
      }
      if (parameter.value.trim().length > 0 && !GlideFilters.includes(parameter.value)) {
        issues.push(parameterError("Filter must be one of: " + GlideFilters.join(","), node, parameter));
      }
      return issues;
    }
  },
  {
    name: "preset",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    expectsTypes: ["string"],
    description: "A collection of pre-configured image manipulation parameters.",
    isDynamic: false,
    isRequired: false
  }
];
function resolveGlideParameterCompletions(parameter, params) {
  if (parameter.name == "orient") {
    return exclusiveResultList(GlideOrients);
  } else if (parameter.name == "format") {
    return exclusiveResultList(GlideFormats);
  } else if (parameter.name == "filter") {
    return exclusiveResultList(GlideFilters);
  } else if (parameter.name == "preset") {
    return exclusiveResultList(params.project.getAssetPresets());
  }
  return EmptyCompletionResult;
}

// server/src/antlers/tags/core/glideBatch.ts
var GlideBatch = {
  tagName: "glide:batch",
  hideFromCompletions: false,
  requiresClose: true,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  injectParentScope: false,
  parameters: GlideParameters,
  introducedIn: null,
  augmentScope: (node, scope) => {
    scope.addVariables(makeGlideVariables(node));
    return scope;
  },
  resovleParameterCompletionItems: resolveGlideParameterCompletions,
  resolveDocumentation: (params) => {
    return makeTagDoc("glide:batch Tag", "The `glide:batch` tag is similar to the glide tag, but can be used to apply image manipulations to multiple images within a piece of content.", "https://statamic.dev/tags/glide-batch");
  }
};
var glideBatch_default = GlideBatch;

// server/src/antlers/tags/core/glide.ts
var GlideCompletionItems = [
  tagToCompletionItem(glideBatch_default)
];
var Glide = {
  tagName: "glide",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  injectParentScope: false,
  requiresClose: false,
  parameters: GlideParameters,
  introducedIn: null,
  augmentScope: (node, scope) => {
    scope.addVariables(makeGlideVariables(node));
    return scope;
  },
  resovleParameterCompletionItems: resolveGlideParameterCompletions,
  resolveCompletionItems: (params) => {
    if (params.isPastTagPart == false && (params.leftWord == "glide" || params.leftWord == "/glide") && params.leftChar == ":") {
      return exclusiveResult(GlideCompletionItems);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("glide Tag", "The `glide` tag is used to manipulate images on the fly. Image manipulations may include resizing, cropping, or adjusting sharpness and constrast, amongst many others.", "https://statamic.dev/tags/glide");
  }
};
var glide_default = Glide;

// server/src/antlers/tags/core/iterate.ts
var IterateTag = {
  tagName: "iterate",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "as",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Optionally rename the key/value variables",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "array",
      acceptsVariableInterpolation: true,
      aliases: [],
      allowsVariableReference: true,
      description: "The array to iterate",
      expectsTypes: ["array"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("iterate Tag", "The `iterate` tag can be used to iterate over arbitrary arrays.", "https://statamic.dev/tags/foreach");
  }
};
var ForeachTag = {
  tagName: "foreach",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "as",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "Optionally rename the key/value variables",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "array",
      acceptsVariableInterpolation: true,
      aliases: [],
      allowsVariableReference: true,
      description: "The array to iterate",
      expectsTypes: ["array"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("foreach Tag", "The `foreach` tag can be used to iterate over arbitrary arrays.", "https://statamic.dev/tags/foreach");
  }
};

// server/src/antlers/variables/localeVariables.ts
function makeLocaleVariables(node) {
  return [
    { name: "url", dataType: "string", sourceField: null, sourceName: "*internal.locale", introducedBy: node },
    { name: "name", dataType: "string", sourceField: null, sourceName: "*internal.locale", introducedBy: node }
  ];
}

// server/src/antlers/tags/core/localeParameters.ts
var LocaleParameters = [
  {
    isRequired: false,
    name: "id",
    description: "The ID of the content to localize",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    name: "sort",
    description: "Sort by a sites key",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "current_first",
    description: "When true, ensures that the current locale is first",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    name: "all",
    description: "When true, all locale data will be returned.",
    acceptsVariableInterpolation: true,
    aliases: [],
    allowsVariableReference: true,
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: true,
    name: "self",
    description: "When true, the current locale will be included.",
    acceptsVariableInterpolation: true,
    aliases: [],
    allowsVariableReference: true,
    expectsTypes: ["boolean"],
    isDynamic: false
  }
];

// server/src/antlers/tags/core/localeCount.ts
var LocalesCount = {
  tagName: "locales:count",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  injectParentScope: false,
  requiresClose: true,
  parameters: LocaleParameters,
  introducedIn: "3.0.36",
  resolveDocumentation: (params) => {
    return makeTagDoc("locales:count Tag", "The `locales:count` tag can be used to count the number of locales the current content is available in.", "https://statamic.dev/tags/locales-count");
  }
};
var localeCount_default = LocalesCount;

// server/src/antlers/tags/core/locales.ts
var LocalesCompletionItems = [
  tagToCompletionItem(localeCount_default)
];
var Locales = {
  tagName: "locales",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  injectParentScope: false,
  requiresClose: true,
  parameters: LocaleParameters,
  introducedIn: null,
  augmentScope: (node, scope) => {
    scope.addVariableArray("locale", makeLocaleVariables(node));
    scope.addVariable({
      name: "current",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.locale",
      introducedBy: node
    });
    scope.addVariable({
      name: "is_current",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.locale",
      introducedBy: node
    });
    scope.addVariable({
      name: "exists",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.locale",
      introducedBy: node
    });
    scope.addVariable({
      name: "permalink",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.locale",
      introducedBy: node
    });
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("locales Tag", "The `locales` tag can be used to access all the locales the current content is available in.", "https://statamic.dev/tags/locales");
  },
  resolveCompletionItems: (params) => {
    if (params.isPastTagPart == false && (params.leftWord == "locale" || params.leftWord == "/locale") && params.leftChar == ":") {
      return exclusiveResult(LocalesCompletionItems);
    }
    return EmptyCompletionResult;
  }
};
var locales_default = Locales;

// server/src/antlers/tags/core/mix.ts
var Mix = {
  tagName: "mix",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: false,
      name: "src",
      description: "The path to the versioned file, relative to the public directory",
      acceptsVariableInterpolation: false,
      aliases: ["path"],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      name: "in",
      description: "The location of the mix manifest file",
      acceptsVariableInterpolation: false,
      aliases: ["from"],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("mix Tag", "The `mix` tag is used to return the path of CSS and JavaScript files versioned with [Laravel Mix](https://laravel.com/docs/8.x/mix).", "https://statamic.dev/tags/mix");
  }
};
var mix_default = Mix;

// server/src/antlers/tags/core/user/permissionUtils.ts
var import_vscode_languageserver_types15 = __toESM(require_main2());
function getAllGroupSuggestionsn(project) {
  const items = [], userGroups = project.getUniqueUserGroupNames();
  for (let i = 0; i < userGroups.length; i++) {
    items.push({
      label: userGroups[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
function getAllRolesSuggestions(project) {
  const items = [], userRoles = project.getUniqueUserRoleNames();
  for (let i = 0; i < userRoles.length; i++) {
    items.push({
      label: userRoles[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
function makeUserGroupSuggestions(existingValues, project) {
  const items = [], userGroups = project.getUniqueUserGroupNames(), groupsToReturn = userGroups.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < groupsToReturn.length; i++) {
    items.push({
      label: groupsToReturn[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}
function makeUserRolesSuggestions(existingValues, project) {
  const items = [], userRoles = project.getUniqueUserRoleNames(), rolesToReturn = userRoles.filter((e) => !existingValues.includes(e));
  for (let i = 0; i < rolesToReturn.length; i++) {
    items.push({
      label: rolesToReturn[i],
      kind: import_vscode_languageserver_types15.CompletionItemKind.Field
    });
  }
  return items;
}

// server/src/antlers/tags/core/userIn.ts
var UserIn = {
  tagName: "user:in",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: ["groups"],
      allowsVariableReference: false,
      name: "group",
      description: "The groups to check against",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "groups" || parameter.name == "group") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeUserGroupSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
      }
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:in Tag", "The `user:in` tag can be used to check if the currently authenticated user belongs to one or more user groups. When used as a tag pair, the tag contents will only be rendered if the user belongs to the specified groups.", "https://statamic.dev/tags/user-in");
  }
};
var userIn_default = UserIn;

// server/src/antlers/tags/core/userNotIn.ts
var UserNotIn = {
  tagName: "user:not_in",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: ["groups"],
      allowsVariableReference: false,
      name: "group",
      description: "The groups to check against",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "groups" || parameter.name == "group") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeUserGroupSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
      }
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:not_in Tag", "The `user:not_in` tag can be used to check if the currently authenticated user does not belong to one or more user groups. When used as a tag pair, the tag contents will be rendered if the user does not belong to the specified groups.", "https://statamic.dev/tags/user-in#not-in");
  }
};
var userNotIn_default = UserNotIn;

// server/src/antlers/tags/core/userIs.ts
var UserIs = {
  tagName: "user:is",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: ["roles"],
      allowsVariableReference: false,
      name: "role",
      description: "The roles to check against",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "roles" || parameter.name == "role") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeUserRolesSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
      }
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:is Tag", "The `user:is` tag can be used to check whether the currently authenticated user has one or more roles.", "https://statamic.dev/tags/user-is");
  }
};
var userIs_default = UserIs;

// server/src/antlers/tags/core/userIsnt.ts
var UserIsnt = {
  tagName: "user:isnt",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: ["roles"],
      allowsVariableReference: false,
      name: "role",
      description: "The roles to check against",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "roles" || parameter.name == "role") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeUserRolesSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
      }
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:isnt Tag", "The `user:isnt` tag can be used to check whether the currently authenticated user does not have one or more roles.", "https://statamic.dev/tags/user-is#isnt");
  }
};
var userIsnt_default = UserIsnt;

// server/src/antlers/tags/core/in.ts
var In = {
  tagName: "in",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: ["groups"],
      allowsVariableReference: false,
      name: "group",
      description: "The groups to check against",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "groups" || parameter.name == "group") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeUserGroupSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
      }
    }
    return null;
  },
  resolveCompletionItems: (params) => {
    if ((params.leftWord == "in" || params.leftWord == "/in") && params.leftChar == ":") {
      return exclusiveResult(getAllGroupSuggestionsn(params.project));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("in Tag", "The `in` tag can be used to check if the authenticated user belongs to one or more groups. This tag operates similarly to the `user:in` tag.", "https://statamic.dev/tags/user-in");
  }
};
var in_default = In;

// server/src/antlers/tags/core/notFound.ts
var NotFound = {
  tagName: "not_found",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  parameters: [],
  introducedIn: null,
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("404 (Not Found) Tag", "The `not_found` tag will trigger a 404 status code, and display the 404 template to the site visitor.", `{{ unless logged_in }}
	{{# Display the 404 Not Found page. #}}
	{{ not_found }}
{{ /unless }}`, "https://statamic.dev/tags/404");
  }
};
var notFound_default = NotFound;

// server/src/antlers/tags/core/is.ts
var Is = {
  tagName: "is",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      acceptsVariableInterpolation: false,
      aliases: ["roles"],
      allowsVariableReference: false,
      name: "role",
      description: "The roles to check against",
      expectsTypes: ["string", "array"],
      isDynamic: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    var _a, _b, _c;
    if (parameter.name == "roles" || parameter.name == "role") {
      if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
        return exclusiveResult(makeUserRolesSuggestions((_c = (_b = params.context.parameterContext.parameter) == null ? void 0 : _b.getArrayValue()) != null ? _c : [], params.project));
      }
    }
    return null;
  },
  resolveCompletionItems: (params) => {
    if ((params.leftWord == "is" || params.leftWord == "/is") && params.leftChar == ":") {
      return exclusiveResult(getAllRolesSuggestions(params.project));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("is Tag", "The `is` tag can be used to check whether the currently authenticated user has one or more roles. This tag behaves the same as the `user:is` tag.", "https://statamic.dev/tags/user-is");
  }
};
var is_default = Is;

// server/src/antlers/tags/core/widont.ts
var Widont = {
  tagName: "widont",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("widont Tag", "The `widont` tag is similar to the [widont modifier](https://statamic.dev/modifiers/widont), and will attempt to prevent lines with a single word from appearing within the tags rendered output.", `{{ widont }}
    {{ content }}
{{ /widont }}`, null);
  }
};
var widont_default = Widont;

// server/src/antlers/tags/core/userProfileParameters.ts
var UserProfileParameters = [
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    allowsVariableReference: true,
    aliases: [],
    name: "id",
    description: "The user ID to fetch",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    allowsVariableReference: true,
    aliases: [],
    name: "email",
    description: "The email address to find the user by",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    allowsVariableReference: true,
    aliases: [],
    name: "field",
    description: "The field to fetch the user by",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    allowsVariableReference: true,
    aliases: [],
    name: "value",
    description: "The value to search for",
    expectsTypes: ["string"],
    isDynamic: false
  }
];

// server/src/antlers/tags/core/userProfile.ts
var UserProfile = {
  tagName: "user:profile",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  parameters: UserProfileParameters,
  introducedIn: null,
  augmentScope: (node, scope) => {
    scope.injectBlueprint(node, "user");
    return scope;
  },
  resovleParameterCompletionItems: (parameter, params) => {
    if (parameter.name == "field") {
      return exclusiveResult(formatSuggestionList(params.project.getUserFields()));
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:profile Tag", "The `user:profile` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter", null);
  }
};
var userProfile_default = UserProfile;

// server/src/antlers/tags/core/dd.ts
var DdTag = {
  tagName: "dd",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("dd Tag", "The `dd` tag is a useful tag for debugging, and will display the raw data available at the point the tag is rendered. This tag will stop the template from rendering after it is encountered.  If Ignition is available, this tag will use the [ddd](https://flareapp.io/blog/1-introducing-ddd-a-new-global-helper-for-laravel) method.", `{{ collection:articles }}
	{{#
		View all data available, for the first
		entry that renders the dd tag.
	#}}
    {{ dd }}
{{ /collection:articles }}`, null);
  }
};
var DddTag = {
  tagName: "ddd",
  hideFromCompletions: false,
  requiresClose: false,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("ddd Tag", "The `ddd` tag is a useful tag for debugging, and will display the raw data available at the point the tag is rendered. This tag will stop the template from rendering after it is encountered.  If Ignition is available, this tag will use the [ddd](https://flareapp.io/blog/1-introducing-ddd-a-new-global-helper-for-laravel) method.", `{{ collection:articles }}
	{{#
		View all data available, for the first
		entry that renders the ddd tag.
	#}}
    {{ ddd }}
{{ /collection:articles }}`, null);
  }
};

// server/src/antlers/tags/core/path.ts
var PathTag = {
  tagName: "path",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: false,
      acceptsVariableInterpolation: false,
      aliases: ["src"],
      allowsVariableReference: true,
      description: "The path source",
      name: "to",
      isDynamic: false,
      expectsTypes: ["string"]
    },
    {
      isRequired: false,
      allowsVariableReference: true,
      acceptsVariableInterpolation: false,
      aliases: [],
      description: "Whether to generate absolute paths",
      expectsTypes: ["boolean"],
      isDynamic: false,
      name: "absolute"
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("path Tag", "The `path` tag can be used to generate URLs from relative URLs, or an entry ID.", null);
  }
};
var path_default = PathTag;

// server/src/antlers/tags/core/userCant.ts
var UserCant = {
  tagName: "user:cant",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: false,
  allowsContentClose: true,
  introducedIn: null,
  resovleParameterCompletionItems: resolveUserParameterCompletionItems,
  parameters: [
    {
      name: "do",
      acceptsVariableInterpolation: false,
      aliases: ["permission"],
      allowsVariableReference: false,
      description: "The permissions to check against",
      expectsTypes: ["string"],
      isRequired: true,
      isDynamic: false
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("user:cant Tag", "The `user:cant` tag is used to check if the currently authenticated user does not have a specific set of permissions. When used as a tag pair, the tag contents will only be rendered if the user does not have the specified permissions.", "https://statamic.dev/tags/user-can#cant");
  }
};
var userCant_default = UserCant;

// server/src/antlers/tags/core/queryTag.ts
var QueryTag = {
  tagName: "query",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: true,
  introducedIn: null,
  parameters: [
    {
      name: "builder",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      description: "The query to evaluate",
      expectsTypes: ["string"],
      isRequired: true,
      isDynamic: false
    }
  ]
};
var queryTag_default = QueryTag;

// server/src/antlers/tags/core/theme/theme.ts
var import_vscode_languageserver_types16 = __toESM(require_main2());

// server/src/antlers/tags/core/theme/themeParameters.ts
var ThemePathParameters = [
  {
    isRequired: true,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    name: "src",
    description: "The relative path to the file",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    name: "cache_bust",
    description: "Whether to output the last modified date",
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    name: "version",
    description: "Whether to check a versioning manifest to produce the final URL",
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    name: "absolute",
    description: "Generate absolute URLs or not",
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: true,
    name: "locale",
    description: "The locale the path should be generated in",
    expectsTypes: ["string"],
    isDynamic: false
  }
];

// server/src/antlers/tags/core/theme/theme.ts
var ThemeTagCompletionItems = [
  { label: "asset", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
  { label: "css", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
  { label: "img", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
  { label: "js", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
  { label: "output", kind: import_vscode_languageserver_types16.CompletionItemKind.Text },
  { label: "path", kind: import_vscode_languageserver_types16.CompletionItemKind.Text }
];
var Theme = {
  tagName: "theme",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  introducedIn: null,
  injectParentScope: false,
  parameters: ThemePathParameters,
  resolveCompletionItems: (params) => {
    if (params.isPastTagPart == false && (params.leftWord == "theme" || params.leftWord == "/theme") && params.leftChar == ":") {
      return exclusiveResult(ThemeTagCompletionItems);
    }
    return EmptyCompletionResult;
  }
};
var theme_default = Theme;

// server/src/antlers/tags/core/theme/themePath.ts
var ThemePath = {
  tagName: "theme:path",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: ThemePathParameters,
  resolveDocumentation: (params) => {
    return makeTagDoc("theme:path Tag", "The `theme:path` tag may be used to generate URLs for public assets. This tag may also optionally add the current locale, generate relative URLs, or add cache busting URL parameters to the end of the generated URL.", null);
  }
};
var ThemeAsset = createDefinitionAlias(ThemePath, "theme:asset");

// server/src/antlers/tags/core/theme/themeCss.ts
var ThemeCss = {
  tagName: "theme:css",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    ...ThemePathParameters,
    {
      isRequired: false,
      isDynamic: false,
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: true,
      name: "tag",
      description: "Whether to generate an HTML tag",
      expectsTypes: ["boolean"]
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("theme:css Tag", "The `theme:css` tag may be used to generate a CSS path relative to a public `css/` directory for any arbitrary file path. This tag may also optionally create the HTML `link` tag.", null);
  }
};
var themeCss_default = ThemeCss;

// server/src/antlers/tags/core/theme/themeImg.ts
var ThemeImg = {
  tagName: "theme:img",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    ...ThemePathParameters,
    {
      isRequired: false,
      isDynamic: false,
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: true,
      name: "tag",
      description: "Whether to generate an HTML tag",
      expectsTypes: ["boolean"]
    },
    {
      isRequired: false,
      isDynamic: false,
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: true,
      name: "alt",
      description: "The alt text to use when generating the HTML tag",
      expectsTypes: ["string"]
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("theme:img Tag", "The `theme:img` tag may be used to generate an image path relative to a public `img/` directory for any arbitrary file path. This tag may also optionally create the HTML `img` tag.", null);
  }
};
var themeImg_default = ThemeImg;

// server/src/antlers/tags/core/theme/themeJs.ts
var ThemeJavaScript = {
  tagName: "theme:js",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    ...ThemePathParameters,
    {
      isRequired: false,
      isDynamic: false,
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: true,
      name: "tag",
      description: "Whether to generate an HTML tag",
      expectsTypes: ["boolean"]
    }
  ],
  resolveDocumentation: (params) => {
    return makeTagDoc("theme:js Tag", "The `theme:js` tag may be used to generate a JavaScript path relative to a public `js/` directory for any arbitrary file path. This tag may also optionally create the HTML `script` tag.", null);
  }
};
var themeJs_default = ThemeJavaScript;

// server/src/antlers/tags/core/theme/themeOutput.ts
var ThemeOutput = {
  tagName: "theme:output",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: true,
  requiresClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      isRequired: true,
      allowsVariableReference: true,
      acceptsVariableInterpolation: false,
      aliases: [],
      name: "src",
      description: "The path to the file",
      expectsTypes: ["string"],
      isDynamic: false
    },
    {
      isRequired: false,
      allowsVariableReference: true,
      acceptsVariableInterpolation: false,
      aliases: [],
      name: "as",
      description: "An optional alias for the contents variable",
      expectsTypes: ["string"],
      isDynamic: false
    }
  ],
  augmentScope: (node, scope) => {
    if (node.isClosedBy != null) {
      const param = node.findParameter("as");
      if (param != null) {
        scope.addVariable({
          name: param.value,
          dataType: "string",
          sourceField: null,
          sourceName: "*internal.theme.context",
          introducedBy: node
        });
      } else {
        scope.addVariable({
          name: "output_contents",
          dataType: "string",
          sourceField: null,
          sourceName: "*internal.theme.context",
          introducedBy: node
        });
      }
    }
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("theme:output Tag", "The `theme:output` tag may be used to output the contents of any arbitrary file, relative to the site's `resources/` directory.", null);
  }
};
var themeOutput_default = ThemeOutput;

// server/src/antlers/tags/core/scopeTag.ts
var ScopeTag = {
  tagName: "scope",
  hideFromCompletions: false,
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("scope Tag", "The `scope` tag creates a copy of all available variables, and saves them to a new  *array* variable defined by the tag's method part.", `{{ scope:scope_name }}
    {{ scope_name:title }}
{{ /scope:scope_name }}
`, null);
  }
};
var scopeTag_default = ScopeTag;

// server/src/antlers/tags/core/conditions/if.ts
var If = {
  tagName: "if",
  hideFromCompletions: true,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: true,
  introducedIn: null,
  parameters: [],
  resolveDynamicParameter: returnDynamicParameter,
  resolveDocumentation: (params) => {
    return makeTagDoc("if Conditional Control Structure", "The contents of the `if` tag will be rendered when it's expression evaluates to `true`.", "https://statamic.dev/antlers#conditions");
  }
};
var if_default = If;

// server/src/antlers/tags/core/conditions/elseIf.ts
var ElseIf = {
  tagName: "elseif",
  hideFromCompletions: true,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: true,
  introducedIn: null,
  parameters: [],
  resolveDynamicParameter: returnDynamicParameter,
  resolveDocumentation: (params) => {
    return makeTagDoc("elseif Conditional Control Structure", "The contents of the `elseif` tag will be rendered when it's expression evaluates to `true`.", "https://statamic.dev/antlers#conditions");
  }
};
var elseIf_default = ElseIf;

// server/src/antlers/tags/core/conditions/else.ts
var Else = {
  tagName: "else",
  hideFromCompletions: true,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: true,
  introducedIn: null,
  parameters: [],
  resolveDocumentation: (params) => {
    return makeTagDoc("else Conditional Control Structure", "The contents of the `else` control structure will be evaluated when all previous conditional branch conditions were not met.", "https://statamic.dev/antlers#conditions");
  }
};
var else_default = Else;

// server/src/antlers/tags/core/session.ts
var import_vscode_languageserver_types17 = __toESM(require_main2());

// server/src/antlers/tags/core/sessionHas.ts
var SessionHas = {
  tagName: "session:has",
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: false,
  allowsArbitraryParameters: true,
  allowsContentClose: true,
  parameters: [],
  introducedIn: "3.1.28",
  resolveDynamicParameter: returnDynamicParameter,
  resolveDocumentation: (params) => {
    return makeTagDoc("session:has Tag", "The `session:has` tag can be used to determine of the user's session contains a specific variable.", "https://statamic.dev/tags/session-has");
  }
};
var sessionHas_default = SessionHas;

// server/src/antlers/tags/core/session.ts
var SessionTagCompletionItems = [
  tagToCompletionItem(sessionSet_default),
  tagToCompletionItem(sessionFlash_default),
  tagToCompletionItem(sessionForget_default),
  tagToCompletionItem(sessionFlush_default),
  tagToCompletionItem(sessionHas_default),
  tagToCompletionItem(sessionDump_default)
];
var SessionTag = {
  tagName: "session",
  requiresClose: false,
  allowsContentClose: true,
  allowsArbitraryParameters: false,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "as",
      description: "An optional alias for the session data",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveCompletionItems: (params) => {
    var _a, _b;
    if (params.isPastTagPart == false && (params.leftWord == "session" || params.leftWord == "/session") && params.leftChar == ":") {
      const knownSessionVars = (_b = (_a = sessionVariableManager_default.instance) == null ? void 0 : _a.getKnownSessionVariableNames()) != null ? _b : [];
      let sessionCompletions = [];
      sessionCompletions = sessionCompletions.concat(SessionTagCompletionItems);
      for (let i = 0; i < knownSessionVars.length; i++) {
        sessionCompletions.push({
          label: knownSessionVars[i],
          kind: import_vscode_languageserver_types17.CompletionItemKind.Variable
        });
      }
      return exclusiveResult(sessionCompletions);
    }
    return EmptyCompletionResult;
  },
  augmentScope: (node, scope) => {
    var _a, _b;
    const asParam = node.findParameter("as"), knownParams = (_b = (_a = sessionVariableManager_default.instance) == null ? void 0 : _a.getKnownSessionVariableNames()) != null ? _b : [], scopeVariables = [];
    for (let i = 0; i < knownParams.length; i++) {
      scopeVariables.push({
        dataType: "*",
        name: knownParams[i],
        sourceField: null,
        sourceName: "project.session",
        introducedBy: node
      });
    }
    if (asParam == null) {
      scope.addVariables(scopeVariables);
    } else {
      scope.addVariableArray(asParam.value, scopeVariables);
    }
    return scope;
  }
};
var session_default = SessionTag;

// server/src/antlers/tags/core/userForgotPasswordForm.ts
var UserForgotPasswordForm = {
  tagName: "user:forgot_password_form",
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "redirect",
      description: "Where the user should be taken after submitting the form",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDynamicParameter: returnDynamicParameter,
  augmentScope: (node, scope) => {
    scope.addVariables([
      {
        name: "success",
        dataType: "boolean",
        sourceField: null,
        sourceName: "*internal.user.reset_password",
        introducedBy: node
      },
      {
        name: "url_invalid",
        dataType: "boolean",
        sourceField: null,
        sourceName: "*internal.user.reset_password",
        introducedBy: node
      },
      {
        name: "errors",
        dataType: "array",
        sourceField: null,
        sourceName: "*internal.user.reset_password",
        introducedBy: node
      }
    ]);
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:forgot_password_form Tag", 'The `user:forgot_password_form` tag is used to quickly create a "forgot password" form for site users.', "https://statamic.dev/tags/user-forgot_password_form");
  }
};
var MemberForgotPasswordForm = createDefinitionAlias(UserForgotPasswordForm, "member:forgot_password_form");
MemberForgotPasswordForm.resolveDocumentation = (params) => {
  return makeTagDoc("member:forgot_password_form Tag", 'The `member:forgot_password_form` tag is used to quickly create a "forgot password" form for site users.', "https://statamic.dev/tags/user-forgot_password_form");
};

// server/src/antlers/tags/core/userPasswordReset.ts
var UserPasswordReset = {
  tagName: "user:reset_password_form",
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "redirect",
      description: "Where the user should be taken after submitting the form",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDynamicParameter: returnDynamicParameter,
  augmentScope: (node, scope) => {
    scope.addVariables([
      {
        name: "success",
        dataType: "boolean",
        sourceField: null,
        sourceName: "*internal.user.password_reset",
        introducedBy: node
      },
      {
        name: "url_invalid",
        dataType: "boolean",
        sourceField: null,
        sourceName: "*internal.user.password_reset",
        introducedBy: node
      },
      {
        name: "errors",
        dataType: "array",
        sourceField: null,
        sourceName: "*internal.user.password_reset",
        introducedBy: node
      }
    ]);
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:reset_password_form Tag", "The `user:reset_password_form` tag is used to quickly create password reset forms. Forms created with this tag should be displayed after a user has received and clicked a password reset email link.", "https://statamic.dev/tags/user-reset_password_form");
  }
};
var MemberPasswordReset = createDefinitionAlias(UserPasswordReset, "member:reset_password_form");
MemberPasswordReset.resolveDocumentation = (params) => {
  return makeTagDoc("member:reset_password_form Tag", "The `member:reset_password_form` tag is used to quickly create password reset forms. Forms created with this tag should be displayed after a user has received and clicked a password reset email link.", "https://statamic.dev/tags/user-reset_password_form");
};

// server/src/antlers/scope/scopeUtilities.ts
function blueprintFieldToScopeVariable(symbol, field) {
  return {
    sourceName: field.blueprintName,
    dataType: field.type,
    name: field.name,
    sourceField: field,
    introducedBy: symbol
  };
}
function valuesToDataMap(variables) {
  const mapToReturn = /* @__PURE__ */ new Map();
  for (let i = 0; i < variables.length; i++) {
    mapToReturn.set(variables[i].name, variables[i]);
  }
  return mapToReturn;
}
function blueprintFieldsToScopeVariables(symbol, blueprintFields) {
  const variables = [];
  for (let i = 0; i < blueprintFields.length; i++) {
    const field = blueprintFields[i];
    variables.push({
      sourceName: field.blueprintName,
      dataType: field.type,
      name: field.name,
      sourceField: field,
      introducedBy: symbol
    });
  }
  return variables;
}

// server/src/antlers/variables/forms/fieldsVariables.ts
function makeFieldsVariables(node) {
  return [
    { name: "handle", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "display", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "type", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "field", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "error", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "instructions", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node },
    { name: "old", dataType: "string", sourceName: "*internal.forms.fields", sourceField: null, introducedBy: node }
  ];
}

// server/src/antlers/tags/core/userRegister.ts
var UserRegister = {
  tagName: "user:register_form",
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "redirect",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      description: "Where the user should be redirected after registering",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "error_redirect",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      description: "Where the user should be redirected after failed registration attempts",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "allow_request_redirect",
      description: "Indicates if query parameters can override the redirect and error_redirect parameters",
      acceptsVariableInterpolation: false,
      allowsVariableReference: true,
      aliases: [],
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDynamicParameter: returnDynamicParameter,
  augmentScope: (node, scope) => {
    scope.addVariableArray("fields", makeFieldsVariables(node));
    scope.addVariable({ name: "errors", dataType: "array", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
    scope.addVariable({ name: "old", dataType: "array", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
    scope.addVariable({ name: "error", dataType: "array", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
    scope.addVariable({ name: "success", dataType: "string", sourceName: "*internal.user.register_form", sourceField: null, introducedBy: node });
    const userFields = scope.statamicProject.getUserFields();
    if (userFields.length > 0) {
      const userFormFields = blueprintFieldsToScopeVariables(node, userFields);
      scope.addVariableArray("old", userFormFields);
      scope.addVariableArray("error", userFormFields);
    }
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:register_form  Form Tag", "The `user:register_form` tag can be used to build out public registration forms for new users.", "https://statamic.dev/tags/user-register_form");
  }
};
var MemberRegister = createDefinitionAlias(UserRegister, "member:register_form");
MemberRegister.resolveDocumentation = (params) => {
  return makeTagDoc("member:register_form Tag", "The `member:register_form` tag can be used to build out public registration forms for new users.", "https://statamic.dev/tags/user-register_form");
};

// server/src/antlers/tags/core/user.ts
var UserTagCompletionItems = [
  tagToCompletionItem(userIs_default),
  tagToCompletionItem(userNotIn_default),
  tagToCompletionItem(userIsnt_default),
  tagToCompletionItem(userProfile_default),
  tagToCompletionItem(userCan_default),
  tagToCompletionItem(userCant_default),
  tagToCompletionItem(UserForgotPasswordForm),
  tagToCompletionItem(userLogout_default),
  tagToCompletionItem(userLogoutUrl_default),
  tagToCompletionItem(UserRegister),
  tagToCompletionItem(UserPasswordReset)
];
var User = {
  tagName: "user",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  parameters: UserProfileParameters,
  introducedIn: null,
  resovleParameterCompletionItems: (parameter, params) => {
    if (params.isPastTagPart == false && params.currentNode != null && params.currentNode.methodIsEmptyOrMatches("profile")) {
      if (parameter.name == "field") {
        return exclusiveResult(formatSuggestionList(params.project.getUserFields()));
      }
    }
    return EmptyCompletionResult;
  },
  augmentScope: (node, scope) => {
    if (node.methodIsEmptyOrMatches("profile")) {
      scope.injectUserFields(node);
    }
    return scope;
  },
  resolveCompletionItems: (params) => {
    if ((params.leftWord == "user" || params.leftWord == "/user" || params.leftWord == "member" || params.leftWord == "/member") && params.leftChar == ":") {
      return exclusiveResult(UserTagCompletionItems);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user Tag", "The `user` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter", null);
  }
};
var user_default = User;

// server/src/antlers/tags/core/memberUserAliases.ts
var MemberTag = createDefinitionAlias(user_default, "member");
var MemberIs = createDefinitionAlias(userIs_default, "member:is");
var MemberIsnt = createDefinitionAlias(userIsnt_default, "member:isnt");
var MemberProfile = createDefinitionAlias(userProfile_default, "member:profile");
var MemberCan = createDefinitionAlias(userCan_default, "member:can");
var MemberLogout = createDefinitionAlias(userLogout_default, "member:logout");
var MemberLogoutUrl = createDefinitionAlias(userLogoutUrl_default, "member:logout_url");
var MemberIn = createDefinitionAlias(userIn_default, "member:in");
var MemberNotIn = createDefinitionAlias(userNotIn_default, "member:not_in");
MemberTag.hideFromCompletions = true;
MemberTag.resolveDocumentation = (params) => {
  return makeTagDoc("member Tag", "The `member` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter", null);
};
MemberIs.resolveDocumentation = (params) => {
  return makeTagDoc("member:is Tag", "The `member:is` tag can be used to check whether the currently authenticated user has one or more roles.", "https://statamic.dev/tags/user-is");
};
MemberIsnt.resolveDocumentation = (params) => {
  return makeTagDoc("member:isnt Tag", "The `member:isnt` tag can be used to check whether the currently authenticated user does not have one or more roles.", "https://statamic.dev/tags/user-is#isnt");
};
MemberProfile.resolveDocumentation = (params) => {
  return makeTagDoc("member:profile Tag", "The `member:profile` tag provides access to the currently logged in user information, or for a specific user when using the `id`, `email`, or `field` parameter", null);
};
MemberCan.resolveDocumentation = (params) => {
  return makeTagDoc("member:can Tag", "The `member:can` tag is used to check if the currently authenticated user has a specific set of permissions. When used as a tag pair, the tag contents will only be rendered if the user has the specified permissions.", "https://statamic.dev/tags/user-can");
};
MemberLogout.resolveDocumentation = (params) => {
  return makeTagDoc("member:logout Tag", "The `member:logout` tag will sign out the currently authenticated user. An optional `redirect` parameter may be used to redirect the visitor to a different page after being logged out.", "https://statamic.dev/tags/user-logout");
};
MemberLogoutUrl.resolveDocumentation = (params) => {
  return makeTagDocWithCodeSample("member:logout_url", "The `member:logout_url` tag can be used to retrieve the URL that will sign the current user out.", `<a href="{{ member:logout_url }}">Log out</a>`, "https://statamic.dev/tags/user-logout_url");
};
MemberIn.resolveDocumentation = (params) => {
  return makeTagDoc("member:in Tag", "The `member:in` tag can be used to check if the currently authenticated user belongs to one or more user groups. When used as a tag pair, the tag contents will only be rendered if the user belongs to the specified groups.", "https://statamic.dev/tags/user-in");
};
MemberNotIn.resolveDocumentation = (params) => {
  return makeTagDoc("member:not_in Tag", "The `member:not_in` tag can be used to check if the currently authenticated user does not belong to one or more user groups. When used as a tag pair, the tag contents will be rendered if the user does not belong to the specified groups.", "https://statamic.dev/tags/user-in#not-in");
};

// server/src/antlers/variables/routeableVariables.ts
function makeRoutableVariables(node) {
  return [
    { name: "title", dataType: "string", sourceField: null, sourceName: "*internal.routeable", introducedBy: node },
    { name: "url", dataType: "string", sourceField: null, sourceName: "*internal.routeable", introducedBy: node }
  ];
}

// server/src/antlers/tags/core/taxonomies/utils.ts
var import_vscode_languageserver_types18 = __toESM(require_main2());

// server/src/antlers/tags/core/taxonomies/resolveTaxonomyParameterCompletions.ts
var SourceTaxonomyParams = ["from", "taxonomy", "is", "use", "folder"];
var ExcludeTaxonomyParams = ["not_from", "not_in", "dont_use", "not_taxonomy"];
var AllSourceParams = SourceTaxonomyParams;
AllSourceParams = AllSourceParams.concat(ExcludeTaxonomyParams);
function resolveTaxonomyParameterCompletions(parameter, params) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (params.nodesInScope.length > 0) {
    const lastSymbolInScope = params.nodesInScope[params.nodesInScope.length - 1];
    if (lastSymbolInScope != null && lastSymbolInScope.currentScope != null) {
      const taxonomyNames = getTaxonomyNames(lastSymbolInScope, params.project), blueprintFields = params.project.getTaxonomyBlueprintFields(taxonomyNames), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
      if (fieldNames.includes(rootLeft)) {
        return exclusiveResult(getConditionCompletionItems(params));
      }
    }
  }
  if (parameter.name == "collection") {
    if (((_a = params.context) == null ? void 0 : _a.parameterContext) != null) {
      return exclusiveResult(makeCollectionNameSuggestions((_d = (_c = (_b = params.context) == null ? void 0 : _b.parameterContext.parameter) == null ? void 0 : _c.getArrayValue()) != null ? _d : [], params.project));
    }
  }
  if (parameter.name == "filter" || parameter.name == "query_scope") {
    return exclusiveResult(makeQueryScopeSuggestions(params.project));
  }
  if (AllSourceParams.includes(parameter.name)) {
    if (((_e = params.context) == null ? void 0 : _e.parameterContext) != null) {
      return exclusiveResult(makeTaxonomyNameSuggestions((_h = (_g = (_f = params.context) == null ? void 0 : _f.parameterContext.parameter) == null ? void 0 : _g.getArrayValue()) != null ? _h : [], params.project));
    }
  }
  return null;
}

// server/src/antlers/tags/core/taxonomies/utils.ts
function getTaxonomyNames(symbol, statamicProject) {
  let taxonomyNames = [];
  if (symbol.hasMethodPart()) {
    taxonomyNames.push(symbol.getMethodNameValue());
    return taxonomyNames;
  }
  const fromParam = symbol.findAnyParameter(SourceTaxonomyParams), restrictParam = symbol.findAnyParameter(ExcludeTaxonomyParams);
  let fromList = [], notInList = [];
  if (typeof fromParam !== "undefined" && fromParam !== null) {
    if (fromParam.value.trim() === "*") {
      fromList = statamicProject.getUniqueTaxonomyNames();
      if (typeof restrictParam !== "undefined" && restrictParam !== null) {
        if (restrictParam.isVariableReference == false && restrictParam.hasInterpolations() == false) {
          notInList = restrictParam.getArrayValue();
        }
      }
    } else {
      if (fromParam.isVariableReference == false && fromParam.hasInterpolations() == false) {
        fromList = fromParam.getArrayValue();
      }
    }
  }
  if (notInList.length > 0) {
    taxonomyNames = fromList.filter(function(n) {
      return notInList.includes(n) == false;
    });
  } else {
    taxonomyNames = fromList;
  }
  return taxonomyNames;
}
function makeTaxonomyNameSuggestions(existingValues, project) {
  const items = [], taxonomyNames = project.getUniqueTaxonomyNames().filter((e) => !existingValues.includes(e));
  for (let i = 0; i < taxonomyNames.length; i++) {
    items.push({
      label: taxonomyNames[i],
      kind: import_vscode_languageserver_types18.CompletionItemKind.Variable
    });
  }
  return items;
}

// server/src/antlers/tags/core/taxonomies/augmentTaxonomiesScope.ts
function augmentTaxonomyScope(node, scope) {
  const taxonomyNames = getTaxonomyNames(node, scope.statamicProject), fields = scope.statamicProject.getTaxonomyBlueprintFields(taxonomyNames), collectionParam = node.findParameter("collection");
  scope.addBlueprintFields(node, fields);
  scope.addVariables([
    {
      name: "first",
      dataType: "boolean",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "last",
      dataType: "boolean",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "count",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "index",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "total_results",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    },
    {
      name: "entries_count",
      dataType: "number",
      sourceName: "*internal.taxonomy",
      sourceField: null,
      introducedBy: node
    }
  ]);
  scope.addVariables(makeRoutableVariables(node));
  if (typeof collectionParam !== "undefined" && collectionParam !== null) {
    const collectionNames = collectionParam.getArrayValue();
    if (collectionNames.length > 0) {
      const collectionFields = scope.statamicProject.getBlueprintFields(collectionNames), aliasScope = scope.introduceScopedAliasScope(node, "entries", "entries", collectionFields);
      aliasScope.addVariables(makeContentVariables(node));
    } else {
      scope.addVariableArray("entries", makeRoutableVariables(node).concat(makeContentVariables(node)));
    }
  } else {
    scope.addVariableArray("entries", makeRoutableVariables(node).concat(makeContentVariables(node)));
  }
  return scope;
}

// server/src/antlers/tags/core/taxonomies/parameters.ts
var TaxonomyParameters = [
  {
    name: "from",
    description: "The taxonomy to use",
    aliases: ["taxonomy", "is", "use", "folder"],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["string", "array"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "not_from",
    description: "Taxonomies to exclude",
    aliases: ["not_in", "not_folder", "dont_use", "not_taxonomy"],
    allowsVariableReference: false,
    acceptsVariableInterpolation: false,
    expectsTypes: ["string", "array"],
    isRequired: false,
    isDynamic: false
  },
  {
    name: "min_count",
    description: "The minimum number of entries a taxonomy term must have to be returned",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["number"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "collection",
    description: "Filter the terms to those that appear in the specified collections",
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    aliases: [],
    expectsTypes: ["string", "array"],
    isDynamic: false,
    isRequired: false
  },
  {
    name: "sort",
    description: "The field to sort terms by",
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false
  },
  {
    isRequired: false,
    name: "filter",
    aliases: ["query_scope"],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    description: "Specifies a custom query scope",
    expectsTypes: ["string"],
    isDynamic: false
  }
];
var parameters_default = TaxonomyParameters;

// server/src/antlers/tags/core/taxonomies/resolveCompletionItems.ts
var import_vscode_languageserver_types19 = __toESM(require_main2());
function resolveTaxonomyCompletions(params) {
  var _a, _b;
  const items = [];
  if (params.currentNode != null && params.currentNode.currentScope != null) {
    const taxonomyNames = getTaxonomyNames(params.currentNode, params.project), blueprintFields = params.project.getTaxonomyBlueprintFields(taxonomyNames), fieldNames = blueprintFields.map((f) => f.name), rootLeft = getRoot(params.leftWord);
    if (fieldNames.includes(rootLeft)) {
      return exclusiveResult(getConditionCompletionItems(params));
    }
    if (params.isCaretInTag && !((_a = params.context) == null ? void 0 : _a.interpolatedContext) && ["taxonomy", "/taxonomy"].includes(params.leftWord) == false) {
      const addedNames = [];
      for (let i = 0; i < blueprintFields.length; i++) {
        const thisField = blueprintFields[i];
        if (addedNames.includes(thisField.name) == false) {
          items.push({
            label: thisField.name,
            detail: thisField.blueprintName,
            documentation: (_b = thisField.instructionText) != null ? _b : "",
            kind: import_vscode_languageserver_types19.CompletionItemKind.Field
          });
          addedNames.push(thisField.name);
        }
      }
      if (items.length > 0) {
        return nonExclusiveResult(items);
      }
    }
  }
  if ((params.leftWord == "taxonomy" || params.leftWord == "/taxonomy") && params.leftChar == ":") {
    const taxonomyNames = params.project.getUniqueTaxonomyNames();
    for (let i = 0; i < taxonomyNames.length; i++) {
      items.push({
        label: taxonomyNames[i],
        kind: import_vscode_languageserver_types19.CompletionItemKind.Field
      });
    }
    return nonExclusiveResult(items);
  }
  return EmptyCompletionResult;
}

// server/src/antlers/tags/core/taxonomies/taxonomy.ts
var TaxonomyTag = {
  tagName: "taxonomy",
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  introducedIn: null,
  injectParentScope: false,
  parameters: parameters_default,
  resolveDynamicParameter: returnDynamicParameter,
  resolveCompletionItems: resolveTaxonomyCompletions,
  resovleParameterCompletionItems: resolveTaxonomyParameterCompletions,
  augmentScope: augmentTaxonomyScope,
  resolveDocumentation: (params) => {
    return makeTagDoc("taxonomy Tag", "The `taxonomy` tag may be used to retrieve taxonomy entries. The taxonomy tag can also be used to access entries associated with any given taxonomy term.", "https://statamic.dev/tags/taxonomy");
  }
};
var taxonomy_default = TaxonomyTag;

// server/src/antlers/tags/core/nav/nav.ts
var import_vscode_languageserver_types20 = __toESM(require_main2());

// server/src/antlers/tags/core/nav/augmentScope.ts
function augmentNavScope(node, scope) {
  scope.addVariables([
    {
      name: "is_published",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_page",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_entry",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "has_entries",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_parent",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_current",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "is_external",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "depth",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "children",
      dataType: "array",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "first",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "last",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "count",
      dataType: "integer",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    },
    {
      name: "index",
      dataType: "integer",
      sourceField: null,
      sourceName: "*internal.nav",
      introducedBy: node
    }
  ]);
  const collectionNames = scope.statamicProject.getUniqueCollectionNames(), currentHandles = [];
  let isCollection = false;
  if (node.hasMethodPart()) {
    const nodeMethodName = node.getMethodNameValue().trim().toLowerCase();
    if (nodeMethodName.startsWith("collection:")) {
      const handleName = nodeMethodName.split(":").pop();
      isCollection = true;
      currentHandles.push(handleName);
    } else if (nodeMethodName == "pages") {
      isCollection = true;
      currentHandles.push("pages");
    } else {
      isCollection = false;
      currentHandles.push(nodeMethodName);
    }
  } else {
    const handleParam = node.findParameter("handle");
    if (handleParam != null) {
      if (collectionNames.includes(handleParam.value)) {
        isCollection = true;
      } else {
        isCollection = false;
      }
      currentHandles.push(handleParam.value);
    }
  }
  if (isCollection) {
    const blueprintFields = scope.statamicProject.getBlueprintFields(currentHandles);
    scope.addBlueprintFields(node, blueprintFields);
    scope.expandScopedAliasScope(node, "page", "page", blueprintFields);
  } else {
    const blueprintFields = variablesToBlueprintFields(makeRoutableVariables(node));
    scope.addBlueprintFields(node, blueprintFields);
    scope.expandScopedAliasScope(node, "page", "page", blueprintFields);
  }
  return scope;
}

// server/src/antlers/tags/core/nav/breadcrumbs.ts
var NavBreadcrumbs = {
  tagName: "nav:breadcrumbs",
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  introducedIn: null,
  injectParentScope: false,
  parameters: [
    {
      name: "include_home",
      description: "Whether to include the home page in the first level",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "reverse",
      description: "Whether to reverse the order of links",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["boolean"],
      isRequired: false,
      isDynamic: false
    },
    {
      name: "trim",
      description: "Whether to trim the whitespace after each iteration of the loop",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    }
  ],
  augmentScope: (node, scope) => {
    scope.addVariables([
      {
        name: "is_current",
        dataType: "boolean",
        sourceName: "*internal.nav.breadcrumbs",
        sourceField: null,
        introducedBy: node
      }
    ]);
    scope.addVariables(makeRoutableVariables(node));
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("nav:breadcrumbs Tag", "The `nav:breadcrumbs` tag can be used to retrieve the URLs of all pages that make up the current URL back to the site's home page.", "https://statamic.dev/tags/nav-breadcrumbs");
  }
};
var breadcrumbs_default = NavBreadcrumbs;

// server/src/antlers/tags/core/nav/parameterCompletions.ts
function resolveNavParameterCompletions(parameter, params) {
  if (parameter.name == "handle") {
    const collectionNames = params.project.getUniqueCollectionNames(), navNames = params.project.getUniqueNavigationMenuNames();
    let allSuggestions = [];
    allSuggestions = collectionNames;
    allSuggestions = allSuggestions.concat(navNames);
    allSuggestions = [...new Set(allSuggestions)];
    return exclusiveResultList(allSuggestions);
  }
  return null;
}

// server/src/antlers/tags/core/nav/parameters.ts
var NavParameters = [
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: ["handle"],
    allowsVariableReference: false,
    name: "for",
    description: "The navigation or collection to use",
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    name: "from",
    description: "The starting point for the navigation",
    allowsVariableReference: true,
    expectsTypes: ["string"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    name: "show_unpublished",
    description: "Whether to include unpublished content",
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    name: "include_home",
    description: "Whether to include the home page in the tree",
    expectsTypes: ["boolean"],
    isDynamic: false
  },
  {
    isRequired: false,
    acceptsVariableInterpolation: false,
    aliases: [],
    allowsVariableReference: false,
    name: "max_depth",
    description: "The maximum depth of the navigation or structure",
    expectsTypes: ["number"],
    isDynamic: false
  }
];
var parameters_default2 = NavParameters;

// server/src/antlers/tags/core/nav/nav.ts
var StructureTag = {
  tagName: "structure",
  hideFromCompletions: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  introducedIn: null,
  injectParentScope: false,
  parameters: parameters_default2,
  augmentScope: augmentNavScope,
  resovleParameterCompletionItems: resolveNavParameterCompletions,
  resolveCompletionItems: (params) => {
    const items = [];
    if (params.isPastTagPart == false) {
      if ((params.leftWord == "nav" || params.leftWord == "/nav" || params.leftWord == "structure" || params.leftWord == "/structure") && params.leftChar == ":") {
        const navNames = params.project.getUniqueNavigationMenuNames();
        for (let i = 0; i < navNames.length; i++) {
          items.push(makeFieldSuggest(navNames[i], "", ""));
        }
        if (params.leftWord == "nav" || params.leftWord == "/nav") {
          items.push(tagToCompletionItem(breadcrumbs_default));
        }
        items.push(makeFieldSuggest("collection", "", ""));
        items.push({ label: "collection", kind: import_vscode_languageserver_types20.CompletionItemKind.Text });
        return nonExclusiveResult(items);
      }
    }
    if ((params.leftWord == "nav:collection" || params.leftWord == "/nav:collection" || params.leftWord == "collection" || params.leftWord == "/collection" || params.leftWord == "structure:collection" || params.leftWord == "/structure:collection") && params.leftChar == ":") {
      const collectionNames = params.project.getUniqueCollectionNames();
      for (let i = 0; i < collectionNames.length; i++) {
        items.push({
          label: collectionNames[i],
          kind: import_vscode_languageserver_types20.CompletionItemKind.Field
        });
      }
      return nonExclusiveResult(items);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("nav Tag", "The `nav` tag can be used to iterate structured collections or navigation menus.", "https://statamic.dev/tags/nav");
  }
};
var NavTag = createDefinitionAlias(StructureTag, "nav");

// server/src/antlers/tags/core/form/form.ts
var import_vscode_languageserver_types22 = __toESM(require_main2());

// server/src/antlers/variables/forms/standardFormVariables.ts
function makeStandardFormVariables(node) {
  return [
    { name: "success", dataType: "string", sourceField: null, sourceName: "*internal.forms", introducedBy: node },
    { name: "submission_created", dataType: "boolean", sourceField: null, sourceName: "*internal.forms", introducedBy: node }
  ];
}

// server/src/antlers/tags/core/form/formHandleParam.ts
var FormHandleParam = {
  name: "in",
  description: "The form to use",
  acceptsVariableInterpolation: true,
  aliases: ["handle", "is", "form", "formset"],
  allowsVariableReference: true,
  expectsTypes: ["string"],
  isDynamic: false,
  isRequired: false
};
var formHandleParam_default = FormHandleParam;

// server/src/suggestions/defaults/httpVerbItems.ts
var import_vscode_languageserver_types21 = __toESM(require_main2());
var FormHttpVerbCompletions = [
  { label: "GET", kind: import_vscode_languageserver_types21.CompletionItemKind.EnumMember },
  { label: "POST", kind: import_vscode_languageserver_types21.CompletionItemKind.EnumMember }
];
var httpVerbItems_default = FormHttpVerbCompletions;

// server/src/antlers/tags/core/form/parameterCompletions.ts
var HandleParams = [
  "in",
  "handle",
  "is",
  "form",
  "formset"
];
function resolveFormParameterCompletions(parameter, params) {
  if (HandleParams.includes(parameter.name)) {
    return exclusiveResultList(params.project.getUniqueFormNames());
  }
  if (parameter.name == "method") {
    return exclusiveResult(httpVerbItems_default);
  }
  if (parameter.name == "files") {
    return exclusiveResult(BooleanCompletionItems);
  }
  return null;
}

// server/src/antlers/tags/core/form/resolveFormSetReference.ts
function resolveFormSetReference(context, project) {
  const parentFormSet = context.structure.findParentWithName("form:set");
  if (parentFormSet != null) {
    return {
      context: parentFormSet,
      issues: []
    };
  }
  return {
    context: null,
    issues: []
  };
}

// server/src/antlers/tags/core/form/utils.ts
var IgnoreFormTagParts = [
  "set",
  "create",
  "errors",
  "success",
  "submissions",
  "submission"
];
function getFormHandle(node) {
  if (node.reference != null && "tagPart" in node.reference) {
    const nodeRef = node.reference;
    if (nodeRef.nameMatches("form:set")) {
      return getFormHandle(nodeRef);
    }
  }
  const handleParam = node.findAnyParameter(HandleParams);
  const nodeMethodName = node.getMethodNameValue();
  if (nodeMethodName != null && IgnoreFormTagParts.includes(nodeMethodName) == false) {
    return nodeMethodName;
  }
  if (typeof handleParam !== "undefined" && handleParam !== null) {
    if (handleParam.containsSimpleValue()) {
      return handleParam.value;
    }
  }
  return "";
}

// server/src/antlers/tags/core/form/formCreate.ts
var FormCreate = {
  tagName: "form:create",
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    formHandleParam_default,
    {
      name: "method",
      description: "The HTTP method to use",
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "files",
      description: "Indicates if the form sends file data",
      aliases: [],
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "redirect",
      description: "The location to redirect users after a successful form submission",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "error_redirect",
      description: "The location to redirect users to after a failed form submission",
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "allow_request_redirect",
      description: "Indicates if query parameters can override redirect or error_redirect",
      aliases: [],
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveSpecialType: resolveFormSetReference,
  resovleParameterCompletionItems: resolveFormParameterCompletions,
  resolveDynamicParameter: returnDynamicParameter,
  augmentScope: (symbol, scope) => {
    scope.addVariables(makeStandardFormVariables(symbol));
    scope.addVariable({ dataType: "array", name: "errors", sourceField: null, sourceName: "*internal.forms", introducedBy: symbol });
    scope.addVariableArray("fields", makeFieldsVariables(symbol));
    const formHandle = getFormHandle(symbol);
    if (formHandle.length > 0) {
      const formFields = scope.statamicProject.getFormBlueprintFields(formHandle), scopeVariables = blueprintFieldsToScopeVariables(symbol, formFields);
      scope.addVariableArray("old", scopeVariables);
      scope.addVariableArray("error", scopeVariables);
    }
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("form:create Tag", "The `form:create` tag can be used to access form data, generate field HTML markup, and handle form validation errors.", "https://statamic.dev/tags/form-create");
  }
};
var formCreate_default = FormCreate;

// server/src/antlers/tags/core/form/formErrors.ts
var FormErrors = {
  tagName: "form:errors",
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    formHandleParam_default
  ],
  resolveSpecialType: resolveFormSetReference,
  resovleParameterCompletionItems: (parameter, params) => {
    if (HandleParams.includes(parameter.name)) {
      return exclusiveResultList(params.project.getUniqueFormNames());
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("form:errors Tag", "The `form:errors` tag can be used to retrieve validation errors after a user has submitted a form.", "https://statamic.dev/tags/form-errors");
  }
};
var formErrors_default = FormErrors;

// server/src/antlers/tags/core/form/formSet.ts
var FormSetTag = {
  tagName: "form:set",
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "in",
      description: "The form to use",
      acceptsVariableInterpolation: true,
      aliases: ["handle", "is", "form", "formset"],
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: true
    }
  ],
  resovleParameterCompletionItems: resolveFormParameterCompletions,
  resolveDocumentation: (params) => {
    return makeTagDoc("form:set Tag", "The `form:set` tag can be used to set the form handle on all nested form tags.", "https://statamic.dev/tags/form-set");
  }
};
var formSet_default = FormSetTag;

// server/src/antlers/tags/core/form/formSubmission.ts
var FormSubmission = {
  tagName: "form:submission",
  requiresClose: true,
  allowsContentClose: false,
  allowsArbitraryParameters: false,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [formHandleParam_default],
  resolveSpecialType: resolveFormSetReference,
  resovleParameterCompletionItems: (parameter, params) => {
    if (HandleParams.includes(parameter.name)) {
      return exclusiveResultList(params.project.getUniqueFormNames());
    }
    return null;
  },
  augmentScope: (symbol, scope) => {
    const formHandle = getFormHandle(symbol);
    if (formHandle.length > 0) {
      const formFields = scope.statamicProject.getFormBlueprintFields(formHandle);
      scope.addBlueprintFields(symbol, formFields);
    }
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("form:submission Tag", "The `form:submission` tag can be used to access the form submission submitted by the current user.", "https://statamic.dev/tags/form-submission");
  }
};
var formSubmission_default = FormSubmission;

// server/src/antlers/tags/core/form/formSubmissions.ts
var FormSubmissions = {
  tagName: "form:submissions",
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  hideFromCompletions: false,
  injectParentScope: false,
  requiresClose: true,
  introducedIn: null,
  parameters: [formHandleParam_default],
  resolveSpecialType: resolveFormSetReference,
  resovleParameterCompletionItems: (parameter, params) => {
    if (HandleParams.includes(parameter.name)) {
      return exclusiveResultList(params.project.getUniqueFormNames());
    }
    return null;
  },
  augmentScope: (symbol, scope) => {
    if (symbol.isClosingTag) {
      return scope;
    }
    const formHandle = getFormHandle(symbol);
    if (formHandle.length > 0) {
      const formFields = scope.statamicProject.getFormBlueprintFields(formHandle);
      scope.addBlueprintFields(symbol, formFields);
    }
    scope.addVariable({
      name: "date",
      dataType: "date",
      sourceField: null,
      sourceName: "*internal.forms.submissions",
      introducedBy: symbol
    });
    scope.addVariable({
      name: "no_results",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.forms.submissions",
      introducedBy: symbol
    });
    scope.addVariable({
      name: "total_results",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.forms.submissions",
      introducedBy: symbol
    });
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("form:submissions Tag", "The `form:submissions` tag can be used to fetch previously saved submissions for a form.", "https://statamic.dev/tags/form-submissions");
  }
};
var formSubmissions_default = FormSubmissions;

// server/src/antlers/tags/core/form/formSuccess.ts
var FormSuccess = {
  tagName: "form:success",
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    formHandleParam_default
  ],
  resolveSpecialType: resolveFormSetReference,
  resovleParameterCompletionItems: (parameter, params) => {
    if (HandleParams.includes(parameter.name)) {
      return exclusiveResultList(params.project.getUniqueFormNames());
    }
    return null;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("form:success Tag", "The `form:success` tag can be used to check if a form submission was successful or not.", "https://statamic.dev/tags/form-success");
  }
};
var formSuccess_default = FormSuccess;

// server/src/antlers/tags/core/form/form.ts
var FormCompletions = [
  tagToCompletionItem(formSet_default),
  tagToCompletionItem(formCreate_default),
  tagToCompletionItem(formErrors_default),
  tagToCompletionItem(formSuccess_default),
  tagToCompletionItem(formSubmissions_default),
  tagToCompletionItem(formSubmission_default)
];
var FormTag = {
  tagName: "form",
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [],
  resovleParameterCompletionItems: resolveFormParameterCompletions,
  resolveCompletionItems: (params) => {
    let items = [];
    if (params.isPastTagPart == false && (params.leftWord == "form" || params.leftWord == "/form") && params.leftChar == ":") {
      const formNames = params.project.getUniqueFormNames();
      items = items.concat(FormCompletions);
      for (let i = 0; i < formNames.length; i++) {
        items.push({
          label: formNames[i],
          kind: import_vscode_languageserver_types22.CompletionItemKind.Field
        });
      }
      return nonExclusiveResult(items);
    }
    return EmptyCompletionResult;
  }
};
var form_default = FormTag;

// server/src/antlers/tags/core/search.ts
var SearchResultsTag = {
  tagName: "search:results",
  allowsArbitraryParameters: false,
  requiresClose: true,
  allowsContentClose: false,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "index",
      description: "The index to search in",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "query",
      description: "The query string parameter to use",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "limit",
      description: "The maximum number of search results to return",
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      isRequired: false,
      isDynamic: false,
      expectsTypes: ["number"]
    },
    {
      name: "offset",
      description: "The number of results to skip",
      allowsVariableReference: false,
      acceptsVariableInterpolation: false,
      aliases: [],
      isRequired: false,
      isDynamic: false,
      expectsTypes: ["number"]
    },
    {
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: null,
      description: "Sets whether not to paginate entry results",
      expectsTypes: ["boolean"],
      isRequired: false,
      name: "paginate",
      isDynamic: false
    },
    {
      name: "as",
      description: "Specifies an alias for search results",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: false,
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "supplement_data",
      description: "Controls whether non-indexed fields are returned",
      acceptsVariableInterpolation: false,
      allowsVariableReference: false,
      aliases: [],
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resovleParameterCompletionItems: (parameter, params) => {
    if (parameter.name == "index") {
      return exclusiveResultList(params.project.getSearchIndexes());
    }
    return null;
  },
  augmentScope: (node, scope) => {
    scope.addVariables([
      {
        name: "no_results",
        dataType: "boolean",
        sourceField: null,
        sourceName: "*internal.search.results",
        introducedBy: node
      },
      {
        name: "total_results",
        dataType: "number",
        sourceField: null,
        sourceName: "*internal.search.results",
        introducedBy: node
      }
    ]);
    const asParam = node.findParameter("as");
    if (asParam != null && asParam.value.trim().length > 0) {
      scope.addVariableArray(asParam.value, makeDefaultSearchResultVariables(node));
    } else {
      scope.addVariables(makeDefaultSearchResultVariables(node));
    }
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("search:results Tag", "The `search:results` tag provides access to all data that was returned as a result of a user's search.", "https://statamic.dev/tags/search");
  }
};
var SearchCompletionItems = [
  tagToCompletionItem(SearchResultsTag)
];
function makeDefaultSearchResultVariables(node) {
  return [
    {
      name: "url",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "title",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "content",
      dataType: "string",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "first",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "last",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "is_entry",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "is_term",
      dataType: "boolean",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "count",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "index",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "search_score",
      dataType: "number",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    },
    {
      name: "_highlightResult",
      dataType: "array",
      sourceField: null,
      sourceName: "*internal.search.results",
      introducedBy: node
    }
  ];
}
var BaseSearchTag = {
  tagName: "search",
  allowsArbitraryParameters: false,
  requiresClose: true,
  allowsContentClose: false,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [],
  resolveCompletionItems: (params) => {
    if (params.isPastTagPart == false && (params.leftWord == "search" || params.leftWord == "/search") && params.leftChar == ":") {
      return nonExclusiveResult(SearchCompletionItems);
    }
    return EmptyCompletionResult;
  }
};

// server/src/antlers/tags/core/userLoginForm.ts
function makeUserLoginFields(node) {
  return [
    { name: "email", dataType: "string", sourceName: "*internal.user.login", sourceField: null, introducedBy: node },
    { name: "password", dataType: "string", sourceName: "*internal.user.login", sourceField: null, introducedBy: node }
  ];
}
var UserLoginForm = {
  tagName: "user:login_form",
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  hideFromCompletions: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: [
    {
      name: "redirect",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      description: "Where the user should be redirected after logging in",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "error_redirect",
      acceptsVariableInterpolation: false,
      aliases: [],
      allowsVariableReference: true,
      description: "Where the user should be redirected after failed login attempts",
      expectsTypes: ["string"],
      isDynamic: false,
      isRequired: false
    },
    {
      name: "allow_request_redirect",
      description: "Indicates if query parameters can override the redirect and error_redirect parameters",
      acceptsVariableInterpolation: false,
      allowsVariableReference: true,
      aliases: [],
      expectsTypes: ["boolean"],
      isDynamic: false,
      isRequired: false
    }
  ],
  resolveDynamicParameter: returnDynamicParameter,
  augmentScope: (node, scope) => {
    scope.addVariables([
      { name: "errors", dataType: "array", sourceName: "*internal.user.login", sourceField: null, introducedBy: node },
      { name: "success", dataType: "string", sourceName: "*internal.user.login", sourceField: null, introducedBy: node }
    ]);
    scope.addVariables(makeUserLoginFields(node));
    scope.addVariableArray("old", makeUserLoginFields(node));
    scope.addVariableArray("error", makeUserLoginFields(node));
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("user:login_form Tag", "The `user:login_form` tag can be used to quickly create a form that users can use to authenticate with the site.", "https://statamic.dev/tags/user-login_form");
  }
};
var MemberLoginForm = createDefinitionAlias(UserLoginForm, "member:login_form");

// server/src/antlers/tags/core/noParse.ts
var NoParse = {
  tagName: "noparse",
  requiresClose: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  hideFromCompletions: false,
  injectParentScope: false,
  parameters: [],
  introducedIn: null,
  resolveDocumentation: (params) => {
    return makeTagDoc("noparse Tag", "The `noparse` tag is used prevent blocks of Antlers code from being parsed, removing the need to escape individual Antlers code regions.", "https://statamic.dev/antlers#the-noparse-tag");
  }
};
var noParse_default = NoParse;

// server/src/antlers/tags/core/conditions/unless.ts
var Unless = {
  tagName: "unless",
  hideFromCompletions: true,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: true,
  introducedIn: null,
  parameters: [],
  resolveDynamicParameter: returnDynamicParameter,
  resolveDocumentation: (docs) => {
    return makeTagDoc("unless Conditional Control Structure", "The `unless` control structure operates the same as an `if` statement, but has it's logic inverted.", "https://statamic.dev/antlers#conditions");
  }
};
var unless_default = Unless;

// server/src/antlers/tags/core/conditions/elseUnless.ts
var ElseUnless = {
  tagName: "elseunless",
  hideFromCompletions: true,
  allowsArbitraryParameters: true,
  allowsContentClose: false,
  requiresClose: true,
  injectParentScope: true,
  introducedIn: null,
  parameters: [],
  resolveDynamicParameter: returnDynamicParameter,
  resolveDocumentation: (docs) => {
    return makeTagDoc("elseunless Conditional Control Structure", "The `elseunless` control structure operates the same as an `elseif` statement, but has it's logic inverted.", "https://statamic.dev/antlers#conditions");
  }
};
var elseUnless_default = ElseUnless;

// server/src/antlers/tags/core/installed.ts
var import_vscode_languageserver8 = __toESM(require_main4());
var InstalledTag = {
  tagName: "installed",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsContentClose: false,
  allowsArbitraryParameters: true,
  introducedIn: "3.1.19",
  parameters: [],
  resolveCompletionItems: (params) => {
    if (params.project != null) {
      const projectPackages = params.project.getComposerPackages(), packageCompletions = [];
      projectPackages.forEach((composerPackage, packageName) => {
        packageCompletions.push({
          label: composerPackage.name,
          kind: import_vscode_languageserver8.CompletionItemKind.Text
        });
      });
      return exclusiveResult(packageCompletions);
    }
    return EmptyCompletionResult;
  },
  resolveDocumentation: (params) => {
    return makeTagDocWithCodeSample("installed Tag", "The `installed` tag is used to check if the site has a specific Composer package available.", `{{ if {installed:composer/package-name} }}
    {{# Package is availabl.e #}}
{{ else }}
    {{# Something else. #}}
{{ /if }}`, "https://statamic.dev/tags/installed");
  }
};

// server/src/antlers/tags/core/relate.ts
var Relate = {
  tagName: "relate",
  hideFromCompletions: true,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  injectParentScope: false,
  requiresClose: true,
  introducedIn: null,
  parameters: []
};
var relate_default = Relate;

// server/src/antlers/tags/core/getErrors/getErrorsParameters.ts
var GetErrorsParameters = [
  {
    name: "bag",
    description: "The error message bag to retrieve errors from.",
    aliases: [],
    acceptsVariableInterpolation: false,
    allowsVariableReference: false,
    expectsTypes: ["string"],
    isDynamic: false,
    isRequired: false
  }
];

// server/src/antlers/tags/core/getErrors/getErrors.ts
var GetErrors = {
  tagName: "get_errors",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  parameters: GetErrorsParameters,
  introducedIn: "3.2.23",
  augmentScope: (node, scope) => {
    var _a;
    if (node.isClosingTag) {
      return scope;
    }
    if (((_a = node.name) == null ? void 0 : _a.methodPart) == null) {
      const fieldsScope = scope.copy();
      fieldsScope.addVariable({
        dataType: "string",
        introducedBy: node,
        name: "field",
        sourceName: "*internal.tag.get_errors",
        sourceField: {
          blueprintName: "*internal.tag.get_errors",
          displayName: "get_errors",
          import: null,
          instructionText: null,
          maxItems: null,
          name: "field",
          refFieldSetField: null,
          sets: null,
          type: "string"
        }
      });
      const messageScope = fieldsScope.copy();
      messageScope.addVariable({
        dataType: "string",
        introducedBy: node,
        name: "message",
        sourceName: "*internal.tag.get_errors",
        sourceField: {
          blueprintName: "*internal.tag.get_errors",
          displayName: "get_errors",
          import: null,
          instructionText: null,
          maxItems: null,
          name: "message",
          refFieldSetField: null,
          sets: null,
          type: "string"
        }
      });
      fieldsScope.addScopeList("messages", messageScope);
      scope.addScopeList("fields", fieldsScope);
    } else {
      const errorScope = scope.copy();
      errorScope.addVariable({
        dataType: "string",
        introducedBy: node,
        name: "message",
        sourceName: "*internal.tag.get_errors",
        sourceField: {
          blueprintName: "*internal.tag.get_errors",
          displayName: "get_errors",
          import: null,
          instructionText: null,
          maxItems: null,
          name: "message",
          refFieldSetField: null,
          sets: null,
          type: "string"
        }
      });
      scope.addScopeList("messages", errorScope);
    }
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("get_errors Tag", "The `get_errors` tag can be used to retrieve form validation errors.", "https://statamic.dev/tags/get_errors");
  }
};
var getErrors_default = GetErrors;

// server/src/antlers/tags/core/getErrors/getAllErrors.ts
var GetAllErrors = {
  tagName: "get_errors:all",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  parameters: GetErrorsParameters,
  introducedIn: null,
  augmentScope: (node, scope) => {
    if (node.isClosingTag) {
      return scope;
    }
    const errorScope = scope.copy();
    errorScope.addVariable({
      dataType: "string",
      introducedBy: node,
      name: "message",
      sourceName: "*internal.tag.get_errors.all",
      sourceField: {
        blueprintName: "*internal.tag.get_errors.all",
        displayName: "get_errors:all",
        import: null,
        instructionText: null,
        maxItems: null,
        name: "message",
        refFieldSetField: null,
        sets: null,
        type: "string"
      }
    });
    scope.addScopeList("messages", errorScope);
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("get_errors:all Tag", "The `get_errors:all` tag can be used to retrieve all form validation errors.", "https://statamic.dev/tags/get_errors#list-all-validation-errors");
  }
};
var getAllErrors_default = GetAllErrors;

// server/src/antlers/tags/core/getErrors/getError.ts
var GetError = {
  tagName: "get_error",
  hideFromCompletions: false,
  requiresClose: true,
  injectParentScope: false,
  allowsArbitraryParameters: false,
  allowsContentClose: false,
  parameters: GetErrorsParameters,
  introducedIn: null,
  augmentScope: (node, scope) => {
    if (node.isClosingTag) {
      return scope;
    }
    scope.addVariable({
      dataType: "string",
      introducedBy: node,
      name: "message",
      sourceName: "*internal.tag.get_error",
      sourceField: {
        blueprintName: "*internal.tag.get_error",
        displayName: "get_error",
        import: null,
        instructionText: null,
        maxItems: null,
        name: "message",
        refFieldSetField: null,
        sets: null,
        type: "string"
      }
    });
    return scope;
  },
  resolveDocumentation: (params) => {
    return makeTagDoc("get_error Tag", "The `get_error` tag can be used to retrieve the first error message for a specific field.", "https://statamic.dev/tags/get_errors#get-the-first-error-for-a-specific-field");
  }
};
var getError_default = GetError;

// server/src/antlers/tags/core/set.ts
var SetTag = {
  tagName: "set",
  hideFromCompletions: true,
  allowsArbitraryParameters: true,
  requiresClose: false,
  allowsContentClose: false,
  injectParentScope: false,
  introducedIn: null,
  parameters: []
};
var set_default = SetTag;

// server/src/antlers/tags/coreTags.ts
var coreTags = [
  if_default,
  elseIf_default,
  else_default,
  unless_default,
  elseUnless_default,
  asset_default,
  assets_default,
  collection_default,
  count_default,
  previous_default,
  next_default,
  CollectionNewer,
  CollectionOlder,
  relate_default,
  form_default,
  formCreate_default,
  formSubmission_default,
  formSubmissions_default,
  formSet_default,
  formSuccess_default,
  formErrors_default,
  set_default,
  getErrors_default,
  getError_default,
  getAllErrors_default,
  BaseSearchTag,
  SearchResultsTag,
  partial_default,
  partialExists_default,
  partialIfExists_default,
  error404_default,
  notFound_default,
  dump_default,
  DddTag,
  DdTag,
  cache_default,
  getContent_default,
  getFiles_default,
  glide_default,
  glideBatch_default,
  link_default,
  Loop,
  RangeTag,
  IterateTag,
  ForeachTag,
  increment_default,
  incrementReset_default,
  locales_default,
  localeCount_default,
  mix_default,
  NavTag,
  StructureTag,
  breadcrumbs_default,
  Yield,
  Yields,
  userIn_default,
  in_default,
  userNotIn_default,
  userIs_default,
  is_default,
  InstalledTag,
  user_default,
  userIsnt_default,
  userCan_default,
  userCant_default,
  userLogout_default,
  userLogoutUrl_default,
  userProfile_default,
  UserLoginForm,
  UserPasswordReset,
  UserForgotPasswordForm,
  UserRegister,
  MemberTag,
  MemberIs,
  MemberIsnt,
  MemberProfile,
  MemberCan,
  MemberLogout,
  MemberLogoutUrl,
  MemberIn,
  MemberNotIn,
  MemberLoginForm,
  MemberPasswordReset,
  MemberForgotPasswordForm,
  MemberRegister,
  noParse_default,
  Switch,
  Rotate,
  oauth_default,
  obfuscate_default,
  parent_default,
  path_default,
  redirect_default,
  route_default,
  scopeTag_default,
  section_default,
  session_default,
  sessionFlash_default,
  sessionFlush_default,
  sessionForget_default,
  sessionSet_default,
  sessionHas_default,
  sessionDump_default,
  svg_default,
  taxonomy_default,
  theme_default,
  ThemePath,
  ThemeAsset,
  themeCss_default,
  themeImg_default,
  themeJs_default,
  themeOutput_default,
  Translate,
  TransTag,
  TransChoiceTag,
  queryTag_default,
  markdown_default,
  markdownIndent_default,
  widont_default
];

// server/src/antlers/tagManagerInstance.ts
var TagManager = class {
  constructor() {
    this.tags = /* @__PURE__ */ new Map();
    this.parameters = /* @__PURE__ */ new Map();
  }
  reset() {
    this.tags.clear();
    this.parameters.clear();
    this.loadCoreTags();
  }
  getVisibleTagsWithDocumentation() {
    const tags = [];
    this.tags.forEach((tag, name) => {
      if (tag.hideFromCompletions == false) {
        let docs = "";
        if (tag.resolveDocumentation != null) {
          docs = tag.resolveDocumentation();
        }
        tags.push({
          label: name,
          documentation: docs
        });
      }
    });
    return tags;
  }
  getVisibleTagNames() {
    const tagNames = [];
    this.tags.forEach((tag, name) => {
      if (tag.hideFromCompletions == false) {
        tagNames.push(name);
      }
    });
    return [...new Set(tagNames)];
  }
  getPossibleTagMethods(tagName) {
    const methodNames = [], len = tagName.length + 1;
    this.tags.forEach((tag, name) => {
      if (name.startsWith(tagName)) {
        const methodName = name.substr(len).trim();
        if (methodName.length > 0) {
          methodNames.push(methodName);
        }
      }
    });
    return [...new Set(methodNames)];
  }
  getTagNames() {
    const tagNames = [];
    this.tags.forEach((tag, name) => {
      tagNames.push(name);
    });
    return [...new Set(tagNames)];
  }
  loadCoreTags() {
    this.registerTags(coreTags);
  }
  cleanTagName(name) {
    return trimLeft(name, "/");
  }
  findTag(name) {
    return this.tags.get(this.resolveTagName(name));
  }
  isKnownTag(name) {
    return this.tags.has(this.resolveTagName(name));
  }
  isSymbolKnownTag(node) {
    return this.isKnownTag(node.runtimeName());
  }
  resolveTagName(name) {
    name = this.cleanTagName(name.trim());
    if (this.tags.has(name)) {
      return name;
    }
    if (name.includes(":")) {
      name = name.split(":")[0];
    }
    return name;
  }
  canResolveSpecialTypes(name) {
    name = this.resolveTagName(name);
    const tag = this.tags.get(name);
    if (typeof tag === "undefined" || tag == null) {
      return false;
    }
    if (tag.resolveSpecialType == null) {
      return false;
    }
    return true;
  }
  resolveSpecialType(tagName, symbol, project) {
    tagName = this.resolveTagName(tagName);
    const tag = this.findTag(tagName);
    if (tag.resolveSpecialType == null) {
      throw new Error(tagName + " does not support special types.");
    }
    return tag.resolveSpecialType(symbol, project);
  }
  getCompletionItems(params) {
    var _a;
    let lastScopeItem = null;
    let resolvedParams = [];
    let runDefaultAnalysis = true;
    if (params.nodesInScope.length > 0) {
      lastScopeItem = params.nodesInScope[params.nodesInScope.length - 1];
    }
    if (params.currentNode != null) {
      if (this.isKnownTag(params.currentNode.runtimeName())) {
        const tagReference = this.findTag(params.currentNode.runtimeName());
        if (typeof tagReference === "undefined") {
          return {
            isExclusive: false,
            items: []
          };
        }
        const dynamicRefNames = [];
        if (tagReference.resolveCompletionItems != null) {
          const result = tagReference.resolveCompletionItems(params);
          if (result.isExclusiveResult) {
            return {
              isExclusive: true,
              items: result.items
            };
          }
          runDefaultAnalysis = result.analyzeDefaults;
          resolvedParams = resolvedParams.concat(result.items);
        }
        if (params.isPastTagPart == false) {
          const tagMethodNames = this.getPossibleTagMethods(tagReference.tagName);
          for (let i = 0; i < tagMethodNames.length; i++) {
            resolvedParams.push({
              label: tagMethodNames[i],
              kind: import_vscode_languageserver9.CompletionItemKind.Text
            });
          }
        }
        if (runDefaultAnalysis) {
          if (params.isCaretInTag == true && tagReference.parameters.length > 0) {
            resolvedParams = resolvedParams.concat(makeTagParameterSuggestions(params, tagReference.parameters));
            if (tagReference.tagName == "partial") {
              if (lastScopeItem == null ? void 0 : lastScopeItem.hasMethodPart()) {
                const lastMethodName = lastScopeItem.getMethodNameValue();
                if (lastMethodName.trim().length > 0) {
                  if ((_a = projectManager_default.instance) == null ? void 0 : _a.hasStructure()) {
                    const projectView = projectManager_default.instance.getStructure().findPartial(lastMethodName);
                    if (projectView != null && projectView.injectsParameters.length > 0) {
                      resolvedParams = resolvedParams.concat(makeTagParameterSuggestions(params, projectView.injectsParameters));
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < params.nodesInScope.length; i++) {
            if (params.nodesInScope[i].runtimeType !== null) {
              const thisRuntimeType = params.nodesInScope[i].runtimeType;
              if (thisRuntimeType != null && thisRuntimeType.assumedType == "structure_ref" && thisRuntimeType.supplementedFields != null) {
                for (let j = 0; j < thisRuntimeType.supplementedFields.length; j++) {
                  resolvedParams.push(formatSuggestion(thisRuntimeType.supplementedFields[j]));
                }
              }
            }
          }
        }
        return {
          items: resolvedParams,
          isExclusive: false
        };
      }
    }
    return {
      items: resolvedParams,
      isExclusive: false
    };
  }
  injectParentScope(tag) {
    const tagReference = this.findTag(tag);
    if (typeof tagReference === "undefined" || tagReference == null) {
      return true;
    }
    return tagReference.injectParentScope;
  }
  resolveParameterCompletions(tag, parameter, params) {
    const tagReference = this.findTag(tag);
    if (typeof tagReference !== "undefined" && tagReference !== null) {
      if (typeof tagReference.resovleParameterCompletionItems !== "undefined" && tagReference.resovleParameterCompletionItems !== null) {
        return tagReference.resovleParameterCompletionItems(parameter, params);
      }
    }
    return null;
  }
  canResolveDynamicParameter(tag) {
    const tagName = this.resolveTagName(tag);
    if (this.isKnownTag(tagName)) {
      const tagRef = this.tags.get(tagName);
      if (typeof tagRef === "undefined") {
        return false;
      }
      if (typeof tagRef.resolveDynamicParameter !== "undefined" && tagRef.resolveDynamicParameter != null) {
        return true;
      }
    }
    return false;
  }
  getParameter(tag, param) {
    const tagName = this.resolveTagName(tag);
    if (this.parameters.has(tagName) == false) {
      return null;
    }
    const tagParams = this.parameters.get(tagName);
    if (tagParams == null) {
      return null;
    }
    if (tagParams.has(param) == false) {
      const tagRef = this.findTag(tag);
      if (tagRef != null && typeof tagRef.resolveDynamicParameter !== "undefined" && tagRef.resolveDynamicParameter != null) {
        const dynamicParam = tagRef.resolveDynamicParameter(null, param);
        if (dynamicParam !== null) {
          return dynamicParam;
        }
      }
      return null;
    }
    const tagParam = tagParams.get(param);
    if (typeof tagParam == "undefined" || tagParams == null) {
      return null;
    }
    return tagParam;
  }
  registerTags(tags) {
    for (let i = 0; i < tags.length; i++) {
      this.registerTag(tags[i]);
    }
  }
  registerTag(tag) {
    this.tags.set(tag.tagName, tag);
    if (this.parameters.has(tag.tagName) == false) {
      this.parameters.set(tag.tagName, /* @__PURE__ */ new Map());
    }
    if (tag.parameters.length > 0) {
      const thisTagsMap = this.parameters.get(tag.tagName);
      for (let i = 0; i < tag.parameters.length; i++) {
        const curParam = tag.parameters[i];
        thisTagsMap == null ? void 0 : thisTagsMap.set(curParam.name, curParam);
      }
    }
  }
  requiresClose(node) {
    const nodeTagName = node.getTagName();
    if (this.tags.has(nodeTagName)) {
      const tag = this.findTag(nodeTagName);
      if (tag != null) {
        if (tag.requiresCloseResolver != null) {
          return tag.requiresCloseResolver(node);
        }
        return tag.requiresClose;
      }
    }
    return false;
  }
};
TagManager.instance = null;
if (typeof TagManager.instance == "undefined" || TagManager.instance == null) {
  TagManager.instance = new TagManager();
  TagManager.instance.loadCoreTags();
}
var tagManagerInstance_default = TagManager;

// server/src/antlers/scope/scope.ts
var _Scope = class {
  constructor(statamicProject) {
    this.generation = 0;
    this.id = "";
    this.name = "";
    this.values = /* @__PURE__ */ new Map();
    this.lists = /* @__PURE__ */ new Map();
    this.pristine = /* @__PURE__ */ new Map();
    this.parentScope = null;
    this.statamicProject = statamicProject;
    _Scope.generationCounter += 1;
    this.generation = _Scope.generationCounter;
    this.id = v4();
  }
  makeNew() {
    return new _Scope(this.statamicProject);
  }
  ancestor() {
    if (this.parentScope != null) {
      return this.parentScope;
    }
    return this;
  }
  canShiftScope(path) {
    if (this.pristine.has(path)) {
      return true;
    }
    return false;
  }
  shiftScope(symbol, path, newScopeName) {
    if (this.pristine.has(path)) {
      const pristineCopy = this.pristine.get(path), newScope = pristineCopy.parentCopy.copy();
      newScope.introduceAliasScope(symbol, newScopeName, pristineCopy.introducedFields);
      return newScope;
    }
    return this;
  }
  containsPath(path) {
    if (path.includes(":")) {
      const parts = path.split(":"), thisPath = parts.shift(), nextPath = parts.join(":");
      if (typeof thisPath === "undefined") {
        return false;
      }
      const nextScope = this.lists.get(thisPath);
      if (typeof nextScope === "undefined") {
        return false;
      }
      return nextScope.containsPath(nextPath);
    }
    if (this.lists.has(path)) {
      return true;
    }
    return false;
  }
  findReference(path) {
    if (path.includes(":")) {
      const parts = path.split(":"), itemToFind = parts.pop(), newPath = parts.join(":"), adjustScope = this.findNestedScope(newPath);
      if (adjustScope != null) {
        return adjustScope.findReference(itemToFind);
      }
    }
    if (this.values.has(path)) {
      return this.values.get(path);
    }
    return null;
  }
  findReferenceWithField(path) {
    if (path.includes(":")) {
      const parts = path.split(":"), itemToFind = parts.pop(), newPath = parts.join(":"), adjustScope = this.findNestedScope(newPath);
      if (adjustScope != null) {
        return adjustScope.findReference(itemToFind);
      }
    }
    if (this.values.has(path)) {
      const varRef = this.values.get(path);
      if (varRef.sourceField == null) {
        if (varRef.introducedBy != null && varRef.introducedBy.currentScope != null && varRef.introducedBy.currentScope != this) {
          return varRef.introducedBy.currentScope.findReferenceWithField(varRef.introducedBy.getTagName());
        }
        if (this.parentScope != null && this.parentScope != this) {
          return this.parentScope.findReferenceWithField(path);
        }
      }
      return varRef;
    }
    return null;
  }
  containsReference(path) {
    const pathRef = this.findReference(path);
    if (pathRef == null) {
      return false;
    }
    return true;
  }
  findNestedScope(path) {
    if (path.includes(":")) {
      const parts = path.split(":"), thisPath = parts.shift(), nextPath = parts.join(":");
      if (typeof thisPath === "undefined") {
        return null;
      }
      const nextScope = this.lists.get(thisPath);
      if (typeof nextScope === "undefined") {
        return null;
      }
      return nextScope.findNestedScope(nextPath);
    }
    if (this.lists.has(path)) {
      return this.lists.get(path);
    }
    if (this.parentScope != null && this.parentScope != this && this.parentScope.hasList(path)) {
      return this.parentScope.lists.get(path);
    }
    return null;
  }
  liftList(name) {
    if (this.lists.has(name)) {
      const list = this.lists.get(name);
      if (typeof list === "undefined" || list === null) {
        return null;
      }
      this.lists.delete(name);
      return list;
    }
    return null;
  }
  hasPristineReference(name) {
    if (this.pristine.has(name)) {
      return true;
    }
    return false;
  }
  hasListInHistory(name) {
    if (this.hasList(name)) {
      return true;
    }
    if (this.parentScope != null) {
      if (this.name == "*root*") {
        return false;
      }
      return this.parentScope.hasList(name);
    }
    return false;
  }
  hasList(name) {
    if (this.lists.has(name)) {
      const list = this.lists.get(name);
      if (typeof list === "undefined" || list === null) {
        return false;
      }
      return true;
    }
    return false;
  }
  bringListIntoMainScope(path) {
    if (path.includes(":")) {
      const parts = path.split(":"), thisPath = parts.shift(), nextPath = parts.join(":");
      if (typeof thisPath === "undefined") {
        return this;
      }
      const nextScope = this.lists.get(thisPath);
      if (typeof nextScope === "undefined") {
        return this;
      }
      return nextScope.bringListIntoMainScope(nextPath);
    }
    const nestedScope = this.lists.get(path);
    this.lists.delete(path);
    return this.mergeScope(nestedScope);
  }
  getListNames() {
    const listNames = [];
    this.lists.forEach((value, name) => {
      listNames.push(name);
    });
    return listNames;
  }
  getVariableNames() {
    const variableNames = [];
    this.values.forEach((variable) => {
      variableNames.push(variable.name);
    });
    return variableNames;
  }
  getList(name) {
    if (this.lists.has(name)) {
      return this.lists.get(name);
    }
    if (this.parentScope != null && this.parentScope != this) {
      return this.parentScope.getList(name);
    }
    return null;
  }
  hasValue(name) {
    return this.values.has(name);
  }
  findAncestorWithList(name) {
    if (this.hasList(name)) {
      return this;
    }
    if (this.parentScope != null && this.parentScope != this) {
      return this.parentScope.findAncestorWithList(name);
    }
    return null;
  }
  findReferenceNotIntroducedBy(name, introducedBy) {
    if (this.hasValue(name)) {
      const varRef = this.values.get(name);
      if (varRef.introducedBy != null && varRef.introducedBy != introducedBy) {
        return varRef;
      }
    }
    if (this.parentScope != null && this.parentScope != this) {
      return this.parentScope.findReferenceNotIntroducedBy(name, introducedBy);
    }
    return null;
  }
  removeThroughIntroduction(name, introducedBy) {
    this.values.delete(name);
    if (this.parentScope != null) {
      const refInSCope = this.findReferenceNotIntroducedBy(name, introducedBy);
      if (refInSCope != null) {
        this.addVariable(refInSCope);
      }
    }
  }
  wasIntroducedBySymbol(name, checkSymbol) {
    if (this.values.has(name) == false) {
      return false;
    }
    const value = this.values.get(name);
    if (value.introducedBy != null) {
      return value.introducedBy == checkSymbol;
    }
    return false;
  }
  referencesArray(name) {
    if (this.values.has(name) == false) {
      return false;
    }
    const ref = this.values.get(name);
    if (ref.dataType == "array") {
      return true;
    }
    return false;
  }
  addScopeList(listName, scope) {
    this.lists.set(listName, scope);
    return this;
  }
  mergeAndList(listName, data) {
    const newListScope = new _Scope(this.statamicProject);
    newListScope.values = valuesToDataMap(data);
    this.lists.set(listName, newListScope);
    this.mergeVariableScope(data);
    return this;
  }
  mergeScope(scope) {
    if (scope == this || scope == null) {
      return this;
    }
    scope.values.forEach((value, name) => {
      this.values.set(name, value);
    });
    scope.lists.forEach((value, name) => {
      this.lists.set(name, value);
    });
    return this;
  }
  mergeVariableScope(data) {
    for (let i = 0; i < data.length; i++) {
      this.values.set(data[i].name, data[i]);
    }
    return this;
  }
  addVariable(variable) {
    this.values.set(variable.name, variable);
  }
  addVariables(variables) {
    for (let i = 0; i < variables.length; i++) {
      this.addVariable(variables[i]);
    }
  }
  addVariableArray(name, variables) {
    if (this.values.has(name)) {
      this.values.delete(name);
    }
    const array = new _Scope(this.statamicProject);
    array.addVariables(variables);
    this.addScopeList(name, array);
  }
  injectAssetContainer(symbol, container) {
    this.addBlueprintFields(symbol, this.statamicProject.getAssetBlueprintFields(container));
  }
  injectUserFields(symbol) {
    this.addBlueprintFields(symbol, this.statamicProject.getUserFields());
  }
  addBlueprintField(symbol, field) {
    this.addVariable({
      dataType: field.type,
      name: field.name,
      sourceField: field,
      sourceName: field.blueprintName,
      introducedBy: symbol
    });
  }
  introduceScopedAliasScope(symbol, scopeName, aliasName, fields) {
    this.pristine.set(aliasName, {
      introducedFields: fields,
      introducedScope: aliasName,
      parentCopy: this.copy()
    });
    const newAliasScope = new _Scope(this.statamicProject), fieldScope = new _Scope(this.statamicProject);
    fieldScope.addBlueprintFields(symbol, fields);
    newAliasScope.name = aliasName;
    newAliasScope.addScopeList(scopeName, fieldScope);
    this.addScopeList(aliasName, newAliasScope);
    return newAliasScope;
  }
  expandScopedAliasScope(symbol, scopeName, aliasName, fields) {
    if (this.lists.has(aliasName) == false) {
      this.introduceScopedAliasScope(symbol, scopeName, aliasName, fields);
    } else {
      const listRef = this.lists.get(aliasName);
      listRef.addBlueprintFields(symbol, fields);
    }
  }
  introduceAliasScope(symbol, aliasName, fields) {
    this.pristine.set(aliasName, {
      introducedFields: fields,
      introducedScope: aliasName,
      parentCopy: this.copy()
    });
    const newAliasScope = new _Scope(this.statamicProject);
    newAliasScope.addBlueprintFields(symbol, fields);
    newAliasScope.name = aliasName;
    this.addScopeList(aliasName, newAliasScope);
  }
  introduceDynamicScopeList(symbol, listName, fields) {
    this.pristine.set(listName, {
      introducedFields: fields,
      introducedScope: listName,
      parentCopy: this.copy()
    });
    const newListScope = new _Scope(this.statamicProject);
    newListScope.name = listName;
    newListScope.addBlueprintFields(symbol, fields);
    this.addScopeList(listName, newListScope);
  }
  addBlueprintFields(symbol, fields) {
    for (let i = 0; i < fields.length; i++) {
      this.addBlueprintField(symbol, fields[i]);
    }
  }
  injectBlueprint(symbol, handle) {
    const blueprintDetails = this.statamicProject.getBlueprintDetails(handle);
    if (blueprintDetails.length > 0) {
      this.addBlueprintFields(symbol, blueprintDetails);
    }
  }
  copy() {
    const newScope = new _Scope(this.statamicProject);
    newScope.pristine = new Map(this.pristine);
    newScope.values = new Map(this.values);
    newScope.lists = new Map(this.lists);
    newScope.parentScope = this;
    return newScope;
  }
};
var Scope = _Scope;
Scope.generationCounter = 0;

// server/src/antlers/variables/systemVariables.ts
function getSiteData(project) {
  const siteScope = new Scope(project);
  siteScope.addVariable({ dataType: "string", name: "handle", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "name", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "locale", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "short_locale", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  siteScope.addVariable({ dataType: "string", name: "url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  return siteScope;
}
function getSystemVariables() {
  const systemVariables = [];
  systemVariables.push({ dataType: "number", name: "response_code", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "csrf_field", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "csrf_token", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "environment", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "template", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "xml_header", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "last_segment", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "homepage", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_uri", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_url", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "string", name: "current_template", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "boolean", name: "is_homepage", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "date", name: "now", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "date", name: "today", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "date", name: "current_date", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "get", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "get_post", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "post", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  systemVariables.push({ dataType: "array", name: "old", sourceField: null, sourceName: "*internal.system", introducedBy: null });
  return systemVariables;
}

// server/src/antlers/scope/factories/paginationFactory.ts
function checkNodeForPagination(node, scope) {
  const paginateParam = node.findParameter("paginate");
  if (paginateParam != null) {
    if (paginateParam.value.toLowerCase() == "true" || parseInt(paginateParam.value).toString() == paginateParam.value) {
      const paginationItems = scope.makeNew(), linksScope = scope.makeNew(), allScope = scope.makeNew(), segmentsScope = scope.makeNew();
      paginationItems.addVariable({
        name: "next_page",
        dataType: "string",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "prev_page",
        dataType: "string",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "total_items",
        dataType: "integer",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "total_pages",
        dataType: "integer",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "current_page",
        dataType: "integer",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      paginationItems.addVariable({
        name: "auto_links",
        dataType: "string",
        sourceName: "*internal.pagination",
        sourceField: null,
        introducedBy: node
      });
      allScope.addVariable({
        name: "url",
        dataType: "string",
        sourceField: null,
        sourceName: "*internal.pagination.all",
        introducedBy: node
      });
      allScope.addVariable({
        name: "page",
        dataType: "integer",
        sourceField: null,
        sourceName: "*internal.pagination.all",
        introducedBy: node
      });
      segmentsScope.addVariable({
        name: "first",
        dataType: "boolean",
        sourceName: "*internal.pagination.segments",
        sourceField: null,
        introducedBy: node
      });
      segmentsScope.addVariable({
        name: "last",
        dataType: "boolean",
        sourceName: "*internal.pagination.segments",
        sourceField: null,
        introducedBy: node
      });
      segmentsScope.addVariable({
        name: "slider",
        dataType: "boolean",
        sourceName: "*internal.pagination.segments",
        sourceField: null,
        introducedBy: node
      });
      linksScope.addScopeList("all", allScope);
      linksScope.addScopeList("segments", segmentsScope);
      paginationItems.addScopeList("links", linksScope);
      scope.addScopeList("paginate", paginationItems);
    }
  }
}

// server/src/antlers/scope/injections.ts
var InjectionManager = class {
  constructor() {
    this.fileInjections = /* @__PURE__ */ new Map();
    this.project = null;
  }
  updateProject(project) {
    this.project = project;
  }
  registerInjections(fileName, nodes) {
    if (nodes.length == 0) {
      return;
    }
    const newNodes = [];
    for (let i = 0; i < nodes.length; i++) {
      const thisNode = nodes[i];
      if (thisNode.hasParameters) {
        newNodes.push(thisNode);
      }
    }
    if (newNodes.length > 0) {
      const partialName = newNodes[0].getMethodNameValue();
      if (partialName != null && this.project != null) {
        const projectPartial = this.project.findPartial(partialName);
        if (projectPartial != null) {
          if (!this.fileInjections.has(projectPartial.documentUri)) {
            this.fileInjections.set(projectPartial.documentUri, /* @__PURE__ */ new Map());
          }
          const partialFiles = this.fileInjections.get(projectPartial.documentUri);
          partialFiles.set(fileName, newNodes);
        }
      }
    }
  }
  hasAvailableInjections(documentUri) {
    return this.fileInjections.has(documentUri);
  }
  getScopeInjection(documentUri, project) {
    const newScope = new Scope(project);
    newScope.name = "*injection*";
    const injections = this.fileInjections.get(documentUri);
    injections.forEach((nodes, file) => {
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.hasParameters) {
          for (let j = 0; j < node.parameters.length; j++) {
            const thisParam = node.parameters[j];
            if (thisParam.containsSimpleValue()) {
              newScope.addVariable({
                dataType: "string",
                name: thisParam.name,
                sourceField: null,
                sourceName: "scope.injection",
                introducedBy: node
              });
            } else if (thisParam.isVariableReference) {
              if (node.currentScope != null) {
                if (node.currentScope.hasListInHistory(thisParam.value)) {
                  const injectList = node.currentScope.findNestedScope(thisParam.value);
                  if (injectList != null) {
                    const adjustedName = trimLeft(thisParam.name, ":"), nestedInjection = injectList.copy();
                    nestedInjection.name = adjustedName;
                    newScope.addScopeList(adjustedName, injectList);
                  }
                }
              }
            }
          }
        }
      }
    });
    return newScope;
  }
};
InjectionManager.instance = null;
if (typeof InjectionManager.instance == "undefined" || InjectionManager.instance == null) {
  InjectionManager.instance = new InjectionManager();
}
var injections_default = InjectionManager;

// server/src/antlers/scope/engine.ts
var IgnoreArrayContextualData = ["collection"];
var ChecksForFieldReferences = ["if", "elseif", "unless", "elseunless"];
var ScopeEngine = class {
  constructor(project, documentUri, document) {
    this.pageVars = [];
    this.viewDataVars = null;
    this.documentUri = "";
    this.lastSymbolId = "";
    this.ideHelperMap = /* @__PURE__ */ new Map();
    this.statamicProject = project;
    this.documentUri = documentUri;
    this.document = document;
    this.makePageScope();
    this.makeViewDataScope();
  }
  makeViewDataScope() {
    if (this.document.hasFrontMatter()) {
      this.viewDataVars = this.document.getFrontMatterScope();
    }
  }
  makePageScope() {
    const newPageVariables = [];
    const projFields = this.statamicProject.getFields();
    if (projFields.has("pages")) {
      const pageFields = projFields.get("pages");
      for (let i = 0; i < pageFields.length; i++) {
        const thisField = pageFields[i];
        newPageVariables.push({
          name: thisField.name,
          dataType: thisField.type,
          sourceField: thisField,
          sourceName: thisField.blueprintName,
          introducedBy: null
        });
      }
    }
    this.pageVars = newPageVariables;
  }
  analyzeScope(nodes) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const rootScope = new Scope(this.statamicProject);
    rootScope.name = "*root*";
    rootScope.parentScope = rootScope;
    rootScope.addScopeList("site", getSiteData(this.statamicProject));
    rootScope.addScopeList("sites", getSiteData(this.statamicProject));
    rootScope.addVariables(getSystemVariables());
    const rootUserVariableScope = new Scope(this.statamicProject);
    rootUserVariableScope.name = "*root_user*";
    rootUserVariableScope.parentScope = rootScope;
    this.statamicProject.getUserFields().forEach((field) => {
      rootUserVariableScope.addBlueprintField(null, field);
    });
    rootScope.addScopeList("current_user", rootUserVariableScope);
    if ((_a = referenceManager_default.instance) == null ? void 0 : _a.pageScopeDisabled(this.documentUri)) {
      if (this.viewDataVars != null) {
        rootScope.addScopeList("view", this.viewDataVars);
      }
    } else {
      if (this.viewDataVars != null) {
        rootScope.mergeAndList("page", this.pageVars).addScopeList("view", this.viewDataVars);
      } else {
        rootScope.mergeAndList("page", this.pageVars);
      }
    }
    let ideHelper = null;
    if (nodes.length > 0 && nodes[0].isComment) {
      ideHelper = parseIdeHelper(this.documentUri, nodes[0]);
    }
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].isComment) {
        const varIdeHelper = parseIdeHelper(this.documentUri, nodes[i]);
        if (varIdeHelper.variableHelper != null) {
          this.ideHelperMap.set(nodes[i].id(), varIdeHelper.variableHelper);
        }
      }
    }
    let documentCollectionNames = this.statamicProject.getCollectionNamesForView(encodeURIComponent(this.documentUri));
    if (ideHelper != null) {
      if (ideHelper.collectionInjections.length > 0) {
        documentCollectionNames = documentCollectionNames.concat(ideHelper.collectionInjections);
      }
      if (ideHelper.blueprints.length > 0) {
        documentCollectionNames = documentCollectionNames.concat(ideHelper.blueprints);
      }
      if (ideHelper.variableHelper != null) {
        if (ideHelper.variableHelper.variableName == "@page") {
          const fieldRef = this.statamicProject.getBlueprintField(ideHelper.variableHelper.collectionName, ideHelper.variableHelper.fieldHandle);
          if (fieldRef != null) {
            if (ideHelper.variableHelper.setHandle.length > 0) {
              if (fieldRef.sets != null) {
                for (let i = 0; i < fieldRef.sets.length; i++) {
                  if (fieldRef.sets[i].handle == ideHelper.variableHelper.setHandle) {
                    rootScope.addVariables(blueprintFieldsToScopeVariables(nodes[0], fieldRef.sets[i].fields));
                    break;
                  }
                }
              }
            } else {
              rootScope.addBlueprintField(nodes[0], fieldRef);
            }
          }
        }
      }
    }
    if (documentCollectionNames.length > 0) {
      for (let i = 0; i < documentCollectionNames.length; i++) {
        rootScope.injectBlueprint(nodes[0], documentCollectionNames[i]);
      }
      rootScope.addVariables(makeContentVariables(nodes[0]));
    }
    if ((_b = injections_default.instance) == null ? void 0 : _b.hasAvailableInjections(this.documentUri)) {
      rootScope.mergeScope((_c = injections_default.instance) == null ? void 0 : _c.getScopeInjection(this.documentUri, this.statamicProject));
    }
    const currentScopeParts = [], popScopeIds = [], resolvedPaths = [], activeScopes = [];
    activeScopes.push(rootScope);
    for (let i = 0; i < nodes.length; i++) {
      const currentNode = nodes[i];
      if (this.lastSymbolId.length > 0 && popScopeIds.includes(currentNode.id())) {
        currentScopeParts.pop();
        activeScopes.pop();
        if (activeScopes.length == 0) {
          activeScopes.push(rootScope);
        }
      }
      let currentScope = activeScopes[activeScopes.length - 1];
      if (currentNode.hasParameters) {
        for (let j = 0; j < currentNode.parameters.length; j++) {
          if (currentNode.parameters[j].interpolations.length > 0) {
            for (let k = 0; k < currentNode.parameters[j].interpolations.length; k++) {
              const tInterpolationName = currentNode.parameters[j].interpolations[k];
              if (currentNode.processedInterpolationRegions.has(tInterpolationName)) {
                const tIntNodes = currentNode.processedInterpolationRegions.get(tInterpolationName);
                tIntNodes.forEach((node) => {
                  if (node instanceof AntlersNode) {
                    node.currentScope = currentScope;
                  }
                });
              }
            }
          }
        }
      }
      if (((_d = tagManagerInstance_default.instance) == null ? void 0 : _d.isKnownTag(currentNode.getTagName())) == false) {
        currentNode.scopeVariable = currentScope.findReference(currentNode.runtimeName());
        if (i > 0) {
          const lastSymbol = nodes[i - 1];
          if (lastSymbol.isComment && this.ideHelperMap.has(lastSymbol.id()) && !lastSymbol.isClosingTag && !currentNode.isClosingTag) {
            const ideHelper2 = this.ideHelperMap.get(lastSymbol.id());
            if (ideHelper2.variableName == currentNode.getTagName()) {
              const collectionFieldReference = this.statamicProject.getBlueprintField(ideHelper2.collectionName, ideHelper2.fieldHandle);
              if (collectionFieldReference != null) {
                currentNode.scopeVariable = blueprintFieldToScopeVariable(currentNode, collectionFieldReference);
              }
            }
          }
        }
        if (currentNode.scopeVariable == null) {
          const trimmedRuntimeName = currentNode.runtimeName().trim();
          if (currentScope.hasList(trimmedRuntimeName) || ((_e = currentNode.currentScope) == null ? void 0 : _e.hasListInHistory(trimmedRuntimeName))) {
            currentNode.sourceType = "array";
            const listReference = currentScope.getList(trimmedRuntimeName);
            if (listReference != null && listReference.values.size > 0) {
              const firstListVar = listReference.values.entries().next().value[1];
              currentNode.scopeVariable = {
                dataType: "array",
                introducedBy: firstListVar.introducedBy,
                name: trimmedRuntimeName,
                sourceField: null,
                sourceName: firstListVar.sourceName
              };
            }
          }
        } else {
          currentNode.sourceType = getFieldRuntimeType(currentNode.scopeVariable.dataType);
          if (currentNode.scopeVariable.sourceField != null) {
            if ((_f = fieldtypeManager_default.instance) == null ? void 0 : _f.hasFieldtype(currentNode.scopeVariable.sourceField.type)) {
              const fieldTypeRef = (_g = fieldtypeManager_default.instance) == null ? void 0 : _g.getFieldType(currentNode.scopeVariable.sourceField.type);
              fieldTypeRef.augmentScope(currentNode, currentScope);
            }
          }
        }
      }
      if (currentNode.hasParameters) {
        checkNodeForPagination(currentNode, currentScope);
      }
      if (currentNode.modifiers != null && currentNode.modifiers.hasModifiers()) {
        currentNode.manifestType = currentNode.modifiers.getLastManifestedModifierRuntimeType();
      } else {
        currentNode.manifestType = currentNode.sourceType;
      }
      if (currentNode.isClosedBy != null) {
        currentScopeParts.push(currentNode.id());
        popScopeIds.push(currentNode.isClosedBy.id());
        currentScope = currentScope.copy();
        activeScopes.push(currentScope);
      }
      if (currentNode.getTagName() == "scope" && currentNode.hasMethodPart()) {
        const snapshot = activeScopes[activeScopes.length - 2].copy();
        currentScope.addScopeList(currentNode.getMethodNameValue(), snapshot);
      }
      if (currentScope.containsPath(currentNode.runtimeName())) {
        currentScopeParts.push(currentNode.id());
        if (currentNode.isClosedBy != null) {
          popScopeIds.push(currentNode.isClosedBy.id());
        }
        currentScope = currentScope.copy().bringListIntoMainScope(currentNode.runtimeName());
        activeScopes.push(currentScope);
        currentNode.currentScope = currentScope;
      } else {
        currentNode.currentScope = currentScope;
      }
      if (currentNode.getTagName() != "cache") {
        const scopeParam = currentNode.findParameter("scope");
        if (scopeParam != null && currentScope.canShiftScope(currentNode.runtimeName())) {
          currentScope = currentScope.shiftScope(currentNode, currentNode.runtimeName(), scopeParam.value);
          currentNode.currentScope = currentScope;
          activeScopes.pop();
          activeScopes.push(currentScope);
        }
      }
      if ((_h = tagManagerInstance_default.instance) == null ? void 0 : _h.isKnownTag(currentNode.runtimeName())) {
        const tagRef = (_i = tagManagerInstance_default.instance) == null ? void 0 : _i.findTag(currentNode.runtimeName());
        if (typeof tagRef !== "undefined" && tagRef.augmentScope != null) {
          tagRef.augmentScope(currentNode, currentScope);
        }
      }
      if (currentNode.modifierChain != null && currentNode.modifierChain.modifierChain.length > 0) {
        currentNode.modifierChain.modifierChain.forEach((modifier) => {
          if (modifier.modifier != null && typeof modifier.modifier.augmentScope != "undefined" && modifier.modifier.augmentScope != null) {
            modifier.modifier.augmentScope(currentNode, currentScope);
          }
        });
      }
      if (currentNode.modifiers.hasParameterModifiers()) {
        currentNode.modifiers.parameterModifiers.forEach((param) => {
          if (param.modifier != null && typeof param.modifier.augmentScope != "undefined" && param.modifier.augmentScope != null) {
            param.modifier.augmentScope(currentNode, currentScope);
          }
        });
      }
      if (currentNode.sourceType == "array") {
        const chunkParam = currentNode.findParameter("chunk");
        let injectContextualArrayData = true;
        if (currentNode.parent != null && currentNode.parent instanceof AntlersNode) {
          if (IgnoreArrayContextualData.includes(currentNode.parent.runtimeName())) {
            injectContextualArrayData = false;
          }
        }
        if (typeof chunkParam !== "undefined" && chunkParam !== null) {
          if (currentNode.currentScope.parentScope != null && (currentNode.currentScope.parentScope.hasList(currentNode.runtimeName()) || currentScope.referencesArray(currentNode.runtimeName()))) {
            const adjustedScope = currentNode.currentScope.parentScope.copy();
            let thisArrayValues = adjustedScope.liftList(currentNode.runtimeName());
            if (thisArrayValues == null && currentScope.referencesArray(currentNode.runtimeName())) {
              thisArrayValues = new Scope(currentScope.statamicProject);
              if (injectContextualArrayData) {
                const symbolArrayVariables = makeArrayVariables(currentNode);
                for (let i2 = 0; i2 < symbolArrayVariables.length; i2++) {
                  const checkVar = symbolArrayVariables[i2];
                  if (adjustedScope.wasIntroducedBySymbol(checkVar.name, currentNode)) {
                    adjustedScope.removeThroughIntroduction(checkVar.name, currentNode);
                  }
                }
                thisArrayValues.addVariables(symbolArrayVariables);
              }
            } else {
              if (injectContextualArrayData) {
                adjustedScope.addVariables(makeArrayVariables(currentNode));
              }
            }
            adjustedScope.addScopeList("chunk", thisArrayValues);
            currentScope = adjustedScope;
            activeScopes.pop();
            activeScopes.push(currentScope);
            currentNode.currentScope = adjustedScope;
          } else {
            const scopeParam = currentNode.findParameter("scope");
            if (typeof scopeParam !== "undefined" && scopeParam !== null) {
              if (currentNode.currentScope != null && currentNode.currentScope.hasList(scopeParam.value) && currentNode.scopeName != null) {
                const adjustedScope = currentNode.currentScope.copy(), injectScope = adjustedScope.ancestor().copy(), thisArrayValues = adjustedScope.liftList(currentNode.scopeName);
                if (injectContextualArrayData) {
                  adjustedScope.addVariables(makeArrayVariables(currentNode));
                }
                injectScope.liftList(currentNode.scopeName);
                adjustedScope.addScopeList(currentNode.scopeName, thisArrayValues);
                injectScope.addScopeList("chunk", adjustedScope);
                currentScope = injectScope;
                activeScopes.pop();
                activeScopes.push(currentScope);
                currentNode.currentScope = injectScope;
              }
            }
          }
        } else {
          if (currentNode.scopeVariable != null && currentNode.scopeVariable.sourceField == null) {
            if (injectContextualArrayData) {
              currentScope.addVariables(makeArrayVariables(currentNode));
              currentScope.addVariables(makeLoopVariables(currentNode));
            }
          }
        }
      }
      if (popScopeIds.includes(currentNode.id())) {
        if (currentNode.parent != null && currentNode.parent instanceof AntlersNode) {
          const tRef = currentNode.currentScope.findAncestorWithList(currentNode.getTagName());
          if (tRef != null) {
            currentNode.currentScope = tRef;
            currentScope = tRef.copy();
            activeScopes.pop();
            if (activeScopes.length == 0) {
              activeScopes.push(rootScope);
            }
            activeScopes.push(currentScope);
          } else {
            if (currentNode.parent.parent != null) {
              currentNode.currentScope = currentNode.parent.parent.currentScope;
            } else {
              currentNode.currentScope = currentNode.parent.currentScope;
            }
          }
        }
      }
      if (currentNode.currentScope != null && currentNode.runtimeNodes.length > 0) {
        currentNode.runtimeNodes.forEach((runtimeNode) => {
          var _a2;
          if (runtimeNode instanceof VariableNode) {
            if ((_a2 = currentNode.currentScope) == null ? void 0 : _a2.hasValue(runtimeNode.name)) {
              const varRef = currentNode.currentScope.findReferenceWithField(runtimeNode.name);
              runtimeNode.currentScope = currentNode.currentScope;
              runtimeNode.scopeName = currentNode.scopeName;
              runtimeNode.scopeVariable = varRef;
            }
          }
        });
      }
      if (ChecksForFieldReferences.includes(currentNode.runtimeName())) {
        if (currentNode.runtimeNodes.length == 3) {
          if (currentNode.runtimeNodes[0] instanceof VariableNode && currentNode.runtimeNodes[1] instanceof EqualCompOperator && currentNode.runtimeNodes[2] instanceof StringValueNode) {
            if (currentNode.runtimeNodes[0].scopeVariable != null && currentNode.runtimeNodes[0].scopeVariable.sourceField != null) {
              const targetVar = currentNode.runtimeNodes[0].scopeVariable, checkValue = currentNode.runtimeNodes[2].value, targetField = targetVar.sourceField;
              if (targetField.sets != null) {
                for (let setIndex = 0; setIndex < targetField.sets.length; setIndex++) {
                  const thisSet = targetField.sets[setIndex];
                  if (thisSet.handle == checkValue && thisSet.fields != null) {
                    currentScope = currentScope.copy();
                    currentScope.addBlueprintFields(currentNode, thisSet.fields);
                    if (currentNode.isClosedBy != null && !currentNode.isSelfClosing) {
                      currentScopeParts.push(currentNode.id());
                      popScopeIds.push(currentNode.isClosedBy.id());
                      activeScopes.push(currentScope);
                    }
                    break;
                  }
                }
              }
            }
          }
        }
      }
      this.lastSymbolId = currentNode.id();
      const scopePath = currentScopeParts.join("/");
      resolvedPaths.push(scopePath);
    }
  }
};

// server/src/runtime/errors/antlersError.ts
var import_ts_md5 = __toESM(require_md52());
var AntlersError = class {
  constructor() {
    this.node = null;
    this.errorCode = "";
    this.message = "";
    this.level = 0 /* Error */;
    this.range = null;
  }
  hash() {
    var _a, _b, _c, _d;
    let positionSlug = "";
    if (this.node != null) {
      positionSlug = ((_b = (_a = this.node.endPosition) == null ? void 0 : _a.offset) != null ? _b : 0).toString() + "|" + ((_d = (_c = this.node.startPosition) == null ? void 0 : _c.offset) != null ? _d : 0).toString() + "|";
    }
    return import_ts_md5.Md5.hashStr(positionSlug + "|" + this.errorCode + "|" + this.message);
  }
  static makeSyntaxError(errorCode, node, message, level) {
    if (level == null) {
      level = 0 /* Error */;
    }
    const error = new AntlersError();
    error.errorCode = errorCode;
    error.node = node;
    error.message = message;
    error.level = level;
    return error;
  }
};

// server/src/runtime/errors/antlersErrorCodes.ts
var AntlersErrorCodes = class {
};
AntlersErrorCodes.TYPE_EXPECTING_OPERAND = "ANTLR_001";
AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT = "ANTLR_002";
AntlersErrorCodes.TYPE_RUNTIME_TYPE_MISMATCH = "ANTLR_003";
AntlersErrorCodes.TYPE_RUNTIME_DIVIDE_BY_ZERO = "ANTLR_004";
AntlersErrorCodes.TYPE_RUNTIME_UNKNOWN_LANG_OPERATOR = "ANTLR_005";
AntlersErrorCodes.TYPE_RUNTIME_UNEXPECTED_STACK_CONDITION = "ANTLR_006";
AntlersErrorCodes.TYPE_RUNTIME_PARSE_VALUE_VIOLATION = "ANTLR_007";
AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL = "ANTLR_008";
AntlersErrorCodes.TYPE_PARSE_EMPTY_CONDITIONAL = "ANTLR_009";
AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL = "ANTLR_008";
AntlersErrorCodes.TYPE_ILLEGAL_STRING_ESCAPE_SEQUENCE = "ANTLR_009";
AntlersErrorCodes.TYPE_INCOMPLETE_ANTLERS_REGION = "ANTLR_010";
AntlersErrorCodes.TYPE_INCOMPLETE_ANTELRS_COMMENT_REGION = "ANTLR_011";
AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_RIGHT = "ANTLR_012";
AntlersErrorCodes.TYPE_ILLEGAL_DOTVARPATH_RIGHT = "ANTLR_013";
AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SUBPATH_START = "ANTLR_014";
AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SPACE_RIGHT = "ANTLR_015";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_VARPATH_ACCESSOR = "ANTLR_016";
AntlersErrorCodes.TYPE_ILLEGAL_VARIABLE_NAME = "ANTLR_017";
AntlersErrorCodes.TYPE_UNSET_MODIFIER_DETAILS = "ANTLR_018";
AntlersErrorCodes.TYPE_MODIFIER_NAME_NOT_START_OF_DETAILS = "ANTLR_019";
AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_VALUE = "ANTLR_020";
AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_END_OF_VALUE_LIST = "ANTLR_021";
AntlersErrorCodes.TYPE_TERNARY_EXPECTING_BRANCH_SEPARATOR = "ANTLR_022";
AntlersErrorCodes.TYPE_TERNARY_UNEXPECTED_EXPRESSION_LENGTH = "ANTLR_023";
AntlersErrorCodes.TYPE_RECURSIVE_UNPAIRED_NODE = "ANTLR_024";
AntlersErrorCodes.TYPE_RECURSIVE_NODE_INVALID_POSITION = "ANTLR_025";
AntlersErrorCodes.TYPE_NO_PARSE_UNASSOCIATED = "ANTLR_026";
AntlersErrorCodes.TYPE_RECURSIVE_NODE_UNASSOCIATED_PARENT = "ANTLR_027";
AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_END = "ANTLR_028";
AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_START = "ANTLR_029";
AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR = "ANTLR_030";
AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR_FOR_VARCOMBINE = "ANTLR_031";
AntlersErrorCodes.TYPE_UNEXPECTED_MODIFIER_SEPARATOR = "ANTLR_032";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_DETAILS = "ANTLR_033";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_VALUE = "ANTLR_034";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NODE_PARAMETER = "ANTLR_035";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_MANIFESTING_ANTLERS_NODE = "ANTLR_036";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_REDUCING_NEGATION_OPERATORS = "ANTLR_037";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_SEMANTIC_GROUP = "ANTLR_038";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NULL_COALESCENCE_GROUP = "ANTLR_039";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP = "ANTLR_040";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP_FALSE_BRANCH = "ANTLR_041";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_EXITING_TERNARY_GROUP = "ANTLR_042";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_NEGATION_OFFSET = "ANTLR_043";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END_DUE_TO_NEGATION = "ANTLR_044";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END = "ANTLR_045";
AntlersErrorCodes.TYPE_RUNTIME_UNKNOWN_LIBRARY = "ANTLR_046";
AntlersErrorCodes.TYPE_RUNTIME_LIBRARY_BAD_METHOD_CALL = "ANTLR_047";
AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_WHILE_CREATING_GROUPS = "ANTLR_048";
AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_OPERAND = "ANTLR_049";
AntlersErrorCodes.TYPE_UNEXPECTED_LOGIC_NEGATION_OPERATOR = "ANTLR_050";
AntlersErrorCodes.TYPE_FACTORIAL_MATERIALIZED_BOOL_DETECTED = "ANTLR_051";
AntlersErrorCodes.TYPE_ARG_UNEXPECTED_NAMED_ARGUMENT = "ANTLR_052";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_BRANCH_GROUP = "ANTLR_053";
AntlersErrorCodes.TYPE_UNEXPECTED_UNNAMED_METHOD_ARGUMENT = "ANTLR_054";
AntlersErrorCodes.TYPE_LIBRARY_CALL_NO_ARGS_PROVIDED = "ANTLR_055";
AntlersErrorCodes.TYPE_LIBRARY_CALL_MISSING_REQUIRED_FORMAL_ARG = "ANTLR_056";
AntlersErrorCodes.TYPE_LIBRARY_CALL_RUNTIME_TYPE_MISMATCH = "ANTLR_057";
AntlersErrorCodes.TYPE_LIBRARY_CALL_UNEXPECTED_ARG_RESOLVE_FAULT = "ANTLR_058";
AntlersErrorCodes.TYPE_LIBRARY_CALL_TOO_MANY_ARGUMENTS = "ANTLR_059";
AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_WHILE_PARSING_METHOD = "ANTLR_060";
AntlersErrorCodes.TYPE_INVALID_NAMED_ARG_IDENTIFIER = "ANTLR_061";
AntlersErrorCodes.TYPE_LIBRARY_CALL_INVALID_ARGUMENT_NAME = "ANTLR_062";
AntlersErrorCodes.TYPE_RUNTIME_ATTEMPT_TO_OVERWRITE_LOADED_LIBRARY = "ANTLR_063";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_ARG_GROUP = "ANTLR_064";
AntlersErrorCodes.TYPE_EXPECTING_ARGUMENT_GROUP = "ANTLR_065";
AntlersErrorCodes.TYPE_RUNTIME_PROTECTED_LIBRARY_ACCESS_VIOLATION = "ANTLR_066";
AntlersErrorCodes.TYPE_RUNTIME_FATAL_UNPAIRED_LOOP_END = "ANTLR_067";
AntlersErrorCodes.TYPE_UNEXPECTED_OPERATOR = "ANTLR_068";
AntlersErrorCodes.TYPE_OPERATOR_INVALID_ON_RIGHT = "ANTLR_069";
AntlersErrorCodes.TYPE_INVALID_ASSIGNMENT_LOOP_PAIR = "ANTLR_070";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_ORDER_GROUP = "ANTLR_071";
AntlersErrorCodes.TYPE_EXPECTING_ORDER_GROUP_FOR_ORDER_BY_OPERAND = "ANTLR_072";
AntlersErrorCodes.TYPE_QUERY_UNSUPPORTED_VALUE_TYPE = "ANTLR_073";
AntlersErrorCodes.TYPE_UNEXPECTED_RUNTIME_RESULT_FOR_ORDER_BY_CLAUSE = "ANTLR_074";
AntlersErrorCodes.TYPE_UNEXPECTED_EMPTY_DIRECTION_GROUP = "ANTLR_075";
AntlersErrorCodes.TYPE_INVALID_ORDER_BY_NAME_VALUE = "ANTLR_076";
AntlersErrorCodes.TYPE_INVALID_ORDER_BY_SORT_VALUE = "ANTLR_077";
AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_GROUP_BY = "ANTLR_78";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_GROUP_BY = "ANTLR_079";
AntlersErrorCodes.TYPE_UNEXPECTED_GROUP_BY_AS_ALIAS_TYPE = "ANTLR_080";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_SWITCH_GROUP = "ANTLR_081";
AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_SWITCH_GROUP = "ANTLR_082";
AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE = "ANTLR_083";
AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE = "ANTLR_084";
AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_SEMANTIC_VALUE = "ANTLR_085";
AntlersErrorCodes.TYPE_SWITCH_DEFAULT_MUST_BE_LAST = "ANTLR_086";
AntlersErrorCodes.TYPE_PARSER_INVALID_SWITCH_TOKEN = "ANTLR_087";
AntlersErrorCodes.TYPE_ORDER_BY_INVALID_RETURN_TYPE = "ANTLR_088";
AntlersErrorCodes.TYPE_GROUP_BY_SCOPED_GROUP_MUST_BE_ENCLOSED = "ANTLR_089";
AntlersErrorCodes.TYPE_PLUCK_INTO_MISSING_VARIABLE_TARGET = "ANTLR_090";
AntlersErrorCodes.TYPE_PLUCK_INTO_INVALID_VARIABLE_TARGET = "ANTLR_091";
AntlersErrorCodes.TYPE_PLUCK_INTO_NO_PREDICATE = "ANTLR_092";
AntlersErrorCodes.TYPE_PLUCK_INTO_INVALID_PREDICATE_VALUE = "ANTLR_093";
AntlersErrorCodes.TYPE_PLUCK_INTO_EMPTY_LOGIC_GROUP = "ANTLR_094";
AntlersErrorCodes.TYPE_PLUCK_INTO_INVALID_NUMBER_OF_TUPLE_VARIABLES = "ANTLR_095";
AntlersErrorCodes.TYPE_PLUCK_INTO_UNKNOWN_ALIAS_VARNAME = "ANTLR_096";
AntlersErrorCodes.TYPE_PLUCK_INTO_UNEXPECTED_EMPTY_T_LOGIC_GROUP = "ANTLR_097";
AntlersErrorCodes.TYPE_PLUCK_INTO_REFERENCE_TYPE_DYNAMIC = "ANTLR_098";
AntlersErrorCodes.TYPE_PLUCK_INTO_REFERENCE_AMBIGUOUS = "ANTLR_099";
AntlersErrorCodes.TYPE_RUNTIME_ASSIGNMENT_TO_NON_VAR = "ANTLR_100";
AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_TARGET = "ANTLR_101";
AntlersErrorCodes.TYPE_ARR_MAKE_UNEXPECTED_TYPE = "ANTLR_102";
AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_ARR_KEY_PAIR_VALUE = "ANTLR_103";
AntlersErrorCodes.TYPE_ARR_KEY_PAIR_INVALID_KEY_TYPE = "ANTLR_104";
AntlersErrorCodes.TYPE_ARR_UNEXPECT_ARG_SEPARATOR = "ANTLR_105";
AntlersErrorCodes.TYPE_ARR_KEY_PAIR_MISSING_KEY = "ANTLR_106";
AntlersErrorCodes.RUNTIME_PROTECTED_VAR_ACCESS = "ANTLR_107";
AntlersErrorCodes.RUNTIME_PROTECTED_TAG_ACCESS = "ANTLR_108";
AntlersErrorCodes.RUNTIME_PROTECTED_MODIFIER_ACCESS = "ANTLR_109";
AntlersErrorCodes.TYPE_INCOMPLETE_PHP_EVALUATION_REGION = "ANTLR_110";
AntlersErrorCodes.RUNTIME_PHP_NODE_WHEN_PHP_DISABLED = "ANTLR_111";
AntlersErrorCodes.RUNTIME_PHP_NODE_USER_CONTENT_TAG = "ANTLR_112";
AntlersErrorCodes.TYPE_UNEXPECTED_TYPE_FOR_TUPLE_LIST = "ANTLR_113";
AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_TUPLE_LIST = "ANTLR_114";
AntlersErrorCodes.TYPE_MISSING_BODY_TUPLE_LIST = "ANTLR_115";
AntlersErrorCodes.TYPE_MISSING_NAMES_TUPLE_LIST = "ANTLR_116";
AntlersErrorCodes.TYPE_VALUE_NAME_LENGTH_MISMATCH_TUPLE_LIST = "ANTLR_117";
AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_NAME_TYPE = "ANTLR_118";
AntlersErrorCodes.TYPE_INVALID_MANIFESTED_NAME_GROUP = "ANTLR_119";
AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE_GROUP = "ANTLR_120";
AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE = "ANTLR_121";
AntlersErrorCodes.TYPE_RUNTIME_BAD_METHOD_CALL = "ANTLR_122";
AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_ARG_GROUP = "ANTLR_123";
AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP = "ANTLR_124";
AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_METHOD = "ANTLR_125";
AntlersErrorCodes.TYPE_MODIFIER_NOT_FOUND = "ANTLR_126";
AntlersErrorCodes.TYPE_RUNTIME_GENERAL_FAULT = "ANTLR_127";
AntlersErrorCodes.TYPE_MODIFIER_INCORRECT_VALUE_POSITION = "ANTLR_128";
AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_TOKEN_METHOD_SYNTAX = "ANTLR_129";
AntlersErrorCodes.PARSER_CANNOT_PARSE_PATH_RECURSIVE = "ANTLR_200";
AntlersErrorCodes.PATH_STRING_NOT_INSIDE_ARRAY_ACCESSOR = "ANTLR_201";
AntlersErrorCodes.LINT_UNKNOWN_PARAMETER = "ANTLR_500";
AntlersErrorCodes.LINT_GENERAL_INVALID_PARAMETER_CONTENTS = "ANTLR_501";
AntlersErrorCodes.LINT_PARAMETER_CONTENT_INVALID_INTEGER = "ANTLR_502";
AntlersErrorCodes.LINT_PARAMETER_CONTENT_INVALID_BOOLEAN = "ANT LR_503";
AntlersErrorCodes.LINT_PAGINATE_INVALID_VALUE = "ANTLR_504";
AntlersErrorCodes.LINT_DEBUG_DATA_EXPOSED = "ANTLR_505";
AntlersErrorCodes.LINT_DOUBLE_COLON_IN_TAG_IDENTIFIER = "ANTLR_506";
AntlersErrorCodes.LINT_MIXED_MODIFIERS = "ANTLER_507";
AntlersErrorCodes.LINT_MODIFIER_UNEXPECTED_TYPE = "ANTLR_508";
AntlersErrorCodes.LINT_REMOVE_RELATE_TAG = "ANTLR_509";
AntlersErrorCodes.LINT_SET_PRODUCES_RUNTIME_ERROR = "ANTLR_510";
AntlersErrorCodes.LINT_FRONT_MATTER_EMPTY_DOCUMENT = "ANTLR_511";
AntlersErrorCodes.LINT_SHORTHAND_MODIFIER_TAG_MUST_MATCH = "ANTLR_512";
AntlersErrorCodes.LINT_INVALID_FRONT_MATTER = "ANTLR_513";
AntlersErrorCodes.LINT_DUPLICATE_CODE = "ANTLR_514";
AntlersErrorCodes.LINT_VERSION_NOT_COMPATIBLE = "ANTLR_515";

// server/src/runtime/runtime/globalRuntimeState.ts
var GlobalRuntimeState = class {
};
GlobalRuntimeState.globalTagEnterStack = [];
GlobalRuntimeState.interpolatedVariables = [];

// server/src/runtime/parser/documentParser.ts
var import_md52 = __toESM(require_md52());

// server/src/runtime/nodes/tagIdentifier.ts
var TagIdentifier = class {
  constructor() {
    this.name = "";
    this.compound = "";
    this.methodPart = "";
    this.content = "";
    this.cachedCompoundTagName = null;
  }
  tagPartIs(check) {
    check = check.toLowerCase().trim();
    const checkAgainst = this.name.toLowerCase().trim();
    return checkAgainst == check;
  }
  isCompound() {
    if (this.methodPart == null) {
      return false;
    }
    return this.methodPart.length > 0;
  }
  getMethodName() {
    if (this.methodPart == "") {
      return "index";
    }
    if (this.methodPart == "null") {
      return "";
    }
    return this.methodPart;
  }
  getRuntimeMethodName() {
  }
  getCompoundTagName() {
    if (this.cachedCompoundTagName == null) {
      const methodName = this.getMethodName();
      this.cachedCompoundTagName = this.name;
      if (methodName != null && methodName != "") {
        this.cachedCompoundTagName = this.cachedCompoundTagName + ":" + methodName;
      }
    }
    return this.cachedCompoundTagName;
  }
};

// server/src/runtime/utilities/nodeHelpers.ts
var NodeHelpers = class {
  static distance(left, right) {
    if (left.endPosition == null || right.startPosition == null) {
      return this.DistMax;
    }
    return right.startPosition.index - left.endPosition.index;
  }
  static getTrueName(node) {
    var _a, _b, _c, _d;
    if (node.originalNode != null) {
      return (_b = (_a = node.originalNode.name) == null ? void 0 : _a.name) != null ? _b : "";
    }
    return (_d = (_c = node.name) == null ? void 0 : _c.name) != null ? _d : "";
  }
  static getSimpleVarName(variableNode) {
    if (variableNode.variableReference != null && variableNode.variableReference.pathParts.length == 1) {
      if (variableNode.variableReference.pathParts[0] instanceof PathNode) {
        return variableNode.variableReference.pathParts[0].name;
      }
    }
    return "";
  }
  static isVariableMatching(node, path) {
    if (node instanceof VariableNode) {
      return node.name == path;
    }
    return false;
  }
  static mergeVarContentLeft(content, referenceNode, target) {
    target.mergeRefName = target.name;
    target.endPosition = referenceNode.endPosition;
    target.name = target.name + content;
    return target;
  }
  static mergeVarContentRight(content, referenceNode, target) {
    target.mergeRefName = target.name;
    target.startPosition = referenceNode.startPosition;
    target.name = content + target.name;
    return target;
  }
  static mergeVarRight(left, right) {
    right.mergeRefName = right.name;
    right.startPosition = left.startPosition;
    right.name = left.name + right.name;
    return right;
  }
  static getUnrefName(text) {
    return StringUtilities.trimLeft(text, ":.");
  }
};
NodeHelpers.DistMax = 65e3;

// server/src/runtime/analyzers/conditionPairAnalyzer.ts
var _ConditionPairAnalyzer = class {
  static isConditionalStructure(node) {
    var _a, _b;
    if (node.isComment) {
      return false;
    }
    const name = (_b = (_a = node.name) == null ? void 0 : _a.name) != null ? _b : "";
    if (name == "if" || name == "elseif" || name == "else") {
      return true;
    }
    return false;
  }
  static requiresClose(node) {
    var _a, _b;
    const name = (_b = (_a = node.name) == null ? void 0 : _a.name) != null ? _b : "";
    if (name == "elseif" || name == "else") {
      if (node.isClosedBy != null) {
        return false;
      }
      return true;
    }
    if (node.isClosingTag) {
      return false;
    }
    if (node.isClosedBy != null) {
      return false;
    }
    return true;
  }
  static getValidClosingPairs(current) {
    if (current == "if" || current == "elseif") {
      return _ConditionPairAnalyzer.conditionClosingPairs;
    }
    return [];
  }
  static findClosestStructurePair(nodes, node, index) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const stack = [], nodeLen = nodes.length, conditionCloseIndex = /* @__PURE__ */ new Map();
    let lastCloseIndex = null;
    stack.push({
      node,
      index
    });
    for (let i = 0; i < nodeLen; i += 1) {
      const node2 = nodes[i];
      if (node2 instanceof AntlersNode) {
        const name = (_b = (_a = node2.name) == null ? void 0 : _a.name) != null ? _b : "";
        if (node2.isClosingTag && name == "if") {
          conditionCloseIndex.set(i, i);
          continue;
        } else {
          if (name == "elseif" || name == "else") {
            conditionCloseIndex.set(i, i);
            continue;
          }
        }
      }
    }
    const conditionIndexLength = conditionCloseIndex.size;
    while (stack.length > 0) {
      const curItem = stack.pop();
      if (curItem == null) {
        continue;
      }
      if (curItem.node._conditionParserAbandonPairing) {
        break;
      }
      const curNode = curItem.node, thisValidPairs = _ConditionPairAnalyzer.getValidClosingPairs((_d = (_c = curNode.name) == null ? void 0 : _c.name) != null ? _d : "");
      let curIndex = curItem.index, doSkipValidation = false;
      if (conditionIndexLength > 50 && lastCloseIndex != null) {
        for (const [cIndex, n] of conditionCloseIndex) {
          if (cIndex > curIndex) {
            curIndex = cIndex;
            break;
          }
        }
      }
      for (let i = curIndex; i < nodeLen; i++) {
        const subNode = nodes[i];
        if (subNode instanceof AntlersNode) {
          if (_ConditionPairAnalyzer.isConditionalStructure(subNode)) {
            if (_ConditionPairAnalyzer.requiresClose(subNode)) {
              stack.push(curItem);
              stack.push({
                node: subNode,
                index: i + 1
              });
              doSkipValidation = true;
              break;
            }
            if (curNode.isClosedBy != null) {
              continue;
            }
            const subNodeName = (_f = (_e = subNode.name) == null ? void 0 : _e.name) != null ? _f : "";
            let canClose = false;
            if (subNode.ref == 0 && (subNode.isClosingTag && subNodeName == "if" || thisValidPairs.includes(subNodeName))) {
              canClose = true;
            }
            if (subNode.refId == curNode.refId) {
              canClose = false;
            }
            if (canClose) {
              lastCloseIndex = i;
              conditionCloseIndex.delete(i);
              curNode.isClosedBy = subNode;
              subNode.isOpenedBy = curNode;
              subNode.ref += 1;
              doSkipValidation = true;
              break;
            }
          }
        }
      }
      if (!doSkipValidation) {
        if (curNode instanceof AntlersNode) {
          const nodeName = (_h = (_g = curNode.name) == null ? void 0 : _g.name) != null ? _h : "";
          if ((nodeName == "elseif" || nodeName == "else") && curNode.isOpenedBy == null) {
            curNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL, curNode, 'Unpaired "' + NodeHelpers.getTrueName(curNode) + '" control structure.'));
            curNode._conditionParserAbandonPairing = true;
          }
          if (curNode.isClosedBy == null && _ConditionPairAnalyzer.requiresClose(curNode)) {
            curNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL, curNode, 'Unclosed "' + NodeHelpers.getTrueName(curNode) + '" control structure.'));
            curNode._conditionParserAbandonPairing = true;
          }
        }
      }
    }
  }
  static pairConditionals(nodes) {
    for (let i = 0; i < nodes.length; i += 1) {
      const node = nodes[i];
      if (node instanceof AntlersNode && _ConditionPairAnalyzer.isConditionalStructure(node)) {
        if (_ConditionPairAnalyzer.requiresClose(node)) {
          _ConditionPairAnalyzer.findClosestStructurePair(nodes, node, i + 1);
        }
      }
    }
    nodes.forEach((node) => {
      var _a, _b;
      if (node instanceof AntlersNode && _ConditionPairAnalyzer.isConditionalStructure(node)) {
        const name = (_b = (_a = node.name) == null ? void 0 : _a.name) != null ? _b : "";
        if ((name == "elseif" || name == "else") && node.isOpenedBy == null) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL, node, 'Unpaired "' + NodeHelpers.getTrueName(node) + '" control structure.'));
          return;
        }
        if (node.isClosedBy == null && _ConditionPairAnalyzer.requiresClose(node)) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL, node, "Unclosed " + NodeHelpers.getTrueName(node) + " control structure."));
          return;
        }
      }
    });
    return nodes;
  }
};
var ConditionPairAnalyzer = _ConditionPairAnalyzer;
ConditionPairAnalyzer.conditionClosingPairs = ["elseif", "else"];

// server/src/runtime/runtime/environmentDetails.ts
var _EnvironmentDetails = class {
  constructor() {
    this.tagNames = [];
    this.modifierNames = [];
  }
  getModifierNames() {
    var _a, _b;
    return this.modifierNames.concat((_b = (_a = modifierManager_default.instance) == null ? void 0 : _a.getModifierNames()) != null ? _b : []);
  }
  getTagNames() {
    var _a, _b;
    return this.tagNames.concat((_b = (_a = tagManagerInstance_default.instance) == null ? void 0 : _a.getTagNames()) != null ? _b : []);
  }
  setTagNames(tagNames) {
    this.tagNames = tagNames;
  }
  setModifierNames(modifierNames) {
    this.modifierNames = modifierNames;
  }
  isTag(value) {
    var _a;
    if (_EnvironmentDetails.alwaysLikeTag.includes(value)) {
      return true;
    }
    if ((_a = tagManagerInstance_default.instance) == null ? void 0 : _a.isKnownTag(value)) {
      return true;
    }
    return this.tagNames.includes(value);
  }
  isModifier(value) {
    var _a;
    if ((_a = modifierManager_default.instance) == null ? void 0 : _a.hasModifier(value)) {
      return true;
    }
    return this.modifierNames.includes(value);
  }
};
var EnvironmentDetails = _EnvironmentDetails;
EnvironmentDetails.alwaysLikeTag = [
  "if",
  "endif",
  "elseif",
  "else",
  "unless",
  "elseunless"
];

// server/src/runtime/analyzers/nodeTypeAnalyzer.ts
var _NodeTypeAnalyzer = class {
  static analyze(nodes, environmentDetails) {
    nodes.forEach((node) => {
      if (node instanceof AntlersNode) {
        if (node.pathReference != null && node.pathReference.isStrictVariableReference) {
          node.isTagNode = false;
          return;
        }
        if (node.name != null) {
          node.isTagNode = environmentDetails.isTag(node.name.name);
        }
      }
    });
  }
  static analyzeNode(node) {
    if (node.pathReference != null && node.pathReference.isStrictVariableReference) {
      node.isTagNode = false;
      return;
    }
    if (_NodeTypeAnalyzer.environmentDetails != null && node.name != null) {
      node.isTagNode = _NodeTypeAnalyzer.environmentDetails.isTag(node.name.name);
    }
    if (node.name != null) {
      node.isConditionNode = EnvironmentDetails.alwaysLikeTag.includes(node.name.name);
    }
  }
  static analyzeParametersForModifiers(node) {
    node.parameters.forEach((parameter) => {
      if (_NodeTypeAnalyzer.environmentDetails != null) {
        parameter.isModifierParameter = _NodeTypeAnalyzer.environmentDetails.isModifier(parameter.name);
      }
    });
  }
};
var NodeTypeAnalyzer = _NodeTypeAnalyzer;
NodeTypeAnalyzer.environmentDetails = null;
if (typeof NodeTypeAnalyzer.environmentDetails == "undefined" || NodeTypeAnalyzer.environmentDetails == null) {
  NodeTypeAnalyzer.environmentDetails = new EnvironmentDetails();
}
var nodeTypeAnalyzer_default = NodeTypeAnalyzer;

// server/src/runtime/analyzers/tagIdentifierAnalyzer.ts
var TagIdentifierAnalyzer = class {
  static getIdentifier(input) {
    var _a;
    const identifier = new TagIdentifier();
    identifier.content = input.trim();
    const parts = input.split(":");
    if (parts.length == 1) {
      identifier.name = parts[0].trim();
      identifier.methodPart = null;
      identifier.compound = identifier.name;
    } else if (parts.length > 1) {
      const name = (_a = parts.shift()) != null ? _a : "", methodPart = parts.join(":");
      identifier.name = name.trim();
      identifier.methodPart = methodPart.trim();
      identifier.compound = identifier.name + ":" + identifier.methodPart;
    } else {
      identifier.name = input.trim();
      identifier.methodPart = "";
    }
    if (identifier.name.startsWith("/")) {
      identifier.name = identifier.name.substr(1);
      identifier.compound = identifier.compound.substr(1);
    }
    return identifier;
  }
};

// server/src/runtime/errors/typeLabeler.ts
var _TypeLabeler = class {
  static getPrettyTypeName(token) {
    if (token instanceof LanguageOperatorConstruct) {
      return _TypeLabeler.TOKEN_LANG_OPERATOR;
    } else if (token instanceof AdditionOperator) {
      return _TypeLabeler.TOKEN_OP_A_ADD;
    } else if (token instanceof VariableNode) {
      return _TypeLabeler.TOKEN_VARIABLE;
    } else if (token instanceof StringValueNode) {
      return _TypeLabeler.TOKEN_STRING;
    } else if (token instanceof NumberNode) {
      return _TypeLabeler.TOKEN_NUMBER;
    } else if (token instanceof FalseConstant) {
      return _TypeLabeler.TOKEN_CONSTANT_FALSE;
    } else if (token instanceof NullConstant) {
      return _TypeLabeler.TOKEN_CONSTANT_NULL;
    } else if (token instanceof TrueConstant) {
      return _TypeLabeler.TOKEN_CONSTANT_TRUE;
    } else if (token instanceof ModifierNode) {
      return _TypeLabeler.TOKEN_MODIFIER_NODE;
    } else if (token instanceof ModifierChainNode) {
      return _TypeLabeler.TOKEN_MODIFIER_CHAIN;
    } else if (token instanceof ModifierParameterNode) {
      return _TypeLabeler.TOKEN_MODIFIER_PARAMETER;
    } else if (token instanceof DivisionOperator) {
      return _TypeLabeler.TOKEN_OP_A_DIVIDE;
    } else if (token instanceof ExponentiationOperator) {
      return _TypeLabeler.TOKEN_OP_A_EXPONENTIATION;
    } else if (token instanceof ModulusOperator) {
      return _TypeLabeler.TOKEN_OP_A_MODULUS;
    } else if (token instanceof MultiplicationOperator) {
      return _TypeLabeler.TOKEN_OP_A_MULTIPLY;
    } else if (token instanceof SubtractionOperator) {
      return _TypeLabeler.TOKEN_OP_A_SUBTRACT;
    } else if (token instanceof AdditionAssignmentOperator) {
      return _TypeLabeler.TOKEN_ASG_ADD;
    } else if (token instanceof DivisionAssignmentOperator) {
      return _TypeLabeler.TOKEN_ASG_DIVIDE;
    } else if (token instanceof ModulusAssignmentOperator) {
      return _TypeLabeler.TOKEN_ASG_MODULUS;
    } else if (token instanceof MultiplicationAssignmentOperator) {
      return _TypeLabeler.TOKEN_ASG_MULTIPLY;
    } else if (token instanceof LeftAssignmentOperator) {
      return _TypeLabeler.TOKEN_ASG_ASSIGN;
    } else if (token instanceof SubtractionAssignmentOperator) {
      return _TypeLabeler.TOKEN_ASG_SUBTRACT;
    } else if (token instanceof EqualCompOperator) {
      return _TypeLabeler.TOKEN_CMP_EQUAL;
    } else if (token instanceof StrictEqualCompOperator) {
      return _TypeLabeler.TOKEN_CMP_SEQUAL;
    } else if (token instanceof GreaterThanCompOperator) {
      return _TypeLabeler.TOKEN_CMP_GT;
    } else if (token instanceof GreaterThanEqualCompOperator) {
      return _TypeLabeler.TOKEN_CMP_GTE;
    } else if (token instanceof LessThanCompOperator) {
      return _TypeLabeler.TOKEN_CMP_LT;
    } else if (token instanceof LessThanEqualCompOperator) {
      return _TypeLabeler.TOKEN_CMP_LTE;
    } else if (token instanceof NotEqualCompOperator) {
      return _TypeLabeler.TOKEN_CMP_NEQ;
    } else if (token instanceof NotStrictEqualCompOperator) {
      return _TypeLabeler.TOKEN_CMP_SNEQ;
    } else if (token instanceof SpaceshipCompOperator) {
      return _TypeLabeler.TOKEN_CMP_SPACESHIP;
    } else if (token instanceof ConditionalVariableFallbackOperator) {
      return _TypeLabeler.TOKEN_OP_VARIABLE_FALLBACK;
    } else if (token instanceof ConditionalFallbackGroup) {
      return _TypeLabeler.TOKEN_COND_FALLBACK_GROUP;
    } else if (token instanceof InlineBranchSeparator) {
      return _TypeLabeler.TOKEN_BRANCH_SEPARATOR;
    } else if (token instanceof InlineTernarySeparator) {
      return _TypeLabeler.TOKEN_TERNARY_SEPARATOR;
    } else if (token instanceof LogicGroupBegin) {
      return _TypeLabeler.TOKEN_GROUP_BEGIN;
    } else if (token instanceof LogicGroupEnd) {
      return _TypeLabeler.TOKEN_GROUP_END;
    } else if (token instanceof ModifierSeparator) {
      return _TypeLabeler.TOKEN_MODIFIER_SEPARATOR;
    } else if (token instanceof ModifierNameNode) {
      return _TypeLabeler.TOKEN_MODIFIER_NAME;
    } else if (token instanceof ModifierValueNode) {
      return _TypeLabeler.TOKEN_MODIFIER_VALUE;
    } else if (token instanceof ModifierValueSeparator) {
      return _TypeLabeler.TOKEN_MODIFIER_VALUE_SEPARATOR;
    } else if (token instanceof NullCoalescenceGroup) {
      return _TypeLabeler.TOKEN_NULL_COALESCE_GROUP;
    } else if (token instanceof SemanticGroup) {
      return _TypeLabeler.TOKEN_SEMANTIC_GROUP;
    } else if (token instanceof StatementSeparatorNode) {
      return _TypeLabeler.TOKEN_STATEMENT_SEPARATOR;
    } else if (token instanceof TernaryCondition) {
      return _TypeLabeler.TOKEN_TERNARY_CONDITION;
    } else if (token instanceof LogicalAndOperator) {
      return _TypeLabeler.TOKEN_OP_AND;
    } else if (token instanceof LogicalNegationOperator) {
      return _TypeLabeler.TOKEN_OP_LOGIC_NEGATION;
    } else if (token instanceof LogicalOrOperator) {
      return _TypeLabeler.TOKEN_OP_OR;
    } else if (token instanceof LogicalXorOperator) {
      return _TypeLabeler.TOKEN_OP_XOR;
    } else if (token instanceof NullCoalesceOperator) {
      return _TypeLabeler.TOKEN_OP_NULL_COALESCE;
    } else if (token instanceof ParameterNode2) {
      return _TypeLabeler.TOKEN_PARAM;
    } else if (token instanceof PathNode) {
      return _TypeLabeler.TOKEN_PATH_ACCESSOR;
    } else if (token instanceof FactorialOperator) {
      return _TypeLabeler.TOKEN_OP_A_FACTORIAL;
    } else if (token instanceof RecursiveNode) {
      return _TypeLabeler.TOKEN_RECURSIVE;
    } else if (token instanceof ArgumentGroup) {
      return _TypeLabeler.TOKEN_ARG_GROUP;
    } else if (token instanceof ArgSeparator) {
      return _TypeLabeler.TOKEN_ARG_SEPARATOR;
    } else if (token instanceof StringConcatenationOperator) {
      return _TypeLabeler.TOKEN_OP_STRING_CONCAT;
    } else if (token instanceof ScopeAssignmentOperator) {
      return _TypeLabeler.TOKEN_OP_SCOPE_REASSIGNMENT;
    } else if (token instanceof SwitchCase) {
      return _TypeLabeler.TOKEN_STRUCT_SWITCH_CASE;
    } else if (token instanceof SwitchGroup) {
      return _TypeLabeler.TOKEN_STRUCT_SWITCH_GROUP;
    } else if (token instanceof DirectionGroup) {
      return _TypeLabeler.TOKEN_STRUCT_DIRECTION_GROUP;
    } else if (token instanceof ScopedLogicGroup) {
      return _TypeLabeler.TOKEN_STRUCT_SCOPED_LOGIC_GROUP;
    } else if (token instanceof LogicGroup) {
      return _TypeLabeler.TOKEN_STRUCT_LOGIC_GROUP;
    } else if (token instanceof ValueDirectionNode) {
      return _TypeLabeler.TOKEN_STRUCT_VALUE_DIRECTION;
    } else if (token instanceof ArrayNode) {
      return _TypeLabeler.TOKEN_STRUCT_ARRAY;
    } else if (token instanceof TupleListStart) {
      return _TypeLabeler.TOKEN_STRUCT_T_LIST_START;
    } else if (token instanceof TupleList) {
      return _TypeLabeler.TOKEN_STRUCT_TUPLE_LIST;
    } else if (token instanceof MethodInvocationNode) {
      return _TypeLabeler.TOKEN_STRUCT_METHOD_CALL;
    }
    return typeof token;
  }
};
var TypeLabeler = _TypeLabeler;
TypeLabeler.TOKEN_LANG_OPERATOR = "T_LANG_OPERATOR";
TypeLabeler.TOKEN_VARIABLE = "T_VAR";
TypeLabeler.TOKEN_NUMBER = "T_NUMERIC";
TypeLabeler.TOKEN_STRING = "T_STRING";
TypeLabeler.TOKEN_RECURSIVE = "T_RECURSIVE";
TypeLabeler.TOKEN_CONSTANT_FALSE = "T_FALSE";
TypeLabeler.TOKEN_CONSTANT_NULL = "T_NULL";
TypeLabeler.TOKEN_CONSTANT_TRUE = "T_TRUE";
TypeLabeler.TOKEN_MODIFIER_NODE = "T_MODIFIER";
TypeLabeler.TOKEN_MODIFIER_CHAIN = "T_MODIFIER_CHAIN";
TypeLabeler.TOKEN_MODIFIER_PARAMETER = "T_MODIFIER_PARAM";
TypeLabeler.TOKEN_OP_A_ADD = "T_AOP_ADD";
TypeLabeler.TOKEN_OP_A_DIVIDE = "T_AOP_DIVIDE";
TypeLabeler.TOKEN_OP_A_EXPONENTIATION = "T_AOP_EXP";
TypeLabeler.TOKEN_OP_A_MODULUS = "T_AOP_MOD";
TypeLabeler.TOKEN_OP_A_MULTIPLY = "T_AOP_MULTIPLY";
TypeLabeler.TOKEN_OP_A_SUBTRACT = "T_AOP_SUBTRACT";
TypeLabeler.TOKEN_OP_A_FACTORIAL = "T_AOP_FACTORIAL";
TypeLabeler.TOKEN_ASG_ADD = "T_ASG_ADD";
TypeLabeler.TOKEN_ASG_DIVIDE = "T_ASG_DIVIDE";
TypeLabeler.TOKEN_ASG_ASSIGN = "T_ASG";
TypeLabeler.TOKEN_ASG_MODULUS = "T_ASG_MODULUS";
TypeLabeler.TOKEN_ASG_MULTIPLY = "T_ASG_MULTIPLY";
TypeLabeler.TOKEN_ASG_SUBTRACT = "T_ASG_SUBTRACT";
TypeLabeler.TOKEN_CMP_EQUAL = "T_CMP_EQ";
TypeLabeler.TOKEN_CMP_SEQUAL = "T_CMP_SEQ";
TypeLabeler.TOKEN_CMP_GT = "T_CMP_GT";
TypeLabeler.TOKEN_CMP_GTE = "T_CMP_GTE";
TypeLabeler.TOKEN_CMP_LT = "T_CMP_LT";
TypeLabeler.TOKEN_CMP_LTE = "T_CMP_LTE";
TypeLabeler.TOKEN_CMP_NEQ = "T_CMP_NEQ";
TypeLabeler.TOKEN_CMP_SNEQ = "T_CMP_SNEQ";
TypeLabeler.TOKEN_CMP_SPACESHIP = "T_CMP_SPSHP";
TypeLabeler.TOKEN_OP_VARIABLE_FALLBACK = "T_VFBK";
TypeLabeler.TOKEN_COND_FALLBACK_GROUP = "T_VFBK_GROUP";
TypeLabeler.TOKEN_BRANCH_SEPARATOR = "T_BRANCH_SEPARATOR";
TypeLabeler.TOKEN_TERNARY_SEPARATOR = "T_TERNARY_SEPARATOR";
TypeLabeler.TOKEN_GROUP_BEGIN = "T_LOGIC_BEGIN";
TypeLabeler.TOKEN_GROUP_END = "T_LOGIC_END";
TypeLabeler.TOKEN_MODIFIER_SEPARATOR = "T_MODIFIER_SEPARATOR";
TypeLabeler.TOKEN_MODIFIER_NAME = "T_MODIFIER_NAME";
TypeLabeler.TOKEN_MODIFIER_VALUE = "T_MODIFIER_VALUE";
TypeLabeler.TOKEN_MODIFIER_VALUE_SEPARATOR = "T_MODIFIER_VALUE_SEPARATOR";
TypeLabeler.TOKEN_NULL_COALESCE_GROUP = "T_NULL_COALESCE_GROUP";
TypeLabeler.TOKEN_SEMANTIC_GROUP = "T_SEMANTIC_GROUP";
TypeLabeler.TOKEN_STATEMENT_SEPARATOR = "T_STATEMENT_SEPARATOR";
TypeLabeler.TOKEN_TERNARY_CONDITION = "T_TERNARY_CONDITION";
TypeLabeler.TOKEN_OP_AND = "T_AND";
TypeLabeler.TOKEN_OP_LOGIC_NEGATION = "T_LOGIC_INVERSE";
TypeLabeler.TOKEN_OP_OR = "T_OR";
TypeLabeler.TOKEN_OP_XOR = "T_XOR";
TypeLabeler.TOKEN_OP_NULL_COALESCE = "T_NULL_COALESCE";
TypeLabeler.TOKEN_PARAM = "T_PARAM";
TypeLabeler.TOKEN_PATH_ACCESSOR = "T_VAR_SEPARATOR";
TypeLabeler.TOKEN_ARG_GROUP = "T_ARG_GROUP";
TypeLabeler.TOKEN_ARG_SEPARATOR = "T_ARG_SEPARATOR";
TypeLabeler.TOKEN_OP_STRING_CONCAT = "T_STR_CONCAT";
TypeLabeler.TOKEN_OP_SCOPE_REASSIGNMENT = "T_SCOPE_ASSIGNMENT";
TypeLabeler.TOKEN_STRUCT_SWITCH_CASE = "T_SWITCH_CASE";
TypeLabeler.TOKEN_STRUCT_SWITCH_GROUP = "T_SWITCH_GROUP";
TypeLabeler.TOKEN_STRUCT_DIRECTION_GROUP = "T_DIRECTION_GROUP";
TypeLabeler.TOKEN_STRUCT_VALUE_DIRECTION = "T_ORDER_DIRECTION";
TypeLabeler.TOKEN_STRUCT_SCOPED_LOGIC_GROUP = "T_SCOPED_LOGIC_GROUP";
TypeLabeler.TOKEN_STRUCT_LOGIC_GROUP = "T_LOGIC_GROUP";
TypeLabeler.TOKEN_STRUCT_ARRAY = "T_ARRAY";
TypeLabeler.TOKEN_STRUCT_T_LIST_START = "T_LIST_START";
TypeLabeler.TOKEN_STRUCT_TUPLE_LIST = "T_LIST";
TypeLabeler.TOKEN_STRUCT_METHOD_CALL = "T_METHOD_CALL";

// server/src/runtime/parser/languageKeywords.ts
var LanguageKeywords = class {
  static isLanguageLogicalKeyword(value) {
    if (value == this.LogicalAnd || value == this.LogicalNot || value == this.LogicalOr || value == this.LogicalXor) {
      return true;
    }
    return false;
  }
};
LanguageKeywords.LogicalAnd = "and";
LanguageKeywords.LogicalNot = "not";
LanguageKeywords.LogicalOr = "or";
LanguageKeywords.LogicalXor = "xor";
LanguageKeywords.ConstTrue = "true";
LanguageKeywords.ConstFalse = "false";
LanguageKeywords.ConstNull = "null";
LanguageKeywords.ArrList = "list";
LanguageKeywords.ScopeAs = "as";

// server/src/runtime/lexer/antlersLexer.ts
var AntlersLexer = class {
  constructor() {
    this.chars = [];
    this.inputLen = 0;
    this.currentIndex = 0;
    this.currentContent = [];
    this.startIndex = 0;
    this.cur = null;
    this.next = null;
    this.prev = null;
    this.isParsingString = false;
    this.isParsingModifierName = false;
    this.isInModifierParameterValue = false;
    this.runtimeNodes = [];
    this.ignorePrevious = false;
    this.lastNode = null;
    this.referenceParser = null;
    this.activeNode = null;
  }
  reset() {
    this.ignorePrevious = false;
    this.runtimeNodes = [];
    this.chars = [];
    this.inputLen = 0;
    this.currentIndex = 0;
    this.currentContent = [];
    this.startIndex = 0;
    this.cur = null;
    this.next = null;
    this.prev = null;
    this.isParsingString = false;
    this.isParsingModifierName = false;
    this.isInModifierParameterValue = false;
    this.referenceParser = null;
    this.activeNode = null;
  }
  checkCurrentOffsets() {
    this.cur = this.chars[this.currentIndex];
    this.prev = null;
    this.next = null;
    if (!this.ignorePrevious) {
      if (this.currentIndex > 0) {
        this.prev = this.chars[this.currentIndex - 1];
      }
    } else {
      this.prev = "";
      this.ignorePrevious = false;
    }
    if (this.currentIndex + 1 < this.inputLen) {
      this.next = this.chars[this.currentIndex + 1];
    }
  }
  isValidChar(char) {
    if (char == null) {
      return false;
    }
    if (char == DocumentParser.Punctuation_Semicolon) {
      return false;
    }
    if (this.isParsingString == false && char == "]") {
      return true;
    }
    if (this.isParsingString == false && char == ")") {
      return false;
    }
    if ((char == "[" || char == "]") && char == this.cur) {
      return true;
    }
    if ((char == "_" || char == "." || char == "[" || char == "]") && (!(this.currentContent.length > 0) || StringUtilities.ctypeAlpha(this.cur) || StringUtilities.ctypeDigit(this.cur))) {
      return true;
    }
    if (StringUtilities.ctypeSpace(char)) {
      return false;
    }
    if (this.isParsingModifierName && (char == DocumentParser.Punctuation_Minus || char == DocumentParser.Punctuation_Underscore)) {
      return true;
    }
    if (StringUtilities.ctypePunct(char)) {
      return false;
    }
    return true;
  }
  isRightOfInterpolationRegion() {
    if (this.activeNode == null) {
      return false;
    }
    if (this.referenceParser == null) {
      return false;
    }
    const relative = this.activeNode._lexerRelativeOffset(this.currentIndex);
    return this.referenceParser.bordersInterpolationRegion(relative);
  }
  scanForwardTo(char, skip = 0) {
    const returnChars = [];
    for (let i = this.currentIndex + 1 + skip; i < this.inputLen; i++) {
      const cur = this.chars[i];
      if (cur == char) {
        returnChars.push(cur);
        break;
      } else {
        returnChars.push(cur);
      }
    }
    return returnChars;
  }
  nextNonWhitespace() {
    for (let i = this.currentIndex + 1; i < this.inputLen; i++) {
      const cur = this.chars[i];
      if (!StringUtilities.ctypeSpace(cur)) {
        return cur;
      }
    }
    return null;
  }
  pushError(error) {
    if (this.referenceParser != null) {
      this.referenceParser.addAntlersError(error);
    }
  }
  guardAgainstNeighboringTypesInModifier(current) {
    if (this.lastNode instanceof ModifierValueNode) {
      this.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_MODIFIER_INCORRECT_VALUE_POSITION, this.lastNode, "Incorrect type [" + TypeLabeler.getPrettyTypeName(current) + "] near [" + TypeLabeler.getPrettyTypeName(this.lastNode) + "]"));
    }
    return false;
  }
  appendContent(char) {
    if (char != null) {
      this.currentContent.push(char);
    }
  }
  tokenize(node, input) {
    this.reset();
    this.referenceParser = node.getParser();
    this.activeNode = node;
    this.chars = input.split("");
    this.inputLen = this.chars.length;
    this.runtimeNodes = [];
    this.lastNode = null;
    let stringStartedOn = null;
    this.isParsingString = false;
    this.isParsingModifierName = false;
    let terminator = null;
    for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.checkCurrentOffsets();
      let addCurrent = true;
      if (this.isParsingString == false) {
        if (this.cur == DocumentParser.String_Terminator_DoubleQuote || this.cur == DocumentParser.String_Terminator_SingleQuote) {
          if (this.prev == DocumentParser.String_EscapeCharacter) {
            this.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ILLEGAL_STRING_ESCAPE_SEQUENCE, node, "Illegal string escape sequence outside string parsing."));
            continue;
          }
          terminator = this.cur;
          this.isParsingString = true;
          stringStartedOn = this.currentIndex;
          continue;
        }
      }
      if (this.isInModifierParameterValue && !this.isParsingString) {
        let breakForKeyword = false;
        if (!this.isParsingString && StringUtilities.ctypeSpace(this.next)) {
          const nextWord = this.scanForwardTo(" ", 1).join("").trim().toLowerCase();
          if (nextWord.length > 0 && LanguageKeywords.isLanguageLogicalKeyword(nextWord)) {
            breakForKeyword = true;
          }
        }
        if (this.next == DocumentParser.String_Terminator_SingleQuote || this.next == DocumentParser.String_Terminator_DoubleQuote || this.next == null || breakForKeyword) {
          this.appendContent(this.cur);
          const implodedCurrentContent = this.currentContent.join("");
          if (implodedCurrentContent.length > 0) {
            const parsedValue = implodedCurrentContent;
            this.currentContent = [];
            if (parsedValue.trimRight().length == 0) {
              const nextNonWhitespace = this.nextNonWhitespace();
              if (nextNonWhitespace == DocumentParser.String_Terminator_SingleQuote || nextNonWhitespace == DocumentParser.String_Terminator_DoubleQuote) {
                this.currentContent = [];
                continue;
              }
            }
            const modifierValueNode = new ModifierValueNode();
            modifierValueNode.isVirtual = false;
            modifierValueNode.name = parsedValue;
            modifierValueNode.value = parsedValue.trimRight();
            modifierValueNode.startPosition = node._lexerRelativeOffset(this.currentIndex - parsedValue.length);
            modifierValueNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
            modifierValueNode.parent = this.activeNode;
            this.guardAgainstNeighboringTypesInModifier(modifierValueNode);
            this.runtimeNodes.push(modifierValueNode);
            this.lastNode = modifierValueNode;
          }
          if (implodedCurrentContent.length == 0) {
            continue;
          }
          this.currentContent = [];
          this.isInModifierParameterValue = false;
          continue;
        }
        if (this.next == DocumentParser.Punctuation_Pipe || this.next == DocumentParser.Punctuation_Colon || this.next == DocumentParser.RightParent) {
          this.isInModifierParameterValue = false;
          this.appendContent(this.cur);
          let additionalSkip = 0, trimStartEnd = false;
          if (this.currentContent[0] == DocumentParser.String_Terminator_SingleQuote || this.currentContent[0] == DocumentParser.String_Terminator_DoubleQuote) {
            const scan = this.scanForwardTo(this.currentContent[0]);
            if (scan.length > 0) {
              this.currentContent = this.currentContent.concat(scan);
              additionalSkip = scan.length;
              trimStartEnd = true;
            }
          }
          let parsedValue = this.currentContent.join("");
          if (trimStartEnd) {
            parsedValue = parsedValue.substr(1);
            parsedValue = parsedValue.slice(0, -1);
          }
          this.currentContent = [];
          const modifierValueNode = new ModifierValueNode();
          modifierValueNode.isVirtual = false;
          modifierValueNode.name = parsedValue;
          modifierValueNode.value = parsedValue;
          modifierValueNode.startPosition = node._lexerRelativeOffset(this.currentIndex - parsedValue.length);
          modifierValueNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
          modifierValueNode.parent = this.activeNode;
          this.runtimeNodes.push(modifierValueNode);
          this.guardAgainstNeighboringTypesInModifier(modifierValueNode);
          this.lastNode = modifierValueNode;
          this.currentIndex += additionalSkip;
        } else {
          this.appendContent(this.cur);
        }
        continue;
      }
      if (this.isParsingString && this.cur == terminator) {
        if (this.prev == DocumentParser.String_EscapeCharacter) {
          this.appendContent(terminator);
        } else {
          if (this.isInModifierParameterValue) {
            const parsedValue = this.currentContent.join("");
            const modifierValueNode = new ModifierValueNode();
            modifierValueNode.isVirtual = false;
            modifierValueNode.name = parsedValue;
            modifierValueNode.value = parsedValue;
            modifierValueNode.startPosition = node._lexerRelativeOffset(stringStartedOn != null ? stringStartedOn : 0);
            modifierValueNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
            modifierValueNode.parent = this.activeNode;
            this.runtimeNodes.push(modifierValueNode);
            this.guardAgainstNeighboringTypesInModifier(modifierValueNode);
            this.lastNode = modifierValueNode;
            this.currentContent = [];
            this.isParsingString = false;
            this.isInModifierParameterValue = false;
            continue;
          }
          const stringNode = new StringValueNode();
          stringNode.isVirtual = false;
          stringNode.startPosition = node._lexerRelativeOffset(stringStartedOn != null ? stringStartedOn : 0);
          stringNode.endPosition = node._lexerRelativeOffset(this.currentIndex);
          stringNode.parent = this.activeNode;
          if (terminator != null) {
            stringNode.sourceTerminator = terminator;
          }
          terminator = null;
          this.isParsingString = false;
          stringNode.value = this.currentContent.join("");
          this.currentContent = [];
          this.guardAgainstNeighboringTypesInModifier(stringNode);
          this.runtimeNodes.push(stringNode);
          this.lastNode = stringNode;
        }
        continue;
      }
      if (this.isParsingString && this.cur == DocumentParser.String_EscapeCharacter) {
        if (this.next == DocumentParser.String_EscapeCharacter) {
          this.appendContent(DocumentParser.String_EscapeCharacter);
          this.ignorePrevious = true;
          this.currentIndex += 1;
          continue;
        } else if (this.next == DocumentParser.String_Terminator_SingleQuote) {
          this.appendContent(DocumentParser.String_Terminator_SingleQuote);
          this.currentIndex += 1;
          continue;
        } else if (this.next == DocumentParser.String_Terminator_DoubleQuote) {
          this.appendContent(DocumentParser.String_Terminator_DoubleQuote);
          this.currentIndex += 1;
          continue;
        } else if (this.next == "n") {
          this.appendContent("\n");
          this.currentIndex += 1;
          continue;
        } else if (this.next == "t") {
          this.appendContent("	");
          this.currentIndex += 1;
          continue;
        } else if (this.next == "r") {
          this.appendContent("\r");
          this.currentIndex += 1;
          continue;
        }
      }
      if (this.isParsingString == false) {
        if (this.isValidChar(this.cur) && this.isValidChar(this.next) == false && this.currentContent.length == 0) {
          this.appendContent(this.cur);
          addCurrent = false;
        }
        if ((this.next == null || this.isValidChar(this.next) == false) && this.currentContent.length > 0) {
          if (addCurrent) {
            this.appendContent(this.cur);
          }
          const parsedValue = this.currentContent.join("").trim(), valueLen = parsedValue.length, valueStartIndex = this.currentIndex - valueLen, startPosition = node._lexerRelativeOffset(valueStartIndex), endPosition = node._lexerRelativeOffset(this.currentIndex);
          this.currentContent = [];
          if (parsedValue == LanguageKeywords.LogicalAnd) {
            const logicalAnd = new LogicalAndOperator();
            logicalAnd.isVirtual = false;
            logicalAnd.content = LanguageKeywords.LogicalAnd;
            logicalAnd.startPosition = startPosition;
            logicalAnd.endPosition = endPosition;
            logicalAnd.parent = this.activeNode;
            this.runtimeNodes.push(logicalAnd);
            this.lastNode = logicalAnd;
            continue;
          } else if (parsedValue == LanguageKeywords.LogicalOr) {
            const logicalOr = new LogicalOrOperator();
            logicalOr.isVirtual = false;
            logicalOr.content = LanguageKeywords.LogicalOr;
            logicalOr.startPosition = startPosition;
            logicalOr.endPosition = endPosition;
            logicalOr.parent = this.activeNode;
            this.runtimeNodes.push(logicalOr);
            this.lastNode = logicalOr;
            continue;
          } else if (parsedValue == LanguageKeywords.LogicalXor) {
            const logicalXor = new LogicalXorOperator();
            logicalXor.isVirtual = false;
            logicalXor.content = LanguageKeywords.LogicalXor;
            logicalXor.startPosition = startPosition;
            logicalXor.endPosition = endPosition;
            logicalXor.parent = this.activeNode;
            this.runtimeNodes.push(logicalXor);
            this.lastNode = logicalXor;
            continue;
          } else if (parsedValue == LanguageKeywords.ConstNull) {
            const constNull = new NullConstant();
            constNull.isVirtual = false;
            constNull.content = LanguageKeywords.ConstNull;
            constNull.startPosition = startPosition;
            constNull.endPosition = endPosition;
            constNull.parent = this.activeNode;
            this.runtimeNodes.push(constNull);
            this.lastNode = constNull;
            continue;
          } else if (parsedValue == LanguageKeywords.ConstTrue) {
            const constTrue = new TrueConstant();
            constTrue.isVirtual = false;
            constTrue.content = LanguageKeywords.ConstTrue;
            constTrue.startPosition = startPosition;
            constTrue.endPosition = endPosition;
            constTrue.parent = this.activeNode;
            this.runtimeNodes.push(constTrue);
            this.lastNode = constTrue;
            continue;
          } else if (parsedValue == LanguageKeywords.ConstFalse) {
            const constFalse = new FalseConstant();
            constFalse.isVirtual = false;
            constFalse.content = LanguageKeywords.ConstFalse;
            constFalse.startPosition = startPosition;
            constFalse.endPosition = endPosition;
            constFalse.parent = this.activeNode;
            this.runtimeNodes.push(constFalse);
            this.lastNode = constFalse;
            continue;
          } else if (parsedValue == LanguageKeywords.LogicalNot) {
            const logicNegation = new LogicalNegationOperator();
            logicNegation.isVirtual = false;
            logicNegation.content = LanguageKeywords.LogicalNot;
            logicNegation.startPosition = startPosition;
            logicNegation.endPosition = endPosition;
            logicNegation.parent = this.activeNode;
            this.runtimeNodes.push(logicNegation);
            this.lastNode = logicNegation;
            continue;
          } else if (parsedValue == LanguageKeywords.ArrList && this.next == DocumentParser.LeftParen) {
            const tupleListStart = new TupleListStart();
            tupleListStart.isVirtual = false;
            tupleListStart.content = LanguageKeywords.ArrList;
            tupleListStart.startPosition = startPosition;
            tupleListStart.endPosition = endPosition;
            tupleListStart.parent = this.activeNode;
            this.runtimeNodes.push(tupleListStart);
            this.lastNode = tupleListStart;
            continue;
          }
          if (StringUtilities.isNumeric(parsedValue)) {
            const numberNode = new NumberNode();
            numberNode.isVirtual = false;
            numberNode.startPosition = startPosition;
            numberNode.endPosition = endPosition;
            numberNode.parent = this.activeNode;
            if (parsedValue.includes(".")) {
              numberNode.value = parseFloat(parsedValue);
            } else {
              numberNode.value = parseInt(parsedValue);
            }
            this.guardAgainstNeighboringTypesInModifier(numberNode);
            this.runtimeNodes.push(numberNode);
            this.lastNode = numberNode;
            continue;
          }
          if (this.runtimeNodes.length > 0) {
            const lastValue = this.runtimeNodes[this.runtimeNodes.length - 1];
            if (lastValue instanceof ModifierSeparator) {
              const modifierNameNode = new ModifierNameNode();
              modifierNameNode.isVirtual = false;
              modifierNameNode.name = parsedValue;
              modifierNameNode.startPosition = startPosition;
              modifierNameNode.endPosition = endPosition;
              modifierNameNode.parent = this.activeNode;
              this.runtimeNodes.push(modifierNameNode);
              this.lastNode = modifierNameNode;
              continue;
            } else if (lastValue instanceof ModifierValueSeparator) {
              const modifierValueNode = new ModifierValueNode();
              modifierValueNode.isVirtual = false;
              modifierValueNode.name = parsedValue;
              modifierValueNode.value = parsedValue;
              modifierValueNode.startPosition = startPosition;
              modifierValueNode.endPosition = endPosition;
              modifierValueNode.parent = this.activeNode;
              this.runtimeNodes.push(modifierValueNode);
              this.lastNode = modifierValueNode;
              this.isParsingModifierName = false;
              continue;
            }
          }
          const variableRefNode = new VariableNode();
          variableRefNode.isVirtual = false;
          variableRefNode.name = parsedValue;
          variableRefNode.startPosition = startPosition;
          variableRefNode.endPosition = endPosition;
          variableRefNode.parent = this.activeNode;
          this.runtimeNodes.push(variableRefNode);
          this.lastNode = variableRefNode;
          continue;
        }
      } else {
        this.appendContent(this.cur);
        continue;
      }
      if (StringUtilities.ctypeSpace(this.cur)) {
        continue;
      }
      if (this.isParsingString == false) {
        if (this.cur == DocumentParser.Punctuation_Equals && this.next == DocumentParser.Punctuation_GreaterThan) {
          const scopeAssignment = new ScopeAssignmentOperator();
          scopeAssignment.isVirtual = false;
          scopeAssignment.content = "=>";
          scopeAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
          scopeAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          scopeAssignment.parent = this.activeNode;
          this.runtimeNodes.push(scopeAssignment);
          this.lastNode = scopeAssignment;
          this.currentContent = [];
          this.currentIndex += 1;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Comma) {
          const argSeparator = new ArgSeparator();
          argSeparator.isVirtual = false;
          argSeparator.content = DocumentParser.Punctuation_Comma;
          argSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          argSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          argSeparator.parent = this.activeNode;
          this.runtimeNodes.push(argSeparator);
          this.lastNode = argSeparator;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Semicolon) {
          const statementSeparator = new StatementSeparatorNode();
          statementSeparator.isVirtual = false;
          statementSeparator.content = DocumentParser.Punctuation_Semicolon;
          statementSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          statementSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          statementSeparator.parent = this.activeNode;
          this.runtimeNodes.push(statementSeparator);
          this.lastNode = statementSeparator;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Plus) {
          if (this.next == DocumentParser.Punctuation_Equals) {
            const additionAssignment = new AdditionAssignmentOperator();
            additionAssignment.isVirtual = false;
            additionAssignment.content = "+=";
            additionAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
            additionAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            additionAssignment.parent = this.activeNode;
            this.runtimeNodes.push(additionAssignment);
            this.lastNode = additionAssignment;
            this.currentIndex += 1;
            continue;
          }
          const additionOperator = new AdditionOperator();
          additionOperator.isVirtual = false;
          additionOperator.content = "+";
          additionOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          additionOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          additionOperator.parent = this.activeNode;
          this.runtimeNodes.push(additionOperator);
          this.lastNode = additionOperator;
          continue;
        }
        if (this.isParsingModifierName == false && this.cur == DocumentParser.Punctuation_Minus) {
          if (StringUtilities.ctypeDigit(this.next) && (StringUtilities.ctypeDigit(this.prev) == false && this.prev != DocumentParser.RightParent) && this.isRightOfInterpolationRegion() == false) {
            this.appendContent(this.cur);
            continue;
          }
          if (this.next == DocumentParser.Punctuation_Equals) {
            const subtractionAssignment = new SubtractionAssignmentOperator();
            subtractionAssignment.isVirtual = false;
            subtractionAssignment.content = "-=";
            subtractionAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
            subtractionAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            subtractionAssignment.parent = this.activeNode;
            this.runtimeNodes.push(subtractionAssignment);
            this.lastNode = subtractionAssignment;
            this.currentIndex += 1;
            continue;
          } else if (this.next == DocumentParser.Punctuation_GreaterThan) {
            const methodInvocation = new MethodInvocationNode();
            methodInvocation.isVirtual = false;
            methodInvocation.content = "->";
            methodInvocation.startPosition = node._lexerRelativeOffset(this.currentIndex);
            methodInvocation.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            methodInvocation.parent = this.activeNode;
            this.runtimeNodes.push(methodInvocation);
            this.lastNode = methodInvocation;
            this.currentIndex += 1;
            continue;
          }
          const subtractionOperator = new SubtractionOperator();
          subtractionOperator.isVirtual = false;
          subtractionOperator.content = "-";
          subtractionOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          subtractionOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          subtractionOperator.parent = this.activeNode;
          this.runtimeNodes.push(subtractionOperator);
          this.lastNode = subtractionOperator;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Asterisk) {
          if (this.next == DocumentParser.Punctuation_Asterisk) {
            const exponentiationOperator = new ExponentiationOperator();
            exponentiationOperator.isVirtual = false;
            exponentiationOperator.content = "**";
            exponentiationOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
            exponentiationOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            exponentiationOperator.parent = this.activeNode;
            this.runtimeNodes.push(exponentiationOperator);
            this.lastNode = exponentiationOperator;
            this.currentIndex += 1;
            continue;
          } else if (this.next == DocumentParser.Punctuation_Equals) {
            const multplicationAssignment = new MultiplicationAssignmentOperator();
            multplicationAssignment.isVirtual = false;
            multplicationAssignment.content = "*=";
            multplicationAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
            multplicationAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            multplicationAssignment.parent = this.activeNode;
            this.runtimeNodes.push(multplicationAssignment);
            this.lastNode = multplicationAssignment;
            this.currentIndex += 1;
            continue;
          }
          const multiplicationOperator = new MultiplicationOperator();
          multiplicationOperator.isVirtual = false;
          multiplicationOperator.content = "*";
          multiplicationOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          multiplicationOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          multiplicationOperator.parent = this.activeNode;
          this.runtimeNodes.push(multiplicationOperator);
          this.lastNode = multiplicationOperator;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_ForwardSlash) {
          if (this.next == DocumentParser.Punctuation_Equals) {
            const divisionAssignment = new DivisionAssignmentOperator();
            divisionAssignment.isVirtual = false;
            divisionAssignment.content = "/=";
            divisionAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
            divisionAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            divisionAssignment.parent = this.activeNode;
            this.runtimeNodes.push(divisionAssignment);
            this.lastNode = divisionAssignment;
            this.currentIndex += 1;
            continue;
          }
          const divisionOperator = new DivisionOperator();
          divisionOperator.isVirtual = false;
          divisionOperator.content = "/";
          divisionOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          divisionOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          divisionOperator.parent = this.activeNode;
          this.runtimeNodes.push(divisionOperator);
          this.lastNode = divisionOperator;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Percent) {
          if (this.next == DocumentParser.Punctuation_Equals) {
            const modulusAssignment = new ModulusAssignmentOperator();
            modulusAssignment.isVirtual = false;
            modulusAssignment.content = "%=";
            modulusAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
            modulusAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            modulusAssignment.parent = this.activeNode;
            this.runtimeNodes.push(modulusAssignment);
            this.lastNode = modulusAssignment;
            this.currentIndex += 1;
            continue;
          }
          const modulusOperator = new ModulusOperator();
          modulusOperator.isVirtual = false;
          modulusOperator.content = "%";
          modulusOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          modulusOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          modulusOperator.parent = this.activeNode;
          this.runtimeNodes.push(modulusOperator);
          this.lastNode = modulusOperator;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_LessThan) {
          if (this.next == DocumentParser.Punctuation_Equals) {
            let peek = null;
            if (this.currentIndex + 2 < this.inputLen) {
              peek = this.chars[this.currentIndex + 2];
            }
            if (peek == DocumentParser.Punctuation_GreaterThan) {
              const spaceshipOperator = new SpaceshipCompOperator();
              spaceshipOperator.isVirtual = false;
              spaceshipOperator.content = "<=>";
              spaceshipOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              spaceshipOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 3);
              spaceshipOperator.parent = this.activeNode;
              this.runtimeNodes.push(spaceshipOperator);
              this.lastNode = spaceshipOperator;
              this.currentIndex += 2;
              continue;
            }
            const lessThanEqual = new LessThanEqualCompOperator();
            lessThanEqual.isVirtual = false;
            lessThanEqual.content = "<=";
            lessThanEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
            lessThanEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            lessThanEqual.parent = this.activeNode;
            this.runtimeNodes.push(lessThanEqual);
            this.lastNode = lessThanEqual;
            this.currentIndex += 1;
            continue;
          }
          const lessThan = new LessThanCompOperator();
          lessThan.isVirtual = false;
          lessThan.content = "<";
          lessThan.startPosition = node._lexerRelativeOffset(this.currentIndex);
          lessThan.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          lessThan.parent = this.activeNode;
          this.runtimeNodes.push(lessThan);
          this.lastNode = lessThan;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_GreaterThan) {
          if (this.next == DocumentParser.Punctuation_Equals) {
            const greaterThanEqual = new GreaterThanCompOperator();
            greaterThanEqual.isVirtual = false;
            greaterThanEqual.content = ">=";
            greaterThanEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
            greaterThanEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            greaterThanEqual.parent = this.activeNode;
            this.runtimeNodes.push(greaterThanEqual);
            this.lastNode = greaterThanEqual;
            this.currentIndex += 1;
            continue;
          }
          const greaterThan = new GreaterThanCompOperator();
          greaterThan.isVirtual = false;
          greaterThan.content = ">";
          greaterThan.startPosition = node._lexerRelativeOffset(this.currentIndex);
          greaterThan.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          greaterThan.parent = this.activeNode;
          this.runtimeNodes.push(greaterThan);
          this.lastNode = greaterThan;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Equals && this.next != DocumentParser.Punctuation_Equals) {
          const leftAssignment = new LeftAssignmentOperator();
          leftAssignment.isVirtual = false;
          leftAssignment.content = "=";
          leftAssignment.startPosition = node._lexerRelativeOffset(this.currentIndex);
          leftAssignment.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          leftAssignment.parent = this.activeNode;
          this.runtimeNodes.push(leftAssignment);
          this.lastNode = leftAssignment;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Equals && this.next == DocumentParser.Punctuation_Equals) {
          let peek = null;
          if (this.currentIndex + 2 < this.inputLen) {
            peek = this.chars[this.currentIndex + 2];
          }
          if (peek == DocumentParser.Punctuation_Equals) {
            const strictEqual = new StrictEqualCompOperator();
            strictEqual.isVirtual = false;
            strictEqual.content = "===";
            strictEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
            strictEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 3);
            strictEqual.parent = this.activeNode;
            this.runtimeNodes.push(strictEqual);
            this.lastNode = strictEqual;
            this.currentIndex += 2;
          } else {
            const equalOperator = new EqualCompOperator();
            equalOperator.isVirtual = false;
            equalOperator.content = "==";
            equalOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
            equalOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            equalOperator.parent = this.activeNode;
            this.runtimeNodes.push(equalOperator);
            this.lastNode = equalOperator;
            this.currentIndex += 1;
          }
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Ampersand) {
          if (this.next == DocumentParser.Punctuation_Ampersand) {
            const logicalAnd2 = new LogicalAndOperator();
            logicalAnd2.isVirtual = false;
            logicalAnd2.content = "&&";
            logicalAnd2.startPosition = node._lexerRelativeOffset(this.currentIndex);
            logicalAnd2.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            logicalAnd2.parent = this.activeNode;
            this.runtimeNodes.push(logicalAnd2);
            this.lastNode = logicalAnd2;
            this.currentIndex += 1;
            continue;
          }
          if (this.next == DocumentParser.Punctuation_Equals) {
            const concatOperator = new StringConcatenationOperator();
            concatOperator.isVirtual = false;
            concatOperator.content = "&=";
            concatOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
            concatOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
            concatOperator.parent = this.activeNode;
            this.runtimeNodes.push(concatOperator);
            this.lastNode = concatOperator;
            continue;
          }
          const logicalAnd = new LogicalAndOperator();
          logicalAnd.isVirtual = false;
          logicalAnd.content = "&";
          logicalAnd.startPosition = node._lexerRelativeOffset(this.currentIndex);
          logicalAnd.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          logicalAnd.parent = this.activeNode;
          this.runtimeNodes.push(logicalAnd);
          this.lastNode = logicalAnd;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Pipe && this.next != DocumentParser.Punctuation_Pipe) {
          const modifierSeparator = new ModifierSeparator();
          modifierSeparator.isVirtual = false;
          modifierSeparator.content = "|";
          modifierSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          modifierSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          modifierSeparator.parent = this.activeNode;
          this.runtimeNodes.push(modifierSeparator);
          this.lastNode = modifierSeparator;
          this.isParsingModifierName = true;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Pipe && this.next == DocumentParser.Punctuation_Pipe) {
          const logicalOr = new LogicalOrOperator();
          logicalOr.isVirtual = false;
          logicalOr.content = "||";
          logicalOr.startPosition = node._lexerRelativeOffset(this.currentIndex);
          logicalOr.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
          logicalOr.parent = this.activeNode;
          this.runtimeNodes.push(logicalOr);
          this.lastNode = logicalOr;
          this.currentIndex += 1;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Exclamation) {
          if (this.next == DocumentParser.Punctuation_Equals) {
            let peek = null;
            if (this.currentIndex + 2 < this.inputLen) {
              peek = this.chars[this.currentIndex + 2];
            }
            if (peek == DocumentParser.Punctuation_Equals) {
              const strictNotEqual = new NotStrictEqualCompOperator();
              strictNotEqual.isVirtual = false;
              strictNotEqual.content = "!==";
              strictNotEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
              strictNotEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 3);
              strictNotEqual.parent = this.activeNode;
              this.runtimeNodes.push(strictNotEqual);
              this.lastNode = strictNotEqual;
              this.currentIndex += 2;
              continue;
            }
            const notEqual = new NotEqualCompOperator();
            notEqual.isVirtual = false;
            notEqual.content = "!=";
            notEqual.startPosition = node._lexerRelativeOffset(this.currentIndex);
            notEqual.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
            notEqual.parent = this.activeNode;
            this.runtimeNodes.push(notEqual);
            this.lastNode = notEqual;
            this.currentIndex += 1;
            continue;
          }
          const logicalNot = new LogicalNegationOperator();
          logicalNot.isVirtual = false;
          logicalNot.content = "!";
          logicalNot.startPosition = node._lexerRelativeOffset(this.currentIndex);
          logicalNot.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          logicalNot.parent = this.activeNode;
          this.runtimeNodes.push(logicalNot);
          this.lastNode = logicalNot;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_Equals) {
          const conditionalFallback = new ConditionalVariableFallbackOperator();
          conditionalFallback.isVirtual = false;
          conditionalFallback.content = "?=";
          conditionalFallback.startPosition = node._lexerRelativeOffset(this.currentIndex);
          conditionalFallback.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
          conditionalFallback.parent = this.activeNode;
          this.runtimeNodes.push(conditionalFallback);
          this.lastNode = conditionalFallback;
          this.currentIndex += 1;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_Question) {
          const nullCoalesceOperator = new NullCoalesceOperator();
          nullCoalesceOperator.isVirtual = false;
          nullCoalesceOperator.content = "??";
          nullCoalesceOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          nullCoalesceOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
          nullCoalesceOperator.parent = this.activeNode;
          this.runtimeNodes.push(nullCoalesceOperator);
          this.lastNode = nullCoalesceOperator;
          this.currentIndex += 1;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Question && this.next == DocumentParser.Punctuation_Colon) {
          const nullCoalesceOperator = new NullCoalesceOperator();
          nullCoalesceOperator.isVirtual = false;
          nullCoalesceOperator.content = "?:";
          nullCoalesceOperator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          nullCoalesceOperator.endPosition = node._lexerRelativeOffset(this.currentIndex + 2);
          nullCoalesceOperator.parent = this.activeNode;
          this.runtimeNodes.push(nullCoalesceOperator);
          this.lastNode = nullCoalesceOperator;
          this.currentIndex += 1;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Question) {
          const ternarySeparator = new InlineTernarySeparator();
          ternarySeparator.isVirtual = false;
          ternarySeparator.content = "?";
          ternarySeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          ternarySeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          ternarySeparator.parent = this.activeNode;
          this.runtimeNodes.push(ternarySeparator);
          this.lastNode = ternarySeparator;
          continue;
        }
        if (this.cur == DocumentParser.LeftParen) {
          const logicalGroupBegin = new LogicGroupBegin();
          logicalGroupBegin.isVirtual = false;
          logicalGroupBegin.content = "(";
          logicalGroupBegin.startPosition = node._lexerRelativeOffset(this.currentIndex);
          logicalGroupBegin.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          logicalGroupBegin.parent = this.activeNode;
          this.runtimeNodes.push(logicalGroupBegin);
          this.lastNode = logicalGroupBegin;
          continue;
        }
        if (this.cur == DocumentParser.RightParent) {
          const logicalGroupEnd = new LogicGroupEnd();
          logicalGroupEnd.isVirtual = false;
          logicalGroupEnd.content = ")";
          logicalGroupEnd.startPosition = node._lexerRelativeOffset(this.currentIndex);
          logicalGroupEnd.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          logicalGroupEnd.parent = this.activeNode;
          this.runtimeNodes.push(logicalGroupEnd);
          this.lastNode = logicalGroupEnd;
          continue;
        }
        if (this.cur == DocumentParser.Punctuation_Colon) {
          if (this.runtimeNodes.length > 0) {
            const lastItem = this.runtimeNodes[this.runtimeNodes.length - 1];
            if (lastItem instanceof ModifierNameNode) {
              const modifierValueSeparator = new ModifierValueSeparator();
              modifierValueSeparator.isVirtual = false;
              modifierValueSeparator.content = ":";
              modifierValueSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
              modifierValueSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
              modifierValueSeparator.parent = this.activeNode;
              this.runtimeNodes.push(modifierValueSeparator);
              if (this.isInModifierParameterValue == false) {
                this.isInModifierParameterValue = true;
              } else {
                this.isInModifierParameterValue = false;
              }
              continue;
            }
          }
          const branchSeparator = new InlineBranchSeparator();
          branchSeparator.isVirtual = false;
          branchSeparator.content = ":";
          branchSeparator.startPosition = node._lexerRelativeOffset(this.currentIndex);
          branchSeparator.endPosition = node._lexerRelativeOffset(this.currentIndex + 1);
          branchSeparator.parent = this.activeNode;
          this.runtimeNodes.push(branchSeparator);
          this.lastNode = branchSeparator;
          this.isParsingModifierName = false;
          continue;
        }
      }
      if (addCurrent) {
        this.appendContent(this.cur);
      }
    }
    const lastIndex = this.runtimeNodes.length - 1;
    for (let i = 0; i < this.runtimeNodes.length; i++) {
      let prev = null, next = null;
      if (i > 0) {
        prev = this.runtimeNodes[i - 1];
      }
      if (i != lastIndex) {
        next = this.runtimeNodes[i + 1];
      }
      const thisNode = this.runtimeNodes[i];
      thisNode.prev = prev;
      thisNode.next = next;
    }
    return this.runtimeNodes;
  }
};

// server/src/runtime/parser/pathParser.ts
var _PathParser = class {
  constructor() {
    this.chars = [];
    this.currentIndex = 0;
    this.lastIndex = 0;
    this.inputLength = 0;
    this.prev = null;
    this.cur = null;
    this.next = null;
    this.isParsingString = false;
    this.isStringKeyPath = false;
    this.antlersErrors = [];
    this._recusriveEntryCheck = /* @__PURE__ */ new Map();
  }
  isValidChar(char) {
    if (this.isParsingString == false && StringUtilities.ctypeSpace(char)) {
      return false;
    }
    if (this.isParsingString == false && char == _PathParser.LeftBracket) {
      return false;
    }
    if (this.isParsingString == false && char == _PathParser.RightBracket) {
      return false;
    }
    return true;
  }
  normalizePath(path) {
    path = path.replace(":", "_");
    path = path.replace(".", "_");
    path = path.replace("[", "_");
    path = path.replace("]", "_");
    return path.replace("]", "_");
  }
  getAntlersErrors() {
    return this.antlersErrors;
  }
  mergeErrors(errors) {
    errors.forEach((error) => {
      this.antlersErrors.push(error);
    });
  }
  parse(content) {
    this.antlersErrors = [];
    this._recusriveEntryCheck.clear();
    const originalContent = content;
    let isStrictVariableReference = false, isExplicitVariableReference = false, isVariableVariable = false, isStrictTagReference = false;
    if (content.startsWith(DocumentParser.AtChar)) {
      isVariableVariable = true;
      content = content.substr(1);
    }
    if (content.startsWith(DocumentParser.Punctuation_Caret)) {
      isStrictTagReference = true;
      content = content.substr(1);
    } else {
      if (content.startsWith(DocumentParser.Punctuation_Dollar)) {
        isStrictVariableReference = true;
        content = content.substr(1);
      }
      if (content.startsWith(DocumentParser.Punctuation_Dollar)) {
        isExplicitVariableReference = true;
        content = content.substr(1);
      }
    }
    this.chars = [];
    this.currentIndex = 0;
    this.lastIndex = 0;
    this.inputLength = 0;
    this.cur = null;
    this.prev = null;
    this.next = null;
    this.chars = content.split("");
    this.inputLength = this.chars.length;
    this.lastIndex = this.inputLength - 1;
    let currentChars = [], isParsingAccessor = false;
    const parts = [];
    let activeDelimiter = _PathParser.ColonSeparator, ignorePrevious = false, terminator = null, isStringVar = false, addCur = true;
    this.isParsingString = false;
    if (this.inputLength == 0) {
      const emptyRef = new VariableReference();
      emptyRef._isFromEmptyFailState = true;
      return emptyRef;
    }
    for (this.currentIndex; this.currentIndex < this.inputLength; this.currentIndex += 1) {
      this.cur = this.chars[this.currentIndex];
      this.next = null;
      if (!ignorePrevious) {
        if (this.currentIndex > 0) {
          this.prev = this.chars[this.currentIndex - 1];
        }
      } else {
        ignorePrevious = false;
        this.prev = "";
      }
      if (this.currentIndex + 1 < this.inputLength) {
        this.next = this.chars[this.currentIndex + 1];
      }
      if (this.isParsingString == false && this.cur == _PathParser.ColonSeparator) {
        activeDelimiter = _PathParser.ColonSeparator;
      }
      if (this.isParsingString == false && this.cur == _PathParser.DotPathSeparator) {
        activeDelimiter = _PathParser.DotPathSeparator;
      }
      if (this.isParsingString && this.cur == DocumentParser.String_EscapeCharacter && this.next == terminator) {
        if (terminator != null) {
          currentChars.push(terminator);
        }
        this.currentIndex += 1;
        continue;
      }
      if (this.cur == DocumentParser.String_Terminator_SingleQuote || this.cur == DocumentParser.String_Terminator_DoubleQuote) {
        if (this.isParsingString) {
          if (this.cur == terminator) {
            if (this.prev == DocumentParser.String_EscapeCharacter) {
              currentChars.push(this.cur);
              continue;
            } else {
              this.isParsingString = false;
              addCur = false;
            }
          } else {
            currentChars.push(this.cur);
            continue;
          }
        } else {
          if (this.prev != DocumentParser.LeftBracket) {
            if (StringUtilities.ctypeAlpha(this.prev) || StringUtilities.ctypeDigit(this.prev)) {
              this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.PATH_STRING_NOT_INSIDE_ARRAY_ACCESSOR, null, "Unexpected string start while parsing variable path. String literals must be within array accessors."));
            }
          }
          this.isParsingString = true;
          isStringVar = true;
          terminator = this.cur;
          this.isStringKeyPath = true;
          continue;
        }
      }
      if (this.isParsingString) {
        if (StringUtilities.ctypeSpace(this.cur)) {
          currentChars.push(this.cur);
          continue;
        } else if (this.cur == DocumentParser.String_EscapeCharacter) {
          if (this.next == DocumentParser.String_EscapeCharacter) {
            currentChars.push(DocumentParser.String_EscapeCharacter);
            this.currentIndex += 1;
            ignorePrevious = true;
            continue;
          } else if (this.next == "n") {
            currentChars.push("\n");
            this.currentIndex += 1;
            continue;
          } else if (this.next == "t") {
            currentChars.push("	");
            this.currentIndex += 1;
            continue;
          } else if (this.next == "r") {
            currentChars.push("\r");
            this.currentIndex += 1;
            continue;
          }
        }
      }
      if (this.isParsingString == false && this.cur == _PathParser.LeftBracket) {
        if (currentChars.length > 0) {
          const pathNode = new PathNode();
          pathNode.name = currentChars.join("");
          pathNode.delimiter = activeDelimiter;
          parts.push(pathNode);
          currentChars = [];
        }
        if (this.next == null || StringUtilities.ctypeSpace(this.next)) {
          this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SPACE_RIGHT, null, "Unexpected end of input or whitespace while parsing variable accessor path."));
          continue;
        }
        const results = this.locateEndOfAccessor();
        this.currentIndex = results.foundOn;
        const parser = new _PathParser();
        parts.push(parser.parse(results.nestedContent));
        this.mergeErrors(parser.getAntlersErrors());
        isParsingAccessor = true;
        if (this.currentIndex == -1) {
          this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.PARSER_CANNOT_PARSE_PATH_RECURSIVE, null, "Cannot parse variable path."));
          isParsingAccessor = false;
          break;
        }
        continue;
      }
      if (this.isParsingString == false && this.next == _PathParser.RightBracket && isParsingAccessor) {
        if (addCur) {
          currentChars.push(this.cur);
        } else {
          addCur = true;
        }
        const accessorNode = new AccessorNode();
        accessorNode.name = currentChars.join("");
        parts.push(accessorNode);
        currentChars = [];
        activeDelimiter = _PathParser.ColonSeparator;
        this.currentIndex += 1;
        isParsingAccessor = false;
        continue;
      }
      if (this.isParsingString == false && (this.cur == _PathParser.LeftBracket || this.cur == _PathParser.ColonSeparator || this.cur == _PathParser.DotPathSeparator || this.currentIndex == this.lastIndex)) {
        if (this.next == null || StringUtilities.ctypeSpace(this.next)) {
          if (this.cur == _PathParser.ColonSeparator) {
            if (currentChars.length == 0) {
              this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR, null, "Unexpected [T_BRANCH_SEPARATOR] while parsing input text."));
              continue;
            }
            this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_RIGHT, null, 'Variable paths cannot end with the ":" character.'));
            continue;
          }
          if (this.cur == _PathParser.LeftBracket) {
            this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ILLEGAL_VARPATH_SUBPATH_START, null, "Illegal variable sub-path start."));
            continue;
          }
        }
        if (this.currentIndex == this.lastIndex && this.isValidChar(this.cur)) {
          if (addCur) {
            currentChars.push(this.cur);
          } else {
            addCur = true;
          }
        }
        const pathNode = new PathNode();
        pathNode.delimiter = activeDelimiter;
        pathNode.name = currentChars.join("");
        if (isStringVar) {
          pathNode.isStringVar = isStringVar;
          pathNode.name = originalContent.substr(1);
          pathNode.name = pathNode.name.slice(0, -1);
          isStringVar = false;
        }
        parts.push(pathNode);
        currentChars = [];
        continue;
      } else {
        currentChars.push(this.cur);
        continue;
      }
    }
    const partLen = parts.length;
    if (partLen > 0) {
      const lastPart = parts[partLen - 1];
      if (lastPart instanceof PathNode) {
        lastPart.isFinal = true;
      } else if (lastPart instanceof VariableReference) {
        lastPart.isFinal = true;
      }
    }
    const variableReference = new VariableReference();
    variableReference.isStrictTagReference = isStrictTagReference;
    variableReference.isStrictVariableReference = isStrictVariableReference;
    variableReference.isExplicitVariableReference = isExplicitVariableReference;
    variableReference.pathParts = parts;
    variableReference.originalContent = content;
    variableReference.isVariableVariable = isVariableVariable;
    variableReference.normalizedReference = content.replace(":", ".");
    return variableReference;
  }
  locateEndOfAccessor() {
    const nestedChars = [];
    let bracketCount = 1, foundOn = -1, nestedContent = "", isParsingString = false, terminator = null;
    if (this._recusriveEntryCheck.has(this.currentIndex + 1) == false) {
      this._recusriveEntryCheck.set(this.currentIndex + 1, true);
    } else {
      return {
        foundOn,
        nestedContent: ""
      };
    }
    for (let i = this.currentIndex + 1; i < this.inputLength; i++) {
      const cur = this.chars[i];
      let next = null, prev = null;
      if (i > 0) {
        prev = this.chars[i - 1];
      }
      if (i + 1 < this.inputLength) {
        next = this.chars[i + 1];
      }
      if (isParsingString == false && (cur == DocumentParser.String_Terminator_SingleQuote || cur == DocumentParser.String_Terminator_DoubleQuote)) {
        isParsingString = true;
        terminator = cur;
        nestedChars.push(cur);
        continue;
      }
      if (isParsingString == false && cur == _PathParser.LeftBracket) {
        bracketCount += 1;
        nestedChars.push(cur);
        continue;
      }
      if (isParsingString && cur == terminator && prev != DocumentParser.String_EscapeCharacter) {
        nestedChars.push(cur);
        isParsingString = false;
        terminator = null;
        continue;
      }
      if (isParsingString == false && cur == _PathParser.RightBracket) {
        bracketCount -= 1;
        if (bracketCount == 0) {
          foundOn = i;
          nestedContent = nestedChars.join("");
          break;
        } else {
          nestedChars.push(cur);
          continue;
        }
      } else {
        nestedChars.push(cur);
      }
      if (isParsingString == false && StringUtilities.ctypeSpace(next)) {
        this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_VARPATH_ACCESSOR, null, "Unexpected end of input or whitespace while parsing inner variable accessor path."));
      }
      if (next == null) {
        this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_VARPATH_ACCESSOR, null, "Unexpected end of input or whitespace while parsing inner variable accessor path."));
      }
    }
    return {
      foundOn,
      nestedContent
    };
  }
};
var PathParser = _PathParser;
PathParser.ColonSeparator = ":";
PathParser.LeftBracket = "[";
PathParser.RightBracket = "]";
PathParser.DotPathSeparator = ".";

// server/src/runtime/parser/antlersNodeParser.ts
var AntlersNodeParser = class {
  constructor() {
    this.chars = [];
    this.inputLen = 0;
    this.currentIndex = 0;
    this.cur = null;
    this.prev = null;
    this.pathParser = new PathParser();
    this.lexer = new AntlersLexer();
    this.activeNode = null;
  }
  reset() {
    this.chars = [];
    this.inputLen = 0;
    this.currentIndex = 0;
    this.cur = null;
    this.prev = null;
  }
  canBeClosingTag(node) {
    var _a;
    const name = (_a = node.name) == null ? void 0 : _a.name;
    if (name == "elseif" || name == "else") {
      return true;
    }
    if (node.name == null) {
      return false;
    }
    return node.name.content.startsWith("/");
  }
  parseNode(node) {
    var _a, _b, _c, _d;
    this.activeNode = node;
    this.reset();
    if (node.content.startsWith("*subrecursive")) {
      let nodeContent = node.content;
      nodeContent = nodeContent.trim();
      nodeContent = StringUtilities.trimRight(nodeContent, "*");
      nodeContent = nodeContent.substr(13);
      const recursiveNode = new RecursiveNode();
      node.copyBasicDetailsTo(recursiveNode);
      recursiveNode.originalNode = node;
      recursiveNode.name = new TagIdentifier();
      recursiveNode.name.name = nodeContent;
      recursiveNode.isNestedRecursive = true;
      recursiveNode.pathReference = this.pathParser.parse(nodeContent);
      recursiveNode.mergeErrors(this.pathParser.getAntlersErrors());
      recursiveNode.content = nodeContent;
      recursiveNode.runtimeContent = nodeContent;
      return recursiveNode;
    }
    if (node.content.trim().startsWith("*recursive")) {
      let nodeContent = node.content;
      nodeContent = nodeContent.trim();
      nodeContent = StringUtilities.trimRight(nodeContent, "*");
      nodeContent = nodeContent.substr(10).trim();
      const recursiveNode = new RecursiveNode();
      node.copyBasicDetailsTo(recursiveNode);
      recursiveNode.originalNode = node;
      recursiveNode.name = new TagIdentifier();
      recursiveNode.name.name = nodeContent;
      recursiveNode.pathReference = this.pathParser.parse(nodeContent);
      recursiveNode.mergeErrors(this.pathParser.getAntlersErrors());
      recursiveNode.content = nodeContent;
      recursiveNode.runtimeContent = nodeContent;
      return recursiveNode;
    }
    this.chars = node.content.split("");
    this.inputLen = this.chars.length;
    const nameContent = [];
    let hasFoundName = false, name = "", isParsingString = false, terminator = null;
    for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.cur = this.chars[this.currentIndex];
      if (this.currentIndex > 0) {
        this.prev = this.chars[this.currentIndex - 1];
      }
      if (hasFoundName == false) {
        if (isParsingString == false && (this.cur == DocumentParser.String_Terminator_DoubleQuote || this.cur == DocumentParser.String_Terminator_SingleQuote)) {
          terminator = this.cur;
          isParsingString = true;
          nameContent.push(this.cur);
          continue;
        }
        if (isParsingString && StringUtilities.ctypeSpace(this.cur)) {
          nameContent.push(this.cur);
          continue;
        }
        if (isParsingString && this.cur == terminator && this.prev != DocumentParser.String_EscapeCharacter) {
          terminator = null;
          isParsingString = false;
          nameContent.push(this.cur);
          continue;
        }
        if (StringUtilities.ctypeSpace(this.cur) || this.currentIndex == this.inputLen - 1 || this.cur == DocumentParser.Punctuation_Pipe) {
          if (nameContent.length == 0) {
            continue;
          } else {
            if (!StringUtilities.ctypeSpace(this.cur)) {
              if (this.cur != DocumentParser.Punctuation_Pipe) {
                nameContent.push(this.cur);
              }
            }
            name = nameContent.join("");
            hasFoundName = true;
            break;
          }
        }
        nameContent.push(this.cur);
      }
    }
    const tagNameStartsAt = node.getContentRelativeStartIndex();
    node.nameStartsOn = node.relativeOffset(tagNameStartsAt, tagNameStartsAt);
    if (node.nameStartsOn != null) {
      node.nameEndsOn = node.nameStartsOn.shiftRight(name.length - 1);
      if (name.includes(DocumentParser.Punctuation_Colon)) {
        const separatorOffset = name.indexOf(DocumentParser.Punctuation_Colon);
        node.nameMethodPartStartsOn = node.nameStartsOn.shiftRight(separatorOffset + 1);
      }
    }
    node.name = TagIdentifierAnalyzer.getIdentifier(name);
    nodeTypeAnalyzer_default.analyzeNode(node);
    node.parameters = this.getParameters(node);
    node.hasParameters = node.parameters.length > 0;
    if (node.hasParameters) {
      nodeTypeAnalyzer_default.analyzeParametersForModifiers(node);
      node.resetContentCache();
    }
    node.pathReference = this.pathParser.parse(name);
    node.mergeErrors(this.pathParser.getAntlersErrors());
    if (node.pathReference != null) {
      if (node.pathReference.isStrictTagReference) {
        node.name.name = node.name.name.substr(1);
        node.name.content = node.name.content.substr(1);
      }
    }
    node.isClosingTag = this.canBeClosingTag(node);
    let runtimeNodes = [];
    if (node.isClosingTag == false) {
      runtimeNodes = this.lexer.tokenize(node, node.getContent());
    }
    node.runtimeNodes = runtimeNodes;
    const trimmedInner = node.content.trim();
    if (ConditionPairAnalyzer.isConditionalStructure(node) && node.name.name != "else" && runtimeNodes.length == 0 && trimmedInner != "/if" && trimmedInner != "/unless" && trimmedInner != "/endunless" && trimmedInner != "endif" && trimmedInner != "endunless" && trimmedInner != "/endif") {
      const nodeContent = node.getContent().trim();
      if (nodeContent.length == 0) {
        this.pushConditionWithoutExpression(node);
      }
    }
    if (node.name.name == "endif") {
      const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
      if (nodeParser != null) {
        replacedNode.withParser(nodeParser);
      }
      replacedNode.name = new TagIdentifier();
      replacedNode.name.name = "if";
      replacedNode.name.compound = "if";
      replacedNode.isClosingTag = true;
      replacedNode.content = " /if ";
      replacedNode.originalNode = node;
      return replacedNode;
    }
    if (node.name.name == "unless") {
      const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
      if (nodeParser != null) {
        replacedNode.withParser(nodeParser);
      }
      replacedNode.name = new TagIdentifier();
      replacedNode.name.name = "if";
      replacedNode.name.compound = "if";
      if (node.isClosingTag == false) {
        const originalContent = (_a = node.getContent()) != null ? _a : "", unlessContent = " if !(" + originalContent + ") ";
        replacedNode.content = unlessContent;
        replacedNode.originalNode = node;
        replacedNode.resetContentCache();
        replacedNode.runtimeNodes = this.lexer.tokenize(replacedNode, (_b = replacedNode.getContent()) != null ? _b : "");
        this.testUnlessContent(replacedNode);
      } else {
        replacedNode.originalNode = node;
        replacedNode.content = " /if ";
      }
      return replacedNode;
    } else if (node.name.name == "elseunless") {
      const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
      if (nodeParser != null) {
        replacedNode.withParser(nodeParser);
      }
      replacedNode.name = new TagIdentifier();
      replacedNode.name.name = "elseif";
      replacedNode.name.compound = "elseif";
      const originalContent = (_c = node.getContent()) != null ? _c : "", unlessContent = " elseif !(" + originalContent + ") ";
      replacedNode.content = unlessContent;
      replacedNode.originalNode = node;
      replacedNode.resetContentCache();
      replacedNode.runtimeNodes = this.lexer.tokenize(replacedNode, (_d = replacedNode.getContent()) != null ? _d : "");
      this.testUnlessContent(replacedNode);
      return replacedNode;
    } else if (node.name.name == "endunless") {
      const replacedNode = node.copyBasicDetails(), nodeParser = node.getParser();
      if (nodeParser != null) {
        replacedNode.withParser(nodeParser);
      }
      replacedNode.name = new TagIdentifier();
      replacedNode.name.name = "if";
      replacedNode.name.compound = "if";
      replacedNode.isClosingTag = true;
      replacedNode.content = " /if ";
      replacedNode.originalNode = node;
      return replacedNode;
    }
    return node;
  }
  pushError(error) {
    if (this.activeNode != null) {
      this.activeNode.pushError(error);
    }
  }
  testUnlessContent(node) {
    var _a;
    let testContent = (_a = node.getContent()) != null ? _a : "";
    testContent = testContent.replace("!", "");
    testContent = testContent.replace("(", "");
    testContent = testContent.replace(")", "").trim();
    if (testContent.length == 0) {
      this.pushConditionWithoutExpression(node);
      return;
    }
  }
  pushConditionWithoutExpression(node) {
    this.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSE_EMPTY_CONDITIONAL, node, "Condition structure lacks comparison expression."));
  }
  getParameters(node) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const content = (_a = node.getContent()) != null ? _a : "", chars = content.split(""), parameters = [], charCount = chars.length;
    let parseContentOffset = 0;
    if (node.name != null) {
      const trimmedName = StringUtilities.trimLeft(node.content, " "), leadOffset = node.content.length - trimmedName.length, nameLength = node.name.content.length;
      if (leadOffset > 0) {
        parseContentOffset = leadOffset + nameLength;
      } else {
        parseContentOffset = nameLength;
      }
    }
    let hasFoundName = false, currentChars = [], name = "", nameStart = 0, startAt = 0, ignorePrevious = false, terminator = null, blockStartAt = -1, blockEndAt = -1, nameBlockStartAt = -1, nameBlockEndAt = -1, valueBlockStartAt = -1, valueBlockEndAt = -1, nameDelimiter = '"';
    for (let i = 0; i < charCount; i++) {
      const current = chars[i];
      let prev = null, next = null;
      if (i + 1 < charCount) {
        next = chars[i + 1];
      }
      if (!ignorePrevious) {
        if (i > 0) {
          prev = chars[i - 1];
        }
      } else {
        prev = "";
        ignorePrevious = false;
      }
      if (hasFoundName == false && StringUtilities.ctypeSpace(current)) {
        currentChars = [];
        blockStartAt = -1;
        blockEndAt = -1;
        nameBlockStartAt = -1;
        nameBlockEndAt = -1;
        valueBlockStartAt = -1;
        valueBlockEndAt = -1;
        continue;
      }
      if (hasFoundName == false && current == DocumentParser.Punctuation_Equals) {
        if (currentChars.length > 0) {
          if ((StringUtilities.ctypeAlpha(currentChars[0]) || currentChars[0] == DocumentParser.Punctuation_Colon || currentChars[0] == DocumentParser.AtChar) == false) {
            currentChars = [];
            continue;
          }
        }
        if (i + 1 >= charCount) {
          this.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, node, "Unexpected end of input"));
          continue;
        }
        let peek = null;
        if (i + 1 < charCount) {
          peek = chars[i + 1];
        }
        if (prev == DocumentParser.Punctuation_Equals) {
          currentChars = [];
          blockStartAt = -1;
          blockEndAt = -1;
          nameBlockStartAt = -1;
          nameBlockEndAt = -1;
          valueBlockStartAt = -1;
          valueBlockEndAt = -1;
          continue;
        }
        if (StringUtilities.ctypeSpace(peek) || peek == DocumentParser.Punctuation_Equals) {
          currentChars = [];
          blockStartAt = -1;
          blockEndAt = -1;
          nameBlockStartAt = -1;
          nameBlockEndAt = -1;
          valueBlockStartAt = -1;
          valueBlockEndAt = -1;
          continue;
        }
        if (currentChars.length > 0) {
          nameBlockEndAt = i;
          valueBlockStartAt = i;
          name = currentChars.join("");
          nameStart = startAt;
          hasFoundName = true;
          currentChars = [];
        }
        if (next == DocumentParser.String_Terminator_DoubleQuote) {
          terminator = DocumentParser.String_Terminator_DoubleQuote;
          nameDelimiter = DocumentParser.String_Terminator_DoubleQuote;
          i += 1;
        }
        if (next == DocumentParser.String_Terminator_SingleQuote) {
          terminator = DocumentParser.String_Terminator_SingleQuote;
          nameDelimiter = DocumentParser.String_Terminator_SingleQuote;
          i += 1;
        }
        continue;
      }
      if (hasFoundName && current == DocumentParser.String_EscapeCharacter) {
        let peek = null;
        if (i + 1 < charCount) {
          peek = chars[i + 1];
        }
        if (peek == DocumentParser.String_EscapeCharacter) {
          currentChars.push(DocumentParser.String_EscapeCharacter);
          i += 1;
          ignorePrevious = true;
          continue;
        }
        if (peek == DocumentParser.String_Terminator_DoubleQuote) {
          currentChars.push(DocumentParser.String_Terminator_DoubleQuote);
          i += 1;
          continue;
        }
        if (peek == DocumentParser.String_Terminator_SingleQuote) {
          currentChars.push(DocumentParser.String_Terminator_SingleQuote);
          i += 1;
          continue;
        }
        if (peek == "n") {
          currentChars.push("\n");
          i += 1;
          continue;
        }
        if (peek == "r") {
          currentChars.push("\r");
          i += 1;
          continue;
        }
      }
      if (hasFoundName && (terminator != null && current == terminator || terminator == null && StringUtilities.ctypeSpace(current))) {
        const content2 = currentChars.join("");
        valueBlockEndAt = i;
        blockEndAt = i;
        hasFoundName = false;
        terminator = null;
        currentChars = [];
        const parameterNode = new ParameterNode2();
        if (name.startsWith(DocumentParser.Punctuation_Colon)) {
          parameterNode.isVariableReference = true;
          name = name.substr(1);
        }
        parameterNode.nameDelimiter = nameDelimiter;
        parameterNode.name = name;
        parameterNode.value = content2;
        parameterNode.startPosition = (_b = node.relativePositionFromOffset(startAt, nameStart)) != null ? _b : null;
        if (i + 1 > charCount) {
          this.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NODE_PARAMETER, node, "Unexpected end of input while parsing parameter content."));
          parameterNode.parent = node;
          parameters.push(parameterNode);
          name = "";
          continue;
        }
        parameterNode.endPosition = (_c = node.relativePositionFromOffset(i + 1, i + 1)) != null ? _c : null;
        parameterNode.parent = node;
        parameterNode.blockPosition = {
          start: (_d = node.relativeOffset(blockStartAt, blockStartAt)) != null ? _d : null,
          end: (_e = node.relativeOffset(blockEndAt, blockEndAt)) != null ? _e : null
        };
        parameterNode.namePosition = {
          start: (_f = node.relativeOffset(nameBlockStartAt, nameBlockStartAt)) != null ? _f : null,
          end: (_g = node.relativeOffset(nameBlockEndAt, nameBlockEndAt)) != null ? _g : null
        };
        parameterNode.valuePosition = {
          start: (_h = node.relativeOffset(valueBlockStartAt + 2, valueBlockStartAt + 2)) != null ? _h : null,
          end: (_i = node.relativeOffset(valueBlockEndAt, valueBlockEndAt)) != null ? _i : null
        };
        parameters.push(parameterNode);
        name = "";
        blockStartAt = -1;
        blockEndAt = -1;
        nameBlockStartAt = -1;
        nameBlockEndAt = -1;
        valueBlockStartAt = -1;
        valueBlockEndAt = -1;
        continue;
      }
      if (hasFoundName == false && (current == DocumentParser.String_Terminator_DoubleQuote || current == DocumentParser.String_Terminator_SingleQuote)) {
        if (i > parseContentOffset) {
          break;
        }
      }
      currentChars.push(current);
      if (blockStartAt == -1) {
        blockStartAt = i;
      }
      if (nameBlockStartAt == -1) {
        nameBlockStartAt = i;
      }
      if (currentChars.length == 1) {
        startAt = i + 1;
      }
    }
    if (terminator != null) {
      this.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, node, "Unexpected end of input while parsing string."));
    }
    return parameters;
  }
};

// server/src/runtime/runtime/noParseManager.ts
var import_md5 = __toESM(require_md52());
var NoParseManager = class {
  static regions() {
    return this.noParseRegions;
  }
  static clear() {
    this.noParseRegions.clear();
  }
  static registerNoParseContent(content) {
    const hash = import_md5.Md5.hashStr(content);
    this.noParseRegions.set(hash, content);
    return hash;
  }
};
NoParseManager.noParseRegions = /* @__PURE__ */ new Map();

// server/src/runtime/utilities/arrayHelpers.ts
function intersect(a, b) {
  const setA = new Set(a), setB = new Set(b), intersection = new Set([...setA].filter((x) => setB.has(x)));
  return Array.from(intersection);
}

// server/src/runtime/analyzers/tagPairAnalyzer.ts
var _TagPairAnalyzer = class {
  constructor() {
    this.closingTagIndex = /* @__PURE__ */ new Map();
    this.closingTagIndexCount = /* @__PURE__ */ new Map();
    this.openTagIndexCount = /* @__PURE__ */ new Map();
    this.closingTagNames = /* @__PURE__ */ new Map();
    this.parentNode = null;
    this.stackCount = 0;
    this.createdExecutionBranches = [];
    this.document = null;
  }
  getClosingCandidates(node) {
    var _a, _b;
    if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosingTag == false) {
      const compound = (_b = (_a = node.name) == null ? void 0 : _a.compound) != null ? _b : "";
      if (compound == "if") {
        return ["if", "elseif", "else"];
      } else if (compound == "elseif") {
        return ["elseif", "else", "if"];
      } else if (compound == "else") {
        return ["if"];
      }
      return [compound];
    }
    return [];
  }
  buildCloseIndex(nodes) {
    var _a, _b, _c;
    nodes.forEach((node) => {
      var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j;
      if (node instanceof RecursiveNode) {
        return;
      }
      if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isSelfClosing) {
        return;
      }
      if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosingTag) {
        if (this.closingTagIndex.has(this.stackCount) == false) {
          this.closingTagIndex.set(this.stackCount, /* @__PURE__ */ new Map());
        }
        if (this.closingTagIndexCount.has(this.stackCount) == false) {
          this.closingTagIndexCount.set(this.stackCount, /* @__PURE__ */ new Map());
        }
        const compound = (_b2 = (_a2 = node.name) == null ? void 0 : _a2.compound) != null ? _b2 : "";
        if (((_c2 = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _c2.has(compound)) == false) {
          (_d = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _d.set(compound, []);
          (_e = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _e.set(compound, 0);
        }
        (_g = (_f = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _f.get(compound)) == null ? void 0 : _g.push(node);
        const curCount = (_i = (_h = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _h.get(compound)) != null ? _i : 0;
        (_j = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _j.set(compound, curCount + 1);
      }
    });
    if (this.closingTagNames.has(this.stackCount) == false) {
      this.closingTagNames.set(this.stackCount, []);
    }
    if (this.closingTagIndex.has(this.stackCount)) {
      this.closingTagNames.set(this.stackCount, Array.from((_b = (_a = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _a.keys()) != null ? _b : []));
      (_c = this.closingTagIndex.get(this.stackCount)) == null ? void 0 : _c.forEach((indexedNodes, tagName) => {
        var _a2, _b2, _c2, _d, _e, _f, _g;
        const indexedNodeCount = indexedNodes.length;
        if (indexedNodeCount == 0) {
          return;
        }
        const lastIndexedNode = indexedNodes[indexedNodeCount - 1];
        for (let i = 0; i < indexedNodeCount; i++) {
          const node = nodes[i];
          if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
            if (node instanceof RecursiveNode) {
              continue;
            }
            if (node.index >= lastIndexedNode.index) {
              break;
            }
            const compound = (_b2 = (_a2 = node.name) == null ? void 0 : _a2.compound) != null ? _b2 : "";
            if (node.isClosingTag == false && tagName == compound) {
              if (this.openTagIndexCount.has(this.stackCount) == false) {
                this.openTagIndexCount.set(this.stackCount, /* @__PURE__ */ new Map());
              }
              if (((_c2 = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _c2.has(tagName)) == false) {
                (_d = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _d.set(tagName, 0);
              }
              const curCount = (_f = (_e = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _e.get(tagName)) != null ? _f : 0;
              (_g = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _g.set(tagName, curCount + 1);
            }
          }
        }
      });
    }
  }
  getScanForList(node) {
    var _a;
    if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
      const compound = (_a = node.name) == null ? void 0 : _a.compound;
      if (compound == "else") {
        return ["if"];
      }
      if (compound == "elseif") {
        return ["elseif", "else", "if"];
      }
      if (node.isClosingTag == false) {
        const candidates = this.getClosingCandidates(node), indexValues = this.closingTagNames.get(this.stackCount);
        return intersect(candidates, indexValues);
      }
    }
    return [];
  }
  canPossiblyClose(node) {
    var _a, _b;
    if (node instanceof RecursiveNode) {
      return false;
    }
    if (node instanceof AntlersParserFailNode || node instanceof AntlersNode) {
      if (node.isComment) {
        return false;
      }
      if (node.isSelfClosing) {
        return false;
      }
      const compound = (_b = (_a = node.name) == null ? void 0 : _a.compound) != null ? _b : "";
      if (compound == "else" || compound == "elseif") {
        return true;
      }
      if (node.isClosingTag == false) {
        const candidates = this.getClosingCandidates(node), indexValues = this.closingTagNames.get(this.stackCount), overlap = intersect(candidates, indexValues);
        return overlap.length > 0;
      }
    }
    return false;
  }
  findClosingPair(nodes, node, scanFor) {
    var _a, _b, _c, _d;
    const refRuntimeNodeCount = node.runtimeNodes.length, nodeLength = nodes.length;
    let refStack = 0;
    for (let i = 0; i < nodeLength; i++) {
      const candidateNode = nodes[i];
      if (candidateNode instanceof AntlersNode || candidateNode instanceof AntlersParserFailNode) {
        if (node.endPosition != null && candidateNode.startPosition != null) {
          if (node.endPosition.isBefore(candidateNode.startPosition)) {
            if (candidateNode.isClosingTag && candidateNode.isOpenedBy != null) {
              continue;
            }
            if (candidateNode.isSelfClosing) {
              continue;
            }
            const compound = (_b = (_a = candidateNode.name) == null ? void 0 : _a.compound) != null ? _b : "";
            if (candidateNode.isClosingTag == false) {
              if (scanFor.includes(compound)) {
                const refOpen = (_c = this.openTagIndexCount.get(this.stackCount)) == null ? void 0 : _c.get(compound), refClose = (_d = this.closingTagIndexCount.get(this.stackCount)) == null ? void 0 : _d.get(compound);
                if (refOpen != refClose) {
                  if (candidateNode.runtimeNodes.length >= refRuntimeNodeCount) {
                  }
                }
                refStack += 1;
              }
              continue;
            }
            if (scanFor.includes(compound)) {
              if (refStack > 0) {
                refStack -= 1;
                continue;
              }
            }
            if (refStack == 0 && scanFor.includes(compound)) {
              candidateNode.isOpenedBy = node;
              node.isClosedBy = candidateNode;
              break;
            }
          }
        } else {
          continue;
        }
      }
    }
  }
  associate(documentNodes, document) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.document = document;
    const nodeStack = [{
      documentNodes,
      parent: null
    }];
    let nodesToReturn = [];
    while (nodeStack.length > 0) {
      const details = nodeStack.pop();
      if (details == null) {
        continue;
      }
      let nodes = details.documentNodes;
      this.parentNode = details.parent;
      this.stackCount += 1;
      this.buildCloseIndex(nodes);
      nodes = ConditionPairAnalyzer.pairConditionals(nodes);
      nodes.forEach((node) => {
        if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && this.canPossiblyClose(node)) {
          if (ConditionPairAnalyzer.isConditionalStructure(node)) {
            return;
          }
          const scanFor = this.getScanForList(node);
          this.findClosingPair(nodes, node, scanFor);
        }
      });
      const nodeCount = nodes.length;
      for (let i = 0; i < nodeCount; i++) {
        const node = nodes[i];
        if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosedBy != null) {
          for (let j = i + 1; j < nodeCount; j++) {
            const childNode = nodes[j];
            if (childNode.index > node.isClosedBy.index) {
              break;
            }
            childNode.parent = node;
            node.children.push(childNode);
            if (childNode instanceof AntlersNode && childNode.index == node.index) {
              childNode.parent = node;
              break;
            }
          }
        }
      }
      nodes.forEach((node) => {
        if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.children.length > 0) {
          const newChildren = [];
          node.children.forEach((childNode) => {
            if (childNode.parent != null) {
              if (childNode.parent.index == node.index) {
                childNode.parent = node;
                newChildren.push(childNode);
              }
            }
          });
          nodeStack.push({
            documentNodes: newChildren,
            parent: node
          });
        }
      });
      let nestedNodes = [];
      nodes.forEach((node) => {
        if (this.parentNode == null) {
          if (node.parent == null) {
            nestedNodes.push(node);
          }
        } else {
          if (node.parent == this.parentNode) {
            nestedNodes.push(node);
          }
        }
      });
      nestedNodes = this.reduceConditionals(nestedNodes);
      const nestedNodeKeyMap = /* @__PURE__ */ new Map();
      nodes.forEach((node) => {
        var _a2, _b2, _c2, _d2;
        if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isClosedBy != null) {
          if (this.document != null) {
            const content = this.document.getText(((_b2 = (_a2 = node.endPosition) == null ? void 0 : _a2.index) != null ? _b2 : 0) + 1, (_d2 = (_c2 = node.isClosedBy.startPosition) == null ? void 0 : _c2.index) != null ? _d2 : 0);
            node.runtimeContent = content;
          }
        }
      });
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i], refId = (_a = node.refId) != null ? _a : "";
        nestedNodeKeyMap.set(refId, 1);
        if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isComment == false && ((_b = node.name) == null ? void 0 : _b.name) == "noparse" && node instanceof EscapedContentNode == false && node.isClosingTag == false) {
          if (node.isClosedBy == null) {
            node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_NO_PARSE_UNASSOCIATED, node, "Encountered noparse region without a closing tag. All noparse regions must be closed."));
            continue;
          }
          let content = node.content;
          if (this.document != null) {
            content = this.document.getText(((_d = (_c = node.endPosition) == null ? void 0 : _c.index) != null ? _d : 0) + 1, (_g = (_f = (_e = node.isClosedBy) == null ? void 0 : _e.startPosition) == null ? void 0 : _f.index) != null ? _g : 0);
          }
          const noParseNode = new EscapedContentNode(), nodeParser = node.getParser();
          if (nodeParser != null) {
            noParseNode.withParser(nodeParser);
          }
          node.copyBasicDetailsTo(noParseNode);
          noParseNode.name = new TagIdentifier();
          noParseNode.name.name = "noparse";
          noParseNode.name.compound = "noparse";
          noParseNode.content = NoParseManager.registerNoParseContent(content);
          noParseNode.originalNode = node;
          nestedNodes[i] = noParseNode;
        }
      }
      if (this.parentNode != null && (this.parentNode instanceof AntlersParserFailNode || this.parentNode instanceof AntlersNode)) {
        this.parentNode.children = nestedNodes;
        if (this.parentNode.parent != null && this.parentNode.parent instanceof AntlersNode) {
          const ancestorNodes = this.parentNode.parent.children, newAncestorNodes = [];
          ancestorNodes.forEach((aNode) => {
            var _a2;
            if (nestedNodeKeyMap.has((_a2 = aNode.refId) != null ? _a2 : "") == false) {
              newAncestorNodes.push(aNode);
            }
          });
          this.parentNode.parent.children = newAncestorNodes;
        }
      }
      if (this.stackCount <= 1) {
        nodesToReturn = nestedNodes;
      }
    }
    if (this.createdExecutionBranches.length > 0) {
      this.createdExecutionBranches.forEach((branch) => {
        if (branch.head != null) {
          branch.nodes = branch.head.children;
        }
      });
    }
    return nodesToReturn;
  }
  findEndOfBranch(nodes, start, startedAt) {
    const children = [], offset = startedAt;
    let tail = null;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isOpenedBy != null && node.isOpenedBy == start) {
        tail = node;
        break;
      } else {
        children.push(node);
      }
    }
    return {
      children,
      tail,
      offset
    };
  }
  reduceConditionals(nodes) {
    var _a, _b, _c;
    const reduced = [];
    for (let i = 0; i < nodes.length; i++) {
      let node = nodes[i];
      if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.isComment == false && node.isClosingTag == false && node.isClosedBy != null) {
        const compound = (_b = (_a = node.name) == null ? void 0 : _a.compound) != null ? _b : "";
        if (compound == "if") {
          const conditionNode = new ConditionNode();
          conditionNode.index = node.index;
          conditionNode.chain.push(node.index);
          if (this.parentNode != null) {
            conditionNode.parent = this.parentNode;
          }
          let exitedOn = null, doContinue = true, currentDepth = 0;
          while (doContinue) {
            currentDepth += 1;
            if (currentDepth > _TagPairAnalyzer.ForceBreakLimit) {
              doContinue = false;
              break;
            }
            if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
              const result = this.findEndOfBranch(nodes.slice(i + 1), node, i), executionBranch = new ExecutionBranch();
              let tail = result.tail;
              executionBranch.head = node;
              executionBranch.tail = tail;
              executionBranch.nodes = node.children;
              if (tail == null) {
                tail = executionBranch.head.isClosedBy;
              }
              if (tail != null && tail.startPosition != null) {
                executionBranch.startPosition = tail.startPosition;
              }
              if (tail != null) {
                executionBranch.index = tail.index;
              }
              if (executionBranch.nodes.length > 0) {
                const lastNode = executionBranch.nodes[executionBranch.nodes.length - 1];
                if (lastNode.endPosition != null) {
                  executionBranch.endPosition = lastNode.endPosition;
                }
              } else {
                if (tail != null && tail.endPosition != null) {
                  executionBranch.endPosition = tail.endPosition;
                }
              }
              this.createdExecutionBranches.push(executionBranch);
              conditionNode.logicBranches.push(executionBranch);
              if ((tail == null ? void 0 : tail.isClosingTag) && ((_c = tail.name) == null ? void 0 : _c.compound) == "if") {
                exitedOn = result.offset;
                doContinue = false;
                break;
              } else {
                if (tail != null) {
                  conditionNode.chain.push(tail.index);
                }
                i = result.offset;
                if (tail instanceof AntlersNode) {
                  node = tail;
                }
              }
            } else {
              doContinue = false;
            }
          }
          if (conditionNode.logicBranches.length > 0) {
            const firstBranch = conditionNode.logicBranches[0], lastBranch = conditionNode.logicBranches[conditionNode.logicBranches.length - 1];
            if (firstBranch.startPosition != null) {
              conditionNode.startPosition = firstBranch.startPosition;
            }
            if (lastBranch.endPosition != null) {
              conditionNode.endPosition = lastBranch.endPosition;
            }
          }
          reduced.push(conditionNode);
          if (exitedOn != null) {
            if (exitedOn == nodes.length) {
              break;
            }
          }
        } else {
          reduced.push(node);
        }
      } else {
        reduced.push(node);
      }
    }
    return reduced;
  }
};
var TagPairAnalyzer = _TagPairAnalyzer;
TagPairAnalyzer.ForceBreakLimit = 1e5;

// server/src/runtime/analyzers/recursiveParentAnalyzer.ts
var RecursiveParentAnalyzer = class {
  static associateRecursiveParent(nodes) {
    var _a, _b;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node instanceof RecursiveNode) {
        const recursiveContent = "*recursive " + ((_a = node.name) == null ? void 0 : _a.name);
        if (i - 1 < 0) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_RECURSIVE_NODE_INVALID_POSITION, node, "Unpaired recursive node. All recursive nodes must have a parent node introducing them."));
          continue;
        }
        let lastNode = null;
        for (let j = i - 1; j >= 0; j -= 1) {
          const subNode = nodes[j];
          if (subNode instanceof LiteralNode) {
            continue;
          }
          if (subNode instanceof AntlersNode && subNode.isClosedBy != null) {
            if (node.isNestedRecursive) {
              if (subNode.content.trim() == ((_b = node.name) == null ? void 0 : _b.name)) {
                lastNode = subNode;
                break;
              }
            } else {
              if (subNode.runtimeContent.includes(recursiveContent) && StringUtilities.substringCount(node.runtimeContent, "*recursive") == 1) {
                lastNode = subNode;
                continue;
              } else {
                if (lastNode != null) {
                  break;
                }
              }
            }
          }
        }
        if (lastNode == null) {
          continue;
        }
        if (node.isNestedRecursive) {
          lastNode.hasRecursiveNode = true;
          node.recursiveParent = lastNode;
          lastNode.recursiveReference = node;
        } else {
          if (lastNode.parent != null) {
            if (lastNode.parent instanceof AntlersNode) {
              lastNode.parent.hasRecursiveNode = true;
              lastNode.parent.recursiveReference = node;
              node.recursiveParent = lastNode.parent;
            }
          } else {
            lastNode.hasRecursiveNode = true;
            node.recursiveParent = lastNode;
            lastNode.recursiveReference = node;
          }
        }
      }
    }
  }
};

// server/src/runtime/errors/lineRetriever.ts
var LineRetriever = class {
  static getNearText(node) {
    var _a, _b, _c, _d;
    if (node instanceof VariableNode) {
      return node.name;
    } else if (node instanceof NumberNode) {
      return (_b = (_a = node.value) == null ? void 0 : _a.toString()) != null ? _b : "";
    } else if (node instanceof StringValueNode) {
      return node.value;
    } else if (node instanceof ModifierNameNode) {
      return node.name;
    } else if (node instanceof ModifierValueNode) {
      return node.value;
    } else if (node instanceof TupleListStart) {
      return node.content;
    }
    if (node instanceof LogicalXorOperator || node instanceof NullConstant || node instanceof TrueConstant || node instanceof FalseConstant || node instanceof LogicalNegationOperator || node instanceof LanguageOperatorConstruct || node instanceof ArgSeparator || node instanceof StatementSeparatorNode || node instanceof AdditionAssignmentOperator || node instanceof AdditionOperator || node instanceof SubtractionAssignmentOperator || node instanceof SubtractionOperator || node instanceof ExponentiationOperator || node instanceof MultiplicationAssignmentOperator || node instanceof MultiplicationOperator || node instanceof DivisionAssignmentOperator || node instanceof DivisionOperator || node instanceof ModulusAssignmentOperator || node instanceof ModulusOperator || node instanceof SpaceshipCompOperator || node instanceof LessThanEqualCompOperator || node instanceof LessThanCompOperator || node instanceof GreaterThanEqualCompOperator || node instanceof GreaterThanCompOperator || node instanceof LeftAssignmentOperator || node instanceof StrictEqualCompOperator || node instanceof EqualCompOperator || node instanceof LogicalAndOperator || node instanceof ModifierSeparator || node instanceof LogicalOrOperator || node instanceof NotStrictEqualCompOperator || node instanceof NotEqualCompOperator || node instanceof ConditionalVariableFallbackOperator || node instanceof NullCoalesceOperator || node instanceof InlineTernarySeparator || node instanceof LogicGroupBegin || node instanceof LogicGroupEnd || node instanceof ModifierValueSeparator || node instanceof InlineBranchSeparator || node instanceof FactorialOperator || node instanceof ScopeAssignmentOperator || node instanceof StringConcatenationOperator || node instanceof MethodInvocationNode) {
      return node.content;
    }
    let text = "";
    if (node instanceof AntlersNode) {
      if (node.originalNode != null) {
        text = node.originalNode.getContent();
      } else {
        text = (_d = (_c = node.startPosition) == null ? void 0 : _c.line.toString()) != null ? _d : "";
      }
    } else {
      if (node.originalAbstractNode != null) {
        text = node.originalAbstractNode.rawContent();
      } else {
        text = node.rawContent();
      }
    }
    if (text.length > 15) {
      text = text.substr(0, -15);
    }
    return text;
  }
};

// server/src/runtime/runtime/libraries/libraryManager.ts
var LibraryManager = class {
};
LibraryManager.deferredCoreLibraries = [
  "arr",
  "array",
  "str",
  "string",
  "method",
  "math",
  "sys",
  "convert",
  "scope",
  "stopwatch",
  "file",
  "path",
  "url",
  "request",
  "json",
  "datetime"
];

// server/src/runtime/runtime/sandbox/languageOperatorRegistry.ts
var LanguageOperatorRegistry = class {
};
LanguageOperatorRegistry.ARR_PLUCK = "pluck";
LanguageOperatorRegistry.ARR_TAKE = "take";
LanguageOperatorRegistry.ARR_SKIP = "skip";
LanguageOperatorRegistry.ARR_MAKE = "arr";
LanguageOperatorRegistry.ARR_ORDERBY = "orderby";
LanguageOperatorRegistry.ARR_GROUPBY = "groupby";
LanguageOperatorRegistry.ARR_MERGE = "merge";
LanguageOperatorRegistry.QUERY_WHERE = "where";
LanguageOperatorRegistry.STRUCT_SWITCH = "switch";
LanguageOperatorRegistry.BITWISE_AND = "bwa";
LanguageOperatorRegistry.BITWISE_OR = "bwo";
LanguageOperatorRegistry.BITWISE_XOR = "bxor";
LanguageOperatorRegistry.BITWISE_NOT = "bnot";
LanguageOperatorRegistry.BITWISE_SHIFT_LEFT = "bsl";
LanguageOperatorRegistry.BITWISE_SHIFT_RIGHT = "bsr";
LanguageOperatorRegistry.operators = [
  "pluck",
  "take",
  "arr",
  "skip",
  "orderby",
  "groupby",
  "merge",
  "where",
  "switch",
  "bwa",
  "bwo",
  "bxor",
  "bsl",
  "bsr"
];

// server/src/runtime/parser/languageParser.ts
var LanguageParser = class {
  constructor() {
    this.pathParser = new PathParser();
    this.tokens = [];
    this.createdModifierChains = [];
    this.createdLanguageOperators = [];
    this.createdArrays = [];
    this.mergedVariablePaths = [];
    this.mergedComponents = /* @__PURE__ */ new Map();
    this.modifierNameMapping = /* @__PURE__ */ new Map();
    this.isRealModifierSeparator = /* @__PURE__ */ new Map();
    this.isRoot = true;
    this.retriggerNonVirtualGroupMembers = [];
  }
  hasModifierConstruct(name) {
    return this.modifierNameMapping.has(name);
  }
  getModifierConstruct(name) {
    return this.modifierNameMapping.get(name);
  }
  isActualModifierSeparator(node) {
    return this.isRealModifierSeparator.has(node);
  }
  isMergedVariableComponent(node) {
    return this.mergedComponents.has(node);
  }
  getMergedVariable(node) {
    return this.mergedComponents.get(node);
  }
  getMergedVariablePaths() {
    return this.mergedVariablePaths;
  }
  getCreatedModifierChains() {
    return this.createdModifierChains;
  }
  getCreatedLangaugeOperators() {
    return this.createdLanguageOperators;
  }
  getCreatedArrays() {
    return this.createdArrays;
  }
  reset() {
    this.tokens = [];
    this.createdModifierChains = [];
    this.createdLanguageOperators = [];
    this.createdArrays = [];
    this.createdModifierChains = [];
    this.createdLanguageOperators = [];
    this.createdArrays = [];
    this.mergedVariablePaths = [];
    this.mergedComponents.clear();
    this.modifierNameMapping.clear();
  }
  parse(tokens) {
    this.tokens = tokens;
    this.tokens = this.combineVariablePaths(this.tokens);
    this.tokens = this.createLanguageOperators(this.tokens);
    this.tokens = this.createLogicalGroups(this.tokens);
    this.tokens = this.associateMethodCalls(this.tokens);
    this.tokens = this.createTupleLists(this.tokens);
    this.tokens = this.createLibraryInvocations(this.tokens);
    this.tokens = this.associateModifiers(this.tokens);
    this.tokens = this.createNullCoalescenceGroups(this.tokens);
    this.tokens = this.correctTypes(this.tokens);
    this.tokens = this.createTernaryGroups(this.tokens);
    this.tokens = this.applyOperationOrder(this.tokens);
    this.validateNeighboringOperators(this.tokens);
    this.tokens = this.createLogicGroupsToRemoveMethodInvocationAmbiguity(this.tokens);
    this.tokens = this.createLogicGroupsToResolveOperatorAmbiguity(this.tokens);
    this.validateNoDanglingLogicGroupEnds(this.tokens);
    if (this.isRoot) {
      this.tokens = this.insertAutomaticStatementSeparators(this.tokens);
      if (this.retriggerNonVirtualGroupMembers.length > 0) {
        this.retriggerNonVirtualGroupMembers.forEach((grouping) => {
          this.markAllNonVirtualAsListGroupMember(grouping);
        });
      }
    }
    return this.createSemanticGroups(this.tokens);
  }
  setIsRoot(isRoot) {
    this.isRoot = isRoot;
    return this;
  }
  validateNeighboringOperators(tokens) {
    const tokenCount = tokens.length;
    for (let i = 0; i < tokenCount; i++) {
      const thisToken = tokens[i];
      if (LanguageParser.isOperatorType(thisToken)) {
        if (i + 1 >= tokenCount) {
          thisToken.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_OPERATOR, thisToken, "Unexpected operator while parsing input text."));
          return;
        }
        const peek = tokens[i + 1];
        if (LanguageParser.isOperatorType(peek)) {
          peek.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_OPERATOR_INVALID_ON_RIGHT, peek, "Unexpected operator while parsing input text."));
          continue;
        }
      }
    }
  }
  static isAssignmentOperator(token) {
    if (token instanceof AdditionAssignmentOperator || token instanceof DivisionAssignmentOperator || token instanceof LeftAssignmentOperator || token instanceof ModulusAssignmentOperator || token instanceof MultiplicationAssignmentOperator || token instanceof SubtractionAssignmentOperator) {
      return true;
    }
    return false;
  }
  static isOperatorType(token) {
    if (token instanceof AdditionAssignmentOperator || token instanceof DivisionAssignmentOperator || token instanceof LeftAssignmentOperator || token instanceof ModulusAssignmentOperator || token instanceof MultiplicationAssignmentOperator || token instanceof SubtractionAssignmentOperator || token instanceof ConditionalVariableFallbackOperator || token instanceof LanguageOperatorConstruct || token instanceof LogicalAndOperator || token instanceof LogicalNegationOperator || token instanceof LogicalOrOperator || token instanceof LogicalXorOperator || token instanceof NullCoalesceOperator || token instanceof StringConcatenationOperator || token instanceof AdditionOperator || token instanceof DivisionOperator || token instanceof ExponentiationOperator || token instanceof ModulusOperator || token instanceof MultiplicationOperator || token instanceof SubtractionOperator || token instanceof EqualCompOperator || token instanceof GreaterThanCompOperator || token instanceof GreaterThanEqualCompOperator || token instanceof LessThanCompOperator || token instanceof LessThanEqualCompOperator || token instanceof NotEqualCompOperator || token instanceof NotStrictEqualCompOperator || token instanceof SpaceshipCompOperator || token instanceof StrictEqualCompOperator) {
      return true;
    }
    return false;
  }
  markAllNonVirtualAsListGroupMember(nodes) {
    nodes.forEach((node) => {
      if (node instanceof LogicGroup || node instanceof ScopedLogicGroup || node instanceof AliasedScopeLogicGroup) {
        if (node.start != null && node.start.isVirtual == false) {
          node.start.isListGroupMember = true;
        }
        if (node.end != null && node.end.isVirtual == false) {
          node.end.isListGroupMember = true;
        }
        if (node.scopeOperator != null) {
          node.scopeOperator.isListGroupMember = true;
        }
        node.nodes.forEach((lgNode) => {
          this.markAllNonVirtualAsListGroupMember([lgNode]);
        });
        return;
      } else if (node instanceof SemanticGroup) {
        if (node.separatorToken != null && node.separatorToken.isVirtual == false) {
          node.separatorToken.isListGroupMember = true;
        }
        this.markAllNonVirtualAsListGroupMember(node.nodes);
      }
      if (node.isVirtual == false) {
        node.isListGroupMember = true;
      }
      if (node.originalAbstractNode != null && node.originalAbstractNode != node) {
        this.markAllNonVirtualAsListGroupMember([node.originalAbstractNode]);
      }
    });
  }
  markAllNonVirtualAsSwitch(nodes) {
    nodes.forEach((node) => {
      if (node instanceof LogicGroup || node instanceof ScopedLogicGroup || node instanceof AliasedScopeLogicGroup) {
        if (node.start != null && node.start.isVirtual == false) {
          node.start.isSwitchGroupMember = true;
        }
        if (node.end != null && node.end.isVirtual == false) {
          node.end.isSwitchGroupMember = true;
        }
        if (node.scopeOperator != null) {
          node.scopeOperator.isSwitchGroupMember = true;
        }
        node.nodes.forEach((lgNode) => {
          this.markAllNonVirtualAsSwitch([lgNode]);
        });
        return;
      } else if (node instanceof SemanticGroup) {
        if (node.separatorToken != null && node.separatorToken.isVirtual == false) {
          node.separatorToken.isSwitchGroupMember = true;
        }
        this.markAllNonVirtualAsSwitch(node.nodes);
      }
      if (node.isVirtual == false) {
        node.isSwitchGroupMember = true;
      }
      if (node.originalAbstractNode != null && node.originalAbstractNode != node) {
        this.markAllNonVirtualAsSwitch([node.originalAbstractNode]);
      }
    });
  }
  validateNoDanglingLogicGroupEnds(tokens) {
    tokens.forEach((token) => {
      if (token instanceof LogicGroupEnd) {
        token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_START, token, "Unexpected [T_LOGIC_END] while parsing input text."));
      }
    });
  }
  isValidModifierValue(node) {
    if (node instanceof ModifierValueNode || node instanceof VariableNode || node instanceof TrueConstant || node instanceof FalseConstant || node instanceof NullConstant || node instanceof NumberNode || node instanceof StringValueNode) {
      return true;
    }
    return false;
  }
  wrapNumberInVariable(node) {
    var _a, _b, _c, _d;
    const variableNode = new VariableNode();
    variableNode.startPosition = node.startPosition;
    variableNode.endPosition = node.endPosition;
    variableNode.name = (_b = (_a = node.value) == null ? void 0 : _a.toString()) != null ? _b : "";
    variableNode.content = (_d = (_c = node.value) == null ? void 0 : _c.toString()) != null ? _d : "";
    variableNode.originalAbstractNode = node;
    variableNode.refId = node.refId;
    variableNode.modifierChain = node.modifierChain;
    variableNode.index = node.index;
    return variableNode;
  }
  wrapArithmeticModifier(operator, modifierName) {
    const node = new ModifierNameNode();
    node.startPosition = operator.startPosition;
    node.endPosition = operator.endPosition;
    node.originalAbstractNode = operator;
    node.content = modifierName;
    node.name = modifierName;
    node.index = operator.index;
    return node;
  }
  combineVariablePaths(tokens) {
    const newNodes = [], tokenCount = tokens.length;
    for (let i = 0; i < tokenCount; i++) {
      const node = tokens[i], newNodeCount = newNodes.length;
      if (node instanceof InlineBranchSeparator) {
        if (newNodeCount == 0) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_BRANCH_SEPARATOR_FOR_VARCOMBINE, node, "Unexpected [T_BRANCH_SEPARATOR] while parsing input text."));
          continue;
        }
        if (i + 1 > tokenCount) {
          let lastNodeText = "";
          if (i > 0) {
            const lastNode = tokens[i - 1];
            lastNodeText = LineRetriever.getNearText(lastNode);
          }
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_BRANCH_GROUP, node, 'Unexpected end of input while parsing input text near "' + lastNodeText + LineRetriever.getNearText(node) + '".'));
          continue;
        }
        const left = newNodes[newNodeCount - 1];
        let right = tokens[i + 1];
        if (right instanceof NumberNode && NodeHelpers.distance(left, right) == 1) {
          right = this.wrapNumberInVariable(right);
        }
        if (left instanceof VariableNode && right instanceof VariableNode && NodeHelpers.distance(left, right) == 1) {
          newNodes.pop();
          NodeHelpers.mergeVarContentRight(":", node, right);
          NodeHelpers.mergeVarRight(left, right);
          newNodes.push(right);
          this.mergedVariablePaths.push(right);
          this.mergedComponents.set(node, right);
          this.mergedComponents.set(left, right);
          this.mergedComponents.set(right, right);
          i += 1;
          continue;
        } else {
          newNodes.push(node);
          continue;
        }
      } else if (node instanceof StringValueNode && newNodeCount > 0) {
        if (i + 1 >= tokenCount) {
          newNodes.push(node);
          continue;
        }
        const left = newNodes[newNodeCount - 1], right = tokens[i + 1];
        if (left instanceof VariableNode && right instanceof VariableNode && NodeHelpers.distance(left, node) <= 1 && NodeHelpers.distance(node, right) <= 1) {
          newNodes.pop();
          NodeHelpers.mergeVarContentLeft(node.sourceTerminator + node.value + node.sourceTerminator, node, left);
          NodeHelpers.mergeVarContentLeft(right.name, right, left);
          newNodes.push(left);
          this.mergedVariablePaths.push(left);
          this.mergedComponents.set(node, left);
          this.mergedComponents.set(left, left);
          this.mergedComponents.set(right, left);
          i += 1;
          continue;
        } else {
          newNodes.push(node);
        }
      } else {
        newNodes.push(node);
      }
    }
    newNodes.forEach((node) => {
      if (node instanceof VariableNode) {
        node.variableReference = this.pathParser.parse(node.name);
        node.mergeErrors(this.pathParser.getAntlersErrors());
      }
    });
    return newNodes;
  }
  convertVarNodeToOperator(variable) {
    const operator = new LanguageOperatorConstruct();
    operator.content = variable.name;
    operator.startPosition = variable.startPosition;
    operator.endPosition = variable.endPosition;
    operator.originalAbstractNode = variable;
    variable.convertedToOperator = true;
    this.createdLanguageOperators.push(operator);
    return operator;
  }
  convertOperatorToVarNode(operator) {
    const varNodeWrap = new VariableNode();
    varNodeWrap.startPosition = operator.startPosition;
    varNodeWrap.endPosition = operator.endPosition;
    varNodeWrap.content = operator.content;
    varNodeWrap.name = operator.content;
    varNodeWrap.originalAbstractNode = operator;
    return varNodeWrap;
  }
  createLanguageOperators(tokens) {
    const nodeCount = tokens.length;
    for (let i = 0; i < nodeCount; i++) {
      const thisNode = tokens[i];
      if (thisNode instanceof VariableNode) {
        if (thisNode.name.includes(DocumentParser.Punctuation_FullStop)) {
          const checkParts = thisNode.name.split(DocumentParser.Punctuation_FullStop);
          if (LanguageOperatorRegistry.operators.includes(checkParts[0]) || LibraryManager.deferredCoreLibraries.includes(checkParts[0])) {
            tokens[i] = this.convertVarNodeToOperator(thisNode);
            continue;
          }
        }
        if (LanguageOperatorRegistry.operators.includes(thisNode.name)) {
          tokens[i] = this.convertVarNodeToOperator(thisNode);
          continue;
        }
      }
      if (thisNode instanceof LanguageOperatorConstruct) {
        if (i + 1 >= nodeCount) {
          tokens[i] = this.convertOperatorToVarNode(thisNode);
          continue;
        }
        const next = tokens[i + 1];
        if (next instanceof StatementSeparatorNode) {
          tokens[i] = this.convertOperatorToVarNode(thisNode);
          continue;
        }
      }
    }
    return tokens;
  }
  createLogicalGroups(tokens) {
    const groupedTokens = [], tokenCount = tokens.length;
    const negatedGroupedTokens = [];
    for (let i = 0; i < tokenCount; i++) {
      const token = tokens[i];
      if (token instanceof LogicalNegationOperator) {
        const negationCount = this.countTypeRight(tokens, i, LogicalNegationOperator);
        if (negatedGroupedTokens.length == 0 && tokens.length == negationCount) {
          token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_LOGIC_NEGATION_OPERATOR, token, "Unexpected [T_LOGIC_INVERSE] while parsing input text."));
          continue;
        }
        if (i > 0 && negatedGroupedTokens.length > 0) {
          const prev = negatedGroupedTokens[negatedGroupedTokens.length - 1];
          if (prev instanceof NumberNode || prev instanceof LogicGroupEnd || prev instanceof LogicGroup) {
            if (prev instanceof LogicGroup) {
              if (prev.start instanceof LogicalNegationOperator) {
                prev.start.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_FACTORIAL_MATERIALIZED_BOOL_DETECTED, prev.start, "[T_AOP_FACTORIAL] operand will always materialize boolean type."));
                continue;
              }
            }
            const factorialOperator = new FactorialOperator();
            factorialOperator.startPosition = token.startPosition;
            factorialOperator.endPosition = token.endPosition;
            factorialOperator.content = "!".repeat(negationCount);
            factorialOperator.originalAbstractNode = token;
            factorialOperator.repeat = negationCount;
            negatedGroupedTokens.push(factorialOperator);
            if (negationCount > 0) {
              i += negationCount - 1;
            }
            continue;
          }
        }
        if (negationCount % 2 == 0) {
          i += negationCount - 1;
          continue;
        }
        const peek = tokens[i + negationCount];
        if (peek instanceof LogicGroupBegin) {
          const targetSliceOffset = i + negationCount + 1;
          if (targetSliceOffset >= tokenCount) {
            peek.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_NEGATION_OFFSET, peek, "Unexpected end of input while parsing input text."));
            continue;
          }
          const groupResults = this.findLogicalGroupEnd(tokens[i + negationCount], tokens.slice(targetSliceOffset));
          if (groupResults.found) {
            const subGroup = groupResults.logicalGroup;
            const wrapperGroup = new LogicGroup();
            wrapperGroup.start = token;
            wrapperGroup.end = subGroup;
            wrapperGroup.nodes.push(token);
            wrapperGroup.nodes.push(subGroup);
            wrapperGroup.startPosition = token.startPosition;
            wrapperGroup.endPosition = subGroup.endPosition;
            negatedGroupedTokens.push(wrapperGroup);
            i += groupResults.skipCount + negationCount;
          }
          continue;
        }
        const results = this.resolveValueRight(tokens, i);
        if (results.value != null) {
          negatedGroupedTokens.push(results.value);
        }
        i += results.negationCount;
      } else {
        negatedGroupedTokens.push(token);
      }
    }
    const negatedTokenCount = negatedGroupedTokens.length;
    for (let i = 0; i < negatedTokenCount; i++) {
      const token = negatedGroupedTokens[i];
      if (token instanceof LogicGroupBegin) {
        if (i + 1 >= negatedTokenCount) {
          token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END_DUE_TO_NEGATION, token, "Unexpected end of input while parsing input text."));
          continue;
        }
        const group = this.findLogicalGroupEnd(token, negatedGroupedTokens.slice(i + 1));
        if (group.found && group.logicalGroup != null) {
          groupedTokens.push(group.logicalGroup);
        }
        i += group.skipCount;
      } else {
        if (token instanceof FactorialOperator) {
          if (groupedTokens.length == 0) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_WHILE_CREATING_GROUPS, token, "Unexpected [T_AOP_FACTORIAL] while parsing input text."));
            continue;
          }
          let prev = groupedTokens[groupedTokens.length - 1];
          if (prev instanceof LogicGroup == false && prev instanceof NumberNode == false) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_FACTORIAL_OPERAND, token, "Unexpected left operand encountered for [T_AOP_FACTORIAL] while parsing input text."));
            continue;
          }
          prev = groupedTokens.pop();
          const wrapperGroup = new LogicGroup();
          wrapperGroup.startPosition = prev.startPosition;
          wrapperGroup.endPosition = token.endPosition;
          wrapperGroup.originalAbstractNode = token;
          wrapperGroup.nodes.push(prev);
          wrapperGroup.nodes.push(token);
          groupedTokens.push(wrapperGroup);
        } else {
          groupedTokens.push(token);
        }
      }
    }
    return groupedTokens;
  }
  makeArgGroup(nodes) {
    const argGroup = new ArgumentGroup(), nodeCount = nodes.length;
    for (let i = 0; i < nodeCount; i++) {
      const thisNode = nodes[i];
      if (this.isOperand(thisNode) == false) {
        thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_WHILE_PARSING_METHOD, thisNode, "Unexpected [" + TypeLabeler.getPrettyTypeName(thisNode) + "] while parsing argument group."));
        continue;
      }
      let next = null;
      if (i + 1 < nodeCount) {
        next = nodes[i + 1];
      }
      if (next == null || next instanceof ArgSeparator) {
        argGroup.args.push(nodes[i]);
        i += 1;
        continue;
      } else if (next instanceof InlineBranchSeparator) {
        if (i + 2 >= nodeCount) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARG_UNEXPECTED_NAMED_ARGUMENT, thisNode, "Unexpected end of input while parsing named argument."));
          continue;
        }
        const valueNode = nodes[i + 2];
        const namedArgument = new NamedArgumentNode();
        namedArgument.startPosition = thisNode.startPosition;
        namedArgument.endPosition = valueNode.endPosition;
        namedArgument.content = thisNode.content + valueNode.content;
        namedArgument.name = thisNode;
        namedArgument.value = valueNode;
        if (thisNode instanceof VariableNode == false) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_NAMED_ARG_IDENTIFIER, thisNode, "Invalid type [" + TypeLabeler.getPrettyTypeName(thisNode) + "] supplied for named argument name."));
        }
        argGroup.hasNamedArguments = true;
        argGroup.numberOfNamedArguments += 1;
        argGroup.args.push(namedArgument);
        if (i + 3 < nodeCount && nodes[i + 3] instanceof ArgSeparator) {
          i += 3;
        } else {
          i += 2;
        }
        continue;
      }
    }
    let remainderMustBeNamed = false;
    argGroup.args.forEach((arg) => {
      if (arg instanceof NamedArgumentNode) {
        remainderMustBeNamed = true;
      } else {
        if (remainderMustBeNamed) {
          arg.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_UNNAMED_METHOD_ARGUMENT, arg, "Unnamed arguments are not allowed to appear after a named argument."));
        }
      }
    });
    return argGroup;
  }
  cleanVariableForMethodInvocation(node) {
    if (node.name.startsWith(":") || node.name.startsWith(".")) {
      node.name = node.name.substr(1);
      if (node.variableReference != null) {
        node.variableReference.originalContent = node.variableReference.originalContent.substr(1);
        node.variableReference.normalizedReference = node.variableReference.normalizedReference.substr(1);
      }
      if (node.startPosition != null) {
        node.startPosition.offset += 1;
        node.startPosition.char += 1;
      }
    }
  }
  reduceVariableReferenceForObjectAccessor(node) {
    var _a;
    const lastPath = (_a = node.variableReference) == null ? void 0 : _a.pathParts.pop(), accessor = lastPath.name, accessorLen = accessor.length + 1;
    node.name = node.name.substr(0, -accessorLen);
    if (node.variableReference != null) {
      node.variableReference.originalContent = node.variableReference.originalContent.substr(0, -accessorLen);
      node.variableReference.normalizedReference = node.variableReference.normalizedReference.substr(0, -accessorLen);
      node.variableReference.pathParts[node.variableReference.pathParts.length - 1].isFinal = true;
    }
    if (node.endPosition != null) {
      node.endPosition.offset -= accessorLen;
      node.endPosition.char -= accessorLen;
    }
    return {
      accessor,
      accessorLen
    };
  }
  associateMethodCalls(tokens) {
    var _a, _b;
    const newTokens = [], nodeCount = tokens.length;
    for (let i = 0; i < nodeCount; i++) {
      const thisNode = tokens[i];
      let prevNode = null, next = null;
      if (newTokens.length > 0) {
        prevNode = newTokens[newTokens.length - 1];
      }
      if (i + 1 < nodeCount) {
        next = tokens[i + 1];
      }
      if (thisNode instanceof VariableNode && next instanceof LogicGroup && prevNode != null && (this.isProperMethodChainTargetStrict(prevNode) || prevNode instanceof InlineBranchSeparator)) {
        const argGroup = next;
        let argNodes = [];
        if (argGroup.nodes.length > 0) {
          if (argGroup.nodes[0] instanceof SemanticGroup) {
            const tSg = argGroup.nodes[0];
            argNodes = tSg.nodes;
          } else {
            argNodes = argGroup.nodes;
          }
        }
        const methodInvocation = new MethodInvocationNode();
        methodInvocation.startPosition = thisNode.startPosition;
        if (prevNode instanceof InlineBranchSeparator) {
          const branchSeparator = newTokens.pop();
          methodInvocation.startPosition = branchSeparator.startPosition;
        }
        this.cleanVariableForMethodInvocation(thisNode);
        methodInvocation.endPosition = argGroup.endPosition;
        methodInvocation.args = this.makeArgGroup(argNodes);
        methodInvocation.method = thisNode;
        prevNode.methodTarget = methodInvocation;
        if (prevNode instanceof VariableNode && prevNode.mergeRefName.length > 0) {
          prevNode.name = NodeHelpers.getUnrefName(prevNode.mergeRefName);
        }
        newTokens.push(methodInvocation);
        i += 1;
        continue;
      } else if (thisNode instanceof LogicGroup && prevNode instanceof VariableNode && prevNode.variableReference != null && prevNode.variableReference.pathParts.length >= 2) {
        let argNodes = [];
        if (thisNode.nodes.length > 0) {
          if (thisNode.nodes[0] instanceof SemanticGroup) {
            const tSg = thisNode.nodes[0];
            argNodes = tSg.nodes;
          } else {
            argNodes = thisNode.nodes;
          }
        }
        if (prevNode.variableReference.pathParts[0] instanceof PathNode) {
          if (LibraryManager.deferredCoreLibraries.includes(prevNode.variableReference.pathParts[0].name)) {
            const varRef = newTokens.pop();
            const libraryInvocation = new LibraryInvocationConstruct();
            libraryInvocation.startPosition = varRef.startPosition;
            libraryInvocation.endPosition = thisNode.endPosition;
            libraryInvocation.content = varRef.content;
            libraryInvocation.originalAbstractNode = thisNode;
            const libraryReference = (_a = varRef.variableReference) == null ? void 0 : _a.pathParts.shift();
            const libraryName = libraryReference.name, methodName = (_b = varRef.variableReference) == null ? void 0 : _b.implodePaths();
            libraryInvocation.libraryName = libraryName;
            libraryInvocation.methodName = methodName;
            libraryInvocation.arguments = this.makeArgGroup(argNodes);
            newTokens.push(libraryInvocation);
            i += 1;
            continue;
          }
        }
        const reductionResult = this.reduceVariableReferenceForObjectAccessor(prevNode);
        const methodInvocation = new MethodInvocationNode();
        methodInvocation.startPosition = thisNode.startPosition;
        methodInvocation.endPosition = thisNode.endPosition;
        prevNode.methodTarget = methodInvocation;
        if (prevNode instanceof VariableNode && prevNode.mergeRefName.length > 0) {
          prevNode.name = NodeHelpers.getUnrefName(prevNode.mergeRefName);
        }
        if (thisNode.start != null) {
          thisNode.start.isPartOfMethodChain = true;
        }
        if (thisNode.end != null) {
          thisNode.end.isPartOfMethodChain = true;
        }
        const wrappedMethod = new VariableNode();
        wrappedMethod.name = reductionResult.accessor;
        wrappedMethod.isPartOfMethodChain = true;
        const args = this.makeArgGroup(argNodes);
        if (methodInvocation.startPosition != null) {
          methodInvocation.startPosition.offset -= reductionResult.accessorLen;
          methodInvocation.startPosition.char -= reductionResult.accessorLen;
        }
        methodInvocation.method = wrappedMethod;
        methodInvocation.args = args;
        if (StringUtilities.isNumeric(prevNode.name)) {
          const varNode = newTokens.pop();
          newTokens.push(this.convertOperatorToVarNode(varNode));
        }
        newTokens.push(methodInvocation);
        continue;
      } else if (thisNode instanceof VariableNode && prevNode instanceof MethodInvocationNode) {
        this.cleanVariableForMethodInvocation(thisNode);
        if (i + 1 > nodeCount) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_ARG_GROUP, thisNode, "Unexpected end of input while parsing method call."));
          continue;
        }
        const argGroupT = tokens[i + 1];
        if (argGroupT instanceof LogicGroup == false) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP, thisNode, "Unexpected [" + TypeLabeler.getPrettyTypeName(argGroupT) + "] while parsing [T_METHOD_CALL]; expecting [T_ARG_GROUP]."));
          continue;
        }
        const argGroup = argGroupT;
        let argNodes = [];
        if (argGroup.nodes.length > 0) {
          if (argGroup.nodes[0] instanceof SemanticGroup) {
            const tSg = argGroup.nodes[0];
            argNodes = tSg.nodes;
          } else {
            argNodes = argGroup.nodes;
          }
        }
        const methodInvocation = new MethodInvocationNode();
        methodInvocation.startPosition = thisNode.startPosition;
        methodInvocation.endPosition = argGroup.endPosition;
        methodInvocation.args = this.makeArgGroup(argNodes);
        methodInvocation.method = thisNode;
        prevNode.methodTarget = methodInvocation;
        newTokens.push(methodInvocation);
        i += 1;
        continue;
      } else if (thisNode instanceof InlineBranchSeparator && prevNode instanceof MethodInvocationNode) {
        if (i + 1 > nodeCount) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_METHOD, thisNode, "Unexpected end of input while parsing method call."));
          continue;
        }
        const next2 = tokens[i + 1];
        if (i + 2 > nodeCount) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_ARG_GROUP, thisNode, "Unexpected end of input while parsing method call."));
          continue;
        }
        const argGroupT = tokens[i + 2];
        if (argGroupT instanceof LogicGroup == false) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP, thisNode, "Unexpected [" + TypeLabeler.getPrettyTypeName(argGroupT) + "] while parsing [T_METHOD_CALL]; expecting [T_ARG_GROUP]."));
          continue;
        }
        const argGroup = argGroupT;
        let argNodes = [];
        if (argGroup.nodes.length > 0) {
          if (argGroup.nodes[0] instanceof SemanticGroup) {
            const tSg = argGroup.nodes[0];
            argNodes = tSg.nodes;
          } else {
            argNodes = argGroup.nodes;
          }
        }
        const methodInvocation = new MethodInvocationNode();
        methodInvocation.startPosition = thisNode.startPosition;
        methodInvocation.endPosition = argGroupT.endPosition;
        methodInvocation.args = this.makeArgGroup(argNodes);
        methodInvocation.method = next2;
        prevNode.methodTarget = methodInvocation;
        newTokens.push(methodInvocation);
        i += 2;
        continue;
      } else if (thisNode instanceof MethodInvocationNode) {
        if (i + 1 > nodeCount) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_METHOD_CALL_MISSING_METHOD, thisNode, "Unexpected end of input while parsing method call."));
          continue;
        }
        const methodNode = tokens[i + 1];
        if (i + 2 > nodeCount) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP, thisNode, "Unexpected end of input while parsing method call."));
          continue;
        }
        const nextT = tokens[i + 2];
        if (nextT instanceof LogicGroup == false) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_METHOD_CALL_ARG_GROUP, thisNode, "Unexpected [" + TypeLabeler.getPrettyTypeName(nextT) + "] while parsing [T_METHOD_CALL]; expecting [T_ARG_GROUP]."));
          continue;
        }
        const next2 = nextT;
        let argNodes = [];
        if (next2.nodes.length > 0) {
          if (next2.nodes[0] instanceof SemanticGroup) {
            const tSg = next2.nodes[0];
            argNodes = tSg.nodes;
          } else {
            argNodes = next2.nodes;
          }
        }
        const args = this.makeArgGroup(argNodes);
        if (prevNode instanceof VariableNode && LibraryManager.deferredCoreLibraries.includes(prevNode.name)) {
          const varRef = newTokens.pop();
          const libraryInvocation = new LibraryInvocationConstruct();
          libraryInvocation.startPosition = varRef.startPosition;
          libraryInvocation.endPosition = next2.endPosition;
          libraryInvocation.libraryName = varRef.name;
          libraryInvocation.methodName = methodNode.name;
          libraryInvocation.content = libraryInvocation.libraryName + "->" + libraryInvocation.methodName;
          libraryInvocation.arguments = args;
          prevNode.libraryTarget = libraryInvocation;
          newTokens.push(libraryInvocation);
          i += 2;
          continue;
        }
        thisNode.method = methodNode;
        thisNode.args = args;
        if (newTokens.length > 0) {
          newTokens[newTokens.length - 1].methodTarget = thisNode;
        }
        i += 2;
        newTokens.push(thisNode);
        continue;
      } else {
        newTokens.push(thisNode);
      }
    }
    return newTokens;
  }
  convertVariableToStringNode(node) {
    const wrappedNode = new StringValueNode();
    wrappedNode.content = node.name;
    wrappedNode.value = node.name;
    wrappedNode.originalAbstractNode = node;
    wrappedNode.startPosition = node.startPosition;
    wrappedNode.endPosition = node.endPosition;
    wrappedNode.index = node.index;
    return wrappedNode;
  }
  createTupleLists(tokens) {
    const tokenCount = tokens.length, newTokens = [];
    for (let i = 0; i < tokenCount; i++) {
      const thisToken = tokens[i];
      if (thisToken instanceof TupleListStart) {
        thisToken.isListGroupMember = true;
        if (i + 1 >= tokenCount) {
          thisToken.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_TUPLE_LIST, thisToken, "Unexpected end of input while parsing tuple list."));
          continue;
        }
        const peekT = tokens[i + 1];
        if (peekT instanceof LogicGroup == false) {
          peekT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_TYPE_FOR_TUPLE_LIST, peekT, "Unexpected [" + TypeLabeler.getPrettyTypeName(peekT) + "] while parsing tuple list."));
          continue;
        }
        const peek = peekT;
        this.markAllNonVirtualAsListGroupMember([peek]);
        this.retriggerNonVirtualGroupMembers.push([peek]);
        const listNodeLength = peek.nodes.length;
        if (listNodeLength == 0) {
          peek.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_MISSING_BODY_TUPLE_LIST, peek, "Missing tuple list body while parsing tuple list."));
          continue;
        }
        const nameGroup = peek.nodes.shift();
        const targetGroupLength = nameGroup.nodes.length;
        const listNames = [];
        for (let j = 0; j < targetGroupLength; j++) {
          const subNodeT = nameGroup.nodes[j];
          if (subNodeT instanceof ArgSeparator == false) {
            let breakFromVarRef = false;
            if (subNodeT instanceof VariableNode) {
              if (subNodeT.variableReference == null) {
                breakFromVarRef = true;
              }
              if (subNodeT.variableReference != null) {
                if (subNodeT.variableReference.pathParts.length > 1) {
                  breakFromVarRef = true;
                }
              }
              if (subNodeT.name.trim().length == 0) {
                breakFromVarRef = true;
              }
            }
            if (breakFromVarRef || subNodeT instanceof VariableNode == false) {
              peek.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_NAME_TYPE, peek, "Invalid [" + TypeLabeler.getPrettyTypeName(subNodeT) + "] name type found while parsing tuple list."));
              continue;
            }
            const subNode = subNodeT;
            listNames.push(this.convertVariableToStringNode(subNode));
          }
        }
        const listValueLength = listNames.length;
        if (listValueLength == 0) {
          peek.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_MANIFESTED_NAME_GROUP, peek, "Invalid Name expression produced an invalid name group while parsing tuple list."));
          continue;
        }
        const arrayNode = new ArrayNode();
        this.createdArrays.push(arrayNode);
        arrayNode.startPosition = thisToken.startPosition;
        arrayNode.endPosition = thisToken.endPosition;
        peek.nodes.forEach((valueNodeCandidateT) => {
          if (valueNodeCandidateT instanceof SemanticGroup == false) {
            valueNodeCandidateT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE_GROUP, valueNodeCandidateT, "Invalid [" + TypeLabeler.getPrettyTypeName(valueNodeCandidateT) + "] name type found while parsing tuple list value expression."));
            return;
          }
          const valueNodeCandidate = valueNodeCandidateT;
          const nestedArrayNode = new ArrayNode();
          this.createdArrays.push(nestedArrayNode);
          nestedArrayNode.startPosition = valueNodeCandidate.startPosition;
          const valueCandidates = [];
          for (let j = 0; j < targetGroupLength; j++) {
            const valueToken = valueNodeCandidate.nodes[j];
            if (valueToken instanceof ArgSeparator == false) {
              if (this.isOperand(valueToken) == false) {
                valueToken.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_TUPLE_LIST_VALUE_TYPE, valueToken, "Unexpected [" + TypeLabeler.getPrettyTypeName(valueToken) + "]  while parsing tuple list value."));
                continue;
              }
              valueCandidates.push(valueToken);
            }
          }
          for (let j = 0; j < listValueLength; j++) {
            if (j > valueCandidates.length) {
              break;
            }
            const valueToken = valueCandidates[j];
            const namedValueNode = new NameValueNode();
            namedValueNode.startPosition = valueToken.startPosition;
            namedValueNode.endPosition = valueToken.endPosition;
            namedValueNode.name = listNames[j];
            namedValueNode.value = valueToken;
            nestedArrayNode.nodes.push(namedValueNode);
            arrayNode.endPosition = valueToken.endPosition;
            nestedArrayNode.endPosition = valueToken.endPosition;
          }
          arrayNode.nodes.push(nestedArrayNode);
        });
        newTokens.push(arrayNode);
        i += 1;
        continue;
      } else {
        newTokens.push(thisToken);
      }
    }
    return tokens;
  }
  makeOrderGroup(nodes) {
    const orders = [], nodeCount = nodes.length;
    let orderCount = 0;
    for (let i = 0; i < nodeCount; i++) {
      const thisNode = nodes[i];
      let next = null;
      if (i + 1 < nodeCount) {
        next = nodes[i + 1];
      }
      if (i > 0) {
        if (next == null || next instanceof ArgSeparator) {
          orderCount += 1;
          const orderNode = new ValueDirectionNode();
          orderNode.order = orderCount;
          orderNode.name = nodes[i - 1];
          orderNode.directionNode = thisNode;
          if (this.isOperand(orderNode.name) == false) {
            orderNode.name.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_ORDER_BY_NAME_VALUE, orderNode.name, "Invalid value or expression supplied for order by name."));
          }
          if (this.isOperand(orderNode.directionNode) == false) {
            orderNode.directionNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INVALID_ORDER_BY_SORT_VALUE, orderNode.directionNode, "Invalid value or expression supplied for order by direction."));
          }
          orderNode.startPosition = orderNode.name.startPosition;
          orderNode.endPosition = orderNode.directionNode.endPosition;
          orders.push(orderNode);
          i += 1;
          continue;
        }
      }
    }
    return orders;
  }
  getValues(nodes) {
    const valueNode = new ListValueNode(), nodeCount = nodes.length, values = [];
    for (let i = 0; i < nodeCount; i++) {
      const thisNode = nodes[i];
      let next = null;
      if (i + 1 < nodeCount) {
        next = nodes[i + 1];
      }
      if (next == null || next instanceof ArgSeparator) {
        values.push(thisNode);
        i += 1;
        continue;
      }
    }
    valueNode.values = values;
    return valueNode;
  }
  createLibraryInvocations(tokens) {
    const newTokens = [], tokenCount = tokens.length;
    for (let i = 0; i < tokenCount; i++) {
      const token = tokens[i];
      if (token instanceof LanguageOperatorConstruct) {
        if (token.content.includes(".")) {
          const content = token.content.split("."), libraryName = content.shift(), methodName = content.join(".");
          const libraryInvocationConstruct = new LibraryInvocationConstruct();
          libraryInvocationConstruct.startPosition = token.startPosition;
          libraryInvocationConstruct.endPosition = token.endPosition;
          libraryInvocationConstruct.content = token.content;
          libraryInvocationConstruct.libraryName = libraryName;
          libraryInvocationConstruct.methodName = methodName;
          libraryInvocationConstruct.originalAbstractNode = token;
          if (i + 1 >= tokenCount) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_ARG_GROUP, token, "Unexpected end of input while parsing argument group."));
            continue;
          }
          if (tokens[i + 1] instanceof LogicGroup == false) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_EXPECTING_ARGUMENT_GROUP, token, "Unexpected token while parsing method call. Expecting [T_ARG_SEPARATOR] got [" + TypeLabeler.getPrettyTypeName(token) + "]."));
            continue;
          }
          const logicGroup = tokens[i + 1];
          let argGroup = null;
          if (logicGroup.nodes.length > 0) {
            const semanticGroup = logicGroup.nodes[0];
            argGroup = this.makeArgGroup(semanticGroup.nodes);
          }
          if (argGroup == null) {
            argGroup = new ArgumentGroup();
            argGroup.startPosition = logicGroup.startPosition;
            argGroup.endPosition = logicGroup.endPosition;
            argGroup.originalAbstractNode = logicGroup;
          }
          libraryInvocationConstruct.arguments = argGroup;
          newTokens.push(libraryInvocationConstruct);
          i += 1;
          continue;
        } else if (token.content == LanguageOperatorRegistry.ARR_ORDERBY) {
          if (i + 1 >= tokenCount) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_PARSING_ORDER_GROUP, token, "Unexpected end of input while parsing order group."));
            continue;
          }
          const nextTokenT = tokens[i + 1];
          if (nextTokenT instanceof LogicGroup == false) {
            nextTokenT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_EXPECTING_ORDER_GROUP_FOR_ORDER_BY_OPERAND, nextTokenT, "Unexpected [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] while parsing order group."));
            continue;
          }
          const nextToken = nextTokenT;
          let subNodes = nextToken.nodes;
          if (subNodes[0] instanceof SemanticGroup) {
            const tSg = subNodes[0];
            subNodes = tSg.nodes;
          }
          const orderClauses = this.makeOrderGroup(subNodes);
          if (orderClauses.length == 0) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EMPTY_DIRECTION_GROUP, token, "Unexpected empty [T_DIRECTION_GROUP]. Must have at least one order clause, and each property must have a direction specified."));
          }
          const orderGroup = new DirectionGroup();
          orderGroup.orderClauses = orderClauses;
          if (orderClauses.length > 0) {
            if (orderClauses[0].directionNode != null) {
              orderGroup.startPosition = orderClauses[0].directionNode.startPosition;
            }
            const ocLastDn = orderClauses[orderClauses.length - 1].directionNode;
            if (ocLastDn != null) {
              orderGroup.endPosition = ocLastDn.endPosition;
            }
          }
          newTokens.push(token);
          newTokens.push(orderGroup);
          i += 1;
          continue;
        } else if (token.content == LanguageOperatorRegistry.ARR_GROUPBY) {
          if (i + 1 >= tokenCount) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_GROUP_BY, token, "Unexpected end of input while parsing group by clause."));
            continue;
          }
          const nextTokenT = tokens[i + 1];
          if (nextTokenT instanceof AliasedScopeLogicGroup || nextTokenT instanceof ScopedLogicGroup) {
            nextTokenT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_GROUP_BY_SCOPED_GROUP_MUST_BE_ENCLOSED, nextTokenT, "Type [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] must be enclosed with parenthesis to be used with groupby."));
            continue;
          }
          if (nextTokenT instanceof LogicGroup == false) {
            nextTokenT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_GROUP_BY, nextTokenT, "Unexpected [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] while parsing group by."));
            continue;
          }
          const nextToken = nextTokenT;
          let subNodes = nextToken.nodes;
          if (subNodes[0] instanceof SemanticGroup) {
            const tSg = subNodes[0];
            subNodes = tSg.nodes;
          }
          const listValues = this.getValues(subNodes);
          newTokens.push(token);
          newTokens.push(listValues);
          if (i + 2 < tokenCount && i + 3 < tokenCount) {
            const peekOne = tokens[i + 2], peekTwo = tokens[i + 3];
            if (NodeHelpers.isVariableMatching(peekOne, LanguageKeywords.ScopeAs)) {
              if (peekTwo instanceof StringValueNode) {
                listValues.isNamedNode = true;
                listValues.parsedName = peekTwo;
                i += 3;
                continue;
              } else {
                peekTwo.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_GROUP_BY_AS_ALIAS_TYPE, peekTwo, "Expecting [T_STRING] for group by collection alias; got [" + TypeLabeler.getPrettyTypeName(peekTwo) + "]."));
              }
            }
          }
          i += 1;
          continue;
        } else if (token.content == LanguageOperatorRegistry.STRUCT_SWITCH) {
          if (i + 1 >= tokenCount) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_SWITCH_GROUP, token, "Unexpected end of input while parsing [T_SWITCH_GROUP]."));
            continue;
          }
          const nextT = tokens[i + 1];
          if (nextT instanceof ScopedLogicGroup == false) {
            nextT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_TOKEN_FOR_SWITCH_GROUP, nextT, "Unexpected [" + TypeLabeler.getPrettyTypeName(nextT) + "] while parsing [T_SWITCH_GROUP]."));
            continue;
          }
          const next = nextT;
          this.markAllNonVirtualAsSwitch([nextT]);
          if (next.scope == null || next.scope instanceof LogicGroup == false) {
            next.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE, next, "Unexpected input while parsing [T_SWITCH_GROUP]."));
            continue;
          }
          const tSwitchScope = next.scope;
          if (tSwitchScope.nodes.length == 0 || tSwitchScope.nodes[0] instanceof SemanticGroup == false) {
            next.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE, next, "Unexpected input while parsing [T_SWITCH_GROUP]."));
            continue;
          }
          const wrapperSemanticGroup = tSwitchScope.nodes[0];
          this.markAllNonVirtualAsSwitch([tSwitchScope]);
          if (wrapperSemanticGroup.nodes.length == 0 || wrapperSemanticGroup.nodes[0] instanceof LogicGroup == false) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE, token, "Unexpected input while parsing [T_SWITCH_GROUP]."));
            continue;
          }
          this.markAllNonVirtualAsSwitch([token]);
          this.markAllNonVirtualAsSwitch(wrapperSemanticGroup.nodes);
          const firstCondition = wrapperSemanticGroup.nodes;
          if (next.nodes.length == 0) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE, token, "Unexpected input while parsing [T_SWITCH_GROUP]."));
          }
          const expressionNodeT = tSwitchScope.nodes[0];
          if (expressionNodeT instanceof SemanticGroup == false) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_SWITCH_START_VALUE_NO_VALUE, token, "Unexpected input while parsing [T_SWITCH_GROUP]."));
            continue;
          }
          const expressionNode = tSwitchScope.nodes[0];
          this.markAllNonVirtualAsSwitch(expressionNode.nodes);
          const subTokens = expressionNode.nodes;
          const switchGroup = new SwitchGroup();
          const wrapperGroup = new LogicGroup();
          wrapperGroup.nodes = firstCondition;
          wrapperGroup.startPosition = wrapperGroup.nodes[0].startPosition;
          wrapperGroup.endPosition = wrapperGroup.nodes[wrapperGroup.nodes.length - 1].endPosition;
          const firstCase = new SwitchCase();
          firstCase.condition = wrapperGroup;
          const expWrapper = new LogicGroup();
          expWrapper.nodes.push(subTokens.shift());
          expWrapper.startPosition = expWrapper.nodes[0].startPosition;
          expWrapper.endPosition = expWrapper.nodes[expWrapper.nodes.length - 1].endPosition;
          firstCase.expression = expWrapper;
          firstCase.startPosition = firstCase.condition.startPosition;
          firstCase.endPosition = firstCase.expression.nodes[firstCase.expression.nodes.length - 1].endPosition;
          subTokens.shift();
          switchGroup.cases.push(firstCase);
          const subTokenCount = subTokens.length;
          if (subTokenCount > 0) {
            if (subTokens[0] instanceof LogicGroup == false) {
              token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSER_INVALID_SWITCH_TOKEN, token, "Invalid [" + TypeLabeler.getPrettyTypeName(subTokens[0]) + "] while parsing case statement."));
              continue;
            }
            for (let c = 0; c < subTokenCount; c++) {
              const thisToken = subTokens[c];
              let next2 = null;
              if (thisToken instanceof ArgSeparator) {
                thisToken.isSwitchGroupMember = true;
                continue;
              }
              if (c + 1 < subTokenCount) {
                next2 = subTokens[c + 1];
              }
              if (next2 instanceof ScopeAssignmentOperator) {
                next2.isSwitchGroupMember = true;
                const newCase = new SwitchCase();
                newCase.condition = thisToken;
                this.markAllNonVirtualAsSwitch([newCase.condition]);
                const expWrapper2 = new LogicGroup();
                expWrapper2.nodes.push(subTokens[c + 2]);
                expWrapper2.startPosition = expWrapper2.nodes[0].startPosition;
                expWrapper2.endPosition = expWrapper2.nodes[expWrapper2.nodes.length - 1].endPosition;
                newCase.expression = expWrapper2;
                this.markAllNonVirtualAsSwitch([expWrapper2]);
                newCase.startPosition = newCase.condition.startPosition;
                newCase.endPosition = newCase.expression.nodes[newCase.expression.nodes.length - 1].endPosition;
                switchGroup.cases.push(newCase);
                if (c + 3 < subTokenCount) {
                  if (subTokens[c + 3] instanceof ArgSeparator == false) {
                    subTokens[c + 3].pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_PARSER_INVALID_SWITCH_TOKEN, subTokens[c + 3], "Invalid [" + TypeLabeler.getPrettyTypeName(subTokens[c + 3]) + "] while parsing case statement; expecting [T_ARG_SEPARATOR]."));
                    continue;
                  }
                }
                subTokens[c + 3].isSwitchGroupMember = true;
                c += 2;
                continue;
              }
            }
          }
          newTokens.push(new NullConstant());
          newTokens.push(token);
          newTokens.push(switchGroup);
          i += 1;
          continue;
        } else if (token.content == LanguageOperatorRegistry.ARR_MAKE) {
          if (i + 1 >= tokenCount) {
            token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_TARGET, token, "Missing target variable for arr operator."));
            continue;
          }
          const nextTokenT = tokens[i + 1];
          if (nextTokenT instanceof LogicGroup == false) {
            nextTokenT.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_MAKE_UNEXPECTED_TYPE, nextTokenT, "Unexpected [" + TypeLabeler.getPrettyTypeName(nextTokenT) + "] while parsing array."));
            continue;
          }
          const isNextScopedLogicGroup = nextTokenT instanceof ScopedLogicGroup;
          const nextToken = nextTokenT;
          let subNodes = nextToken.nodes;
          if (subNodes[0] instanceof SemanticGroup) {
            const tSg = subNodes[0];
            subNodes = tSg.nodes;
          }
          if (isNextScopedLogicGroup) {
            const nextTScoped = nextTokenT;
            subNodes.unshift(new ScopeAssignmentOperator());
            subNodes.unshift(nextTScoped.scope);
          }
          const values = this.getArrayValues(subNodes);
          const arrayNode = new ArrayNode();
          arrayNode.startPosition = token.startPosition;
          const valueNodeCount = values.values.length;
          if (valueNodeCount > 0) {
            arrayNode.endPosition = values.values[valueNodeCount - 1].endPosition;
          } else {
            arrayNode.endPosition = token.endPosition;
          }
          if (nextToken.end != null) {
            arrayNode.endPosition = nextToken.end.endPosition;
          }
          arrayNode.nodes = values.values;
          this.createdArrays.push(arrayNode);
          newTokens.push(arrayNode);
          i += 1;
        } else {
          newTokens.push(token);
        }
      } else {
        newTokens.push(token);
      }
    }
    return newTokens;
  }
  getArrayValues(nodes) {
    const valueNode = new ListValueNode(), nodeCount = nodes.length, values = [];
    for (let i = 0; i < nodeCount; i++) {
      const thisNode = nodes[i];
      if (thisNode instanceof ArgSeparator) {
        thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_UNEXPECT_ARG_SEPARATOR, thisNode, "Unexpected [T_ARG_SEPARATOR] while parsing array."));
        continue;
      }
      if (thisNode instanceof ScopeAssignmentOperator) {
        if (i == 0) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_KEY_PAIR_MISSING_KEY, thisNode, "Missing key for key/value pair while parsing array."));
          continue;
        } else {
          if (nodes[i - 1] instanceof ArgSeparator) {
            thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_KEY_PAIR_MISSING_KEY, thisNode, "Missing key for key/value pair while parsing array."));
            continue;
          }
        }
      }
      let next = null;
      if (i + 1 < nodeCount) {
        next = nodes[i + 1];
      }
      if (next instanceof ScopeAssignmentOperator) {
        if (i + 2 >= nodeCount) {
          next.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_MAKE_MISSING_ARR_KEY_PAIR_VALUE, next, "Missing key/pair value while parsing array."));
          continue;
        }
        const keyValue = nodes[i + 2];
        const namedValueNode = new NameValueNode();
        if (this.isValidArrayKeyNode(thisNode) == false) {
          thisNode.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_ARR_KEY_PAIR_INVALID_KEY_TYPE, thisNode, "Invalid [" + TypeLabeler.getPrettyTypeName(thisNode) + "] type for key/value key."));
          continue;
        }
        namedValueNode.name = thisNode;
        namedValueNode.value = keyValue;
        namedValueNode.startPosition = thisNode.startPosition;
        namedValueNode.endPosition = keyValue.endPosition;
        values.push(namedValueNode);
        i += 3;
        continue;
      }
      if (next == null || next instanceof ArgSeparator) {
        const namedValueNode = new NameValueNode();
        namedValueNode.value = thisNode;
        namedValueNode.startPosition = thisNode.startPosition;
        namedValueNode.endPosition = thisNode.endPosition;
        values.push(namedValueNode);
        i += 1;
        continue;
      }
    }
    valueNode.values = values;
    return valueNode;
  }
  isValidArrayKeyNode(node) {
    if (node instanceof NumberNode || node instanceof StringValueNode) {
      return true;
    }
    return false;
  }
  associateModifiers(tokens) {
    const newNodes = [], tokenCount = tokens.length;
    let applyModifiersToNode = null;
    for (let i = 0; i < tokenCount; i++) {
      const node = tokens[i];
      if (node instanceof ModifierSeparator) {
        const newNodeCount = newNodes.length;
        if (newNodeCount == 0) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_MODIFIER_SEPARATOR, node, "Unexpected [T_MODIFIER_SEPARATOR] while parsing input text."));
          continue;
        }
        this.isRealModifierSeparator.set(node, true);
        applyModifiersToNode = newNodes[newNodeCount - 1];
        if (applyModifiersToNode.modifierChain == null) {
          applyModifiersToNode.modifierChain = new ModifierChainNode();
          applyModifiersToNode.modifierChain.modifierTarget = applyModifiersToNode;
          this.createdModifierChains.push(applyModifiersToNode.modifierChain);
        }
        if (i + 1 >= tokenCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_DETAILS, node, "Unexpected end of input while preparing to gather modifier details."));
          continue;
        }
        const results = this.scanToEndOfModifier(tokens.slice(i + 1));
        const resultCount = results.length;
        if (resultCount > 1) {
          if (results[1] instanceof InlineBranchSeparator) {
            this.isRealModifierSeparator.set(results[1], true);
            const firstToken = results[0];
            if (firstToken instanceof AdditionOperator) {
              results[0] = this.wrapArithmeticModifier(firstToken, "add");
            } else if (firstToken instanceof SubtractionOperator) {
              results[0] = this.wrapArithmeticModifier(firstToken, "subtract");
            } else if (firstToken instanceof DivisionOperator) {
              results[0] = this.wrapArithmeticModifier(firstToken, "divide");
            } else if (firstToken instanceof MultiplicationOperator) {
              results[0] = this.wrapArithmeticModifier(firstToken, "multiply");
            } else if (firstToken instanceof ModulusOperator) {
              results[0] = this.wrapArithmeticModifier(firstToken, "mod");
            }
          }
        }
        if (resultCount == 0) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNSET_MODIFIER_DETAILS, node, "Invalid or missing modifier details."));
          continue;
        }
        if (results[0] instanceof ModifierNameNode == false) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_MODIFIER_NAME_NOT_START_OF_DETAILS, node, "Invalid [" + TypeLabeler.getPrettyTypeName(results[0]) + "]; expecting [T_MODIFIER_NAME]"));
          continue;
        }
        const modifier = this.createModifier(results);
        if (modifier.nameNode != null) {
          this.modifierNameMapping.set(modifier.nameNode, modifier);
        }
        i += resultCount;
        applyModifiersToNode.modifierChain.modifierChain.push(modifier);
        applyModifiersToNode.modifierChain.updateValues();
        continue;
      } else {
        newNodes.push(node);
      }
    }
    return newNodes;
  }
  createNullCoalescenceGroups(tokens) {
    const newTokens = [], tokenCount = tokens.length;
    for (let i = 0; i < tokenCount; i++) {
      const node = tokens[i];
      if (node instanceof NullCoalesceOperator) {
        const left = newTokens.pop();
        if (i + 1 >= tokenCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_NULL_COALESCENCE_GROUP, node, "Unexpected end of input while parsing input text."));
          continue;
        }
        const right = tokens[i + 1];
        const nullCoalescenceGroup = new NullCoalescenceGroup();
        nullCoalescenceGroup.left = left;
        nullCoalescenceGroup.right = right;
        newTokens.push(nullCoalescenceGroup);
        i += 1;
        continue;
      } else {
        newTokens.push(node);
      }
    }
    return newTokens;
  }
  isOperand(token) {
    return token instanceof VariableNode || token instanceof LogicGroup || token instanceof StringValueNode || token instanceof NumberNode || token instanceof FalseConstant || token instanceof NullConstant || token instanceof TrueConstant || token instanceof LibraryInvocationConstruct || token instanceof DirectionGroup || token instanceof ListValueNode || token instanceof SwitchGroup || token instanceof ArrayNode;
  }
  isProperMethodChainTargetStrict(token) {
    return token instanceof LogicGroup || token instanceof StringValueNode || token instanceof NumberNode || token instanceof FalseConstant || token instanceof NullConstant || token instanceof TrueConstant || token instanceof LibraryInvocationConstruct || token instanceof DirectionGroup || token instanceof ListValueNode || token instanceof SwitchGroup || token instanceof ArrayNode;
  }
  assertOperandRight(tokens, i) {
    if (i + 1 > tokens.length - 1) {
      tokens[i].pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, tokens[i], "Unexpected end of input; expecting operand for operator " + TypeLabeler.getPrettyTypeName(tokens[i]) + ' near "' + LineRetriever.getNearText(tokens[i]) + '".'));
      return false;
    }
    const token = tokens[i + 1];
    if (!this.isOperand(token)) {
      token.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_EXPECTING_OPERAND, tokens[i], "Expecting operand, found " + TypeLabeler.getPrettyTypeName(token) + ' near "' + LineRetriever.getNearText(tokens[i]) + '".'));
      return false;
    }
    return true;
  }
  resolveValueRight(nodes, index) {
    let value = null, negationCount = 0, lastNegation = null;
    if (nodes.length > 0) {
      let doContinue = true;
      while (doContinue) {
        const curNode = nodes[index];
        if (curNode instanceof LogicalNegationOperator) {
          lastNegation = curNode;
          negationCount += 1;
          index += 1;
          doContinue = false;
          continue;
        } else if (this.isOperand(curNode)) {
          value = curNode;
          doContinue = false;
          break;
        } else {
          doContinue = false;
          break;
        }
      }
    }
    if (negationCount % 2 != 0) {
      const logicGroup = new LogicGroup();
      logicGroup.nodes = [];
      if (lastNegation != null && value != null) {
        logicGroup.nodes.push(lastNegation);
        logicGroup.nodes.push(value);
      }
      return {
        value: logicGroup,
        negationCount
      };
    }
    return {
      value,
      negationCount
    };
  }
  correctTypes(tokens) {
    const newNodes = [];
    tokens.forEach((node) => {
      if (node instanceof ModifierValueSeparator) {
        const branchSeparator = new InlineBranchSeparator();
        branchSeparator.startPosition = node.startPosition;
        branchSeparator.endPosition = node.endPosition;
        branchSeparator.originalAbstractNode = node;
        newNodes.push(branchSeparator);
      } else if (node instanceof ModifierValueNode) {
        const varNode = new VariableNode();
        varNode.name = node.value;
        varNode.startPosition = node.startPosition;
        varNode.endPosition = node.endPosition;
        varNode.modifierChain = node.modifierChain;
        varNode.originalAbstractNode = node;
        newNodes.push(varNode);
      } else {
        newNodes.push(node);
      }
    });
    return newNodes;
  }
  createTernaryGroups(tokens) {
    var _a, _b, _c;
    let newTokens = [];
    const tokenCount = tokens.length;
    for (let i = 0; i < tokenCount; i++) {
      const node = tokens[i];
      if (node instanceof InlineTernarySeparator) {
        const separator = this.seek(InlineBranchSeparator, i + 1);
        if (separator.found == false) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_TERNARY_EXPECTING_BRANCH_SEPARATOR, node, "Unexpected end of input; expecting [T_BRANCH_SEPARATOR]."));
          continue;
        }
        const result = this.collectUntil(newTokens);
        newTokens = result.tokens;
        const condition = result.collectedTokens[0];
        const targetTokenIndex = (_a = separator.foundAt) != null ? _a : 0;
        if (targetTokenIndex >= tokenCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP, node, "Unexpected end of input while parsing ternary group."));
          continue;
        }
        const truthBranch = tokens.slice(i + 1, targetTokenIndex);
        if (truthBranch.length > 1 || truthBranch.length == 0) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_TERNARY_UNEXPECTED_EXPRESSION_LENGTH, node, "Unexpected number of operations within ternary truth branch."));
          continue;
        }
        const truthBranchNodes = truthBranch[0];
        const falseBranchStart = ((_b = separator.foundAt) != null ? _b : 0) + 1;
        if (falseBranchStart >= tokenCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_TERNARY_GROUP_FALSE_BRANCH, node, "Unexpected end of input while parsing ternary false execution branch."));
          continue;
        }
        const falseBranch = tokens[falseBranchStart];
        const ternaryStructure = new TernaryCondition();
        ternaryStructure.head = condition;
        ternaryStructure.truthBranch = truthBranchNodes;
        ternaryStructure.falseBranch = falseBranch;
        newTokens.push(ternaryStructure);
        const targetJumpIndex = ((_c = separator.foundAt) != null ? _c : 0) + 1;
        i = targetJumpIndex;
        continue;
      } else {
        newTokens.push(node);
      }
    }
    return newTokens;
  }
  groupNodesByType(nodes, type2) {
    const newNodes = [], nodeCount = nodes.length;
    for (let i = 0; i < nodeCount; i++) {
      const node = nodes[i];
      if (i > 0 && node instanceof type2) {
        const left = [];
        const poppedLeft = newNodes.pop();
        left.push(poppedLeft);
        if (!this.assertOperandRight(nodes, i)) {
          continue;
        }
        if (i + 1 >= nodeCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_REDUCING_NEGATION_OPERATORS, node, "Unexpected end of input while parsing input text."));
          continue;
        }
        const right = nodes[i + 1];
        right.isVirtualGroupMember = true;
        poppedLeft.isVirtualGroupMember = true;
        node.isVirtualGroupMember = true;
        const logicGroup = new LogicGroup();
        logicGroup.nodes = left;
        logicGroup.nodes.push(node);
        logicGroup.nodes.push(right);
        i += 1;
        newNodes.push(logicGroup);
        continue;
      } else {
        newNodes.push(node);
      }
    }
    return newNodes;
  }
  flagNodeAsOperatorResolve(node) {
    if (node instanceof LogicGroup) {
      if (node.nodes.length == 0) {
        return;
      }
      this.flagNodeAsOperatorResolve(node.nodes[node.nodes.length - 1]);
    }
    node.isVirtualGroupOperatorResolve = true;
    if (node.next instanceof StatementSeparatorNode == false) {
      node.producesVirtualStatementTerminator = true;
    }
  }
  groupNodesByOperatorType(nodes) {
    const newNodes = [], nodeCount = nodes.length;
    for (let i = 0; i < nodeCount; i++) {
      const node = nodes[i];
      if (i > 0 && LanguageParser.isOperatorType(node)) {
        const left = [];
        const poppedLeft = newNodes.pop();
        left.push(poppedLeft);
        if (!this.assertOperandRight(nodes, i)) {
          continue;
        }
        if (i + 1 >= nodeCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_REDUCING_NEGATION_OPERATORS, node, "Unexpected end of input while parsing input text."));
          continue;
        }
        const right = nodes[i + 1];
        this.flagNodeAsOperatorResolve(right);
        poppedLeft.isVirtualGroupMember = true;
        right.isVirtualGroupMember = true;
        node.isVirtualGroupMember = true;
        const logicGroup = new LogicGroup();
        logicGroup.nodes = left;
        logicGroup.nodes.push(node);
        logicGroup.nodes.push(right);
        i += 1;
        newNodes.push(logicGroup);
        continue;
      } else {
        newNodes.push(node);
      }
    }
    return newNodes;
  }
  applyOperationOrder(nodes) {
    nodes = this.groupNodesByType(nodes, ExponentiationOperator);
    nodes = this.groupNodesByType(nodes, MultiplicationOperator);
    nodes = this.groupNodesByType(nodes, DivisionOperator);
    nodes = this.groupNodesByType(nodes, AdditionOperator);
    nodes = this.groupNodesByType(nodes, SubtractionOperator);
    return nodes;
  }
  createLogicGroupsToRemoveMethodInvocationAmbiguity(nodes) {
    const newNodes = [], nodeLen = nodes.length, lastNodeIndex = nodeLen - 1;
    for (let i = 0; i < nodeLen; i++) {
      const thisNode = nodes[i];
      if (thisNode instanceof MethodInvocationNode) {
        const lastNode = newNodes.pop();
        const wrapperGroup = new LogicGroup();
        wrapperGroup.startPosition = lastNode.startPosition;
        lastNode.isVirtualGroupMember = true;
        thisNode.isVirtualGroupMember = true;
        wrapperGroup.nodes.push(lastNode);
        wrapperGroup.nodes.push(thisNode);
        if (i != lastNodeIndex) {
          for (let j = i + 1; j < nodeLen; j++) {
            if (nodes[j] instanceof MethodInvocationNode) {
              nodes[j].isVirtualGroupMember = true;
              wrapperGroup.nodes.push(nodes[j]);
              if (j == lastNodeIndex) {
                j += 1;
                break;
              }
            } else {
              if (j == lastNodeIndex) {
                j += 1;
                break;
              }
              i = j - 1;
              break;
            }
          }
        }
        wrapperGroup.endPosition = wrapperGroup.nodes[wrapperGroup.nodes.length - 1].endPosition;
        newNodes.push(wrapperGroup);
      } else {
        newNodes.push(thisNode);
      }
    }
    return newNodes;
  }
  countTypeRight(tokens, start, type2) {
    let count = 0;
    for (let i = start; i < tokens.length; i++) {
      if (tokens[i] instanceof type2) {
        count += 1;
      } else {
        break;
      }
    }
    return count;
  }
  createLogicGroupsToResolveOperatorAmbiguity(nodes) {
    nodes = this.groupNodesByType(nodes, GreaterThanEqualCompOperator);
    nodes = this.groupNodesByType(nodes, GreaterThanCompOperator);
    nodes = this.groupNodesByType(nodes, LessThanEqualCompOperator);
    nodes = this.groupNodesByType(nodes, LessThanCompOperator);
    nodes = this.groupNodesByType(nodes, StrictEqualCompOperator);
    nodes = this.groupNodesByType(nodes, EqualCompOperator);
    nodes = this.groupNodesByType(nodes, NotStrictEqualCompOperator);
    nodes = this.groupNodesByType(nodes, NotEqualCompOperator);
    nodes = this.groupNodesByType(nodes, SpaceshipCompOperator);
    nodes = this.groupNodesByOperatorType(nodes);
    return nodes;
  }
  createModifier(tokens) {
    const modifierName = tokens.shift(), values = [], tokenCount = tokens.length;
    if (tokens.length > 0 && tokens[0] instanceof LogicGroup) {
      const unwrapped = this.unpack(tokens[0].nodes), tArgGroup = this.makeArgGroup(unwrapped);
      const modifier = new ModifierNode();
      modifier.nameNode = modifierName;
      modifier.methodStyleArguments = tArgGroup;
      if (tokens.length > 1) {
        for (let i = 1; i < tokenCount; i++) {
          tokens[i].pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_TOKEN_METHOD_SYNTAX, tokens[i], "Unexpected [" + TypeLabeler.getPrettyTypeName(tokens[i]) + "] while parsing modifier argument group. Expecting [T_MODIFIER_SEPARATOR] or end of current expression."));
        }
      }
      return modifier;
    }
    for (let i = 0; i < tokenCount; i++) {
      if (tokens[i] instanceof ModifierValueSeparator || tokens[i] instanceof InlineBranchSeparator) {
        if (i + 1 >= tokenCount) {
          tokens[i].pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_END_OF_VALUE_LIST, tokens[i], "Unexpected end of modifier value list while parsing modifier."));
          return tokens;
        }
        const next = tokens[i + 1];
        if (this.isValidModifierValue(next)) {
          if (next instanceof VariableNode) {
            if (next.variableReference != null && next.variableReference.pathParts.length > 0) {
              next.variableReference.pathParts.forEach((combinedPart) => {
                if (combinedPart instanceof PathNode) {
                  const modifierValue = new ModifierValueNode();
                  modifierValue.startPosition = combinedPart.startPosition;
                  modifierValue.endPosition = combinedPart.endPosition;
                  modifierValue.value = combinedPart.name;
                  modifierValue.name = combinedPart.name;
                  modifierValue.originalAbstractNode = combinedPart;
                  if (modifierValue.endPosition == null && modifierValue.startPosition == null) {
                    modifierValue.startPosition = next.startPosition;
                    modifierValue.endPosition = next.endPosition;
                  }
                  values.push(modifierValue);
                }
              });
            } else {
              const modifierValue = new ModifierValueNode();
              modifierValue.startPosition = next.startPosition;
              modifierValue.endPosition = next.endPosition;
              modifierValue.value = next.name;
              modifierValue.name = next.name;
              modifierValue.originalAbstractNode = next;
              values.push(modifierValue);
            }
          } else {
            values.push(next);
          }
          i += 1;
          continue;
        } else {
          next.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_MODIFIER_UNEXPECTED_VALUE, next, "Unexpected [" + TypeLabeler.getPrettyTypeName(next) + "] while parsing modifier value."));
          return tokens;
        }
      }
    }
    const modifierNode = new ModifierNode();
    modifierNode.nameNode = modifierName;
    modifierNode.valueNodes = values;
    modifierNode.startPosition = modifierNode.nameNode.startPosition;
    if (modifierNode.valueNodes.length > 0) {
      modifierNode.endPosition = modifierNode.valueNodes[modifierNode.valueNodes.length - 1].endPosition;
    } else {
      modifierNode.endPosition = modifierNode.nameNode.endPosition;
    }
    return modifierNode;
  }
  scanToEndOfModifier(tokens) {
    const subTokens = [], tokenCount = tokens.length;
    for (let i = 0; i < tokenCount; i++) {
      const subToken = tokens[i];
      if (subToken instanceof ModifierValueSeparator) {
        const subTokenCount = subTokens.length;
        if (subTokenCount == 0) {
          subToken.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_MODIFIER_VALUE, subToken, "Unexpected end of input while parsing modifier value."));
          continue;
        }
        this.isRealModifierSeparator.set(subToken, true);
        const last = subTokens[subTokenCount - 1];
        if (NodeHelpers.distance(last, subToken) > 1) {
          break;
        }
      }
      if (subToken instanceof ModifierSeparator || subToken instanceof LogicGroupEnd || subToken instanceof LogicGroupBegin || subToken instanceof EqualCompOperator || subToken instanceof GreaterThanCompOperator || subToken instanceof GreaterThanEqualCompOperator || subToken instanceof LessThanCompOperator || subToken instanceof LessThanEqualCompOperator || subToken instanceof NotEqualCompOperator || subToken instanceof NotStrictEqualCompOperator || subToken instanceof SpaceshipCompOperator || subToken instanceof StrictEqualCompOperator || subToken instanceof LogicalAndOperator || subToken instanceof LogicalOrOperator || subToken instanceof LogicalXorOperator || subToken instanceof NullCoalesceOperator || subToken instanceof StringConcatenationOperator || subToken instanceof LanguageOperatorConstruct || subToken instanceof LibraryInvocationConstruct || subToken instanceof MethodInvocationNode || subToken instanceof LogicalNegationOperator) {
        break;
      } else {
        subTokens.push(subToken);
      }
    }
    return subTokens;
  }
  static isAssignmentOperatorNode(node) {
    return node instanceof AdditionAssignmentOperator || node instanceof DivisionAssignmentOperator || node instanceof LeftAssignmentOperator || node instanceof ModulusAssignmentOperator || node instanceof MultiplicationAssignmentOperator || node instanceof SubtractionOperator;
  }
  insertAutomaticStatementSeparators(tokens) {
    const tokenCount = tokens.length, adjustedTokens = [];
    for (let i = 0; i < tokenCount; i++) {
      const thisToken = tokens[i];
      if (LanguageParser.isAssignmentOperatorNode(thisToken)) {
        if (i + 2 < tokenCount) {
          const peek = tokens[i + 2];
          if (peek instanceof StatementSeparatorNode == false) {
            adjustedTokens.push(thisToken);
            adjustedTokens.push(tokens[i + 1]);
            adjustedTokens.push(new StatementSeparatorNode());
            i += 1;
            continue;
          } else {
            adjustedTokens.push(thisToken);
            adjustedTokens.push(tokens[i + 1]);
            adjustedTokens.push(tokens[i + 2]);
            i += 2;
            continue;
          }
        } else {
          adjustedTokens.push(thisToken);
          adjustedTokens.push(tokens[i + 1]);
          adjustedTokens.push(new StatementSeparatorNode());
          break;
        }
      } else {
        adjustedTokens.push(thisToken);
      }
    }
    return tokens;
  }
  createSemanticGroups(tokens) {
    const groups = [], tokenCount = tokens.length;
    let groupNodes = [];
    for (let i = 0; i < tokenCount; i++) {
      if (tokens[i] instanceof StatementSeparatorNode) {
        const semanticGroup = new SemanticGroup();
        semanticGroup.nodes = groupNodes;
        semanticGroup.separatorToken = tokens[i];
        groups.push(semanticGroup);
        groupNodes = [];
        continue;
      } else {
        groupNodes.push(tokens[i]);
        if (i + 1 >= tokenCount) {
          const semanticGroup = new SemanticGroup();
          semanticGroup.nodes = groupNodes;
          groups.push(semanticGroup);
          break;
        }
      }
    }
    return groups;
  }
  findLogicalGroupEnd(root, nodes) {
    const subNodes = [], nodeCount = nodes.length;
    let end = null, skipCount = 0, i = 0;
    for (i; i < nodeCount; i++) {
      const node = nodes[i];
      skipCount += 1;
      if (node instanceof LogicGroupEnd) {
        end = node;
        break;
      } else if (node instanceof LogicGroupBegin) {
        if (i + 1 >= nodeCount) {
          node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_PARSING_LOGIC_GROUP_END, node, "Unexpected end of input while parsing input text."));
          return {
            found: false,
            logicalGroup: null,
            skipCount
          };
        }
        const subGroup = this.findLogicalGroupEnd(node, nodes.slice(i + 1));
        if (subGroup.found) {
          if (subGroup.logicalGroup != null) {
            subNodes.push(subGroup.logicalGroup);
          }
          skipCount += subGroup.skipCount;
          i += subGroup.skipCount;
          continue;
        } else {
          continue;
        }
      } else {
        subNodes.push(node);
      }
    }
    if (end == null) {
      root.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_LOGIC_GROUP_NO_END, root, "Unexpected end of input while parsing logic group."));
      return {
        found: false,
        logicalGroup: null,
        skipCount
      };
    }
    const parser = new LanguageParser();
    parser.setIsRoot(false);
    let logicalGroup = new LogicGroup();
    if (subNodes.length >= 2 && subNodes[1] instanceof ScopeAssignmentOperator) {
      logicalGroup = new ScopedLogicGroup();
      logicalGroup.scopeOperator = subNodes[1];
      if (i + 2 < nodeCount && nodes[i + 1] instanceof VariableNode && nodes[i + 2] instanceof StringValueNode) {
        const candidateVarNode = nodes[i + 1];
        if (candidateVarNode.name == LanguageKeywords.ScopeAs) {
          const aliasNode = nodes[i + 2];
          logicalGroup = new AliasedScopeLogicGroup();
          if (logicalGroup instanceof AliasedScopeLogicGroup) {
            logicalGroup.alias = aliasNode;
          }
          skipCount += 2;
        }
      }
      const scopedNodes = subNodes.splice(0, 2);
      if (logicalGroup instanceof ScopedLogicGroup || logicalGroup instanceof AliasedScopeLogicGroup) {
        logicalGroup.scope = scopedNodes[0];
      }
    }
    logicalGroup.nodes = parser.parse(subNodes);
    logicalGroup.start = root;
    logicalGroup.end = end;
    logicalGroup.startPosition = root.startPosition;
    logicalGroup.endPosition = end.endPosition;
    if (logicalGroup instanceof AliasedScopeLogicGroup) {
      if (logicalGroup.alias != null) {
        logicalGroup.endPosition = logicalGroup.alias.endPosition;
      }
    }
    return {
      found: true,
      logicalGroup,
      skipCount
    };
  }
  unpack(tokens) {
    if (tokens.length == 0) {
      return [];
    }
    if (tokens[0] instanceof SemanticGroup) {
      const wSg = tokens[0];
      return this.unpack(wSg.nodes);
    }
    return tokens;
  }
  collectUntil(tokens) {
    const len = tokens.length;
    let collectedTokens = [];
    for (let i = len - 1; i >= 0; i--) {
      if (LanguageParser.isAssignmentOperator(tokens[i])) {
        break;
      }
      const token = tokens.pop();
      collectedTokens.push(token);
    }
    collectedTokens = collectedTokens.reverse();
    if (collectedTokens.length >= 3) {
      const parser = new LanguageParser();
      parser.setIsRoot(false);
      return {
        collectedTokens: this.unpack(parser.parse(collectedTokens)),
        tokens
      };
    }
    return {
      collectedTokens,
      tokens
    };
  }
  seek(type2, startingAt) {
    for (let i = startingAt; i < this.tokens.length; i++) {
      if (this.tokens[i] instanceof type2) {
        return {
          found: true,
          foundAt: i,
          node: this.tokens[i]
        };
      }
    }
    return {
      found: false,
      foundAt: null,
      node: null
    };
  }
};

// server/src/runtime/document/scanners/wordScanner.ts
var WordScanner = class {
  static findRightBeighboringNextPunctuation(index, text, tabSize = 4) {
    text = text.replace("	", " ".repeat(tabSize));
    let okayToBreak = false;
    for (let i = index + 1; i < text.length; i++) {
      const cur = text[i];
      if (StringUtilities.ctypeSpace(cur)) {
        okayToBreak = true;
      }
      if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
        return null;
      }
      if (StringUtilities.ctypePunct(cur) || cur == DocumentParser.String_Terminator_SingleQuote || cur == DocumentParser.String_Terminator_DoubleQuote) {
        return cur;
      }
    }
    return null;
  }
  static findRightNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
    text = text.replace("	", " ".repeat(tabSize));
    let okayToBreak = false;
    for (let i = index + 1; i < text.length; i++) {
      const cur = text[i];
      if (StringUtilities.ctypeSpace(cur) || StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore) {
        okayToBreak = true;
      }
      if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
        return i + 1;
      }
    }
    return null;
  }
  static findLeftNeighboringNextPunctuation(index, text, tabSize = 4) {
    text = text.replace("	", " ".repeat(tabSize));
    let okayToBreak = false;
    for (let i = index - 2; i >= 0; i--) {
      const cur = text[i];
      if (StringUtilities.ctypeSpace(cur)) {
        okayToBreak = true;
      }
      if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
        return null;
      }
      if (StringUtilities.ctypePunct(cur)) {
        return cur;
      }
    }
    return null;
  }
  static findLeftNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
    text = text.replace("	", " ".repeat(tabSize));
    let okayToBreak = false;
    for (let i = index - 1; i >= 0; i--) {
      const cur = text[i];
      if (StringUtilities.ctypeSpace(cur) || StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore) {
        okayToBreak = true;
      }
      if (okayToBreak && (StringUtilities.ctypeAlpha(cur) || StringUtilities.ctypeDigit(cur))) {
        return i + 1;
      }
    }
    return null;
  }
  static scanWordAt(index, text, tabSize = 4) {
    text = text.replace("	", " ".repeat(tabSize));
    if (index < 0 || index > text.length) {
      return null;
    }
    const leftChars = [], rightChars = [];
    for (let i = index - 1; i >= 0; i--) {
      const cur = text[i];
      if (StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore || StringUtilities.ctypeSpace(cur)) {
        break;
      }
      leftChars.push(cur);
    }
    for (let i = index; i < text.length; i++) {
      const cur = text[i];
      if (StringUtilities.ctypePunct(cur) && cur != DocumentParser.Punctuation_Underscore || StringUtilities.ctypeSpace(cur)) {
        break;
      }
      rightChars.push(cur);
    }
    return leftChars.reverse().join("") + rightChars.join("");
  }
};

// server/src/runtime/parser/virtualDocument/virtualHierarchy.ts
var VirtualHierarchy = class {
  constructor(parser) {
    this.parser = parser;
  }
  findParentWithName(name, anchor) {
    let currentParent = anchor.parent;
    while (currentParent != null) {
      if (currentParent instanceof AntlersNode && currentParent.nameMatches(name)) {
        return currentParent;
      }
      if (currentParent.parent == currentParent) {
        break;
      }
      currentParent = currentParent.parent;
    }
    return null;
  }
};

// server/src/runtime/analyzers/modifierAnalyzer.ts
var ModifierAnalyzer = class {
  static analyzeModifierNodeParameters(node) {
    var _a, _b, _c, _d;
    if (!node.hasParameters) {
      return;
    }
    node.parameters.forEach((parameter) => {
      var _a2, _b2, _c2, _d2;
      parameter.isModifierParameter = (_b2 = (_a2 = modifierManager_default.instance) == null ? void 0 : _a2.hasModifier(parameter.name)) != null ? _b2 : false;
      if (parameter.isModifierParameter) {
        node.modifiers.parameterModifiers.push(parameter);
        parameter.modifier = (_d2 = (_c2 = modifierManager_default.instance) == null ? void 0 : _c2.getModifier(parameter.name)) != null ? _d2 : null;
        if (node.modifiers.modifierNames.includes(parameter.name) == false) {
          node.modifiers.modifierNames.push(parameter.name);
        }
      }
    });
    if (node.modifierChain != null && node.modifierChain.modifierChain.length > 0) {
      let lastModifier = null;
      node.modifierChain.modifierChain.forEach((modifier) => {
        var _a2, _b2;
        if (modifier.nameNode != null) {
          modifier.modifier = (_b2 = (_a2 = modifierManager_default.instance) == null ? void 0 : _a2.getModifier(modifier.nameNode.content)) != null ? _b2 : null;
          if (node.modifiers.modifierNames.includes(modifier.nameNode.content) == false) {
            node.modifiers.modifierNames.push(modifier.nameNode.content);
          }
          if (modifier.modifier != null) {
            lastModifier = modifier.modifier;
            if (node.modifierChain != null) {
              node.modifierChain.lastManifestedModifier = modifier;
            }
          }
        }
      });
      node.modifierChain.lastModifier = lastModifier;
      if (node.modifiers.parameterModifiers.length > 0) {
        node.modifiers.hasMixedModifierStyles = true;
      }
    }
    const lastManifestModifier = node.modifiers.getLastManifestedModifier();
    if (lastManifestModifier != null) {
      if (lastManifestModifier.name == "macro") {
        const macroName = node.modifiers.getLastManifestedModifierValue();
        node.manifestType = (_b = (_a = modifierManager_default.instance) == null ? void 0 : _a.getMacroManifestingType(macroName)) != null ? _b : "";
      } else {
        node.manifestType = (_d = (_c = modifierManager_default.instance) == null ? void 0 : _c.getProbableReturnType(lastManifestModifier, node.isPaired())) != null ? _d : "";
      }
    }
  }
};

// server/src/featureConfiguration.ts
var GlobalFeatureConfiguration = {
  warnUnknownParameters: false
};

// server/src/runtime/analyzers/parameterValidator.ts
var ParameterValidator = class {
  static validateInteger(string) {
    if (parseInt(string).toString() !== string) {
      return {
        isValid: false,
        message: '"' + string + '" is not a valid integer.'
      };
    }
    return {
      isValid: true,
      message: ""
    };
  }
  static validateBoolean(string) {
    if (string == "true" || string == "false") {
      return {
        isValid: true,
        message: ""
      };
    }
    return {
      isValid: false,
      message: '"' + string + '" is not a valid value. Expecting true/false.'
    };
  }
  static validateParameters(node) {
    var _a, _b, _c, _d, _e;
    if (node.isTagNode && ((_a = tagManagerInstance_default.instance) == null ? void 0 : _a.isKnownTag(node.runtimeName()))) {
      const tagReference = (_b = tagManagerInstance_default.instance) == null ? void 0 : _b.findTag(node.runtimeName());
      if (node.hasParameters) {
        for (let p = 0; p < node.parameters.length; p++) {
          const paramToAnalyze = node.parameters[p];
          let registeredParam = null, attemptedToResolve = false, paramName = paramToAnalyze.name.trim();
          paramName = trimLeft(paramName, ":");
          if (((_c = tagManagerInstance_default.instance) == null ? void 0 : _c.canResolveDynamicParameter(node.runtimeName())) && typeof tagReference.resolveDynamicParameter !== "undefined" && tagReference.resolveDynamicParameter != null) {
            registeredParam = tagReference.resolveDynamicParameter(node, paramName);
            attemptedToResolve = true;
          } else {
            registeredParam = (_d = tagManagerInstance_default.instance) == null ? void 0 : _d.getParameter(node.runtimeName(), paramName);
          }
          if (attemptedToResolve && registeredParam == null) {
            registeredParam = (_e = tagManagerInstance_default.instance) == null ? void 0 : _e.getParameter(node.runtimeName(), paramName);
          }
          if (registeredParam == null) {
            if (GlobalFeatureConfiguration.warnUnknownParameters) {
              let suggestionSuffix = "";
              if (tagReference.suggestAlternativeParams != null) {
                const alternatives = tagReference.suggestAlternativeParams(paramName);
                if (alternatives.length == 1) {
                  suggestionSuffix = '. Did you mean "' + alternatives[0] + '"?';
                } else if (alternatives.length > 1) {
                  suggestionSuffix = ". Try one of the following: " + alternatives.join(", ");
                }
              }
              const errorMessage = 'Unknown parameter name: "' + paramName + '"' + suggestionSuffix;
              node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.LINT_UNKNOWN_PARAMETER, node, errorMessage, 1 /* Warning */));
            }
          } else {
            if (registeredParam.validate != null) {
              const paramResults = registeredParam.validate(node, paramToAnalyze);
              if (paramResults.length > 0) {
                paramResults.forEach((error) => {
                  node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.LINT_GENERAL_INVALID_PARAMETER_CONTENTS, paramToAnalyze, error.message, 1 /* Warning */));
                });
              }
            } else {
              if (paramToAnalyze.hasInterpolations()) {
                continue;
              }
              for (let q = 0; q < registeredParam.expectsTypes.length; q++) {
                const curTypeToCheck = registeredParam.expectsTypes[q];
                if (curTypeToCheck == "integer") {
                  const result = this.validateInteger(paramToAnalyze.value);
                  if (!result.isValid) {
                    node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.LINT_PARAMETER_CONTENT_INVALID_INTEGER, paramToAnalyze, result.message, 1 /* Warning */));
                  }
                } else if (curTypeToCheck == "boolean") {
                  const result = this.validateBoolean(paramToAnalyze.value);
                  if (registeredParam.name == "paginate") {
                    if (paramToAnalyze.value == "true" || paramToAnalyze.value == "false") {
                      continue;
                    } else {
                      if (parseInt(paramToAnalyze.value).toString() != paramToAnalyze.value) {
                        const message = 'Unexpected "' + paramToAnalyze.value + '". Expecting a numeric value, or true/false.';
                        node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.LINT_PAGINATE_INVALID_VALUE, paramToAnalyze, message, 0 /* Error */));
                      }
                    }
                  } else {
                    if (!result.isValid) {
                      node.pushError(AntlersError.makeSyntaxError(AntlersErrorCodes.LINT_PARAMETER_CONTENT_INVALID_BOOLEAN, paramToAnalyze, result.message, 1 /* Warning */));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

// server/src/runtime/parser/documentParser.ts
var _DocumentParser = class {
  constructor() {
    this.interpolationRegions = /* @__PURE__ */ new Map();
    this.nodeParser = new AntlersNodeParser();
    this.chars = [];
    this.charLen = 0;
    this.lastAntlersNode = null;
    this.content = "";
    this.originalContent = "";
    this.currentIndex = 0;
    this.currentContent = [];
    this.sourceContent = [];
    this.startIndex = 0;
    this._recoveryStartIndex = 0;
    this.cur = null;
    this.next = null;
    this.prev = null;
    this.nodes = [];
    this.renderNodes = [];
    this.isInterpolatedParser = false;
    this.inputLen = 0;
    this.documentOffsets = /* @__PURE__ */ new Map();
    this.lineIndex = /* @__PURE__ */ new Map();
    this.lastDocumentOffsetKey = null;
    this.isDoubleBrace = false;
    this.interpolationEndOffsets = /* @__PURE__ */ new Map();
    this.isScanningInterpolations = false;
    this.seedStartLine = 1;
    this.seedStartchar = 1;
    this.frontMatterEndLine = -1;
    this.lastAntlersEndIndex = -1;
    this.seedOffset = 0;
    this.antlersStartIndex = [];
    this.antlersStartPositionIndex = /* @__PURE__ */ new Map();
    this.chunkSize = 5;
    this.maxLine = 1;
    this.currentChunkOffset = 0;
    this.antlersErrors = [];
    this.languageParser = new LanguageParser();
    this.documentPath = null;
    this.pushedErrors = /* @__PURE__ */ new Map();
    this.frontMatter = "";
    this.doesHaveUncloseIfStructures = false;
    this.structure = new VirtualHierarchy(this);
  }
  hasUnclosedIfStructures() {
    return this.doesHaveUncloseIfStructures;
  }
  getFrontMatter() {
    return this.frontMatter;
  }
  setDocumentPath(path) {
    this.documentPath = path;
  }
  getFrontMatterEndLine() {
    return this.frontMatterEndLine;
  }
  pushError(error) {
    if (error.errorCode == AntlersErrorCodes.TYPE_PARSE_UNCLOSED_CONDITIONAL || error.errorCode == AntlersErrorCodes.TYPE_PARSE_UNPAIRED_CONDITIONAL) {
      this.doesHaveUncloseIfStructures = true;
    }
    const errorHash = error.hash();
    if (!this.pushedErrors.has(errorHash)) {
      this.pushedErrors.set(errorHash, error);
      this.antlersErrors.push(error);
    }
  }
  getInterpolationRegions() {
    return this.interpolationRegions;
  }
  getDocumentPath() {
    return this.documentPath;
  }
  checkCurrentOffsets() {
    this.cur = this.chars[this.currentIndex];
    this.prev = null;
    this.next = null;
    if (this.currentIndex > 0) {
      this.prev = this.chars[this.currentIndex - 1];
    }
    if (this.currentIndex + 1 < this.inputLen) {
      let doPeek = true;
      if (this.currentIndex == this.charLen - 1) {
        const nextChunk = StringUtilities.split(StringUtilities.substring(this.content, this.currentChunkOffset + this.chunkSize, this.chunkSize));
        this.currentChunkOffset += this.chunkSize;
        if (this.currentChunkOffset == this.inputLen) {
          doPeek = false;
        }
        nextChunk.forEach((nextChar) => {
          this.chars.push(nextChar);
          this.charLen += 1;
        });
      }
      if (doPeek) {
        this.next = this.chars[this.currentIndex + 1];
      }
    }
  }
  charLeftAt(position) {
    if (position == null) {
      return null;
    }
    if (position.char <= 1) {
      return null;
    }
    return this.charAt(this.positionFromCursor(position.line, position.char - 1));
  }
  charLeftAtCursor(line, char) {
    return this.charLeftAt(this.positionFromCursor(line, char));
  }
  charRightAt(position) {
    if (position == null) {
      return null;
    }
    return this.charAt(this.positionFromCursor(position.line, position.char + 1));
  }
  charRightAtCursor(line, char) {
    return this.charRightAt(this.positionFromCursor(line, char));
  }
  punctuationLeftAt(position, tabSize = 4) {
    if (position == null) {
      return null;
    }
    const lineText = this.getLineText(position.line);
    if (lineText == null) {
      return null;
    }
    return WordScanner.findLeftNeighboringNextPunctuation(position.char, lineText, tabSize);
  }
  punctuationLeftAtCursor(line, char, tabSize = 4) {
    return this.punctuationLeftAt(this.positionFromCursor(line, char), tabSize);
  }
  punctuationRightAt(position, tabSize = 4) {
    if (position == null) {
      return null;
    }
    const lineText = this.getLineText(position.line);
    if (lineText == null) {
      return null;
    }
    return WordScanner.findRightBeighboringNextPunctuation(position.char, lineText, tabSize);
  }
  punctuationRightAtCursor(line, char, tabSize = 4) {
    return this.punctuationRightAt(this.positionFromCursor(line, char), tabSize);
  }
  wordRightAt(position, tabSize = 4) {
    if (position == null) {
      return null;
    }
    const lineText = this.getLineText(position.line);
    if (lineText == null) {
      return null;
    }
    const rightWordChar = WordScanner.findRightNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
    if (rightWordChar == null) {
      return null;
    }
    return WordScanner.scanWordAt(rightWordChar, lineText, tabSize);
  }
  wordRightAtCursor(line, char, tabSize = 4) {
    return this.wordRightAt(this.positionFromCursor(line, char), tabSize);
  }
  wordLeftAt(position, tabSize = 4) {
    if (position == null) {
      return null;
    }
    const lineText = this.getLineText(position.line);
    if (lineText == null) {
      return null;
    }
    const leftWordChar = WordScanner.findLeftNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
    if (leftWordChar == null) {
      return null;
    }
    return WordScanner.scanWordAt(leftWordChar, lineText, tabSize);
  }
  wordLeftAtCursor(line, char, tabSize = 4) {
    return this.wordLeftAt(this.positionFromCursor(line, char), tabSize);
  }
  wordAt(position, tabSize = 4) {
    if (position == null) {
      return null;
    }
    const lineText = this.getLineText(position.line);
    if (lineText == null) {
      return null;
    }
    return WordScanner.scanWordAt(position.char, lineText, tabSize);
  }
  getLineText(lineNumber) {
    const index = this.getLineIndex(lineNumber);
    if (index != null) {
      return StringUtilities.trimRight(this.getContent().substring(index.start, index.end + 1));
    }
    return null;
  }
  wordAtCursor(line, char, tabSize = 4) {
    return this.wordAt(this.positionFromCursor(line, char), tabSize);
  }
  charAt(position) {
    if (position == null) {
      return null;
    }
    return this.content.substr(position.offset, 1);
  }
  charAtCursor(line, char) {
    return this.charAt(this.positionFromCursor(line, char));
  }
  getLineIndex(line) {
    if (line == this.maxLine) {
      const lastIndex = this.lineIndex.get(line - 1);
      if (lastIndex != null) {
        const startIndex = lastIndex.endIndex + 1, endIndex = this.inputLen - 1;
        return {
          end: endIndex,
          start: startIndex
        };
      }
      return null;
    }
    const indexEntry = this.lineIndex.get(line);
    if (indexEntry != null) {
      return {
        start: indexEntry.startIndex,
        end: indexEntry.endIndex
      };
    }
    return null;
  }
  positionFromCursor(line, char) {
    if (line == this.maxLine) {
      const lastIndex = this.lineIndex.get(line - 1);
      if (lastIndex != null) {
        const startIndex = lastIndex.endIndex + 1, thisOffset = startIndex + (char - 1);
        const position = new Position();
        position.offset = thisOffset;
        position.line = line;
        position.char = char;
        position.index = thisOffset;
        return position;
      }
      return null;
    }
    const indexEntry = this.lineIndex.get(line);
    if (indexEntry != null) {
      const position = new Position();
      position.offset = indexEntry.startIndex + (char - 1);
      position.line = indexEntry.line;
      position.char = char;
      position.index = indexEntry.startIndex + (char - 1);
      return position;
    }
    return null;
  }
  parse(text) {
    var _a, _b, _c, _d;
    this.resetState();
    if (!this.processInputText(text)) {
      return [];
    }
    const indexCount = this.antlersStartIndex.length;
    const lastIndex = indexCount - 1;
    if (indexCount == 0) {
      const fullDocumentLiteral = new LiteralNode();
      fullDocumentLiteral.withParser(this);
      fullDocumentLiteral.content = this.prepareLiteralContent(this.content);
      fullDocumentLiteral.startPosition = this.positionFromOffset(0, 0);
      fullDocumentLiteral.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
      this.nodes.push(fullDocumentLiteral);
    } else {
      for (let i = 0; i < indexCount; i += 1) {
        const offset = this.antlersStartIndex[i];
        this.seedOffset = offset;
        if (i == 0 && offset > 0) {
          const node = new LiteralNode();
          node.withParser(this);
          node.content = this.prepareLiteralContent(this.content.substr(0, offset));
          if (node.content.length > 0) {
            node.startPosition = this.positionFromOffset(0, 0);
            node.endPosition = this.positionFromOffset(offset, offset - 1);
            this.nodes.push(node);
          }
        }
        if (offset < this.lastAntlersEndIndex) {
          continue;
        }
        this.currentChunkOffset = offset;
        this.resetIntermediateState();
        this.parseIntermediateText();
        if (this.lastAntlersNode != null && this.lastAntlersNode instanceof PhpExecutionNode == false && (this.lastAntlersNode.isComment && !(this.lastAntlersNode instanceof CommentParserFailNode))) {
          if (i + 1 < indexCount) {
            const nextAntlersStart = this.antlersStartPositionIndex.get(i + 1);
            if (this.lastAntlersNode.endPosition != null) {
              if (nextAntlersStart < this.lastAntlersNode.endPosition.offset) {
                let skipIndex = null;
                for (let j = i + 1; j < indexCount; j++) {
                  if (this.antlersStartIndex[j] > this.lastAntlersNode.endPosition.offset) {
                    skipIndex = j;
                    break;
                  }
                }
                if (skipIndex == null) {
                  const nodeContent = this.prepareLiteralContent(this.content.substr(this.lastAntlersNode.endPosition.offset + 1));
                  if (nodeContent.length > 0) {
                    const literalNode = new LiteralNode();
                    literalNode.withParser(this);
                    literalNode.content = nodeContent;
                    const literalStartOffset = this.lastAntlersNode.endPosition.offset + 1;
                    literalNode.startPosition = this.positionFromOffset(literalStartOffset, literalStartOffset);
                    literalNode.endPosition = this.positionFromOffset(this.inputLen, this.inputLen);
                    this.nodes.push(literalNode);
                  }
                  break;
                } else {
                  const nextStart = this.antlersStartIndex[skipIndex], spanLen = nextStart - this.lastAntlersNode.endPosition.offset - 1;
                  if (spanLen > 0) {
                    let spanStart = this.lastAntlersNode.endPosition.offset, spanEnd = nextStart - 1;
                    spanStart += 1;
                    spanEnd -= 1;
                    const nodeContent = this.content.substr(spanStart, spanLen);
                    if (nodeContent.length > 0) {
                      const literalNode = new LiteralNode();
                      literalNode.withParser(this);
                      literalNode.content = nodeContent;
                      literalNode.startPosition = this.positionFromOffset(spanStart, spanStart);
                      literalNode.endPosition = this.positionFromOffset(spanEnd, spanEnd);
                      this.nodes.push(literalNode);
                    }
                    continue;
                  }
                  i = skipIndex - 1;
                  continue;
                }
              }
            }
          }
        }
        let shouldProduceLiteralNode = false;
        if (!this.antlersStartPositionIndex.has(this.currentChunkOffset)) {
          shouldProduceLiteralNode = true;
        } else if (this.lastAntlersEndIndex < this.currentChunkOffset) {
          shouldProduceLiteralNode = true;
        }
        if (shouldProduceLiteralNode) {
          if (i + 1 < indexCount) {
            let nextAntlersStart = this.antlersStartIndex[i + 1];
            let literalStartIndex = this.lastAntlersEndIndex + 1;
            if (nextAntlersStart < literalStartIndex) {
              if (this.lastAntlersEndIndex > nextAntlersStart) {
                if (i + 2 < indexCount) {
                  nextAntlersStart = this.antlersStartIndex[i + 2];
                }
              } else {
                continue;
              }
            }
            if (i + 1 == lastIndex && nextAntlersStart <= this.lastAntlersEndIndex) {
              const thisOffset = this.currentChunkOffset, nodeContent = this.content.substr(literalStartIndex);
              const literalNode = new LiteralNode();
              literalNode.withParser(this);
              literalNode.content = this.prepareLiteralContent(nodeContent);
              if (literalNode.content.length > 0) {
                literalNode.startPosition = this.positionFromOffset(thisOffset, thisOffset);
                literalNode.endPosition = this.positionFromOffset(nextAntlersStart, nextAntlersStart - 1);
                this.nodes.push(literalNode);
              }
              break;
            } else {
              let literalLength = nextAntlersStart - this.lastAntlersEndIndex - 1;
              if (literalLength == 0) {
                continue;
              }
              const thisOffset = this.currentChunkOffset;
              let literalOffset = thisOffset;
              if (this.lastAntlersNode instanceof CommentParserFailNode) {
                literalStartIndex = ((_b = (_a = this.lastAntlersNode.endPosition) == null ? void 0 : _a.offset) != null ? _b : 0) + 1;
                literalLength -= ((_d = (_c = this.lastAntlersNode.endPosition) == null ? void 0 : _c.offset) != null ? _d : 0) + 1;
                literalOffset = literalStartIndex;
              }
              const nodeContent = this.content.substr(literalStartIndex, literalLength);
              const literalNode = new LiteralNode();
              literalNode.withParser(this);
              literalNode.content = this.prepareLiteralContent(nodeContent);
              if (literalNode.content.length > 0) {
                literalNode.startPosition = this.positionFromOffset(literalStartIndex, literalStartIndex);
                literalNode.endPosition = this.positionFromOffset(nextAntlersStart, nextAntlersStart - 1);
                this.nodes.push(literalNode);
              }
            }
            continue;
          }
          if (i !== lastIndex && this.lastAntlersNode != null && this.lastAntlersNode.endPosition != null) {
            const startCandidate = this.positionFromOffset(offset, offset);
            if (startCandidate.isBefore(this.lastAntlersNode.endPosition)) {
              if (i + 1 < indexCount) {
                const nextAntlersStart = this.antlersStartIndex[i + 1];
                if (nextAntlersStart < this.lastAntlersNode.endPosition.offset) {
                  continue;
                }
              } else {
                if (i + 1 != lastIndex) {
                  continue;
                }
              }
            }
          }
          if (i == lastIndex) {
            const literalStart = this.currentIndex + offset;
            if (literalStart < this.inputLen) {
              const literalNode = new LiteralNode();
              literalNode.withParser(this);
              literalNode.content = this.prepareLiteralContent(this.content.substr(literalStart));
              if (literalNode.content.length > 0) {
                literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                literalNode.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
                this.nodes.push(literalNode);
              }
              break;
            }
          }
        }
      }
    }
    let index = 0;
    this.nodes.forEach((node) => {
      node.index = index;
      index += 1;
    });
    this.nodes.forEach((node) => {
      if (node instanceof AntlersNode && node.interpolationRegions.size > 0) {
        node.interpolationRegions.forEach((content, varName) => {
          const docParser = new _DocumentParser();
          docParser.setIsInterpolatedParser(true);
          let parseResults = docParser.parse(content.parseContent);
          if (parseResults.length > 1) {
            if (parseResults[1] instanceof AntlersNode) {
              parseResults = [parseResults[1]];
            }
          }
          node.processedInterpolationRegions.set(varName, parseResults);
          this.mergeErrors(docParser.getAntlersErrors());
        });
        node.hasProcessedInterpolationRegions = true;
      }
    });
    const tagPairAnalyzer = new TagPairAnalyzer();
    this.renderNodes = tagPairAnalyzer.associate(this.nodes, this);
    RecursiveParentAnalyzer.associateRecursiveParent(this.nodes);
    this.nodes.forEach((node) => {
      var _a2;
      if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
        node.isInterpolationNode = this.isInterpolatedParser;
      }
      if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.interpolationRegions.size > 0) {
        node.runtimeNodes.forEach((runtimeNode) => {
          if (runtimeNode instanceof VariableNode) {
            if (node.interpolationRegions.has(runtimeNode.name)) {
              runtimeNode.isInterpolationReference = true;
              runtimeNode.interpolationNodes = node.processedInterpolationRegions.get(runtimeNode.name);
            }
          }
        });
      }
      if ((node instanceof AntlersNode || node instanceof AntlersParserFailNode) && node.hasParameters && node.interpolationRegions.size > 0) {
        node.parameters.forEach((parameter) => {
          node.interpolationRegions.forEach((interVar, interpolationVariable) => {
            if (parameter.value.includes(interpolationVariable)) {
              parameter.interpolations.push(interpolationVariable);
            }
          });
        });
      }
      if (node instanceof AntlersNode && node.runtimeNodes.length > 0) {
        if (node.isClosingTag == false && !node.isComment) {
          node.parsedRuntimeNodes = this.languageParser.parse(node.runtimeNodes);
          node.hasParsedRuntimeNodes = true;
          if (!node.isTagNode && node.parsedRuntimeNodes.length > 0) {
            const principalNode = node.nodeAtIndex(0);
            if (principalNode != null && principalNode instanceof VariableNode) {
              if (principalNode.name == ((_a2 = node.name) == null ? void 0 : _a2.name)) {
                node.modifierChain = principalNode.modifierChain;
              }
            }
          }
        }
      }
    });
    this.languageParser.getCreatedModifierChains().forEach((chain) => {
      if (chain.modifierChain.length > 0) {
        chain.modifierChain.forEach((modifier) => {
          var _a2, _b2;
          if (modifier.nameNode != null && modifierManager_default.instance != null && modifierManager_default.instance.hasModifier((_a2 = modifier.nameNode) == null ? void 0 : _a2.name)) {
            modifier.modifier = (_b2 = modifierManager_default.instance) == null ? void 0 : _b2.getModifier(modifier.nameNode.name);
          }
        });
      }
    });
    let curIndex = 1;
    this.nodes.forEach((node) => {
      var _a2, _b2;
      if (node instanceof AntlersNode) {
        node.isTagNode = (_b2 = (_a2 = tagManagerInstance_default.instance) == null ? void 0 : _a2.isKnownTag(node.runtimeName())) != null ? _b2 : false;
        node.scopeName = node.findParameterValue("scope", "");
        node.antlersNodeIndex = curIndex;
        curIndex += 1;
        ModifierAnalyzer.analyzeModifierNodeParameters(node);
        ParameterValidator.validateParameters(node);
      }
    });
    return this.renderNodes;
  }
  positionFromOffset(offset, index, isRelativeOffset = false) {
    let lineToUse = 0, charToUse = 0;
    if (!this.documentOffsets.has(offset)) {
      if (this.documentOffsets.size == 0) {
        lineToUse = 1;
        charToUse = offset + 1;
      } else {
        let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
        for (const documentOffset of this.documentOffsets.keys()) {
          if (documentOffset >= offset) {
            if (lastOffsetIndex != null && offset > lastOffsetIndex) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            } else {
              nearestOffset = this.documentOffsets.get(documentOffset);
              nearestOffsetIndex = documentOffset;
            }
            break;
          }
          lastOffset = this.documentOffsets.get(documentOffset);
          lastOffsetIndex = documentOffset;
        }
        if (nearestOffset == null) {
          nearestOffset = lastOffset;
          nearestOffsetIndex = lastOffsetIndex;
        }
        if (nearestOffset != null) {
          if (isRelativeOffset) {
            const t_Chars = this.content.split("");
            const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
            const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
            charToUse = tChar;
            lineToUse = nearestOffset.line;
            if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
              lineToUse = nearestOffset.line;
              charToUse = offset + 1;
            } else {
              lineToUse = nearestOffset.line + 1;
            }
          } else {
            const t_Chars = this.content.split("");
            const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
            const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
            charToUse = tChar;
            lineToUse = nearestOffset.line;
            if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
              lineToUse = nearestOffset.line;
              charToUse = offset + 1;
            } else {
              lineToUse = nearestOffset.line + 1;
            }
          }
        } else {
          if (this.lastDocumentOffsetKey != null) {
            const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
            lineToUse = lastOffset2.line + 1;
            charToUse = offset + this.lastDocumentOffsetKey;
          }
        }
      }
    } else {
      const offsetDetails = this.documentOffsets.get(offset);
      lineToUse = offsetDetails.line;
      charToUse = offsetDetails.char;
    }
    const position = new Position();
    position.index = index;
    position.offset = offset;
    position.line = lineToUse;
    position.char = charToUse;
    return position;
  }
  getLanguageParser() {
    return this.languageParser;
  }
  getText(start, end) {
    return this.content.substr(start, end - start);
  }
  getOriginalContent() {
    return this.originalContent;
  }
  getContent() {
    return this.content;
  }
  setIsInterpolatedParser(isInterpolation) {
    this.isInterpolatedParser = isInterpolation;
    return this;
  }
  setStartLineSeed(startLine) {
    this.seedStartLine = startLine;
    return this;
  }
  setSeedStartChar(startChar) {
    this.seedStartchar = startChar;
    return this;
  }
  resetIntermediateState() {
    this.chars = [];
    this.charLen = 0;
    this.currentIndex = 0;
    this.currentContent = [];
    this.sourceContent = [];
    this.cur = null;
    this.next = null;
    this.prev = null;
  }
  resetState() {
    this.languageParser.reset();
    this.charLen = 0;
    this.antlersStartIndex = [];
    this.antlersErrors = [];
    this.pushedErrors.clear();
    this.antlersStartPositionIndex.clear();
    this.lastAntlersEndIndex = -1;
    this.renderNodes = [];
    this.nodes = [];
    if (GlobalRuntimeState.globalTagEnterStack.length > 0) {
      const lastTagNode = GlobalRuntimeState.globalTagEnterStack[GlobalRuntimeState.length - 1];
      if (lastTagNode != null && lastTagNode.endPosition != null) {
        this.setStartLineSeed(lastTagNode.endPosition.line);
      }
    }
    this.seedOffset = 0;
    this.isScanningInterpolations = false;
    this.content = "";
    this.chars = [];
    this.currentIndex = 0;
    this.startIndex = 0;
    this._recoveryStartIndex = 0;
    this.cur = null;
    this.next = null;
    this.prev = null;
    this.inputLen = 0;
    this.documentOffsets.clear();
    this.isDoubleBrace = false;
    this.interpolationRegions.clear();
    this.interpolationEndOffsets.clear();
  }
  peek(count) {
    if (count == this.charLen) {
      const nextChunk = StringUtilities.split(StringUtilities.substring(this.content, this.currentChunkOffset + this.chunkSize, this.chunkSize));
      this.currentChunkOffset += this.chunkSize;
      nextChunk.forEach((nextChar) => {
        this.chars.push(nextChar);
        this.charLen += 1;
      });
    }
    return this.chars[count];
  }
  parseIntermediateText() {
    this.currentContent = [];
    this.sourceContent = [];
    this.startIndex = 0;
    this.chars = this.content.substr(this.currentChunkOffset, this.chunkSize).split("");
    this.charLen = this.chars.length;
    for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.checkCurrentOffsets();
      if (this.cur == _DocumentParser.LeftBrace && this.next == _DocumentParser.LeftBrace && this.prev == _DocumentParser.AtChar) {
        this.dumpLiteralNode(this.currentIndex);
        const escapeNode = new EscapedContentNode();
        escapeNode.withParser(this);
        escapeNode.name = new TagIdentifier();
        escapeNode.name.name = "noparse";
        escapeNode.content = "{{";
        escapeNode.startPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
        escapeNode.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
        this.nodes.push(escapeNode);
        this.currentContent = [];
        this.sourceContent = [];
        this.currentIndex += 1;
        continue;
      }
      if ((this.prev == null || this.prev != null && this.prev != _DocumentParser.AtChar) && this.next != null && this.cur == _DocumentParser.LeftBrace && this.next == _DocumentParser.LeftBrace) {
        this.dumpLiteralNode(this.currentIndex);
        let peek = null;
        if (this.currentIndex + 2 < this.inputLen) {
          peek = this.peek(this.currentIndex + 2);
        }
        if (peek == _DocumentParser.Punctuation_Dollar) {
          this.isDoubleBrace = true;
          this.currentIndex += 3;
          this._recoveryStartIndex = this.currentIndex;
          this.scanToEndOfPhpRegion();
          this.isDoubleBrace = false;
          break;
        }
        if (peek == _DocumentParser.Punctuation_Octothorp) {
          this.isDoubleBrace = true;
          this.currentIndex += 3;
          this._recoveryStartIndex = this.currentIndex;
          this.scanToEndOfAntlersCommentRegion();
          this.isDoubleBrace = false;
          break;
        }
        this.startIndex = this.currentIndex;
        this._recoveryStartIndex = this.currentIndex;
        this.isDoubleBrace = true;
        this.currentIndex += 2;
        this._recoveryStartIndex = this.currentIndex;
        this.scanToEndOfAntlersRegion();
        this.isDoubleBrace = false;
        break;
      }
      if (this.cur == _DocumentParser.AtChar && this.next != null && this.next == _DocumentParser.LeftBrace) {
        if (this.currentIndex + 2 >= this.inputLen) {
          this.appendContent(this.next);
          this.dumpLiteralNode(this.currentIndex + 1);
          break;
        }
        let leftBraceCount = 0;
        for (let countIndex = this.currentIndex + 1; countIndex < this.inputLen; countIndex += 1) {
          const subChar = this.chars[countIndex];
          if (subChar == _DocumentParser.LeftBrace) {
            leftBraceCount += 1;
          } else {
            break;
          }
        }
        this.currentContent = this.currentContent.concat(_DocumentParser.LeftBrace.repeat(leftBraceCount).split(""));
        this.sourceContent = this.currentContent.concat(_DocumentParser.LeftBrace.repeat(leftBraceCount).split(""));
        this.currentIndex += leftBraceCount;
      }
      this.appendContent(this.cur);
      if (this.next == null && this.currentContent.length > 0) {
        this.dumpLiteralNode(this.currentIndex);
      }
    }
  }
  getRenderNodes() {
    return this.renderNodes;
  }
  processInputText(input) {
    var _a;
    this.originalContent = input;
    this.content = StringUtilities.normalizeLineEndings(input);
    this.inputLen = this.content.length;
    if (this.content.startsWith("---")) {
      const lines = this.content.split("\n"), frontMatter = [];
      let newLines = [];
      newLines.push("");
      for (let i = 1; i < lines.length; i++) {
        const lineText = lines[i];
        if (lineText.startsWith("---")) {
          newLines.push("");
          newLines = newLines.concat(lines.slice(i + 1));
          this.content = newLines.join("\n");
          this.frontMatter = frontMatter.join("\n");
          this.frontMatterEndLine = i + 1;
          break;
        } else {
          frontMatter.push(lineText);
          newLines.push("");
        }
      }
    }
    const documentNewLines = [...this.content.matchAll(/(\n)/gm)];
    const newLineCountLen = documentNewLines.length;
    let currentLine = this.seedStartLine, lastOffset = null, lastStartIndex = 0, lastEndIndex = 0;
    for (let i = 0; i < newLineCountLen; i++) {
      const thisNewLine = documentNewLines[i], thisIndex = (_a = thisNewLine.index) != null ? _a : 0;
      let indexChar = thisIndex;
      if (lastOffset != null) {
        indexChar = thisIndex - lastOffset;
      } else {
        indexChar = indexChar + 1;
      }
      this.documentOffsets.set(thisIndex, {
        char: indexChar,
        line: currentLine
      });
      let thisStartIndex = 0, thisEndIndex = 0;
      if (i == 0) {
        thisEndIndex = indexChar - 1;
        thisStartIndex = 0;
      } else {
        thisStartIndex = lastEndIndex + 1;
        thisEndIndex = thisIndex;
      }
      this.lineIndex.set(currentLine, {
        char: indexChar,
        line: currentLine,
        startIndex: thisStartIndex,
        endIndex: thisEndIndex
      });
      this.lastDocumentOffsetKey = thisIndex;
      this.maxLine = currentLine;
      currentLine += 1;
      lastOffset = thisIndex;
      lastEndIndex = thisEndIndex;
      lastStartIndex = thisStartIndex;
    }
    this.maxLine += 1;
    const antlersStartCandidates = [...this.content.matchAll(/@?{{/gm)];
    let lastAntlersOffset = 0, lastWasEscaped = false;
    antlersStartCandidates.forEach((antlersRegion) => {
      const matchText = antlersRegion[0];
      if (matchText.startsWith(_DocumentParser.AtChar)) {
        lastAntlersOffset = this.content.indexOf(matchText, lastAntlersOffset) + 2;
        lastWasEscaped = true;
        return;
      }
      const offset = this.content.indexOf(matchText, lastAntlersOffset);
      if (lastWasEscaped) {
        if (lastAntlersOffset == offset) {
          lastAntlersOffset = offset;
          return;
        }
      }
      this.antlersStartIndex.push(offset);
      this.antlersStartPositionIndex.set(offset, 1);
      lastAntlersOffset = offset + 2;
      lastWasEscaped = false;
    });
    return true;
  }
  prepareLiteralContent(content) {
    return content.replace("@{{", "{{");
  }
  scanToEndOfPhpRegion() {
    for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.checkCurrentOffsets();
      if (this.cur == _DocumentParser.Punctuation_Dollar && this.next != null && this.next == _DocumentParser.RightBrace) {
        const peek = this.peek(this.currentIndex + 2);
        if (peek == _DocumentParser.RightBrace) {
          const node = this.makeAntlersPhpNode(this.currentIndex);
          this.currentContent = [];
          this.sourceContent = [];
          this.currentIndex += 3;
          this.startIndex = this.currentIndex;
          this._recoveryStartIndex = this.startIndex;
          this.nodes.push(node);
          this.lastAntlersNode = node;
          break;
        }
      }
      this.appendContent(this.cur);
      if (this.next == null) {
        const failNode = this.makeAntlersPhpFailedNode(this.currentIndex);
        this.nodes.push(failNode);
        this.lastAntlersNode = failNode;
        this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INCOMPLETE_PHP_EVALUATION_REGION, failNode, "Unexpected end of input while parsing Antlers PHP region."));
        break;
      }
    }
  }
  appendContent(char) {
    if (char == null) {
      return;
    }
    this.currentContent.push(char);
    this.sourceContent.push(char);
  }
  scanToEndOfAntlersCommentRegion() {
    for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.checkCurrentOffsets();
      if (this.cur == _DocumentParser.Punctuation_Octothorp && this.next != null && this.next == _DocumentParser.RightBrace) {
        const peek = this.peek(this.currentIndex + 2);
        if (peek == _DocumentParser.RightBrace) {
          const node = this.makeAntlersTagNode(this.currentIndex, true);
          this.currentContent = [];
          this.sourceContent = [];
          this.currentIndex += 3;
          this.nodes.push(node);
          this.lastAntlersNode = node;
          break;
        }
      }
      this.appendContent(this.cur);
      if (this.next == null) {
        const failNode = this.makeAntlersCommentFailedNode(this.currentIndex);
        this.nodes.push(failNode);
        this.lastAntlersNode = failNode;
        this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INCOMPLETE_ANTELRS_COMMENT_REGION, failNode, "Unexpected end of input while parsing Antlers comment region."));
        break;
      }
    }
  }
  scanToEndOfInterpolatedRegion() {
    const subContent = [];
    this.isScanningInterpolations = true;
    let braceCount = 0;
    for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.checkCurrentOffsets();
      if (this.cur == _DocumentParser.LeftBrace) {
        if (this.prev == _DocumentParser.AtChar) {
          subContent.push(this.cur);
          continue;
        }
        braceCount += 1;
        subContent.push(this.cur);
      } else if (this.cur == _DocumentParser.RightBrace) {
        if (this.prev == _DocumentParser.AtChar) {
          subContent.push(this.cur);
          continue;
        }
        braceCount -= 1;
        subContent.push(this.cur);
        if (braceCount == 0) {
          this.interpolationEndOffsets.set(this.currentIndex, 1);
          break;
        }
      } else {
        if (this.cur != null) {
          subContent.push(this.cur);
        }
      }
    }
    const content = subContent.join(""), varSlug = "int_" + import_md52.Md5.hashStr(content);
    let varContent = varSlug.substr(0, content.length);
    const newLen = varContent.length, origLen = content.length;
    if (newLen < origLen) {
      const padLen = origLen - newLen;
      varContent += "x".repeat(padLen);
    }
    this.isScanningInterpolations = false;
    return {
      content,
      varContent
    };
  }
  bordersInterpolationRegion(position) {
    if (this.interpolationEndOffsets.size == 0) {
      return false;
    }
    const offsetCheck = position.offset - 1;
    if (offsetCheck <= 0) {
      return false;
    }
    return this.interpolationEndOffsets.has(offsetCheck);
  }
  getParseableContent(toIndex) {
    let newString = "";
    for (let i = 0; i <= toIndex; i++) {
      if (this.content[i] == _DocumentParser.LeftBrace || this.content[i] == _DocumentParser.RightBrace) {
        newString += "~";
      } else {
        newString += this.content[i];
      }
    }
    return newString;
  }
  scanToEndOfAntlersRegion() {
    for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
      this.checkCurrentOffsets();
      if (this.cur == _DocumentParser.LeftBrace && this.prev == _DocumentParser.AtChar) {
        this.currentContent.pop();
        this.appendContent(this.cur);
        continue;
      }
      if (this.isInterpolatedParser && this.cur == _DocumentParser.RightBrace && this.prev == _DocumentParser.AtChar) {
        this.currentContent.pop();
        this.appendContent(this.cur);
        continue;
      }
      if (this.cur == _DocumentParser.LeftBrace) {
        const results = this.scanToEndOfInterpolatedRegion();
        const regionEnd = this.currentIndex + this.seedOffset, regionStart = regionEnd - results.content.length, leadingContent = this.getParseableContent(regionStart - 1);
        GlobalRuntimeState.interpolatedVariables.push(results.varContent);
        this.currentContent = this.currentContent.concat(results.varContent.split(""));
        this.sourceContent = this.sourceContent.concat(results.content.split(""));
        const parseContent = leadingContent + "{" + results.content + "}";
        this.interpolationRegions.set(results.varContent, {
          content: results.content,
          parseContent,
          varContent: results.varContent,
          startOffset: regionStart,
          endOffset: regionEnd
        });
        continue;
      }
      if (this.cur == _DocumentParser.RightBrace && this.next != null && this.next == _DocumentParser.RightBrace) {
        const node = this.makeAntlersTagNode(this.currentIndex, false);
        this.currentIndex += 2;
        this.nodes.push(node);
        this.lastAntlersNode = node;
        break;
      }
      this.appendContent(this.cur);
      if (this.next == null) {
        const failNode = this.makeAntlersFailedNode(this.currentIndex, false);
        this.nodes.push(failNode);
        this.lastAntlersNode = failNode;
        let message = "Unexpected end of input while parsing Antlers region.";
        if (this.isScanningInterpolations) {
          message = "Unexpected end of input wihle parsing interpolated Antlers region.";
        }
        this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_INCOMPLETE_ANTLERS_REGION, failNode, message));
        break;
      }
    }
  }
  makeAntlersPhpNode(index) {
    const node = new PhpExecutionNode();
    node.rawStart = "{{$";
    node.rawEnd = "$}}";
    node.content = this.currentContent.join("");
    node.sourceContent = this.sourceContent.join("");
    node.startPosition = this.positionFromOffset(this.startIndex + this.seedOffset, this.startIndex + this.seedOffset);
    if (index + 3 > this.inputLen) {
      node.endPosition = this.positionFromOffset(this.inputLen, this.inputLen - 1);
      this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_MANIFESTING_ANTLERS_NODE, node, "Unexpected end of input while locating end of Antlers region."));
      return node;
    }
    this.lastAntlersEndIndex = index + 3 + this.seedOffset;
    node.endPosition = this.positionFromOffset(index + this.seedOffset, index + 3 + this.seedOffset);
    return node;
  }
  makeAntlersPhpFailedNode(index) {
    const node = new PhpParserFailNode();
    node.rawStart = "{{$";
    node.rawEnd = "$}}";
    node._isEndVirtual = true;
    node.content = this.currentContent.join("");
    node.sourceContent = this.sourceContent.join("");
    node.startPosition = this.positionFromOffset(this.startIndex + this.seedOffset, this.startIndex + this.seedOffset);
    const lineContent = this.getLineText(node.startPosition.line), lineIndexEntry = this.getLineIndex(node.startPosition.line);
    if (lineContent != null) {
      const failedContent = lineContent.substr(this._recoveryStartIndex);
      node.content = failedContent;
      node.sourceContent = failedContent;
    }
    let failedNodeEndIndex = index + this.seedOffset;
    if (lineIndexEntry != null) {
      this.currentIndex = lineIndexEntry.end;
      failedNodeEndIndex = lineIndexEntry.end;
    }
    node.endPosition = this.positionFromOffset(failedNodeEndIndex, failedNodeEndIndex);
    return node;
  }
  makeAntlersCommentFailedNode(index) {
    const node = new CommentParserFailNode();
    if (this.isDoubleBrace) {
      node.rawStart = "{{";
      node.rawEnd = "}}";
    } else {
      node.rawStart = "{";
      node.rawEnd = "}";
    }
    node._isEndVirtual = true;
    let isSelfClosing = false;
    const contentLen = this.currentContent.length;
    if (contentLen > 0 && this.currentContent[contentLen - 1] == _DocumentParser.Punctuation_ForwardSlash) {
      this.currentContent.pop();
      isSelfClosing = true;
    }
    node.isComment = true;
    node.isSelfClosing = isSelfClosing;
    node.withParser(this);
    node.content = this.currentContent.join("");
    node.sourceContent = this.sourceContent.join("");
    node.startPosition = this.positionFromOffset(this.startIndex + this.seedOffset, this.startIndex + this.seedOffset);
    const lineContent = this.getLineText(node.startPosition.line), lineIndexEntry = this.getLineIndex(node.startPosition.line);
    if (lineContent != null) {
      const failedContent = lineContent.substr(this._recoveryStartIndex);
      node.content = failedContent;
      node.sourceContent = failedContent;
    }
    let failedNodeEndIndex = index + this.seedOffset;
    if (lineIndexEntry != null) {
      this.currentIndex = lineIndexEntry.end;
      failedNodeEndIndex = lineIndexEntry.end;
    }
    node.endPosition = this.positionFromOffset(failedNodeEndIndex, failedNodeEndIndex);
    node.interpolationRegions = /* @__PURE__ */ new Map();
    this.interpolationRegions.forEach((region, key) => {
      if (node.content.includes(key)) {
        node.interpolationRegions.set(key, region);
      }
    });
    return node;
  }
  makeAntlersFailedNode(index, isComment) {
    const node = new AntlersParserFailNode();
    if (this.isDoubleBrace) {
      node.rawStart = "{{";
      node.rawEnd = "}}";
    } else {
      node.rawStart = "{";
      node.rawEnd = "}";
    }
    node._isEndVirtual = true;
    let isSelfClosing = false;
    const contentLen = this.currentContent.length;
    if (contentLen > 0 && this.currentContent[contentLen - 1] == _DocumentParser.Punctuation_ForwardSlash) {
      this.currentContent.pop();
      isSelfClosing = true;
    }
    node.isComment = isComment;
    node.isSelfClosing = isSelfClosing;
    node.withParser(this);
    node.content = this.currentContent.join("");
    node.sourceContent = this.sourceContent.join("");
    node.startPosition = this.positionFromOffset(this.startIndex + this.seedOffset, this.startIndex + this.seedOffset);
    const lineContent = this.getLineText(node.startPosition.line), lineIndexEntry = this.getLineIndex(node.startPosition.line);
    if (lineContent != null) {
      const failedContent = StringUtilities.trimLeft(this.content.substring(node.startPosition.offset + node.rawStart.length - 1, lineIndexEntry == null ? void 0 : lineIndexEntry.end), "{");
      node.content = failedContent;
      node.sourceContent = failedContent;
    }
    let failedNodeEndIndex = index + this.seedOffset;
    if (lineIndexEntry != null) {
      this.currentIndex = lineIndexEntry.end;
      failedNodeEndIndex = lineIndexEntry.end;
    }
    node.endPosition = this.positionFromOffset(failedNodeEndIndex, failedNodeEndIndex);
    node.interpolationRegions = /* @__PURE__ */ new Map();
    this.interpolationRegions.forEach((region, key) => {
      if (node.content.includes(key)) {
        node.interpolationRegions.set(key, region);
      }
    });
    const returnNode = this.nodeParser.parseNode(node);
    this.mergeErrors(returnNode.getErrors());
    return returnNode;
  }
  makeAntlersTagNode(index, isComment) {
    const node = new AntlersNode();
    if (this.isDoubleBrace) {
      node.rawStart = "{{";
      node.rawEnd = "}}";
    } else {
      node.rawStart = "{";
      node.rawEnd = "}";
    }
    let isSelfClosing = false;
    const contentLen = this.currentContent.length;
    if (contentLen > 0 && this.currentContent[contentLen - 1] == _DocumentParser.Punctuation_ForwardSlash) {
      this.currentContent.pop();
      isSelfClosing = true;
    }
    node.isComment = isComment;
    node.isSelfClosing = isSelfClosing;
    node.withParser(this);
    node.content = this.currentContent.join("");
    node.sourceContent = this.sourceContent.join("");
    const t_CHars = this.content.split("");
    node.startPosition = this.positionFromOffset(this.startIndex + this.seedOffset, this.startIndex + this.seedOffset);
    if (index + 2 > this.inputLen) {
      node.endPosition = this.positionFromOffset(this.inputLen, this.inputLen - 1);
      this.antlersErrors.push(AntlersError.makeSyntaxError(AntlersErrorCodes.TYPE_UNEXPECTED_EOI_WHILE_MANIFESTING_ANTLERS_NODE, node, "Unexpected end of input while locating end of Antlers region."));
      return node;
    }
    if (isComment) {
      this.lastAntlersEndIndex = index + 2 + this.seedOffset;
    } else {
      this.lastAntlersEndIndex = index + 1 + this.seedOffset;
    }
    node.endPosition = this.positionFromOffset(this.lastAntlersEndIndex, this.lastAntlersEndIndex);
    node.interpolationRegions = /* @__PURE__ */ new Map();
    this.interpolationRegions.forEach((region, key) => {
      if (node.content.includes(key)) {
        node.interpolationRegions.set(key, region);
      }
    });
    const returnNode = this.nodeParser.parseNode(node);
    this.mergeErrors(returnNode.getErrors());
    return returnNode;
  }
  mergeErrors(errors) {
    errors.forEach((error) => {
      this.antlersErrors.push(error);
    });
  }
  getNodes() {
    return this.nodes;
  }
  antlersNodes() {
    return this.nodes.filter(function(node) {
      return node instanceof AntlersNode;
    });
  }
  dumpLiteralNode(index) {
    if (this.currentContent.length > 0) {
      this.nodes.push(this.makeLiteralNode(this.currentContent, this.startIndex, index));
    }
    this.currentContent = [];
    this.sourceContent = [];
  }
  makeLiteralNode(buffer, startOffset, currentOffset) {
    const node = new LiteralNode();
    node.content = buffer.join("");
    node.sourceContent = this.sourceContent.join("");
    node.startPosition = this.positionFromOffset(startOffset, startOffset);
    node.endPosition = this.positionFromOffset(currentOffset, currentOffset);
    node.withParser(this);
    return node;
  }
  addAntlersError(error) {
    this.antlersErrors.push(error);
  }
  getAntlersErrors() {
    return this.antlersErrors;
  }
};
var DocumentParser = _DocumentParser;
DocumentParser.K_CHAR = "char";
DocumentParser.K_LINE = "line";
DocumentParser.NewLine = "\n";
DocumentParser.AtChar = "@";
DocumentParser.LeftBrace = "{";
DocumentParser.RightBrace = "}";
DocumentParser.LeftBracket = "[";
DocumentParser.RightBracket = "]";
DocumentParser.String_EscapeCharacter = "\\";
DocumentParser.String_Terminator_DoubleQuote = '"';
DocumentParser.String_Terminator_SingleQuote = "'";
DocumentParser.Punctuation_Question = "?";
DocumentParser.Punctuation_Equals = "=";
DocumentParser.Punctuation_Comma = ",";
DocumentParser.Punctuation_Colon = ":";
DocumentParser.Punctuation_Semicolon = ";";
DocumentParser.Punctuation_Exclamation = "!";
DocumentParser.Punctuation_Pipe = "|";
DocumentParser.Punctuation_Ampersand = "&";
DocumentParser.Punctuation_LessThan = "<";
DocumentParser.Punctuation_GreaterThan = ">";
DocumentParser.Punctuation_Octothorp = "#";
DocumentParser.Punctuation_Tilde = "~";
DocumentParser.Punctuation_FullStop = ".";
DocumentParser.Punctuation_Dollar = "$";
DocumentParser.Punctuation_Asterisk = "*";
DocumentParser.Punctuation_Percent = "%";
DocumentParser.Punctuation_Plus = "+";
DocumentParser.Punctuation_Minus = "-";
DocumentParser.Punctuation_Underscore = "_";
DocumentParser.Punctuation_ForwardSlash = "/";
DocumentParser.Punctuation_Caret = "^";
DocumentParser.LeftParen = "(";
DocumentParser.RightParent = ")";

// server/src/runtime/document/scanners/nodeQueries.ts
var NodeQueries = class {
  static findAssignmentNodes(nodes) {
    const returnNodes = [];
    for (let i = 0; i < nodes.length; i++) {
      if (LanguageParser.isAssignmentOperatorNode(nodes[i])) {
        returnNodes.push(nodes[i]);
      }
    }
    return returnNodes;
  }
  static findAbstractNodesBefore(node, nodes) {
    return this.findAbstractNodesBeforePosition(node.startPosition, nodes);
  }
  static findAbstractNodesBeforePosition(position, nodes) {
    if (position == null) {
      return [];
    }
    const subNodes = [];
    for (let i = 0; i < nodes.length; i++) {
      const checkNode = nodes[i];
      if (checkNode.startPosition != null) {
        if (checkNode.startPosition.index > position.index) {
          break;
        }
        subNodes.push(checkNode);
      }
    }
    return subNodes;
  }
  static findNodesBeforePosition(position, nodes) {
    const beforeNodes = [];
    if (position == null) {
      return beforeNodes;
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (NodeQueries.isLiteralType(node)) {
        continue;
      }
      if (node.startPosition != null && node.endPosition != null) {
        if (node.startPosition.index > position.index) {
          break;
        }
        beforeNodes.push(node);
      }
    }
    return beforeNodes;
  }
  static findNodesAfterPosition(position, nodes) {
    const afterNodes = [];
    if (position == null) {
      return afterNodes;
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (NodeQueries.isLiteralType(node)) {
        continue;
      }
      if (node.startPosition != null) {
        if (node.startPosition.index > position.index) {
          afterNodes.push(node);
        }
      }
    }
    return afterNodes;
  }
  static findNodeBeforePosition(position, nodes) {
    if (position == null) {
      return null;
    }
    let lastNode = null;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (NodeQueries.isLiteralType(node)) {
        continue;
      }
      if (node.startPosition != null) {
        if (node.startPosition.index > position.index) {
          break;
        }
        lastNode = node;
      }
    }
    return lastNode;
  }
  static findNodeAfterPosition(position, nodes) {
    if (position == null) {
      return null;
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (NodeQueries.isLiteralType(node)) {
        continue;
      }
      if (node.startPosition != null) {
        if (node.startPosition.index > position.index) {
          return node;
        }
      }
    }
    return null;
  }
  static findNodeAtPosition(position, nodes) {
    if (position == null) {
      return null;
    }
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (NodeQueries.isLiteralType(node)) {
        continue;
      }
      if (node.startPosition != null && node.endPosition != null) {
        if (position.index >= node.startPosition.index && position.index <= node.endPosition.index) {
          return node;
        }
      }
    }
    return null;
  }
  static isLiteralType(node) {
    if (node instanceof EscapedContentNode || node instanceof LiteralNode) {
      return true;
    }
    return false;
  }
};

// server/src/runtime/document/featureContextResolver.ts
var FeatureContextResolver = class {
  static isModifierLeftOf(node, nodes) {
    return FeatureContextResolver.isModifierLeftOfPosition(node.startPosition, nodes);
  }
  static isModifierLeftOfPosition(position, nodes) {
    const checkNodes = NodeQueries.findAbstractNodesBeforePosition(position, nodes);
    for (let i = checkNodes.length - 1; i >= 0; i--) {
      const thisNode = checkNodes[i];
      if (thisNode instanceof LogicGroupBegin || thisNode instanceof LogicGroupEnd) {
        return false;
      }
      if (thisNode instanceof ModifierSeparator) {
        return true;
      }
    }
    return false;
  }
};

// server/src/runtime/document/contexts/generalContext.ts
var GeneralContext = class {
  constructor() {
    this.isRightOfOperator = false;
    this.isLeftOfOperator = false;
  }
  static resolveContext(position, node, feature) {
    const context = new GeneralContext();
    if (feature != null) {
      if (feature.prev != null && LanguageParser.isOperatorType(feature.prev)) {
        context.isRightOfOperator = true;
      }
      if (feature.next != null && LanguageParser.isOperatorType(feature.next)) {
        context.isLeftOfOperator = true;
      }
    }
    return context;
  }
};

// server/src/runtime/document/contexts/identifierContext.ts
var IdentifierContext = class {
  constructor() {
    this.inTagPart = false;
    this.inMethodPart = false;
  }
};

// server/src/runtime/document/contexts/modifierContext.ts
var ModifierContext = class {
  constructor() {
    this.modifierChain = null;
    this.activeModifier = null;
    this.name = "";
    this.inModifierName = false;
    this.inModifierParameter = false;
    this.valueCount = 0;
    this.activeValueIndex = -1;
    this.activeValue = null;
  }
  static resolveContext(position, node, feature, document) {
    const parser = node.getParser(), context = new ModifierContext(), chains = parser.getLanguageParser().getCreatedModifierChains();
    let modifier = null;
    for (let i = 0; i < chains.length; i++) {
      const chain = chains[i];
      if (position.isWithin(chain.startPosition, chain.endPosition)) {
        for (let j = 0; j < chain.modifierChain.length; j++) {
          const thisModifier = chain.modifierChain[j];
          if (position.isWithin(thisModifier.startPosition, thisModifier.endPosition)) {
            modifier = thisModifier;
            break;
          }
        }
        if (modifier != null) {
          break;
        }
      }
    }
    if (modifier == null && feature instanceof ModifierNameNode) {
      if (document.getDocumentParser().getLanguageParser().hasModifierConstruct(feature)) {
        modifier = document.getDocumentParser().getLanguageParser().getModifierConstruct(feature);
      }
    }
    if (modifier != null) {
      context.activeModifier = modifier;
      context.valueCount = modifier.valueNodes.length;
      if (modifier.nameNode != null) {
        context.name = modifier.nameNode.name;
      }
      if (modifier.nameNode != null && position.isWithin(modifier.nameNode.startPosition, modifier.nameNode.endPosition, 1)) {
        context.inModifierName = true;
      } else {
        for (let i = 0; i < modifier.valueNodes.length; i++) {
          const value = modifier.valueNodes[i];
          if (position.isWithin(value.startPosition, value.endPosition, 1)) {
            context.activeValueIndex = i;
            context.inModifierParameter = true;
            context.activeValue = value;
            break;
          }
        }
      }
    }
    return context;
  }
};

// server/src/runtime/document/contexts/parameterContext.ts
var ParameterContext = class {
  constructor() {
    this.parameter = null;
    this.isInName = false;
    this.isInValue = false;
  }
  static resolveContext(position, node) {
    const context = new ParameterContext();
    context.parameter = node;
    if (position.isWithinRange(node.namePosition)) {
      context.isInName = true;
    } else if (position.isWithinRange(node.valuePosition)) {
      context.isInValue = true;
    }
    return context;
  }
};

// server/src/runtime/document/contexts/positionContext.ts
var PositionContext = class {
  constructor() {
    this.refId = "";
    this.node = null;
    this.leftPunctuation = null;
    this.rightPunctuation = null;
    this.leftChar = null;
    this.rightChar = null;
    this.word = null;
    this.char = null;
    this.interpolatedContext = false;
    this.leftWord = null;
    this.rightWord = null;
    this.isCursorInIdentifier = false;
    this.root = null;
    this.identifierContext = null;
    this.position = null;
    this.feature = null;
    this.isInParameter = false;
    this.subContext = null;
    this.parameterContext = null;
    this.modifierContext = null;
    this.generalContext = null;
    this.variableContext = null;
    this.cursorContext = CursorContext.Unknown;
    this.refId = v4();
  }
};
var CursorContext = /* @__PURE__ */ ((CursorContext2) => {
  CursorContext2[CursorContext2["Unknown"] = 0] = "Unknown";
  CursorContext2[CursorContext2["Variable"] = 1] = "Variable";
  CursorContext2[CursorContext2["Modifier"] = 2] = "Modifier";
  CursorContext2[CursorContext2["Parameter"] = 3] = "Parameter";
  CursorContext2[CursorContext2["General"] = 4] = "General";
  CursorContext2[CursorContext2["LanguageOperator"] = 5] = "LanguageOperator";
  return CursorContext2;
})(CursorContext || {});

// server/src/runtime/document/contexts/variableContext.ts
var VariableContext = class {
  constructor() {
    this.variableNode = null;
    this.varPathText = "";
  }
  static resolveContext(position, node, feature, document) {
    var _a;
    if (feature == null) {
      return null;
    }
    let featureToCheck = feature;
    const parser = document.getDocumentParser().getLanguageParser(), context = new VariableContext(), curWord = (_a = document.wordAt(position)) != null ? _a : "";
    if (feature instanceof InlineBranchSeparator && parser.isMergedVariableComponent(feature) == false && feature.prev instanceof VariableNode) {
      featureToCheck = feature.prev;
    }
    let varPathText = "";
    if (parser.isMergedVariableComponent(featureToCheck)) {
      const mergedStructure = parser.getMergedVariable(featureToCheck);
      if (mergedStructure.startPosition != null) {
        varPathText = document.getText(mergedStructure.startPosition.index, position.index).trim();
      }
      context.variableNode = mergedStructure;
    } else if (featureToCheck instanceof VariableNode) {
      context.variableNode = featureToCheck;
      varPathText = featureToCheck.name;
      if (featureToCheck.variableReference != null) {
        varPathText = featureToCheck.variableReference.normalizedReference;
      }
    }
    if (varPathText.length > 0) {
      varPathText = replaceAllInString(varPathText, "\\.", ":");
    }
    const varParts = varPathText.split(":");
    if (curWord.trim().length > 0) {
      varParts.pop();
    }
    varPathText = varParts.join(":");
    if (varPathText.endsWith(":")) {
      varPathText = trimRight(varPathText, ":");
    }
    context.varPathText = varPathText;
    return context;
  }
};

// server/src/runtime/document/contexts/contextResolver.ts
var ContextResolver = class {
  static resolveIdentifierContext(position, node) {
    const identifierContext = new IdentifierContext();
    if (node.nameMethodPartStartsOn != null) {
      if (position.char < node.nameMethodPartStartsOn.char) {
        identifierContext.inTagPart = true;
        identifierContext.inMethodPart = false;
      } else {
        identifierContext.inTagPart = false;
        identifierContext.inMethodPart = true;
      }
    } else {
      identifierContext.inMethodPart = false;
      identifierContext.inTagPart = true;
    }
    return identifierContext;
  }
  static resolveContext(position, node, document, isInterpolated = false, root = null) {
    var _a, _b, _c, _d, _e, _f;
    if (node == null || position == null) {
      return null;
    }
    if (node instanceof ParserFailNode || node instanceof AntlersNode) {
      const cursorContext = new PositionContext();
      if (node.nameStartsOn != null && position.line == node.nameStartsOn.line) {
        let isInName = false;
        if (position.char >= node.nameStartsOn.char) {
          isInName = true;
        }
        if (node.nameEndsOn != null) {
          if (position.char > node.nameEndsOn.char) {
            isInName = false;
          }
        }
        if (isInName) {
          cursorContext.isCursorInIdentifier = true;
          cursorContext.identifierContext = ContextResolver.resolveIdentifierContext(position, node);
        }
      }
      node.addContext(cursorContext);
      if (root != null) {
        root.addContext(cursorContext);
      }
      cursorContext.interpolatedContext = isInterpolated;
      cursorContext.node = node;
      cursorContext.position = position;
      cursorContext.root = root;
      cursorContext.leftPunctuation = document.punctuationLeftAt(position);
      cursorContext.rightPunctuation = document.punctuationRightAt(position);
      cursorContext.leftChar = document.charLeftAt(position);
      cursorContext.rightChar = document.charRightAt(position);
      cursorContext.word = document.wordAt(position);
      cursorContext.char = document.charAt(position);
      cursorContext.leftWord = document.wordLeftAt(position);
      cursorContext.rightWord = document.wordRightAt(position);
      let foundParameterContext = false;
      if (node.parameters.length > 0) {
        for (let i = 0; i < node.parameters.length; i++) {
          const thisParam = node.parameters[i];
          if (thisParam.blockPosition != null && thisParam.blockPosition.start != null && thisParam.blockPosition.end != null) {
            if (position.char > thisParam.blockPosition.start.char && position.char <= thisParam.blockPosition.end.char + 1 && position.line >= ((_c = (_b = (_a = thisParam.namePosition) == null ? void 0 : _a.start) == null ? void 0 : _b.line) != null ? _c : thisParam.blockPosition.start.line) && position.line <= ((_f = (_e = (_d = thisParam.valuePosition) == null ? void 0 : _d.end) == null ? void 0 : _e.line) != null ? _f : thisParam.blockPosition.end.line)) {
              cursorContext.cursorContext = 3 /* Parameter */;
              cursorContext.parameterContext = ParameterContext.resolveContext(position, thisParam);
              cursorContext.isInParameter = true;
              cursorContext.feature = thisParam;
              foundParameterContext = true;
              break;
            }
          }
        }
      }
      if (!foundParameterContext) {
        node.runtimeNodes.forEach((runtimeNode) => {
          if (runtimeNode.startPosition != null && runtimeNode.endPosition != null) {
            if (position.isWithin(runtimeNode.startPosition, runtimeNode.endPosition, 1)) {
              cursorContext.feature = runtimeNode;
            }
          }
        });
      }
      if (foundParameterContext) {
        if (node.interpolationRegions.size > 0) {
          const regions = Array.from(node.interpolationRegions, ([name, region]) => region);
          for (let j = 0; j < regions.length; j++) {
            const interpolatedRegion = regions[j];
            if (position.index >= interpolatedRegion.startOffset && position.index <= interpolatedRegion.endOffset) {
              const interpolatedNode = node.getInterpolationNode(interpolatedRegion.varContent);
              return ContextResolver.resolveContext(position, interpolatedNode, document, true, root);
            }
          }
        }
      }
      if (cursorContext.feature instanceof VariableNode && cursorContext.feature.isInterpolationReference && cursorContext.feature.parent != null && cursorContext.feature.parent instanceof AntlersNode && cursorContext.feature.parent.processedInterpolationRegions.has(cursorContext.feature.name)) {
        return ContextResolver.resolveContext(position, cursorContext.feature.parent.getInterpolationNode(cursorContext.feature.name), document, true, root);
      }
      const isInModifier = FeatureContextResolver.isModifierLeftOfPosition(position, node.runtimeNodes);
      if (isInModifier) {
        cursorContext.cursorContext = 2 /* Modifier */;
        cursorContext.modifierContext = ModifierContext.resolveContext(position, node, cursorContext.feature, document);
      } else {
        if (!foundParameterContext) {
          cursorContext.cursorContext = 4 /* General */;
          cursorContext.generalContext = GeneralContext.resolveContext(position, node, cursorContext.feature);
        }
      }
      cursorContext.variableContext = VariableContext.resolveContext(position, node, cursorContext.feature, document);
      return cursorContext;
    }
    return null;
  }
};

// server/src/runtime/document/scanners/antlersNodeQueries.ts
var AntlersNodeQueries = class {
  static isPairedNode(node) {
    if (node instanceof ConditionNode) {
      return true;
    }
    if (node instanceof ParserFailNode || node instanceof AntlersNode) {
      return node.isClosedBy != null;
    }
    return false;
  }
  static findAncestorsBeforePosition(position, documentNodes) {
    var _a, _b, _c, _d, _e, _f;
    const nodesToReturn = [];
    const skippedNodes = [];
    let forceSkipLine = -1, forceSkipOffset = -1;
    for (let i = 0; i < documentNodes.length; i++) {
      const currentNode = documentNodes[i];
      if (currentNode.isClosedBy != null) {
        if ((_a = currentNode.isClosedBy.endPosition) == null ? void 0 : _a.isBefore(position)) {
          skippedNodes.push(currentNode);
          skippedNodes.push(currentNode.isClosedBy);
          forceSkipLine = currentNode.isClosedBy.endPosition.line;
          forceSkipOffset = currentNode.isClosedBy.endPosition.char;
        }
      }
      if (forceSkipLine > -1) {
        if (currentNode.endPosition != null) {
          if (currentNode.endPosition.line < forceSkipLine) {
            continue;
          }
          if (currentNode.endPosition.line == forceSkipLine && forceSkipOffset > -1) {
            if (currentNode.endPosition.char < forceSkipOffset) {
              continue;
            }
          }
        }
      }
      if (currentNode.startPosition != null) {
        if (position.isBefore(currentNode.startPosition)) {
          break;
        }
        if (currentNode.startPosition.line == position.line && position.char <= currentNode.startPosition.char) {
          skippedNodes.push(currentNode);
          continue;
        }
      }
      if (((_b = tagManagerInstance_default.instance) == null ? void 0 : _b.requiresClose(currentNode)) && currentNode.isClosedBy != null) {
        const closingNode = currentNode.isClosedBy;
        if ((_c = closingNode.startPosition) == null ? void 0 : _c.isBefore(position)) {
          skippedNodes.push(currentNode);
          skippedNodes.push(closingNode);
          continue;
        } else if (((_d = closingNode.startPosition) == null ? void 0 : _d.line) == position.line && ((_e = closingNode.startPosition) == null ? void 0 : _e.char) < position.char) {
          skippedNodes.push(currentNode);
        } else {
          nodesToReturn.push(currentNode);
        }
      } else {
        if (currentNode.parent != null) {
          const parent = currentNode.parent;
          if (skippedNodes.includes(parent)) {
            skippedNodes.push(currentNode);
            continue;
          } else {
            if ((_f = currentNode.endPosition) == null ? void 0 : _f.isBefore(position)) {
              nodesToReturn.push(currentNode);
            } else {
              skippedNodes.push(currentNode);
            }
          }
        } else {
          nodesToReturn.push(currentNode);
        }
      }
    }
    return nodesToReturn;
  }
};

// server/src/runtime/document/documentCursor.ts
var DocumentCursor = class {
  constructor(doc) {
    this.doc = doc;
  }
  getAncestorsAt(line, char) {
    const position = this.position(line, char);
    if (position == null) {
      return [];
    }
    return AntlersNodeQueries.findAncestorsBeforePosition(position, this.doc.getAllAntlersNodes());
  }
  getNameAt(line, char) {
    const node = this.getNodeAt(line, char);
    if (node instanceof AntlersNode) {
      return node.name;
    }
    return null;
  }
  getScopeAt(line, char) {
    const node = this.getNodeAt(line, char);
    if (node instanceof AntlersNode) {
      if (node.currentScope != null) {
        return node.currentScope;
      }
    }
    return null;
  }
  getFeaturesAt(line, char) {
    const position = this.position(line, char), node = this.getNodeAt(line, char);
    return ContextResolver.resolveContext(position, node, this.doc, false, node);
  }
  getNodeAt(line, char) {
    return NodeQueries.findNodeAtPosition(this.position(line, char), this.doc.getDocumentParser().getNodes());
  }
  getNodeBefore(line, char) {
    return NodeQueries.findNodeBeforePosition(this.position(line, char), this.doc.getDocumentParser().getNodes());
  }
  getNodeAfter(line, char) {
    return NodeQueries.findNodeAfterPosition(this.position(line, char), this.doc.getDocumentParser().getNodes());
  }
  getNodesBefore(line, char) {
    return NodeQueries.findNodesBeforePosition(this.position(line, char), this.doc.getDocumentParser().getNodes());
  }
  getNodesAfter(line, char) {
    return NodeQueries.findNodesAfterPosition(this.position(line, char), this.doc.getDocumentParser().getNodes());
  }
  getIsWithinPairedNode(line, char) {
    const node = this.getNodeBefore(line, char);
    if (node == null) {
      return false;
    }
    return AntlersNodeQueries.isPairedNode(node);
  }
  position(line, char) {
    return this.doc.getDocumentParser().positionFromCursor(line, char);
  }
  charLeftAt(line, char) {
    return this.doc.getDocumentParser().charLeftAtCursor(line, char);
  }
  charAt(line, char) {
    return this.doc.getDocumentParser().charAtCursor(line, char);
  }
  charRightAt(line, char) {
    return this.doc.getDocumentParser().charRightAtCursor(line, char);
  }
  wordLeftAt(line, char, tabSize = 4) {
    return this.doc.getDocumentParser().wordLeftAtCursor(line, char, tabSize);
  }
  wordRightAt(line, char, tabSize = 4) {
    return this.doc.getDocumentParser().wordRightAtCursor(line, char, tabSize);
  }
  wordAt(line, char, tabSize = 4) {
    return this.doc.getDocumentParser().wordAtCursor(line, char, tabSize);
  }
  punctuationLeftAt(line, char, tabSize = 4) {
    return this.doc.getDocumentParser().punctuationLeftAtCursor(line, char, tabSize);
  }
  punctuationRightAt(line, char, tabSize = 4) {
    return this.doc.getDocumentParser().punctuationRightAtCursor(line, char, tabSize);
  }
};

// server/src/runtime/document/documentErrors.ts
var DocumentErrors = class {
  constructor(doc) {
    this.doc = doc;
  }
  hasAny() {
    return this.all().length > 0;
  }
  all() {
    const errorHashes = [], errors = [];
    this.doc.getAllAntlersNodes().forEach((node) => {
      node.getErrors().forEach((error) => {
        if (errorHashes.includes(error.hash()) == false) {
          errorHashes.push(error.hash());
          errors.push(error);
        }
      });
    });
    return errors;
  }
};

// server/src/runtime/document/frontMatter/frontMatterParser.ts
var YAML = __toESM(require_yaml());

// server/node_modules/yaml/types.mjs
var import_types = __toESM(require_types(), 1);
var binaryOptions = import_types.default.binaryOptions;
var boolOptions = import_types.default.boolOptions;
var intOptions = import_types.default.intOptions;
var nullOptions = import_types.default.nullOptions;
var strOptions = import_types.default.strOptions;
var Schema = import_types.default.Schema;
var Alias = import_types.default.Alias;
var Collection2 = import_types.default.Collection;
var Merge = import_types.default.Merge;
var Node = import_types.default.Node;
var Pair = import_types.default.Pair;
var Scalar = import_types.default.Scalar;
var YAMLMap = import_types.default.YAMLMap;
var YAMLSeq = import_types.default.YAMLSeq;

// server/src/runtime/document/frontMatter/frontMatterParser.ts
var FrontMatterParser = class {
  constructor(projectProvider) {
    this.documentScope = null;
    this.project = projectProvider;
  }
  getKeyValue(node) {
    if (node instanceof Scalar) {
      return node.value;
    }
    return "";
  }
  getNodeValue(node) {
    if (node instanceof Scalar) {
      return node.value;
    } else if (node instanceof YAMLMap) {
      return this.analyzeDocument(node.items);
    }
    return "";
  }
  getScalarRuntimeType(value) {
    if (parseFloat(value).toString() == value || parseInt(value).toString() == value) {
      return "number";
    }
    return "string";
  }
  analyzeDocument(items) {
    const nestedScope = new Scope(this.project);
    items.forEach((item) => {
      if (item instanceof Pair) {
        const varName = this.getKeyValue(item.key), varValue = this.getNodeValue(item.value);
        if (item.value instanceof Scalar) {
          nestedScope.addVariable({
            dataType: this.getScalarRuntimeType(varValue),
            introducedBy: null,
            name: varName,
            sourceField: null,
            sourceName: "*frontmatter"
          });
        } else {
          nestedScope.addScopeList(varName, varValue);
        }
      }
    });
    return nestedScope;
  }
  parse(text) {
    const docs = YAML.parseDocument(text);
    try {
      if (docs.contents instanceof YAMLMap) {
        this.documentScope = this.analyzeDocument(docs.contents.items);
      }
    } catch (err) {
      this.documentScope = null;
    }
  }
  hasScope() {
    if (this.documentScope == null) {
      return false;
    }
    return true;
  }
  getScope() {
    return this.documentScope;
  }
};

// server/src/runtime/document/scanners/nodeScanner.ts
var NodeScanner = class {
  constructor(doc) {
    this.doc = doc;
  }
  getAncestors(position) {
    return AntlersNodeQueries.findAncestorsBeforePosition(position, this.doc.getAllAntlersNodes());
  }
  getNodeAt(position) {
    return NodeQueries.findNodeAtPosition(position, this.doc.getDocumentParser().getNodes());
  }
  getNodesBefore(position) {
    return NodeQueries.findNodesBeforePosition(position, this.doc.getDocumentParser().getNodes());
  }
  getNodeBefore(position) {
    return NodeQueries.findNodeBeforePosition(position, this.doc.getDocumentParser().getNodes());
  }
  getNodeAfter(position) {
    return NodeQueries.findNodeAfterPosition(position, this.doc.getDocumentParser().getNodes());
  }
  getNodesAfter(position) {
    return NodeQueries.findNodesAfterPosition(position, this.doc.getDocumentParser().getNodes());
  }
  getIsWithinPairedNode(position) {
    const node = this.getNodeBefore(position);
    if (node == null) {
      return false;
    }
    return AntlersNodeQueries.isPairedNode(node);
  }
  filter(predicate) {
    return this.doc.getDocumentParser().getNodes().filter(predicate);
  }
  getComments() {
    const nodes = [];
    this.doc.getAllNodes().forEach((node) => {
      if (node instanceof AntlersNode && node.isComment) {
        nodes.push(node);
      }
    });
    return nodes;
  }
  getMultilineNodes() {
    const nodes = [];
    this.doc.getAllNodes().forEach((node) => {
      var _a, _b;
      if (node instanceof AntlersNode && !node.isComment && ((_a = node.startPosition) == null ? void 0 : _a.line) != ((_b = node.endPosition) == null ? void 0 : _b.line)) {
        nodes.push(node);
      }
    });
    return nodes;
  }
  getMultiLineComments() {
    const nodes = [];
    this.getComments().forEach((comment) => {
      var _a, _b;
      if (((_a = comment.startPosition) == null ? void 0 : _a.line) != ((_b = comment.endPosition) == null ? void 0 : _b.line)) {
        nodes.push(comment);
      }
    });
    return nodes;
  }
  getAllLiteralNodes() {
    const nodes = [];
    this.doc.getAllNodes().forEach((node) => {
      if (node instanceof LiteralNode || node instanceof EscapedContentNode) {
        nodes.push(node);
      }
    });
    return nodes;
  }
  getStructuralNodes() {
    const nodes = [];
    this.doc.getDocumentParser().getRenderNodes().forEach((node) => {
      if (node instanceof AntlersNode) {
        nodes.push(node);
      } else if (node instanceof ConditionNode) {
        if (node.logicBranches.length > 0) {
          node.logicBranches.forEach((branch) => {
            if (branch.head != null) {
              const tBrancHead = branch.head;
              if (tBrancHead.originalNode != null) {
                nodes.push(tBrancHead.originalNode);
              } else {
                nodes.push(tBrancHead);
              }
            }
          });
        }
      }
    });
    return nodes;
  }
  getAllRuntimeNodes() {
    const allNodes = [];
    this.doc.getAllNodes().forEach((node) => {
      if (node instanceof ParserFailNode || node instanceof AntlersNode) {
        if (node.runtimeNodes.length > 0) {
          node.runtimeNodes.forEach((runtimeNode) => {
            allNodes.push(runtimeNode);
          });
        }
      }
    });
    return allNodes;
  }
  getAllParameterNodes() {
    const allParameters = [];
    this.doc.getAllNodes().forEach((node) => {
      if (node instanceof ParserFailNode || node instanceof AntlersNode) {
        if (node.hasParameters) {
          node.parameters.forEach((parameter) => {
            allParameters.push(parameter);
          });
        }
      }
    });
    return allParameters;
  }
  getAssignmentNodes() {
    return NodeQueries.findAssignmentNodes(this.getAllRuntimeNodes());
  }
};

// server/src/runtime/document/scanners/rangeScanner.ts
var RangeScanner = class {
  constructor(doc) {
    this.doc = doc;
  }
  getAllSelfClosingNodes() {
    const nodes = [];
    this.doc.getAllNodes().forEach((node) => {
      if (node instanceof AntlersNode) {
        if (node.isSelfClosing) {
          nodes.push(node);
        }
      }
    });
    return nodes;
  }
  getAllPairedNodes() {
    const nodes = [];
    this.doc.getAllNodes().forEach((node) => {
      if (node instanceof AntlersNode || node instanceof AntlersParserFailNode) {
        if (node.isClosedBy != null && !node.isSelfClosing) {
          nodes.push(node);
        }
      }
    });
    return nodes;
  }
};

// server/src/runtime/document/yamlDocument.ts
var YAML2 = __toESM(require_yaml());
var YamlDocument = class {
  constructor() {
    this.content = "";
    this.ranges = [];
    this.lastDocumentOffsetKey = null;
    this.documentOffsets = /* @__PURE__ */ new Map();
    this.lineIndex = /* @__PURE__ */ new Map();
    this.keys = [];
    this.values = [];
    this.isValid = false;
    this.parseError = null;
  }
  loadString(text) {
    var _a;
    this.content = StringUtilities.normalizeLineEndings(text);
    let doc = null;
    try {
      doc = YAML2.parseDocument(this.content);
      this.isValid = true;
    } catch (err) {
      this.isValid = false;
      this.parseError = err;
    }
    if (doc == null) {
      return;
    }
    const documentNewLines = [...this.content.matchAll(/(\n)/gm)], newLineCountLen = documentNewLines.length;
    let currentLine = 2, lastOffset = null, lastStartIndex = 0, lastEndIndex = 0;
    for (let i = 0; i < newLineCountLen; i++) {
      const thisNewLine = documentNewLines[i], thisIndex = (_a = thisNewLine.index) != null ? _a : 0;
      let indexChar = thisIndex;
      if (lastOffset != null) {
        indexChar = thisIndex - lastOffset;
      } else {
        indexChar = indexChar + 1;
      }
      this.documentOffsets.set(thisIndex, {
        char: indexChar,
        line: currentLine
      });
      let thisStartIndex = 0, thisEndIndex = 0;
      if (i == 0) {
        thisEndIndex = indexChar - 1;
        thisStartIndex = 0;
      } else {
        thisStartIndex = lastEndIndex + 1;
        thisEndIndex = thisIndex;
      }
      this.lineIndex.set(currentLine, {
        char: indexChar,
        line: currentLine,
        startIndex: thisStartIndex,
        endIndex: thisEndIndex
      });
      this.lastDocumentOffsetKey = thisIndex;
      currentLine += 1;
      lastOffset = thisIndex;
      lastEndIndex = thisEndIndex;
      lastStartIndex = thisStartIndex;
    }
    const docContents = doc.contents;
    this.processMap(docContents);
  }
  processMap(map2) {
    map2.items.forEach((item) => {
      this.processItem(item);
    });
  }
  processItem(item) {
    if (item.type == "PAIR") {
      if (item.value instanceof YAMLMap || item.value instanceof YAMLSeq) {
        const key2 = item.key;
        if (key2.range != null) {
          const s1 = this.positionFromOffset(key2.range[0], key2.range[0]), e1 = this.positionFromOffset(key2.range[1], key2.range[1]);
          this.ranges.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: "property" });
          this.keys.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: key2.value });
          if (item.value instanceof YAMLSeq) {
            this.processMap(item.value.items[0]);
          } else {
            this.processMap(item.value);
          }
          return;
        }
      }
      const pair = item, key = pair.key, value = pair.value;
      if (key.range != null && value.range != null) {
        const s1 = this.positionFromOffset(key.range[0], key.range[0]), e1 = this.positionFromOffset(key.range[1], key.range[1]), s2 = this.positionFromOffset(value.range[0], value.range[0]), e2 = this.positionFromOffset(value.range[1], value.range[1]);
        let vValue = "string";
        if (parseInt(value.value) == value.value) {
          vValue = "number";
        }
        this.ranges.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: "property" });
        this.keys.push({ start: s1, end: e1, length: e1.char - s1.char + 1, content: key.value });
        this.ranges.push({ start: s2, end: e2, length: e2.char - s2.char + 1, content: vValue });
        this.values.push({ start: s2, end: e2, length: e2.char - s2.char + 1, content: value.value });
      }
    }
  }
  positionFromOffset(offset, index, isRelativeOffset = false) {
    let lineToUse = 0, charToUse = 0;
    if (!this.documentOffsets.has(offset)) {
      if (this.documentOffsets.size == 0) {
        lineToUse = 1;
        charToUse = offset + 1;
      } else {
        let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
        for (const documentOffset of this.documentOffsets.keys()) {
          if (documentOffset >= offset) {
            if (lastOffsetIndex != null && offset > lastOffsetIndex) {
              nearestOffset = lastOffset;
              nearestOffsetIndex = lastOffsetIndex;
            } else {
              nearestOffset = this.documentOffsets.get(documentOffset);
              nearestOffsetIndex = documentOffset;
            }
            break;
          }
          lastOffset = this.documentOffsets.get(documentOffset);
          lastOffsetIndex = documentOffset;
        }
        if (nearestOffset == null) {
          nearestOffset = lastOffset;
          nearestOffsetIndex = lastOffsetIndex;
        }
        if (nearestOffset != null) {
          if (isRelativeOffset) {
            const t_Chars = this.content.split("");
            const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
            const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
            charToUse = tChar;
            lineToUse = nearestOffset.line;
            if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
              lineToUse = nearestOffset.line;
              charToUse = offset + 1;
            } else {
              lineToUse = nearestOffset.line + 1;
            }
          } else {
            const t_Chars = this.content.split("");
            const tChar = offset - (nearestOffsetIndex != null ? nearestOffsetIndex : 0);
            const offsetDelta = nearestOffset.char - (nearestOffsetIndex != null ? nearestOffsetIndex : 0) + offset;
            charToUse = tChar;
            lineToUse = nearestOffset.line;
            if (offset <= (nearestOffsetIndex != null ? nearestOffsetIndex : 0)) {
              lineToUse = nearestOffset.line;
              charToUse = offset + 1;
            } else {
              lineToUse = nearestOffset.line + 1;
            }
          }
        } else {
          if (this.lastDocumentOffsetKey != null) {
            const lastOffset2 = this.documentOffsets.get(this.lastDocumentOffsetKey);
            lineToUse = lastOffset2.line + 1;
            charToUse = offset + this.lastDocumentOffsetKey;
          }
        }
      }
    } else {
      const offsetDetails = this.documentOffsets.get(offset);
      lineToUse = offsetDetails.line;
      charToUse = offsetDetails.char;
    }
    const position = new Position();
    position.index = index;
    position.offset = offset;
    position.line = lineToUse;
    position.char = charToUse;
    return position;
  }
  getRanges() {
    return this.ranges;
  }
  getKeys() {
    return this.keys;
  }
  getValues() {
    return this.values;
  }
};

// server/src/runtime/document/antlersDocument.ts
var AntlersDocument = class {
  constructor() {
    this.documentParser = new DocumentParser();
    this.ranges = new RangeScanner(this);
    this.nodes = new NodeScanner(this);
    this.cursor = new DocumentCursor(this);
    this.errors = new DocumentErrors(this);
    this.project = null;
    this.documentUri = "";
  }
  static fromText(text, project) {
    const document = new AntlersDocument();
    if (typeof project != "undefined") {
      document.project = project;
    }
    return document.loadString(text);
  }
  hasInvalidControlFlowStructures() {
    return this.documentParser.hasUnclosedIfStructures();
  }
  getFrontMatterDoc() {
    if (this.hasFrontMatter()) {
      const yamlDoc = new YamlDocument();
      yamlDoc.loadString(this.getFrontMatter());
      return yamlDoc;
    }
    return null;
  }
  hasFrontMatter() {
    return this.documentParser.getFrontMatter().trim().length > 0;
  }
  getFrontMatter() {
    return this.documentParser.getFrontMatter();
  }
  getFrontMatterScope() {
    if (this.project == null) {
      return null;
    }
    const frontMatterParser = new FrontMatterParser(this.project);
    frontMatterParser.parse(this.getFrontMatter());
    return frontMatterParser.getScope();
  }
  updateProject(project) {
    this.project = project;
    this.updateProjectDetails();
  }
  updateProjectDetails() {
    try {
      if (this.project != null) {
        const scopeEngine = new ScopeEngine(this.project, this.documentUri, this), analysisNodes = this.documentParser.antlersNodes();
        analysisNodes.forEach((node) => {
          var _a, _b;
          if (this.project != null && ((_a = tagManagerInstance_default.instance) == null ? void 0 : _a.canResolveSpecialTypes(node.getTagName()))) {
            const specialResults = (_b = tagManagerInstance_default.instance) == null ? void 0 : _b.resolveSpecialType(node.getTagName(), node, this.project);
            if (specialResults.context != null) {
              node.reference = specialResults.context;
            }
          }
        });
        scopeEngine.analyzeScope(analysisNodes);
        for (let i = 0; i < analysisNodes.length; i++) {
          const node = analysisNodes[i];
          if (node.hasParameters) {
            for (let j = 0; j < node.parameters.length; j++) {
              const thisParam = node.parameters[j];
              if (thisParam.hasInterpolations()) {
                for (let l = 0; l < thisParam.interpolations.length; l++) {
                  const thisInterpolation = thisParam.interpolations[l];
                  if (node.processedInterpolationRegions.has(thisInterpolation)) {
                    const tInterpolation = node.processedInterpolationRegions.get(thisInterpolation);
                    tInterpolation.forEach((interpolationNode) => {
                      if (interpolationNode instanceof AntlersNode) {
                        interpolationNode.currentScope = node.currentScope;
                      }
                    });
                  }
                }
              }
            }
          }
        }
        resolveTypedTree(this);
      }
    } catch (err) {
      console.log(err);
    }
  }
  loadString(text) {
    this.documentParser.parse(text);
    this.updateProjectDetails();
    return this;
  }
  getDocumentParser() {
    return this.documentParser;
  }
  getAllNodes() {
    return this.documentParser.getNodes();
  }
  getAllAntlersNodes() {
    return this.documentParser.antlersNodes();
  }
  extractText() {
    const parts = [];
    this.nodes.getAllLiteralNodes().forEach((node) => {
      parts.push(node.content);
    });
    return parts.join("");
  }
  getNameAt(position) {
    const node = this.nodes.getNodeAt(position);
    if (node instanceof AntlersNode) {
      return node.name;
    }
    return null;
  }
  getContent() {
    return this.documentParser.getContent();
  }
  getOriginalContent() {
    return this.documentParser.getOriginalContent();
  }
  getFeaturesAt(position) {
    const node = this.nodes.getNodeAt(position);
    return ContextResolver.resolveContext(position, node, this, false, node);
  }
  getText(start, end) {
    return this.documentParser.getText(start, end);
  }
  charLeftAt(position) {
    return this.documentParser.charLeftAt(position);
  }
  charAt(position) {
    return this.documentParser.charAt(position);
  }
  charRightAt(position) {
    return this.documentParser.charRightAt(position);
  }
  getLineIndex(lineNumber) {
    return this.documentParser.getLineIndex(lineNumber);
  }
  getLineText(lineNumber) {
    return this.documentParser.getLineText(lineNumber);
  }
  wordAt(position, tabSize = 4) {
    return this.documentParser.wordAt(position, tabSize);
  }
  wordLeftAt(position, tabSize = 4) {
    return this.documentParser.wordLeftAt(position, tabSize);
  }
  wordRightAt(position, tabSize = 4) {
    return this.documentParser.wordRightAt(position, tabSize);
  }
  punctuationLeftAt(position, tabSize = 4) {
    return this.documentParser.punctuationLeftAt(position, tabSize);
  }
  punctuationRightAt(position, tabSize = 4) {
    return this.documentParser.punctuationRightAt(position, tabSize);
  }
  getLineChars(lineNumber) {
    const lineText = this.getLineText(lineNumber);
    if (lineText != null) {
      return lineText.split("");
    }
    return null;
  }
};

// server/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// server/src/formatting/frontMatterFormatter.ts
var FrontMatterFormatter = class {
  static formatFrontMatter(contents) {
    try {
      const docFrontMatter = load(contents, {});
      let temp = dump(docFrontMatter, {
        indent: 2,
        noArrayIndent: false,
        condenseFlow: false,
        forceQuotes: true,
        noRefs: true,
        skipInvalid: true
      });
      if (temp.endsWith("\n")) {
        temp = temp.trimEnd();
      }
      return temp;
    } catch (err) {
      return contents;
    }
  }
};

// server/src/formatting/htmlCompat.ts
function getFormatOption(options, key, dflt) {
  if (options && options.hasOwnProperty(key)) {
    const value = options[key];
    if (value !== null) {
      return value;
    }
  }
  return dflt;
}
function getTagsFormatOption(options, key, dflt) {
  const list = getFormatOption(options, key, null);
  if (typeof list === "string") {
    if (list.length > 0) {
      return list.split(",").map((t) => t.trim().toLowerCase());
    }
    return [];
  }
  return dflt;
}

// server/src/formatting/printers/genericPrinters.ts
var GenericPrinters = class {
  static frontMatterBlock(text) {
    return "---\n" + text + "\n---\n\n";
  }
};

// server/src/formatting/antlersFormatter.ts
var beautify = require_js().html;
var NodeBuffer = class {
  constructor(node, indent, prepend) {
    this.buffer = "";
    this.closeString = "";
    this.baseIndent = indent;
    if (node.isInterpolationNode) {
      this.buffer = "{";
      this.closeString = "}";
    } else {
      this.buffer = "{{ ";
      if (node.isSelfClosing) {
        this.closeString = " /}}";
      } else {
        this.closeString = " }}";
      }
    }
    if (prepend != null && prepend.trim().length > 0) {
      this.buffer += prepend + " ";
    }
  }
  close() {
    if (this.closeString == " }}") {
      if (this.buffer.endsWith(" ")) {
        this.buffer += "}}";
      } else {
        this.buffer += this.closeString;
      }
    } else {
      this.buffer += this.closeString;
    }
    return this;
  }
  appendT(text) {
    if (this.buffer.endsWith(" ")) {
      this.buffer = this.buffer.trimEnd();
    }
    this.buffer += text;
    return this;
  }
  appendTS(text) {
    if (this.buffer.endsWith(" ")) {
      this.buffer = this.buffer.trimEnd();
    }
    if (this.buffer.endsWith("{")) {
      text = text.trimStart();
    }
    this.buffer += text;
    return this;
  }
  append(text) {
    this.buffer += text;
    return this;
  }
  appendOS(text) {
    if (this.buffer.endsWith(" ") == false && this.buffer.endsWith("(") == false && this.buffer.endsWith("[") == false && this.buffer.endsWith(":") == false) {
      this.buffer += " ";
    }
    return this.append(text);
  }
  appendS(text) {
    let appendBuffer = "";
    if (this.buffer.endsWith(" ") == false) {
      appendBuffer += " ";
    }
    appendBuffer += text + " ";
    this.buffer += appendBuffer;
    return this;
  }
  indent() {
    let repeatCount = this.baseIndent;
    if (repeatCount == 0) {
      repeatCount = 1;
    } else {
      repeatCount += 2;
    }
    this.buffer += " ".repeat(repeatCount);
    return this;
  }
  addIndent(number) {
    if (number <= 0) {
      return this;
    }
    this.buffer += " ".repeat(number);
    return this;
  }
  paramS(param) {
    let bParam = " ";
    if (param.isVariableReference) {
      bParam += ":";
    }
    bParam += param.name + "=" + param.nameDelimiter + param.value + param.nameDelimiter;
    this.append(bParam);
    return this;
  }
  replace(find, replace) {
    this.buffer = replaceAllInString(this.buffer, find, replace);
    return this;
  }
  newlineIndent() {
    this.newLine();
    this.indent();
    return this;
  }
  newlineNDIndent() {
    this.buffer = this.buffer.trimEnd();
    this.newLine();
    this.indent();
    return this;
  }
  newLine() {
    this.buffer += "\n";
    return this;
  }
  getContent() {
    return this.buffer;
  }
};
var AntlersFormatter = class {
  constructor(options) {
    this.antlersRegions = /* @__PURE__ */ new Map();
    this.conditionRegions = /* @__PURE__ */ new Map();
    this.commentRegions = /* @__PURE__ */ new Map();
    this.pruneList = [];
    this.chopList = [];
    this.commentCount = 0;
    this.formatOptions = options;
  }
  tabIndent() {
    let indentSize = this.formatOptions.tabSize;
    if (indentSize <= 0) {
      indentSize = 4;
    }
    return " ".repeat(indentSize);
  }
  printComment(node) {
    const commentText = node.getContent().trim();
    if (commentText.includes("\n")) {
      let contents = "{{#\n";
      const commentLines = commentText.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
      commentLines.forEach((line) => {
        contents += this.tabIndent() + line.trim() + "\n";
      });
      contents += "#}}";
      return contents;
    }
    return "{{# " + commentText + " #}}";
  }
  prettyPrintNode(antlersNode, doc, indent, prepend) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (antlersNode.isComment) {
      return this.printComment(antlersNode);
    }
    const lexerNodes = antlersNode.getTrueRuntimeNodes();
    let nodeStatements = 0, nodeOperators = 0;
    if (lexerNodes.length > 0) {
      const nodeBuffer = new NodeBuffer(antlersNode, indent, prepend);
      let lastPrintedNode = null;
      for (let i = 0; i < lexerNodes.length; i++) {
        const node = lexerNodes[i];
        if (lastPrintedNode != null) {
          if ((_a = node.endPosition) == null ? void 0 : _a.isBefore(lastPrintedNode.startPosition)) {
            continue;
          }
        }
        let insertNlAfter = false;
        if (node instanceof LogicGroupEnd) {
          if (node.next instanceof LogicGroupEnd == false && node.next != null) {
            if (!LanguageParser.isOperatorType(node.next) || !LanguageParser.isAssignmentOperator(node.next)) {
              if (node.next instanceof StatementSeparatorNode == false && node.next instanceof InlineBranchSeparator == false) {
                if (!node.isSwitchGroupMember && !LanguageParser.isOperatorType(node.next)) {
                  insertNlAfter = true;
                  if (node.next instanceof VariableNode && node.next.name == "as") {
                    insertNlAfter = false;
                  }
                }
              }
            }
          }
        } else {
          if (!((_b = node.prev) == null ? void 0 : _b.isVirtual) && ((_c = node.prev) == null ? void 0 : _c.isVirtualGroupOperatorResolve) && node.prev.producesVirtualStatementTerminator) {
            if (node.next != null) {
              if (!(node.prev instanceof VariableNode)) {
                nodeBuffer.newlineIndent();
              }
            }
          }
        }
        if (node instanceof VariableNode) {
          if (node.convertedToOperator) {
            if (node.name == "arr") {
              nodeBuffer.appendT(" arr");
            } else if (node.name == "switch" || node.name == "list") {
              nodeBuffer.appendTS(" " + node.name);
              if (i + 1 < lexerNodes.length) {
                const next = lexerNodes[i + 1];
                if (!(next instanceof LogicGroupBegin)) {
                  break;
                }
                nodeBuffer.append("(");
                if (node.name != "list") {
                  nodeBuffer.newlineIndent().indent();
                }
                i += 1;
                lastPrintedNode = lexerNodes[i + 1];
                continue;
              } else {
                break;
              }
            } else {
              nodeOperators += 1;
              if (nodeOperators > 1) {
                nodeBuffer.newlineNDIndent().indent().addIndent(6).appendS(node.name);
              } else {
                nodeBuffer.appendS(node.name);
              }
            }
            lastPrintedNode = node;
            continue;
          }
          if (node.mergeRefName != null && node.mergeRefName.trim().length > 0 && node.mergeRefName != node.name) {
            nodeBuffer.append(node.mergeRefName.trim());
          } else {
            if (node.name == "as") {
              nodeBuffer.appendOS("as");
            } else {
              nodeBuffer.append(node.name.trim());
            }
          }
        } else if (node instanceof TupleListStart) {
          nodeBuffer.appendTS(" list");
          if (i + 1 < lexerNodes.length) {
            const next = lexerNodes[i + 1];
            if (!(next instanceof LogicGroupBegin)) {
              break;
            }
            nodeBuffer.append("(");
            i += 1;
            lastPrintedNode = lexerNodes[i + 1];
            continue;
          } else {
            break;
          }
        } else if (node instanceof ModifierSeparator) {
          nodeBuffer.appendS("|");
        } else if (node instanceof InlineBranchSeparator) {
          if (lastPrintedNode != null) {
            if ((_d = node.startPosition) == null ? void 0 : _d.isBefore(lastPrintedNode.endPosition)) {
              continue;
            }
          }
          if (node.next instanceof VariableNode) {
            if (node.next.mergeRefName.startsWith(":")) {
              continue;
            }
          }
          if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
            continue;
          }
          if (node.prev != null && node.next != null) {
            if (NodeHelpers.distance(node.prev, node) <= 1 && NodeHelpers.distance(node.next, node) <= 1) {
              nodeBuffer.append(":");
              lastPrintedNode = node;
              continue;
            }
          }
          if (doc.getDocumentParser().getLanguageParser().isActualModifierSeparator(node)) {
            nodeBuffer.append(":");
            lastPrintedNode = node;
            continue;
          }
          if (lastPrintedNode instanceof ModifierNameNode || lastPrintedNode instanceof ModifierValueNode) {
            nodeBuffer.append(":");
            lastPrintedNode = node;
            continue;
          }
          nodeBuffer.appendS(":");
        } else if (node instanceof ModifierNameNode) {
          nodeBuffer.append(node.name);
        } else if (node instanceof InlineTernarySeparator) {
          nodeBuffer.appendS("?");
        } else if (node instanceof ModifierValueSeparator) {
          if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
            continue;
          }
          if (doc.getDocumentParser().getLanguageParser().isActualModifierSeparator(node)) {
            nodeBuffer.append(":");
            lastPrintedNode = node;
            continue;
          }
          nodeBuffer.append(":");
        } else if (node instanceof ModifierValueNode) {
          nodeBuffer.append(node.value.trim());
        } else if (node instanceof LogicGroupBegin) {
          nodeBuffer.append("(");
        } else if (node instanceof LogicGroupEnd) {
          nodeBuffer.append(")");
        } else if (node instanceof StringValueNode) {
          if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
            continue;
          }
          if (node.startPosition != null && node.endPosition != null) {
            const originalDocText = doc.getText(node.startPosition.index, node.endPosition.index + 1);
            nodeBuffer.appendOS(originalDocText);
          } else {
            nodeBuffer.appendOS(node.sourceTerminator + node.value + node.sourceTerminator);
          }
        } else if (node instanceof ArgSeparator) {
          if (node.isSwitchGroupMember) {
            nodeBuffer.append(",").newlineIndent().indent();
          } else {
            nodeBuffer.append(", ");
          }
        } else if (node instanceof NumberNode) {
          lastPrintedNode = node;
          if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
            continue;
          }
          nodeBuffer.append((_f = (_e = node.value) == null ? void 0 : _e.toString()) != null ? _f : "");
        } else if (node instanceof LeftAssignmentOperator) {
          nodeBuffer.appendS("=");
        } else if (node instanceof ScopeAssignmentOperator) {
          nodeBuffer.appendS("=>");
        } else if (node instanceof AdditionOperator) {
          nodeBuffer.appendS("+");
        } else if (node instanceof MultiplicationOperator) {
          nodeBuffer.appendS("*");
        } else if (node instanceof DivisionOperator) {
          lastPrintedNode = node;
          if ((_g = node.startPosition) == null ? void 0 : _g.isBefore(antlersNode.nameEndsOn)) {
            nodeBuffer.append("/");
            continue;
          }
          if (doc.getDocumentParser().getLanguageParser().isMergedVariableComponent(node)) {
            continue;
          }
          nodeBuffer.appendS("/");
          continue;
        } else if (node instanceof StatementSeparatorNode) {
          if (node.isListGroupMember) {
            nodeBuffer.append(";").newlineIndent().indent().addIndent(7);
            if (i + 1 < lexerNodes.length && lexerNodes[i + 1] instanceof LogicGroupEnd == false) {
              nodeBuffer.indent();
            }
          } else {
            nodeStatements += 1;
            if (nodeStatements < this.formatOptions.maxStatementsPerLine) {
              nodeBuffer.appendT("; ");
            } else {
              nodeBuffer.appendT(";").newlineIndent();
              nodeStatements = 0;
            }
          }
        } else if (node instanceof LogicalNegationOperator) {
          if (node.content == "not") {
            nodeBuffer.appendS("not");
          } else {
            nodeBuffer.append("!");
          }
        } else {
          nodeBuffer.appendS(node.rawContent());
        }
        if (insertNlAfter) {
          nodeBuffer.newlineIndent();
        }
        lastPrintedNode = node;
      }
      if (antlersNode.hasParameters) {
        antlersNode.parameters.forEach((param) => {
          nodeBuffer.paramS(param);
        });
      }
      nodeBuffer.close();
      let bContent = nodeBuffer.getContent();
      if (antlersNode.processedInterpolationRegions.size > 0) {
        antlersNode.processedInterpolationRegions.forEach((region, key) => {
          const iTResult = this.formatDocumentNodes(region, doc);
          bContent = replaceAllInString(bContent, key, iTResult);
        });
      }
      return bContent;
    }
    return antlersNode.getTrueRawContent();
  }
  formatDocumentNodes(nodes, doc) {
    var _a;
    let rootText = "";
    const unformatted = (_a = getTagsFormatOption(this.formatOptions.htmlOptions, "unformatted", void 0)) != null ? _a : [];
    const content_unformatted = [], antlersSingleNodes = /* @__PURE__ */ new Map(), includesEnd = false;
    let lastLiteralNode = null;
    nodes.forEach((node) => {
      if (node instanceof LiteralNode) {
        if (node.startPosition != null && node.endPosition != null) {
          const originalDocText = doc.getText(node.startPosition.index, node.endPosition.index + 1);
          rootText += originalDocText;
        } else {
          rootText += node.rawContent();
        }
        lastLiteralNode = node;
      } else if (node instanceof AntlersNode) {
        if (node.isComment) {
          this.commentCount += 1;
          const commentConstruction = "__ANTLR_COMMENT" + this.commentCount.toString() + "C";
          this.commentRegions.set(commentConstruction, node);
          rootText += commentConstruction;
        } else {
          if (node.isSelfClosing || node.isClosedBy == null) {
            const elementConstruction = "__ANTLR_" + node.refId;
            rootText += elementConstruction;
            antlersSingleNodes.set(elementConstruction, node);
          } else if (node.children.length > 0) {
            const formatChildren = node.children;
            formatChildren.pop();
            const tChildResult = this.formatDocumentNodes(formatChildren, doc);
            const elementConstruction = "<ANTLR_" + node.refId + ">";
            const closeConstruct = "</ANTLR_" + node.refId + ">";
            this.antlersRegions.set(elementConstruction, node);
            rootText += elementConstruction + "\n" + tChildResult + "\n" + closeConstruct;
          }
        }
      } else if (node instanceof ConditionNode) {
        for (let i = 0; i < node.logicBranches.length; i++) {
          const logicBranch = node.logicBranches[i];
          if (logicBranch.head == null) {
            continue;
          }
          const logicChildren = logicBranch.head.children;
          logicChildren.pop();
          const tChildResult = this.formatDocumentNodes(logicChildren, doc);
          const elementConstruction = "<ANTLER_COND" + logicBranch.head.refId + ">";
          const closeConstruct = "</ANTLER_COND" + logicBranch.head.refId + ">";
          this.conditionRegions.set(elementConstruction, logicBranch.head);
          rootText += elementConstruction + tChildResult + closeConstruct;
        }
      }
    });
    rootText = replaceAllInString(rootText, "<{{ as", "<ANTLER_COMMON_ALIAS");
    rootText = replaceAllInString(rootText, "</{{ as", "</ANTLER_COMMON_ALIAS");
    let tResult = beautify(rootText, {
      indent_size: this.formatOptions.tabSize,
      indent_char: this.formatOptions.insertSpaces ? " " : "	",
      indent_empty_lines: getFormatOption(this.formatOptions.htmlOptions, "indentEmptyLines", false),
      wrap_line_length: getFormatOption(this.formatOptions.htmlOptions, "wrapLineLength", 120),
      unformatted,
      content_unformatted,
      indent_inner_html: getFormatOption(this.formatOptions.htmlOptions, "indentInnerHtml", false),
      preserve_newlines: getFormatOption(this.formatOptions.htmlOptions, "preserveNewLines", true),
      max_preserve_newlines: getFormatOption(this.formatOptions.htmlOptions, "maxPreserveNewLines", 32786),
      indent_handlebars: getFormatOption(this.formatOptions.htmlOptions, "indentHandlebars", false),
      end_with_newline: includesEnd && getFormatOption(this.formatOptions.htmlOptions, "endWithNewline", false),
      extra_liners: getTagsFormatOption(this.formatOptions.htmlOptions, "extraLiners", void 0),
      wrap_attributes: getFormatOption(this.formatOptions.htmlOptions, "wrapAttributes", "auto"),
      wrap_attributes_indent_size: getFormatOption(this.formatOptions.htmlOptions, "wrapAttributesIndentSize", void 0),
      eol: "\n",
      indent_scripts: getFormatOption(this.formatOptions.htmlOptions, "indentScripts", "normal"),
      unformatted_content_delimiter: getFormatOption(this.formatOptions.htmlOptions, "unformattedContentDelimiter", "")
    });
    const indentLines = tResult.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
    antlersSingleNodes.forEach((node, construction) => {
      const constructionIndex = this.getIndent(construction, indentLines);
      tResult = replaceAllInString(tResult, construction, this.prettyPrintNode(node, doc, constructionIndex, null));
    });
    tResult = replaceAllInString(tResult, "<ANTLER_COMMON_ALIAS", "<{{ as");
    tResult = replaceAllInString(tResult, "</ANTLER_COMMON_ALIAS", "</{{ as");
    return tResult;
  }
  getIndent(construction, lines) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes(construction)) {
        const constructionIndex = line.indexOf(construction);
        if (constructionIndex >= 0) {
          return constructionIndex + 1;
        }
      }
    }
    return 0;
  }
  static applyPositionsFromDocument(fromDoc, toDoc) {
    const fromNodes = fromDoc.getAllAntlersNodes(), toNodes = toDoc.getAllAntlersNodes();
    if (fromNodes.length != toNodes.length) {
      return;
    }
    for (let i = 0; i < fromNodes.length; i++) {
      const fromNode = fromNodes[i], toNode = toNodes[i];
      toNode.startPosition = fromNode.startPosition;
      toNode.endPosition = fromNode.endPosition;
      if (toNode.runtimeNodes.length == fromNode.runtimeNodes.length) {
        for (let j = 0; j < toNode.runtimeNodes.length; j++) {
          const fromRuntimeNode = fromNode.runtimeNodes[j], toRuntimeNode = toNode.runtimeNodes[j];
          toRuntimeNode.startPosition = fromRuntimeNode.startPosition;
          toRuntimeNode.endPosition = fromRuntimeNode.endPosition;
        }
      }
    }
  }
  formatDocument(doc) {
    if (doc.hasInvalidControlFlowStructures()) {
      return doc.getOriginalContent();
    }
    const rootNodes = doc.getDocumentParser().getRenderNodes();
    let documentRootFormatted = this.formatDocumentNodes(rootNodes, doc);
    const indentLines = documentRootFormatted.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
    this.antlersRegions.forEach((node, construction) => {
      const constructionIndex = this.getIndent(construction, indentLines);
      const tOpenPrettyPrint = this.prettyPrintNode(node, doc, constructionIndex, null), closeConstruct = "</ANTLR_" + node.refId + ">";
      let tCloseContent = "";
      if (node.isClosedBy != null) {
        tCloseContent = node.isClosedBy.getTrueRawContent().trim();
      }
      documentRootFormatted = replaceAllInString(documentRootFormatted, construction, tOpenPrettyPrint);
      documentRootFormatted = replaceAllInString(documentRootFormatted, closeConstruct, tCloseContent);
    });
    this.commentRegions.forEach((comment, construction) => {
      const constructionIndex = this.getIndent(construction, indentLines);
      const cPrettyPrint = this.prettyPrintNode(comment, doc, constructionIndex, null);
      documentRootFormatted = replaceAllInString(documentRootFormatted, construction, cPrettyPrint);
    });
    this.conditionRegions.forEach((node, construction) => {
      var _a, _b;
      const closeConstruct = "</ANTLER_COND" + node.refId + ">";
      let doReplaceClose = true;
      const constructionIndex = this.getIndent(construction, indentLines), tOpenTrue = node.getTrueNode();
      if (node.isClosedBy != null) {
        const tCloseTrue = node.isClosedBy;
        if (tCloseTrue.startPosition != null && node.endPosition != null) {
          if (tCloseTrue.startPosition.line == node.endPosition.line) {
            this.chopList.push(closeConstruct + "\n");
          }
        }
      }
      if (node.isClosedBy != null && ((_a = node.isClosedBy.name) == null ? void 0 : _a.name) != "if") {
        this.pruneList.push(closeConstruct.toLowerCase());
        this.chopList.push(closeConstruct);
        doReplaceClose = false;
      }
      let tOpenPrettyPrint = this.prettyPrintNode(tOpenTrue, doc, constructionIndex, tOpenTrue.runtimeName());
      let pushClose = false;
      if (node.isClosedBy != null) {
        const tCloseTrue = node.isClosedBy;
        if (tCloseTrue.startPosition != null && node.endPosition != null) {
          if (tCloseTrue.startPosition.line != node.endPosition.line) {
            tOpenPrettyPrint += "\n{{@cond_break@}}" + " ".repeat(constructionIndex + 3);
            pushClose = true;
          }
        }
      }
      documentRootFormatted = replaceAllInString(documentRootFormatted, construction, tOpenPrettyPrint);
      if (doReplaceClose) {
        let tClosePrefix = "";
        if (pushClose) {
          let closeConstructIndex = constructionIndex;
          if (closeConstructIndex == 1) {
            closeConstructIndex = 0;
          }
          tClosePrefix = "{{@cond_break@}}\n" + " ".repeat(closeConstructIndex);
        }
        const trueCloseNode = (_b = node.isClosedBy) == null ? void 0 : _b.getTrueNode();
        let trueName = trueCloseNode == null ? void 0 : trueCloseNode.runtimeName();
        if ((trueName == null ? void 0 : trueName.toLowerCase()) == "endunless") {
          trueName = "unless";
        }
        let tCloseContent = tClosePrefix + "{{ ";
        if (trueName != "endif") {
          tCloseContent += "/";
        }
        tCloseContent += trueName + " }}";
        documentRootFormatted = replaceAllInString(documentRootFormatted, closeConstruct, tCloseContent);
        documentRootFormatted = replaceAllInString(documentRootFormatted, closeConstruct, "");
      }
    });
    this.chopList.forEach((chop) => {
      documentRootFormatted = replaceAllInString(documentRootFormatted, chop, "");
    });
    const rLines = documentRootFormatted.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
    const nLines = [];
    rLines.forEach((line) => {
      if (this.pruneList.includes(line.trim().toLowerCase())) {
        return;
      }
      if (line.trim() == "{{@cond_break@}}") {
        return;
      }
      nLines.push(line);
    });
    documentRootFormatted = nLines.join("\n");
    documentRootFormatted = replaceAllInString(documentRootFormatted, "{{@cond_break@}}", "");
    if (doc.hasFrontMatter()) {
      const frontMatter = doc.getFrontMatter();
      if (this.formatOptions.formatFrontMatter) {
        documentRootFormatted = GenericPrinters.frontMatterBlock(FrontMatterFormatter.formatFrontMatter(frontMatter)) + documentRootFormatted;
      } else {
        documentRootFormatted = GenericPrinters.frontMatterBlock(frontMatter) + documentRootFormatted;
      }
    }
    return documentRootFormatted;
  }
};

// server/src/formatting/cli/index.ts
var yargs = require_yargs();
var EXIT_SUCCESS = 0;
var EXIT_FILE_NOT_FOUND = 3;
var EXIT_GENERAL_FAILURE = 1;
var argv = yargs.command("format", "Formats a file and writes the changes to disk", {
  path: {
    description: "The file to format",
    alias: "f",
    type: "string"
  },
  output: {
    description: "An optional output path",
    alias: "out",
    type: "string",
    default: null
  },
  dump: {
    description: "Optionally writes the formatted results to the output instead of saving",
    alias: "dd",
    type: "boolean",
    default: false
  },
  options: {
    description: "An optional path to an Antlers format configuration file",
    alias: "o",
    type: "string"
  }
}).help().alias("help", "h").argv;
var defaultSettings = {
  htmlOptions: {},
  formatFrontMatter: true,
  insertSpaces: true,
  maxStatementsPerLine: 3,
  tabSize: 4
};
function resolveSettings(path) {
  if (fs.existsSync(path)) {
    const optionContents = fs.readFileSync(path, { encoding: "utf8" });
    try {
      return JSON.parse(optionContents);
    } catch (err) {
      console.error(err);
    }
  }
  return null;
}
if (argv._.includes("format")) {
  let settingsToUse = defaultSettings;
  if (argv.options !== null) {
    const fileSettings = resolveSettings(argv.options);
    if (fileSettings != null) {
      settingsToUse = fileSettings;
    }
  }
  if (fs.existsSync(argv.path)) {
    try {
      const contents = fs.readFileSync(argv.path, { encoding: "utf8" }), doc = AntlersDocument.fromText(contents), formatter = new AntlersFormatter(settingsToUse), formatResults = formatter.formatDocument(doc);
      if (argv.dump === true) {
        console.log(formatResults);
      } else {
        let writePath = argv.path;
        if (argv.output !== null) {
          writePath = argv.output;
        }
        fs.writeFileSync(writePath, formatResults, { encoding: "utf8" });
      }
      process.exit(EXIT_SUCCESS);
    } catch (err) {
      console.error(err);
      process.exit(EXIT_GENERAL_FAILURE);
    }
  } else {
    process.exit(EXIT_FILE_NOT_FOUND);
  }
}
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
